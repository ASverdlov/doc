# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-07-14 13:15+0300\n"
"PO-Revision-Date: 2017-07-14 14:12+0300\n"
"Last-Translator: \n"
"Language: ru\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 "
"&& (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"
"X-Generator: Poedit 2.0.2\n"

#: ../doc/1.7/book/admin/backups.rst:33
msgid "Backups"
msgstr "Резервное копирование"

#: ../doc/1.7/book/admin/backups.rst:35
msgid ""
"Tarantool storage architecture is append-only: files are only appended to, and "
"are never overwritten. Old files are removed by garbage collection after a "
"checkpoint. You can configure the amount of past checkpoints preserved by "
"garbage collection by configuring Tarantool's :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. Backups can be taken at any time, with minimal "
"overhead on database performance."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:46
#, fuzzy
msgid "Hot backup (memtx)"
msgstr "**\"Горячее\" резервирование**"

#: ../doc/1.7/book/admin/backups.rst:48
msgid "This is a special case when there are only in-memory tables."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:50
#, fuzzy
msgid ""
"The last snapshot file is a backup of the entire database; and the WAL files "
"that are made after the last snapshot are incremental backups. Therefore taking "
"a backup is a matter of copying the snapshot and WAL files."
msgstr ""
"Суть процедуры: последний созданный Tarantool'ом файл-снимок является резервной "
"копией всей базы; а WAL-файлы, созданные следом, являются инкрементными копиями. "
"Поэтому вся процедура резервирования сводится к копированию последнего файла-"
"снимка и последующих WAL-файлов."

#: ../doc/1.7/book/admin/backups.rst:54
#, fuzzy
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and .xlog "
"files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and :ref:`wal_dir <cfg_basic-"
"wal_dir>` directories."
msgstr ""
"С помощью :program:`tar` создайте сжатую (насколько это можно) копию последнего :"
"file:`.snap`-файла и последующих :file:`.xlog`-файлов из директорий :ref:"
"`snap_dir <cfg_basic-snap_dir>` и :ref:`wal_dir <cfg_basic-wal_dir>`."

#: ../doc/1.7/book/admin/backups.rst:58
#, fuzzy
msgid "If there is a security policy, encrypt the .tar file."
msgstr ""
"Если того требуют правила безопасности, зашифруйте получившийся :file:`tar`-файл."

#: ../doc/1.7/book/admin/backups.rst:60
#, fuzzy
msgid "Copy the .tar file to a safe place."
msgstr "Скопируйте :file:`tar`-файл в надежное место."

#: ../doc/1.7/book/admin/backups.rst:62
#, fuzzy
msgid ""
"Later, restoring the database is a matter of taking the .tar file and putting "
"its contents back in the memtx_dir and wal_dir directories."
msgstr ""
"... В дальнейшем вы сможете восстановить базу данных, просто взяв этот :file:"
"`tar`-файл и разархивировав его содержимое в директории ``snap_dir`` и "
"``wal_dir``."

#: ../doc/1.7/book/admin/backups.rst:69
msgid "Hot backup (vinyl/memtx)"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:71
msgid ""
"Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and creates a "
"folder for each database space. Dump and compaction processes are append-only "
"and create new files. Old files are garbage collected after each checkpoint."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:75
msgid "To take a mixed backup:"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:77
msgid ""
"Issue ``box.backup.begin()`` on the administrative console. This will suspend "
"garbage collection till the next ``box.backup.end()`` and will return a list of "
"files to backup."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:81
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, vinyl run and index files, at a state consistent with the last "
"checkpoint."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:85
msgid "Resume garbage collection with ``box.backup.end()``."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:91
#, fuzzy
msgid "Continuous remote backup (memtx)"
msgstr "**Постоянное удаленное резервирование**"

#: ../doc/1.7/book/admin/backups.rst:93
msgid ""
"The :ref:`replication <replication>` feature is useful for backup as well as for "
"load balancing."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:96
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica is up "
"to date, and doing a cold backup on it. Since all the other replicas continue to "
"operate, this is not a cold backup from the end user’s point of view. This could "
"be done on a regular basis, with a ``cron`` job or with a Tarantool fiber."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:105
#, fuzzy
msgid "Continuous backup (memtx)"
msgstr "**Постоянное удаленное резервирование**"

#: ../doc/1.7/book/admin/backups.rst:107
#, fuzzy
msgid ""
"The logged changes done since the last cold backup must be secured, while the "
"system is running."
msgstr ""
"Суть процедуры: по ходу работы системы нужно сохранять записи об изменениях, "
"сделанных со времени последнего \"холодного\" резервирования."

#: ../doc/1.7/book/admin/backups.rst:110
#, fuzzy
msgid ""
"For this purpose, you need a file copy utility that will do the copying remotely "
"and continuously, copying only the parts of a write ahead log file that are "
"changing. One such utility is `rsync <https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""
"Для этого вам понадобится специальная утилита для копирования частей файлов "
"(например, `rsync <https://en.wikipedia.org/wiki/rsync>`_), которая позволит "
"удаленно и на постоянной основе копировать только изменившиеся части файлов-"
"снимков и WAL-файлов, а не все эти файлы целиком."

#: ../doc/1.7/book/admin/backups.rst:115
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should be "
"frequent production of new snapshot files or new WAL files as changes occur, so "
"that only the new files need to be copied."
msgstr ""
"Вы можете взять и обычную утилиту (для копирования файлов целиком), но тогда вам "
"придется создавать файлы-снимки и WAL-файлы на каждое изменение, чтобы нужно "
"было копировать только новые файлы."

#: ../doc/1.7/book/admin/bug_reports.rst:33
msgid "Bug reports"
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:35
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the time to "
"tell us about it."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:38
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage you to "
"include the following information:"
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:41
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs from the "
"expected behavior according to our manual. Please provide specific unique "
"information. For example, instead of \"I can’t get certain information\", say "
"\"box.space.x:delete() didn’t report what was deleted\"."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:46
msgid ""
"Your operating system name and version, the Tarantool name and version, and any "
"unusual details about your machine and its configuration."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:49
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a Tarantool :ref:"
"`log file <admin-logs>`."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:52
msgid ""
"If this is a feature request or if it affects a special category of users, be "
"sure to mention that."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:55
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:33
msgid "Daemon supervision"
msgstr "Контроль за фоновыми программами"

#: ../doc/1.7/book/admin/daemon_supervision.rst:39
#, fuzzy
msgid "Server signals"
msgstr "Обработка сигналов от сервера"

#: ../doc/1.7/book/admin/daemon_supervision.rst:41
#, fuzzy
msgid "Tarantool processes these signals during the main thread event loop:"
msgstr "Во время основного цикла Tarantool-сервер обрабатывает следующие сигналы:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:49
msgid "Signal"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:49
#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
#: ../doc/1.7/book/box/data_model.rst:631
msgid "Effect"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:51
msgid "SIGHUP"
msgstr "SIGHUP"

#: ../doc/1.7/book/admin/daemon_supervision.rst:51
#, fuzzy
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""
"может привести к ротации лога, см. :ref:`пример в разделе \"Запись в журнал\" "
"<cfg_logging-logging_example>`."

#: ../doc/1.7/book/admin/daemon_supervision.rst:55
msgid "SIGUSR1"
msgstr "SIGUSR1"

#: ../doc/1.7/book/admin/daemon_supervision.rst:55
#, fuzzy
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""
"может привести к сохранению снимка, см. описание функции :ref:`box.snapshot "
"<admin-snapshot>`."

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
msgid "SIGTERM"
msgstr "SIGTERM"

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
#, fuzzy
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""
"может привести к корректному завершению работы (с предварительным сохранением "
"всех данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:61
#, fuzzy
msgid "SIGINT (also known as keyboard interrupt)"
msgstr ""
"(или \"прерывание с клавиатуры\") может привести к корректному завершению работы "
"(с предварительным сохранением всех данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:61
#, fuzzy
msgid "May cause graceful shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
msgid "SIGKILL"
msgstr "SIGKILL"

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
#, fuzzy
msgid "Causes an immediate shutdown."
msgstr "приводит к аварийному завершению работы (с возможной потерей данных)."

#: ../doc/1.7/book/admin/daemon_supervision.rst:68
msgid ""
"Other signals will result in behavior defined by the operating system. Signals "
"other than SIGKILL may be ignored, especially if Tarantool is executing a long-"
"running procedure which prevents return to the main thread event loop."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:76
#, fuzzy
msgid "Automatic instance restart"
msgstr "Запуск экземпляров"

#: ../doc/1.7/book/admin/daemon_supervision.rst:78
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to destroy "
"an instance:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:82
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:93
#, fuzzy
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr "А теперь убедимся, что :program:`systemd` перезапустила его:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:95
#, fuzzy
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""
"$ systemctl status tarantool@example|grep PID\n"
"Main PID: 5914 (tarantool)"

#: ../doc/1.7/book/admin/daemon_supervision.rst:100
#, fuzzy
msgid "Finally, let’s check the boot logs:"
msgstr "И под конец проверим содержимое журнала загрузки:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:102
#, fuzzy
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: Unit "
"entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@my_app.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."
msgstr ""
"$ journalctl -u tarantool@example -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:09:45 "
"MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: tarantool@example.service: "
"Service hold-off time over, scheduling restart.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server."

#: ../doc/1.7/book/admin/daemon_supervision.rst:119
msgid "Core dumps"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:121
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool crashes."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:124
#, fuzzy
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves core dumps "
"and stack traces in case of a crash. Here is a general \"how to\" for how to "
"enable core dumps on a Unix system:"
msgstr ""
"При аварийном завершении Tarantool-сервера, :program:`coredumpctl` автоматически "
"сохраняет дампы памяти (core dumps) и трассировку стека (stack traces). Вот как "
"работает этот механизм:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:128
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say ``ulimit -c "
"unlimited``. Check  \"man 5 core\" for other reasons why a core dump may not be "
"produced."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:132
msgid ""
"Set a directory for writing core dumps to, and make sure that the directory is "
"writable. On Linux, the directory path is set in a kernel parameter configurable "
"via ``/proc/sys/kernel/core_pattern``."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:136
msgid ""
"Make sure that core dumps include stack trace information. If you use a binary "
"Tarantool distribution, this is automatic. If you build Tarantool from source, "
"you will not get detailed information if you pass ``-DCMAKE_BUILD_TYPE=Release`` "
"to CMake."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:141
msgid ""
"To simulate a crash, you can execute an illegal command against a Tarantool "
"instance:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:144
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', 0)[0] = "
"48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host closed "
"connection"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:151
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer to it "
"as $PID), you can abort a Tarantool instance by running ``gdb`` debugger:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:154
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:158
msgid "or manually sending a SIGABRT signal:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:160
msgid "$ kill -SIGABRT $PID"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:166
msgid "To find out the process id of the instance ($PID), you can:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:168
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-box_info>`,"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:170
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:172
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.7/book/admin/daemon_supervision.rst:174
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the Tarantool "
"daemon, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:177
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:184
msgid "To save a core dump into a file, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:186
#, fuzzy
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr ""
"Теперь введем :samp:`coredumpctl -o filename.core info <pid>`, чтобы сохранить "
"дамп памяти в отдельный файл."

#: ../doc/1.7/book/admin/daemon_supervision.rst:194
msgid "Stack traces"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:196
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack trace"
"\" or \"backtrace\"."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:200
msgid "To save a stack trace into a file, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:202
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" --batch -c "
"core> /tmp/tarantool_trace.txt"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:206
#: ../doc/1.7/book/admin/instance_config.rst:140
#: ../doc/1.7/book/replication/repl_bootstrap.rst:67
msgid "where:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:208
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:209
msgid "\"core\" is the path to the core file, and"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:210
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the stack "
"trace."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:214
msgid ""
"Occasionally, you may find that the trace file contains output without debug "
"symbols – the lines will contain ”??” instead of names. If this happens, check "
"the instructions on these Tarantool wiki pages: `How to debug core dump of "
"stripped tarantool <https://github.com/tarantool/tarantool/wiki/How-to-debug-"
"core-dump-of-stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-different-"
"OS>`_."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:221
#, fuzzy
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""
"Чтобы получить трассировку стека и прочую полезную информацию, введем :samp:"
"`coredumpctl info <pid>`:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:223
#, fuzzy
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool example.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"         Unit: tarantool@example.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex (tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."

#: ../doc/1.7/book/admin/daemon_supervision.rst:262
msgid "Debugger"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:264
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:266
msgid "$ coredumpctl gdb <pid>"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:270
#, fuzzy
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to improve "
"``gdb`` experience, for example:"
msgstr ""
"Мы очень рекомендуем установить пакет ``tarantool-debuginfo``, чтобы сделать "
"отладку средствами :program:`gdb` более эффективной. Например:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:273
msgid "$ dnf debuginfo-install tarantool"
msgstr "$ dnf debuginfo-install tarantool"

#: ../doc/1.7/book/admin/daemon_supervision.rst:277
#, fuzzy
msgid ""
"``gdb`` also provides information about the debuginfo packages you need to "
"install:"
msgstr ""
"С помощью :program:`gdb` вы можете узнать, какие еще ``debuginfo``-пакеты нужно "
"установить:"

#: ../doc/1.7/book/admin/daemon_supervision.rst:280
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"

#: ../doc/1.7/book/admin/daemon_supervision.rst:291
#, fuzzy
msgid ""
"Symbolic names are present in stack traces even if you don’t have ``tarantool-"
"debuginfo`` package installed."
msgstr ""
"В трассировке стека используются символические имена, даже если у вас не "
"установлен пакет ``tarantool-debuginfo``."

#: ../doc/1.7/book/admin/disaster_recovery.rst:33
msgid "Disaster recovery"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:35
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a replication "
"cluster that includes a master and a replica, or two masters."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:38
msgid ""
"The basic recommendation is to configure all Tarantool instances in a cluster to "
"create :ref:`snapshot files <index-box_persistence>` at a regular basis."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:41
msgid "Here follow action plans for typical crash scenarios."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:47
#, fuzzy
msgid "Master-replica"
msgstr "Репликация по схеме master-master"

#: ../doc/1.7/book/admin/disaster_recovery.rst:49
msgid "Configuration: One master and one replica."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:51
msgid "Problem: The master has crashed."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:53
#: ../doc/1.7/book/admin/disaster_recovery.rst:120
#, fuzzy
msgid "Your actions:"
msgstr "Операции"

#: ../doc/1.7/book/admin/disaster_recovery.rst:55
msgid ""
"Ensure the master is stopped for good. For example, log in to the master machine "
"and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:58
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` parameter to *false* and let the load be handled by the replica "
"(effective master)."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:62
msgid ""
"Set up a replacement for the crashed master on a spare host, with :ref:"
"`replication <cfg_replication-replication>` parameter set to replica (effective "
"master), so it begins to catch up with the new master’s state. The new instance "
"should have :ref:`box.cfg.read_only <cfg_basic-read_only>` parameter set to "
"*true*."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:68
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file <index-"
"box_persistence>`, which it may have not transferred to the replica before "
"crash. If you were able to salvage the master .xlog file, you may be able to "
"recover these. In order to do it:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:73
msgid ""
"Find out the position of the crashed master, as reflected on the new master."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:75
msgid "Find out instance UUID from the crashed master xlog:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:77
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:82
msgid "On the new master, use the UUID to find the position:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:84
msgid ""
"tarantool>box.info.vclock[box.space._cluster.index.uuid:"
"select{'ed607cad-8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:91
msgid ""
"Play the records from the crashed .xlog to the new master, starting from the new "
"master position:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:94
msgid ""
"Issue this request locally at the new master's machine to find out instance ID "
"of the new master:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:97
#: ../doc/1.7/book/replication/repl_architecture.rst:111
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:104
msgid "Play the records to the new master:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:106
msgid ""
"$ tarantoolctl <new_master_uri> <xlog_file> play --from-lsn 23425 --replica 1"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:114
#, fuzzy
msgid "Master-master"
msgstr "Репликация по схеме master-master"

#: ../doc/1.7/book/admin/disaster_recovery.rst:116
msgid "Configuration: Two masters."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:118
msgid "Problem: Master#1 has crashed."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:122
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:124
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-disaster_recovery-"
"master_replica>` recovery scenario to create a new master and salvage lost data."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:132
msgid "Data loss"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:134
msgid "Configuration: Master-master or master-replica."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:136
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated to the "
"other node (master or replica)."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:139
msgid ""
"The following steps are applicable only to data in memtx storage engine. Your "
"actions:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:142
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"checkpointing with ``box.backup.begin()``. Disabling the checkpointing is "
"necessary to prevent automatic garbage collection of older checkpoints."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:146
msgid ""
"Get the latest valid .snap file and use ``tarantoolctl cat`` command to "
"calculate at which lsn the data loss occurred."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:149
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command to play "
"to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:152
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:33
msgid "Server administration"
msgstr "Администрирование серверной части"

#: ../doc/1.7/book/admin/index.rst:35
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:37
msgid ""
"Here we show how to administer Tarantool instances using any of the following "
"utilities:"
msgstr ""

#: ../doc/1.7/book/admin/index.rst:40
msgid "``systemd`` native utilities, or"
msgstr ""

#: ../doc/1.7/book/admin/index.rst:41
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as part of "
"Tarantool distribution."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:46
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:47
#, fuzzy
msgid "Console examples here are for Fedora."
msgstr "(здесь и далее мы приводим примеры консольного вывода для Fedora)."

#: ../doc/1.7/book/admin/index.rst:49 ../doc/1.7/book/replication/index.rst:39
msgid "This chapter includes the following sections:"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:33
msgid "Instance configuration"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:35
msgid "For each Tarantool instance, you need two files:"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:37
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with instance-"
"specific logic. Put this file into the ``/usr/share/tarantool/`` directory."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:41
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as a :ref:"
"`Lua module <app_server-modules>` that bootstraps the database and exports "
"``start()`` function for API calls):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:45
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:57
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, into the "
"``/etc/tarantool/instances.enabled`` directory."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:61
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we load "
"``my_app.lua`` module and make a call to ``start()`` function from that module):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:65
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:81
#, fuzzy
msgid "Instance file"
msgstr "``instance_dir``"

#: ../doc/1.7/book/admin/instance_config.rst:83
msgid ""
"After this short introduction, you may wonder what an instance file is, what it "
"is for, and how ``tarantoolctl`` uses it. After all, Tarantool is an application "
"server, so why not start the application stored in ``/usr/share/tarantool`` "
"directly?"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:88
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP "
"socket. This daemon needs to be started automatically when the operating system "
"starts, and managed with the operating system standard tools for service "
"management -- such as ``systemd`` or ``init.d``. To serve this very purpose, we "
"created **instance files**."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:95
msgid ""
"You can have more than one instance file. For example, a single application in "
"``/usr/share/tarantool`` can run in multiple instances, each of them having its "
"own instance file. Or you can have multiple applications in ``/usr/share/"
"tarantool`` -- again, each of them having its own instance file."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:100
msgid ""
"An instance file is typically created by a system administrator. An application "
"file is often provided by a developer, in a Lua rock or an rpm/deb package."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:103
msgid ""
"An instance file is designed to not differ in any way from a Lua application. It "
"must, however, configure the database, i.e. contain a call to :ref:`box.cfg{} "
"<box_introspection-box_cfg>` somewhere in it, because it’s the only way to turn "
"a Tarantool script into a background process, and ``tarantoolctl`` is a tool to "
"manage background processes. Other than that, an instance file may contain "
"arbitrary Lua code, and, in theory, even include the entire application business "
"logic in it. We, however, do not recommend this, since it clutters the instance "
"file and leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:117
#, fuzzy
msgid "`tarantoolctl` configuration file"
msgstr "``tarantoolctl connect``."

#: ../doc/1.7/book/admin/instance_config.rst:119
msgid ""
"While instance files contain instance configuration, ``tarantoolctl`` "
"configuration file contains the configuration that ``tarantoolctl`` uses to "
"override instance configuration. In other words, it contains system-wide "
"configuration defaults."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:124
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (installed to ``/etc/"
"default/tarantool`` as part of Tarantool distribution):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:128
#, fuzzy
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr "``pid_file``"

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will add “/"
"instance_name” to the directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr "``wal_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add \"/instance_name"
"\" to the directory name."
msgstr ""
"Директория, где хранятся :file:`*.xlog`-файлы. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid "``memtx_dir``"
msgstr "``wal_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add \"/instance_name\" "
"to the directory name."
msgstr ""
"Директория, где хранятся :file:`*.snap`-файлы. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid ""
"Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" to the "
"directory name."
msgstr ""
"Директория, где хранятся pid-файл и socket-файл. Скрипт :program:`tarantoolctl` "
"добавляет \":samp:`/{instance-name}`\" к имени директории."

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid "``log``"
msgstr "``logger``"

#: ../doc/1.7/book/admin/instance_config.rst
#, fuzzy
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add \"/"
"instance_name.log\" to the name."
msgstr ""
"Директория, где хранятся файлы журнала с сообщениями от Tarantool-приложений. "
"Скрипт :program:`tarantoolctl` добавляет \":samp:`/{instance-name}`\" к имени "
"директории."

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``username``"
msgstr "``username``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system user "
"name rather than the Tarantool-client user name. Tarantool will change its "
"effective user to this user after becoming a daemon."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr "``instance_dir``"

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put instance "
"files in this directory, or create symbolic links."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:171
msgid ""
"As a full-featured example, you can take `example.lua <https://github.com/"
"tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_ script that ships with "
"Tarantool and defines all configuration options."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:33
msgid "Logs"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:35
msgid ""
"Tarantool logs important events to a file, e.g. ``/var/log/tarantool/my_app."
"log``. To build the log file path, ``tarantoolctl`` takes the instance name, "
"prepends the instance directory and appends “.log” extension."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:39
#, fuzzy
msgid "Let’s write something to the log file:"
msgstr "Давайте запишем что-нибудь в файл журнала:"

#: ../doc/1.7/book/admin/logs.rst:41
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for the "
"manual readers\")\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:49
msgid "Then check the logs:"
msgstr "Затем проверим содержимое журнала:"

#: ../doc/1.7/book/admin/logs.rst:51
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version 1.7.3-382-"
"g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping 134217728 bytes "
"for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to [::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from `/var/"
"lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at unix/:/var/run/"
"tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the manual "
"readers"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:67
msgid ""
"When logging to a file, the system administrator must ensure logs are rotated "
"timely and do not take up all the available disk space. With ``tarantoolctl``, "
"log rotation is pre-configured to use ``logrotate`` program, which you must have "
"installed."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:72
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This is what "
"this file is usually like:"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:76
#, fuzzy, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""
"/path/to/tarantool/\\*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /path/to/tarantoolctl logrotate `basename $ 1 .log`\n"
"    endscript\n"
"}"

#: ../doc/1.7/book/admin/logs.rst:91
msgid ""
"If you use a different log rotation program, you can invoke ``tarantoolctl "
"logrotate`` command to request instances to reopen their log files after they "
"were moved by the program of your choice."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:97
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program specified in "
"the configuration file (see :ref:`log <cfg_logging-log>` parameter)."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:100
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` defaults. "
"``tarantoolctl`` automatically detects if an instance is using ``syslog`` or an "
"external program for logging, and does not override the log destination in this "
"case. In such configurations, log rotation is usually handled by the external "
"program used for logging. So, ``tarantoolctl logrotate`` command works only if "
"logging-into-file is enabled in the instance file."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:33
#, fuzzy
msgid "Notes for operating systems"
msgstr "Заметки для пользователей systemd"

#: ../doc/1.7/book/admin/os_notes.rst:39
msgid "Mac OS"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:41
msgid ""
"On Mac OS, you can administer Tarantool instances only with ``tarantoolctl``. No "
"native system tools are supported."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:48
msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/1.7/book/admin/os_notes.rst:50
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD, use "
"paths other than those suggested in :ref:`Instance configuration <admin-"
"instance_config>`. Instead of ``/usr/share/tarantool/`` directory, use ``/usr/"
"local/etc/tarantool/`` and create the following subdirectories:"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:56
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:57
msgid "``instances.available`` for all available instance files, and"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:58
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:60
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:62
#, fuzzy
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- /var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- /var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\",\n"
"    wal_dir    = \"/var/lib/tarantool\",\n"
"    snap_dir   = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    logger     = \"/var/log/tarantool\",\n"
"    username   = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""

#: ../doc/1.7/book/admin/security.rst:33
msgid "Security"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:35
msgid "Tarantool allows for two types of connections:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:37
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` module, "
"you can set up a port which can be used to open an administrative console to the "
"server. This is for administrators to connect to a running instance and make "
"requests. ``tarantoolctl`` invokes ``console.listen()`` to create a control "
"socket for each started instance."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:43
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box`` "
"module, you can set up a binary port for connections which read and write to the "
"database or invoke stored procedures."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:47
#, fuzzy
msgid "When you connect to an admin console:"
msgstr "При установке соединение через порт для администрирования:"

#: ../doc/1.7/book/admin/security.rst:49
msgid "The client-server protocol is plain text."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:50
#, fuzzy
msgid "No password is necessary."
msgstr "Пароль не требуется"

#: ../doc/1.7/book/admin/security.rst:51
#, fuzzy
msgid "The user is automatically 'admin'."
msgstr "Пользователь автоматически получает привилегии администратора."

#: ../doc/1.7/book/admin/security.rst:52
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:54
#, fuzzy
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If it is "
"a TCP port, it should only be opened for a specific IP. Ideally, it should not "
"be a TCP port at all, it should be a Unix domain socket, so that access to the "
"server machine is required. Thus a typical port setup for admin console is:"
msgstr ""
"Поэтому порты для администрирования следует настраивать очень осторожно. Если "
"это TCP-порт, то он должен быть открыть только для определенного IP-адреса. В "
"идеале мы рекомендуем вовсе не использовать TCP-порты. Вместо них лучше "
"настроить доменный Unix-сокет, который требует настройки прав доступа к "
"серверной машине. Тогда типичная настройка порта для администрирования будет "
"выглядеть следующим образом:"

#: ../doc/1.7/book/admin/security.rst:59
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr "console.listen('/var/lib/tarantool/socket_name.sock')"

#: ../doc/1.7/book/admin/security.rst:63
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr "а типичный :ref:`URI <index-uri>` для соединения будет таким:"

#: ../doc/1.7/book/admin/security.rst:65
#, fuzzy
msgid "/var/lib/tarantool/socket_name.sock"
msgstr "admin:any_string@/var/lib/tarantool/socket_name.sock"

#: ../doc/1.7/book/admin/security.rst:69
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and the "
"connector has the privilege to read on ``/var/lib/tarantool``. Alternatively, to "
"connect to an admin console of an instance started with ``tarantoolctl``, use :"
"ref:`tarantoolctl enter <admin-executing_code_on_an_instance>`."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:74
#, fuzzy
msgid ""
"To find out whether a TCP port is a port for admin console, use ``telnet``. For "
"example:"
msgstr ""
"Выяснить, является ли некий TCP-порт портом для администрирования, можно с "
"помощью :program:`telnet`. Например:"

#: ../doc/1.7/book/admin/security.rst:77
#, fuzzy
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.3 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.1-70-gbc479ad (Lua console)\n"
"type 'help' for interactive help"

#: ../doc/1.7/book/admin/security.rst:86
#, fuzzy
msgid ""
"In this example, the response does not include the word \"binary\" and does "
"include the words \"Lua console\". Therefore it is clear that this is a "
"successful connection to a port for admin console, and you can now enter admin "
"requests on this terminal."
msgstr ""
"В этом примере в ответе от сервера нет слова \"binary\" и есть слова \"Lua "
"console\". Это значит, что мы установили соединение на порту для "
"администрирования и можем вводить администраторские запросы на этом терминале."

#: ../doc/1.7/book/admin/security.rst:91
#, fuzzy
msgid "When you connect to a binary port:"
msgstr "При установке соединение через порт для администрирования:"

#: ../doc/1.7/book/admin/security.rst:93
msgid "The client-server protocol is :ref:`binary <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:94
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:95
msgid "To change the user, it’s necessary to authenticate."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:97
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects the type "
"of connection during handshake and uses :ref:`EVAL <box_protocol-eval>` binary "
"protocol command when it’s necessary to execute Lua commands over a binary "
"connection. To execute EVAL, the authenticated user must have global \"EXECUTE\" "
"privilege."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:103
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating a "
"Tarantool user with global \"EXECUTE\" privilege and non-empty password can be "
"used to provide a system administrator **remote** access to an instance."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:33
msgid "Server introspection"
msgstr "Просмотр состояния сервера"

#: ../doc/1.7/book/admin/server_introspection.rst:39
#, fuzzy
msgid "Using Tarantool as a client"
msgstr "Использование tarantool в качестве клиента"

#: ../doc/1.7/book/admin/server_introspection.rst:41
msgid "Tarantool enters the interactive mode if:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:43
msgid ""
"you start Tarantool without an :ref:`instance file <admin-instance_file>`, or"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:46
#, fuzzy
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-module>`, "
"либо"

#: ../doc/1.7/book/admin/server_introspection.rst:48
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter requests. "
"When used this way, Tarantool can be a client for a remote server. See basic "
"examples in :ref:`Getting started <getting_started>`."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:52
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" and "
"\"connect\" commands."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:59
#, fuzzy
msgid "Executing code on an instance"
msgstr "Настройка конкретного экземпляра Tarantool-сервера:"

#: ../doc/1.7/book/admin/server_introspection.rst:61
#, fuzzy
msgid ""
"You can attach to an instance's admin console and execute some Lua code using "
"``tarantoolctl``:"
msgstr ""
"Вы можете подсоединиться к запущенному экземпляру Tarantool-сервера и выполнить "
"некий Lua-скрипт с помощью утилиты :program:`tarantoolctl`:"

#: ../doc/1.7/book/admin/server_introspection.rst:64
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:80
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance without "
"attaching to its admin console. For example:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:83
msgid ""
"# executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"$ # - OR -\n"
"# executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:95
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or the :"
"ref:`net.box <net_box-module>` module from a Tarantool server. Also, you can "
"write your client programs with any of the :ref:`connectors <index-"
"box_connectors>`. However, most of the examples in this manual illustrate usage "
"with either ``tarantoolctl connect`` or :ref:`using the Tarantool server as a "
"client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:106
msgid "Health checks"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:108
msgid "To check the instance status, say:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:110
#, fuzzy
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"$ # - OR -\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""
"$ systemctl status tarantool@example\n"
"tarantool@example.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor preset: "
"disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, status=0/"
"SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@example.service\n"
"+ 5350 tarantool example.lua <running>"

#: ../doc/1.7/book/admin/server_introspection.rst:126
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:128
#, fuzzy
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found my_app.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"
msgstr ""
"$ journalctl -u tarantool@example -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 21:17:47 "
"MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool Database "
"Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool Database "
"Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Found example.lua in /etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: /usr/bin/tarantoolctl: "
"Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool Database "
"Server"

#: ../doc/1.7/book/admin/server_introspection.rst:138
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:140
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify all "
"configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:143
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total use "
"and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:146
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect Tarantool "
"server variables, primarily those related to replication)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:149
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect Tarantool "
"request and network statistics)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:152
msgid ""
"You can also try `tarantool/prometheus <https://github.com/tarantool/"
"prometheus>`_, a Lua module that makes it easy to collect metrics (e.g. memory "
"usage or number of requests) from Tarantool applications and databases and "
"expose them via the Prometheus protocol."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:157
#: ../doc/1.7/book/box/authentication.rst:246
#: ../doc/1.7/book/box/box_schema.rst:111 ../doc/1.7/book/box/box_session.rst:105
#: ../doc/1.7/book/box/box_session.rst:134 ../doc/1.7/book/box/box_session.rst:178
#: ../doc/1.7/book/box/box_session.rst:282 ../doc/1.7/book/box/triggers.rst:100
#, fuzzy
msgid "**Example**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/admin/server_introspection.rst:159
msgid ""
"A very popular administrator request is :ref:`box.slab.info() <box_slab_info>`, "
"which displays detailed memory usage statistics for a Tarantool instance."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:162
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:33
#, fuzzy
msgid "Starting/stopping an instance"
msgstr "Запуск/остановка конкретного экземпляра:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:35
msgid ""
"While a Lua application is executed by Tarantool, an instance file is executed "
"by ``tarantoolctl`` which is a Tarantool script."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:38
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:40
#, fuzzy
msgid "$ tarantoolctl start <instance_name>"
msgstr "$ tarantoolctl eval /etc/tarantool/instance.enabled/myappcfg.lua"

#: ../doc/1.7/book/admin/start_stop_instance.rst:44
msgid ""
"Read and parse the command line arguments. The last argument, in our case, "
"contains an instance name."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:47
msgid ""
"Read and parse its own configuration file. This file contains ``tarantoolctl`` "
"defaults, like the path to the directory where instances should be searched for."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:51
msgid ""
"The default ``tarantoolctl`` configuration file is installed in ``/etc/default/"
"tarantool``. This file is used when ``tarantoolctl`` is invoked by root. When "
"invoked by a local user, ``tarantoolctl`` first looks for its defaults file in "
"the current directory (``$PWD/.tarantoolctl``), and then in the current user’s "
"home directory (``$HOME/.config/tarantool/tarantool``). If not found, "
"``tarantoolctl`` falls back to :ref:`built-in defaults <admin-"
"tarantoolctl_config_file>`."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:59
msgid ""
"Look up the instance file in the instance directory, e.g. ``/etc/tarantool/"
"instances.enabled``. To build the instance file path, ``tarantoolctl`` takes the "
"instance name, prepends the instance directory and appends \".lua\" extension to "
"the instance file."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:64
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-process "
"its parameters and ensure that instance paths are pointing to the paths defined "
"in the ``tarantoolctl`` configuration file. For example, if the configuration "
"file specifies that instance work directory must be in ``/var/tarantool``, then "
"the new implementation of ``box.cfg{}`` ensures that :ref:`work_dir <cfg_basic-"
"work_dir>` parameter in ``box.cfg{}`` is set to ``/var/tarantool/"
"<instance_name>``, regardless of what the path is set to in the instance file "
"itself."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:73
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with Lua "
"console attached to it. This file is used later by ``tarantoolctl`` to query the "
"instance state, send commands to the instance and so on."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:77
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:79
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance name "
"is ``my_app``):"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:82
#, fuzzy
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"my_app.lua <running>"
msgstr ""
"$ systemctl start tarantool@example\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 tarantool "
"example.lua <running>"

#: ../doc/1.7/book/admin/start_stop_instance.rst:88
#, fuzzy
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl start "
"my_app``."
msgstr ""
"$ cd /tarantool_test\n"
"$ sudo tarantoolctl start my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:91
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app`` "
"instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:94
#, fuzzy
msgid "$ tarantoolctl check my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:98
#, fuzzy
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""
"Для автоматической загрузки экземпляра ``${MYAPP}`` во время запуска всей "
"системы используйте команду :samp:`systemctl enable tarantool@${MYAPP}`."

#: ../doc/1.7/book/admin/start_stop_instance.rst:100
#, fuzzy
msgid "$ systemctl enable tarantool@my_app"
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.7/book/admin/start_stop_instance.rst:104
msgid "To stop a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:106
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:112
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:114
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:124
#, fuzzy
msgid "Running Tarantool locally"
msgstr "Использование tarantool в качестве клиента"

#: ../doc/1.7/book/admin/start_stop_instance.rst:126
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test "
"purposes. Let's configure a local instance, then start and monitor it with "
"``tarantoolctl``."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:130
msgid "First, we create a sandbox directory on the user's path:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:132
#, fuzzy
msgid "$ mkdir ~/tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../doc/1.7/book/admin/start_stop_instance.rst:136
msgid ""
"... and set default ``tarantoolctl`` configuration in ``$HOME/.config/tarantool/"
"tarantool``. Let the file contents be:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:139
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:152
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:154
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have permissions "
"to switch current user when invoked by a local user. The instance will be "
"running under 'admin'."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:158
#, fuzzy
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let the file "
"contents be:"
msgstr ""
"Создадим файл :file:`/tarantool_test/my_app.lua` для приложения ``my_app``:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:161
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"

#: ../doc/1.7/book/admin/start_stop_instance.rst:177
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` first:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:179
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version 1.7.3-489-"
"gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an empty "
"data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:197
#, fuzzy
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr "С помощью :program:`tarantoolctl` запустим наше приложение..."

#: ../doc/1.7/book/admin/start_stop_instance.rst:199
#, fuzzy
msgid "$ tarantoolctl start my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:203
#, fuzzy
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""
"... и получим сообщения о том, что экземпляр нашего приложения запущен. Затем "
"скажем:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:205
#, fuzzy
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr "$ ls -l /tarantool_test/my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:209
#, fuzzy
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr "... и увидим :file:`.snap`-файл и :file:`.xlog`-файл. Затем скажем:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:211
#, fuzzy
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr "$ sudo less /tarantool_test/log/my_app.log"

#: ../doc/1.7/book/admin/start_stop_instance.rst:215
#, fuzzy
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages, if "
"any. Then:"
msgstr ""
"... и увидим содержимое файла журнала для приложения ``my_app``, в т.ч. "
"сообщения об ошибках, если они были. Затем скажем:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:218
#, fuzzy
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""
"$ cd /tarantool_test\n"
"$ # допустим, что 'tarantool' запускает Tarantool-сервер\n"
"$ sudo tarantool\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#: ../doc/1.7/book/admin/start_stop_instance.rst:226
#, fuzzy
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr "... и увидим те несколько кортежей, которые создало приложение ``my_app``."

#: ../doc/1.7/book/admin/start_stop_instance.rst:228
#, fuzzy
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus we say:"
msgstr ""
"Всё. Теперь остановим приложение ``my_app``. Единственный корректный способ — "
"это использовать :program:`tarantoolctl`:"

#: ../doc/1.7/book/admin/start_stop_instance.rst:230
#, fuzzy
msgid "$ tarantoolctl stop my_app"
msgstr "$ sudo tarantoolctl stop my_app"

#: ../doc/1.7/book/admin/start_stop_instance.rst:234
msgid "Finally, we make a cleanup."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:236
#, fuzzy
msgid "$ rm -R tarantool_test"
msgstr "$ sudo mkdir /tarantool_test"

#: ../doc/1.7/book/admin/upgrades.rst:33
#, fuzzy
msgid "Upgrades"
msgstr "Обновление сервера и базы данных"

#: ../doc/1.7/book/admin/upgrades.rst:39
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:41
msgid ""
"If you created a database with an older Tarantool version and have now installed "
"a newer version, make the request ``box.schema.upgrade()``. This updates "
"Tarantool system spaces to match the currently installed version of Tarantool."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:45
#, fuzzy
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` with a "
"database created with Tarantool version 1.6.4 to version 1.7.2 (only a small "
"part of the output is shown):"
msgstr ""
"Например, вот что происходит, если выполнить запрос :samp:`box.schema.upgrade()` "
"для базы, созданной в начале 2015 года (для примера показана лишь малая часть "
"выводимых сообщений):"

#: ../doc/1.7/book/admin/upgrades.rst:49
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to [[0,"
"\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."

#: ../doc/1.7/book/admin/upgrades.rst:64
#, fuzzy
msgid "Upgrading a Tarantool instance"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.7/book/admin/upgrades.rst:66
msgid ""
"Tarantool is backward compatible between two adjacent versions. For example, you "
"should have no or little trouble when upgrading from Tarantool 1.6 to 1.7, or "
"from Tarantool 1.7 to 1.8. Meanwhile Tarantool 1.8 may have incompatible changes "
"when migrating from Tarantool 1.6. to 1.8 directly."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:73
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:75
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in production "
"from 1.6.x to 1.7.x. Notice that this will **always imply a downtime**. To "
"upgrade **without downtime**, you need several Tarantool servers running in a "
"replication cluster (see :ref:`below <admin-upgrades_replication_cluster>`)."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:80
msgid ""
"Tarantool 1.7 has an incompatible .snap and .xlog file format: 1.6 files are "
"supported during upgrade, but you won’t be able to return to 1.6 after running "
"under 1.7 for a while. It also renames a few configuration parameters, but old "
"parameters are supported. The full list of breaking changes is available in "
"`release notes for Tarantool 1.7 <https://github.com/tarantool/tarantool/"
"releases>`_."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:86
msgid ""
"Check with application developers whether application files need to be updated "
"due to incompatible changes (see `1.7 release notes <https://github.com/"
"tarantool/tarantool/releases>`_). If yes, back up the old application files."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:91
msgid "Stop the Tarantool server."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:93
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in :ref:"
"`Backups <admin-backups>`) and the package from which the current (old) version "
"was installed (for rollback purposes)."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:97
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:100
msgid ""
"Update the Tarantool database. Make the request ``box.schema.upgrade()``. This "
"will create new system spaces, update data type names (e.g. num -> unsigned, str "
"-> string) and options in Tarantool system spaces."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:104
#, fuzzy
msgid "Update application files, if needed."
msgstr ""
"Произвести ротацию журналов указанного приложения (создать новые, удалить старые)"

#: ../doc/1.7/book/admin/upgrades.rst:106
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or ``systemctl``."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:112
#, fuzzy
msgid "Upgrading Tarantool in a replication cluster"
msgstr "Обновление Tarantool'а в условиях эксплуатации"

#: ../doc/1.7/book/admin/upgrades.rst:114
msgid ""
"Tarantool 1.7 can work as a replica for Tarantool 1.6 and vice versa. Replicas "
"perform capability negotiation on handshake, and new 1.7 replication features "
"are not used with 1.6 replicas. This allows upgrading clustered configurations."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:118
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and works for "
"any cluster configuration: master-master or master-replica."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:121
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master cluster). "
"See details in :ref:`Upgrading a Tarantool instance <admin-upgrades_instance>`."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:125
msgid "Verify installation on the replicas:"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:127
#, fuzzy
msgid "Start Tarantool."
msgstr "Утилита tarantoolctl"

#: ../doc/1.7/book/admin/upgrades.rst:129
msgid "Attach to the master and start working as before."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:131
msgid ""
"The master runs the old Tarantool version, which is always compatible with the "
"next major version."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:134
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:136
msgid "Verify master installation:"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:138
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:140
msgid "Switch to master mode."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:142
msgid ""
"Upgrade the database on any master node in the cluster. Make the request ``box."
"schema.upgrade()``. This updates Tarantool system spaces to match the currently "
"installed version of Tarantool. Changes are propagated to other nodes via the "
"regular replication mechanism."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:33
msgid "Contributing a module"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:35
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for local "
"usage <app_server-modules>`. Now let's discuss how to create a more advanced "
"Tarantool module and then get it published on `Tarantool rocks page <http://"
"tarantool.org/rocks.html>`_ and included in `official Tarantool images <http://"
"github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:42
msgid ""
"To help our contributors, we have created `modulekit <http://github.com/"
"tarantool/modulekit>`_, a set of templates for creating Tarantool modules in Lua "
"and C."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:48
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` package "
"first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:51
#, fuzzy
msgid "$ sudo apt-get install tarantool-dev"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.7/book/app_server/contributing_module.rst:59
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:61
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository <http://"
"github.com/tarantool/modulekit/blob/luakit/README.md>`_ for detailed "
"instructions and examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:69
msgid "Contributing a module in C"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:71
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than in "
"Lua. For example, to work with specific hardware or low-level system interfaces."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:74
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository <http://github."
"com/tarantool/modulekit/blob/ckit/README.md>`_ for detailed instructions and "
"examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:80
msgid ""
"You can also create modules with C++, provided that the code does not throw "
"exceptions."
msgstr ""
"Вы можете аналогичным образом создавать модули на C++ при условии, что в их коде "
"не будут выбрасываться исключения."

#: ../doc/1.7/book/app_server/cookbook.rst:33
msgid "Cookbook recipes"
msgstr "Книга рецептов"

#: ../doc/1.7/book/app_server/cookbook.rst:35
msgid ""
"Here are contributions of Lua programs for some frequent or tricky situations."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:37
msgid ""
"You can execute any of these programs by copying the code into a ``.lua`` file, "
"and then entering :samp:`chmod +x ./{program-name}.lua` and :samp:`./{program-"
"name}.lua` on the terminal."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:41
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:43
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:47
msgid ""
"This runs  Tarantool Lua application server, which should be on the execution "
"path."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:50
msgid "Use freely."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:56
msgid "hello_world.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:58
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:60
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:70
msgid "console_start.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:72
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating spaces) if "
"this is the first time the server has been run. Then use :ref:`console.start() "
"<console-start>` to start interactive mode."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:76
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:97
msgid "fio_read.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:99
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:101
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:119
msgid "fio_write.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:121
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:123
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:141
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:143
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C built-"
"in function: printf(). (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:146
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:161
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:163
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"function: gettimeofday(). This delivers time with millisecond precision, unlike "
"the time function in Tarantool's :ref:`clock module <clock-module>`."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:167
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / 1000))\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:191
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:193
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a C "
"library function. (For help understanding ffi, see the `FFI tutorial <http://"
"luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:196
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:241
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:243
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access a C "
"object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:247
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:277
msgid "print_arrays.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:279
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator function "
"is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is recommended for "
"map-like tables or mixed tables.) The display will look like: \"1 Apple | 2 "
"Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2 v2\"."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:287
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:301
msgid "count_array.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:303
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua table. This "
"operation has O(log(N)) complexity."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:306
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:317
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:319
msgid ""
"Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple \"#\" "
"operator to deliver improper results. The \"print(#t)\" instruction will print "
"\"4\"; the \"print(counter)\" instruction will print \"3\"; the \"print(max)\" "
"instruction will print \"10\". Other table functions, such as table.sort(), will "
"also misbehave when \"nils\" are present."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:327
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:347
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:349
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil == "
"missing value behavior. Although :code:`json.NULL == nil` is :code:`true`, all "
"the print instructions in this program will print the correct value: 10."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:354
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:377
msgid "count_map.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:379
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:381
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:394
msgid "swap.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:396
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third variable."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:398
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:411
msgid "class.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:413
msgid ""
"Create a class, create a metatable for the class, create an instance of the "
"class. Another illustration is at `http://lua-users.org/wiki/"
"LuaClassesWithMetatable <http://lua-users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:417
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:451
msgid "garbage.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:453
msgid ""
"Force Lua `garbage collection <https://www.lua.org/manual/5.1/manual."
"html#2.10>`_ with the `collectgarbage function <https://www.lua.org/manual/5.1/"
"manual.html#pdf-collectgarbage>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:456
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:466
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:468
msgid ""
"Start one fiber for producer and one fiber for consumer. Use :ref:`fiber."
"channel() <fiber_ipc-channel>` to exchange data and synchronize. One can tweak "
"the channel size (:code:`ch_size` in the program code) to control the number of "
"simultaneous tasks waiting for processing."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:473
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:527
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:529
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a remote host "
"via TCP. Display the connection details and the result of a GET request."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:533
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:551
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:553
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple TCP "
"server, by creating a function that handles requests and echos them, and passing "
"the function to :ref:`socket.tcp_server() <socket-tcp_server>`. This program has "
"been used to test with 100,000 clients, with each client getting a separate "
"fiber."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:561
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, handler)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:584
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:586
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-blocking DNS "
"resolution, getting both the AF_INET6 and AF_INET information for 'google.com'. "
"This technique is not always necessary for tcp connections because :ref:`socket."
"tcp_connect() <socket-tcp_connect>` performs `socket.getaddrinfo` under the "
"hood, before trying to connect to the first available address."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:594
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:614
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:616
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can be "
"implemented with sockets and fibers."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:621
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:670
msgid ""
"A function for a client that connects to this server could look something like "
"this ..."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:673
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:694
msgid "http_get.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:696
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:699
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = http_client.get('http://api.openweathermap.org/data/2.5/weather?"
"q=Oakland,us')\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:717
msgid "http_send.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:719
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:722
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:739
msgid "http_server.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:741
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool into a "
"web server."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:744
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:761
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:763
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML pages "
"from templates. The `http`_ `rock`_ has a fairly simple template engine which "
"allows execution of regular Lua code inside text blocks (like PHP). Therefore "
"there is no need to learn new languages in order to write templates."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:769
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:782
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it would "
"produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:785
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:33
#, fuzzy
msgid "Creating an application"
msgstr "Остановить приложение"

#: ../doc/1.7/book/app_server/creating_app.rst:35
msgid ""
"Further we walk you through key programming practices that will give you a good "
"start in writing Lua applications for Tarantool. For an adventure, this is a "
"story of implementing... a real microservice based on Tarantool! We implement a "
"backend for a simplified version of `Pokémon Go <https://en.wikipedia.org/wiki/"
"Pokémon_Go>`_, a location-based augmented reality game released in mid-2016. In "
"this game, players use a mobile device's GPS capability to locate, capture, "
"battle and train virtual monsters called \"pokémon\", who appear on the screen "
"as if they were in the same real-world location as the player."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:45
msgid ""
"To stay within the walk-through format, let's narrow the original gameplay as "
"follows. We have a map with pokémon spawn locations. Next, we have multiple "
"players who can send catch-a-pokémon requests to the server (which runs our "
"Tarantool microservice). The server replies whether the pokémon is caught or "
"not, increases the player's pokémon counter if yes, and triggers the respawn-a-"
"pokémon method that spawns a new pokémon at the same location in a while."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:53
msgid ""
"We leave client-side applications outside the scope of this story. Yet we "
"promise a mini-demo in the end to simulate real users and give us some fun. :-)"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:59
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:65
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:67
msgid ""
"To make our game logic available to other developers and Lua applications, let's "
"put it into a Lua module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:70
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which enhances "
"Tarantool functionality. So, we can install our logic as a module in Tarantool "
"and use it from any Tarantool application or module. Like applications, modules "
"in Tarantool can be written in Lua (rocks), C or C++."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:75
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:77
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:78
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:80
msgid ""
"Technically, a module is a file with source code that exports its functions in "
"an API. For example, here is a Lua module named ``mymodule.lua`` that exports "
"one function named ``myfun``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:84
#, fuzzy
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""
"-- mymodule - простейший Lua-модуль для Tarantool'а\n"
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"    print('Hello', input_string)\n"
"end\n"
"return exports"

#: ../doc/1.7/book/app_server/creating_app.rst:92
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as a file, "
"then load this module with the ``require()`` directive and call the exported "
"function."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:96
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from "
"``mymodule.lua`` module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:99
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:109
msgid ""
"A thing to remember here is that the ``require()`` directive takes load paths to "
"Lua modules from the ``package.path`` variable. This is a semicolon-separated "
"string, where a question mark is used to interpolate the module name. By "
"default, this variable contains system-wide Lua paths and the working directory. "
"But if we put our modules inside a specific folder (e.g. ``scripts/``), we need "
"to add this folder to ``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:116
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:120
msgid ""
"For our microservice, a simple and convenient solution would be to put all "
"methods in a Lua module (say ``pokemon.lua``) and to write a Lua application "
"(say ``game.lua``) that initializes the gaming environment and starts the game "
"loop."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:128
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:130
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn locations; in "
"this version of the game, let a location be a rectangle identified with two "
"points, upper-left and lower-right;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:133
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's location "
"point;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:135
msgid ""
"**pokémon**, which has the same fields as the player, plus a status (active/"
"inactive, that is present on the map or not) and a catch probability (well, "
"let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:139
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver our "
"backend application as a microservice, the good practice would be to send/"
"receive our data in the universal JSON format, thus using Tarantool as a "
"document storage."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:147
msgid "Avro schemas"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:149
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which reduces data "
"footprint and ensures all stored documents are valid. We will use Tarantool "
"module `avro-schema <https://github.com/tarantool/avro-schema>`_ which checks "
"the schema of a JSON document and converts it to a Tarantool tuple. The tuple "
"will contain only field values, and thus take a lot less space than the original "
"document. In avro-schema terms, converting JSON documents to tuples is "
"\"flattening\", and restoring the original documents is \"unflattening\". The "
"usage is quite straightforward:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:158
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema <https://en."
"wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the entity's fields with "
"their names and :ref:`Lua types <index-box_data-types>`."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:162
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects in "
"memory for all schema entities, and ``compile()`` that generates flatten/"
"unflatten methods for each entity."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:165
msgid ""
"Further on, we just call flatten/unflatten methods for a respective entity on "
"receiving/sending the entity's data."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:168
msgid ""
"Here's what our schema definitions for the player and pokémon entities look like:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:170
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:215
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:217
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:240
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for it, "
"because we have only one map in the game, it has very few fields, and -- which "
"is most important -- we use the map only inside our logic, never exposing it to "
"external users."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:248
msgid ""
"Next, we need methods to implement the game logic. To simulate object-oriented "
"programming in our Lua code, let's store all Lua functions and shared variables "
"in a single local variable (let's name it as ``game``). This will allow us to "
"address functions or variables from within our module as ``self.func_name`` or "
"``self.var_name``. Like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:254
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:273
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object "
"fields, and local functions as object methods."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:278
#, fuzzy
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** variables "
"with caution, since the module’s users may be unaware of them."
msgstr ""
"Обратите внимание, что в текущей документации в примерах Lua-кода используются "
"*локальные* переменные. Будьте аккуратны, если в своих модулях вы будете "
"использовать *глобальные* переменные, поскольку пользователи ваших модулей могут "
"не знать об этих переменных."

#: ../doc/1.7/book/app_server/creating_app.rst:281
msgid ""
"To enable/disable the use of undeclared global variables in your Lua code, use "
"Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:284
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:286
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the coordinates "
"of both the player and pokémon, this method will apply a probability factor, so "
"not every pokémon within the player's reach will be caught);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:290
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds (we "
"assume that a frightened pokémon runs away, so we remove a pokémon from the map "
"on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:293
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 caught "
"pokémon A\");"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:295
msgid ""
"``start()`` to initialize the game (it will create database spaces, create and "
"compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:298
msgid ""
"Besides, it would be convenient to have methods for working with Tarantool "
"storage. For example:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:301
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:302
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:304
msgid ""
"We'll need these two methods primarily when initializing our game, but we can "
"also call them later, for example to test our code."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:311
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:313
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to populate "
"Tarantool spaces with pokémon data. Why not keep all game data in memory? Why "
"use a database? The answer is: :ref:`persistence <index-box_persistence>`. "
"Without a database, we risk losing data on power outage, for example. But if we "
"store our data in an in-memory database, Tarantool takes care to persist it on "
"disk whenever it's changed. This gives us one more benefit: quick startup in "
"case of failure. Tarantool has a :ref:`smart algorithm <internals-"
"recovery_process>` that quickly loads all data from disk into memory on startup, "
"so the warm-up takes little time."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:323
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:325
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named ``pokemon`` for "
"storing information about pokémons (we don't create a similar space for players, "
"because we intend to only send/receive player information via API calls, so we "
"needn't store it);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:329
#, fuzzy
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/app_server/creating_app.rst:331
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:334
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon ID is "
"the first field in a Tarantool tuple since it’s the first member of the "
"respective Avro type. So does the pokémon status. The actual JSON document may "
"have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:339
#, fuzzy
msgid "The implementation of ``start()`` method looks like this:"
msgstr "C-файл в нашем примере будет таким:"

#: ../doc/1.7/book/app_server/creating_app.rst:341
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:379
msgid "GIS"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:381
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:383
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID number, and "
"we need to answer whether the player has actually caught the pokémon or not "
"(remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:387
msgid ""
"First thing, we validate the received player data against its :ref:`Avro schema "
"<app_server-avro_schemas>`. And we check whether such a pokémon exists in our "
"database and is displayed on the map (the pokémon must have the active status):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:392
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:416
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:418
msgid ""
"To work with geographical coordinates, we use Tarantool `gis <https://github.com/"
"tarantool/gis>`_ module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:421
msgid ""
"To keep things simple, we don't load any specific map, assuming that we deal "
"with a world map. And we do not validate incoming coordinates, assuming again "
"that all received locations are within the planet Earth."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:425
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:427
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic System "
"standard, `WGS84 <https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. "
"Basically, it comprises a standard coordinate system for the Earth and "
"represents the Earth as an ellipsoid."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:431
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area <https://"
"epsg.io/2163>`_. This is a projected coordinates system based on WGS84. It gives "
"us a zero base for location projection and allows positioning our players and "
"pokémons in meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:436
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, where "
"each system has a unique number. In our code, we assign these listing numbers to "
"respective variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:440
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:445
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which defines "
"how close a player must get to a pokémon before trying to catch it. Let's set "
"the distance to 100 meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:449
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:453
msgid ""
"Now we're ready to calculate the answer. We need to project the current location "
"of both player (``p_pos``) and pokémon (``m_pos``) on the map, check whether the "
"player is close enough to the pokémon (using ``catch_distance``), and calculate "
"whether the player has caught the pokémon (here we generate some random value "
"and let the pokémon escape if the random value happens to be less than 100 minus "
"pokémon's chance value):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:460
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:489
#, fuzzy
msgid "Index iterators"
msgstr "Операции с индексами"

#: ../doc/1.7/book/app_server/creating_app.rst:491
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do this "
"for all pokémons on the map every 60 seconds using ``respawn()`` method. We "
"iterate through pokémons by status using Tarantool index iterator function :ref:"
"`index:pairs <box_index-index_pairs>` and reset the statuses of all \"caught\" "
"pokémons back to \"active\" using ``box.space.pokemons:update()``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:497
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:510
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:512
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:515
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:517
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:557
msgid "Fibers"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:559
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the function "
"will be executed only once, just like all the other methods. But we need to "
"execute ``respawn()`` every 60 seconds. Creating a :ref:`fiber <fiber-module>` "
"is the Tarantool way of making application logic work in the background at all "
"times."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:565
msgid ""
"A **fiber** is a lightweight **thread**. The key difference is that threads use "
"preemptive multitasking, while fibers use cooperative multitasking. This gives "
"fibers the following two advantages over threads:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:569
msgid ""
"Better controllability. Threads often depend on the kernel's thread scheduler to "
"preempt a busy thread and resume another thread, so preemption may occur "
"unpredictably. Fibers yield themselves to run another fiber while executing, so "
"yields are controlled by application logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:573
msgid ""
"Higher performance. Threads require more resources to preempt as they need to "
"address the system kernel. Fibers are lighter and faster as they don't need to "
"address the kernel to yield."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:577
msgid ""
"Yet fibers have some limitations as compared with threads, the main limitation "
"being no multi-core mode. All fibers in an application belong to a single "
"thread, so they all use the same CPU core as the parent thread. Meanwhile, this "
"limitation is not really serious for Tarantool applications, because a typical "
"bottleneck for Tarantool is the HDD, not the CPU."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:583
msgid ""
"A fiber has all the features of a Lua `coroutine <http://www.lua.org/pil/"
"contents.html#9>`_ and all programming concepts that apply for Lua coroutines "
"will apply for fibers as well. However, Tarantool has made some enhancements for "
"fibers and has used fibers internally. So, although use of coroutines is "
"possible and supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:590
msgid ""
"Well, performance or controllability are of little importance in our case. We'll "
"launch ``respawn()`` in a fiber to make it work in the background all the time. "
"To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:594
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:612
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:614
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:634
#, fuzzy
msgid "Logging"
msgstr "Отладка"

#: ../doc/1.7/book/app_server/creating_app.rst:636
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` from "
"Tarantool :ref:`log <log-module>` module. We also need this function in "
"``notify()`` to add a record to the log file on every successful catch:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:640
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:647
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see the log "
"output in console when we launch our application in script mode."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:653
msgid ""
"Great! We've discussed all programming practices used in our Lua module (see "
"`pokemon.lua <https://github.com/Sulverus/pokemon/blob/master/src/pokemon."
"lua>`_)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:656
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua application "
"(see `game.lua <https://github.com/Sulverus/pokemon/blob/master/game.lua>`_) to "
"initialize Tarantool's database module, initialize our game, call the game loop "
"and simulate a couple of player requests."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:661
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and ``game.lua`` "
"application in the current directory, install all external modules, and launch "
"the Tarantool instance running our ``game.lua`` application (this example is for "
"Ubuntu):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:666
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:674
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes the demo "
"logic from ``game.lua``: adds a pokémon named Pikachu (its chance to be caught "
"is very high, 99.1), displays the current map (it contains one active pokémon, "
"Pikachu) and processes catch requests from two players. Player1 is located just "
"near the lonely Pikachu pokémon and Player2 is located far away from it. As "
"expected, the catch results in this output are \"true\" for Player1 and \"false"
"\" for Player2. Finally, Tarantool displays the current map which is empty, "
"because Pikachu is caught and temporarily inactive:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:683
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version 1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 bytes for "
"tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty data "
"directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': 'Pikachu', "
"'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' caught "
"'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:708
msgid "nginx"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:710
msgid ""
"In the real life, this microservice would work over HTTP. Let's add `nginx "
"<https://nginx.org/en/>`_ web server to our environment and make a similar demo. "
"But how do we make Tarantool methods callable via REST API? We use nginx with "
"`Tarantool nginx upstream <https://github.com/tarantool/nginx_upstream_module>`_ "
"module and create one more Lua script (`app.lua <https://github.com/Sulverus/"
"pokemon/blob/master/src/app.lua>`_) that exports three of our game methods -- "
"``add_pokemon()``, ``map()`` and ``catch()`` -- as REST endpoints of the nginx "
"upstream module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:719
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:748
msgid ""
"An easy way to configure and launch nginx would be to create a Docker container "
"based on a `Docker image <https://hub.docker.com/r/tarantool/tarantool-nginx/>`_ "
"with nginx and the upstream module already installed (see `http/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/http/Dockerfile>`_). We take a "
"standard `nginx.conf <https://github.com/Sulverus/pokemon/blob/master/http/nginx."
"conf>`_, where we define an upstream with our Tarantool backend running (this is "
"another Docker container, see details below):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:757
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:764
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the upstream "
"module's `README <https://github.com/tarantool/"
"nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:768
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:794
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second Docker "
"container based on the `official Tarantool 1.7 image <https://github.com/"
"tarantool/docker>`_ (see `src/Dockerfile <https://github.com/Sulverus/pokemon/"
"blob/master/src/Dockerfile>`_) and set the container's default command to "
"``tarantool app.lua``. This is the backend."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:803
msgid "Non-blocking IO"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:805
msgid ""
"To test the REST API, we create a new script (`client.lua <https://github.com/"
"Sulverus/pokemon/blob/master/client/client.lua>`_), which is similar to our "
"``game.lua`` application, but makes HTTP POST and GET requests rather than "
"calling Lua functions:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:810
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:885
msgid ""
"When you run this script, you’ll notice that both players have equal chances to "
"make the first attempt at catching the pokémon. In a classical Lua script, a "
"networked call blocks the script until it’s finished, so the first catch attempt "
"can only be done by the player who entered the game first. In Tarantool, both "
"players play concurrently, since all modules are integrated with Tarantool :ref:"
"`cooperative multitasking <atomic-cooperative_multitasking>` and use non-"
"blocking I/O."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:893
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block. The "
"fiber running ``catch()`` function on behalf of Player1 issues a non-blocking "
"call to the operating system and yields control to the next fiber, which happens "
"to be the fiber of Player2. Player2’s fiber does the same. When the network "
"response is received, Player1's fiber is activated by Tarantool cooperative "
"scheduler, and resumes its work. All Tarantool :ref:`modules <built_in_modules>` "
"use non-blocking I/O and are integrated with Tarantool cooperative scheduler. "
"For module developers, Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:902
msgid ""
"For our HTTP test, we create a third container based on the `official Tarantool "
"1.7 image <https://github.com/tarantool/docker>`_ (see `client/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/client/Dockerfile>`_) and set "
"the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:910
msgid ""
"To run this test locally, download our `pokemon <https://github.com/Sulverus/"
"pokemon>`_ project from GitHub and say:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:913
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:918
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` (Tarantool "
"backend), ``phttp`` (nginx) and ``pclient`` (demo client). You can see log "
"messages from all these containers in the console, pclient saying that it made "
"an HTTP request to create a pokémon, made two catch requests, requested the map "
"(empty since the pokémon is caught and temporarily inactive) and exited:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:924
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | {\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x"
"\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:937
msgid ""
"Congratulations! Here's the end point of our walk-through. As further reading, "
"see more about :ref:`installing <app_server-installing_module>` and :ref:"
"`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:941
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and :ref:`C "
"API <index-c_api_reference>`, and don't miss our :ref:`Lua cookbook recipes "
"<cookbook>`."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:33
msgid "Application server"
msgstr "Сервер приложений"

#: ../doc/1.7/book/app_server/index.rst:35
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a Lua "
"application server."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:38 ../doc/1.7/book/box/index.rst:38
#: ../doc/1.7/book/getting_started/index.rst:38
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:33
#, fuzzy
msgid "Installing a module"
msgstr "Установка существующего модуля"

#: ../doc/1.7/book/app_server/installing_module.rst:35
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:38
msgid "Tarantool LuaRocks repository, and"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:39
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:43
msgid ""
"As a current limitation, neither of these locations is available for Mac OS "
"users."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:50
msgid "Installing a module from LuaRocks"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:52
#, fuzzy
msgid ""
"See `README in tarantool/rocks repository <https://github.com/tarantool/"
"rocks#installing-a-module-from-luarocks>`_ for detailed instructions."
msgstr ""
"Далее на странице `репозитория \"tarantool/rocks\" на GitHub <https://github.com/"
"tarantool/rocks>`_ вы можете посмотреть примеры модулей и инструкции по "
"добавлению собственных модулей в общий репозиторий."

#: ../doc/1.7/book/app_server/installing_module.rst:60
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:62
msgid "Follow these steps:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:64
msgid ""
"Install Tarantool as recommended on the `download page <http://tarantool.org/"
"download.html>`_."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:67
msgid ""
"Install the module you need. Look up the module's name on `Tarantool rocks page "
"<http://tarantool.org/rocks.html>`_ and put the prefix \"tarantool-\" before the "
"module name to avoid ambiguity:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:71
msgid ""
"# for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"# for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:79
msgid ""
"For example, to install the module `shard <http://github.com/tarantool/shard>`_ "
"on Ubuntu, say:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:82
#, fuzzy
msgid "$ sudo apt-get install tarantool-shard"
msgstr "$ sudo apt-get install luarocks"

#: ../doc/1.7/book/app_server/installing_module.rst:86
msgid "Once these steps are complete, you can:"
msgstr "Теперь можно:"

#: ../doc/1.7/book/app_server/installing_module.rst:88
#, fuzzy
msgid "load any module with"
msgstr "загружать любой модуль для Tarantool'а с помощью ``require``"

#: ../doc/1.7/book/app_server/installing_module.rst:90
msgid "tarantool> local-name = require('module-name')"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:94
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or ``package."
"cpath`` (C):"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:97
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; /usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:117
#, fuzzy
msgid ""
"Question-marks stand for the module name that was specified earlier when saying "
"``require('module-name')``."
msgstr ""
"Знаки вопроса стоят вместо имени модуля, которое было указано ранее при вызове :"
"extsamp:`require('{*{имя_модуля}*}')`."

#: ../doc/1.7/book/app_server/launching_app.rst:33
#, fuzzy
msgid "Launching an application"
msgstr "Остановить приложение"

#: ../doc/1.7/book/app_server/launching_app.rst:35
msgid ""
"Using Tarantool as an application server, you can write your own applications. "
"Tarantool’s native language for writing applications is `Lua <http://www.lua.org/"
"about.html>`_, so a typical application would be a file that contains your Lua "
"script. But you can also write applications in C or C++."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:43
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool tutorial "
"before proceeding with this chapter. To launch the tutorial, say ``tutorial()`` "
"in Tarantool console:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:47
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:62
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a "
"simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:65
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:70
msgid "We save it in a file (let it be ``myapp.lua`` in the current directory)."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:72
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:78
msgid "Launching in Docker"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:80
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-using_docker>`, "
"the following command will start Tarantool without any application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:83
msgid ""
"# create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:88
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:90
msgid ""
"# create a temporary container and\n"
"# launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:99
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:101
msgid "our application file (``\\`pwd\\`/myapp.lua``) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:102
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:104
msgid ""
"By convention, the directory for Tarantool application code inside a container "
"is ``/opt/tarantool``, and the directory for data is ``/var/lib/tarantool``."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:111
msgid "Launching a binary program"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:113
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-using_binary>` "
"or from a :ref:`source build <building_from_source>`, we can launch our "
"application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:117
msgid "in the script mode,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:118
#, fuzzy
msgid "as a server application, or"
msgstr "Репликация по схеме master-master"

#: ../doc/1.7/book/app_server/launching_app.rst:119
msgid "as a daemon service."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:121
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:129
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:131
msgid ""
"Now let’s turn this script into a **server application**. We use :ref:`box.cfg "
"<box_introspection-box_cfg>` from Tarantool’s built-in Lua module to:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:135
msgid ""
"launch the database (a database has a persistent on-disk state, which needs to "
"be restored after we start an application) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:137
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:139
msgid ""
"We also add some simple database logic, using :ref:`space.create() <box_schema-"
"space_create>` and :ref:`create_index() <box_space-create_index>` to create a "
"space with a primary index. We use the function :ref:`box.once() <box-once>` to "
"make sure that our logic will be executed only once when the database is "
"initialized for the first time, so we don't try to create an existing space or "
"index on each invocation of the script:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:160
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:179
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:189
msgid ""
"But the Tarantool instance will stop if we close the current terminal window. To "
"detach Tarantool and our application from the terminal window, we can launch it "
"in the **daemon mode**. To do so, we add some parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:193
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:195
msgid ""
":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool daemon "
"where to store its log file (other log settings are available in Tarantool :ref:"
"`log <log-module>` module), and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:198
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the Tarantool "
"daemon where to store its pid file."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:201
msgid "For example:"
msgstr "Например:"

#: ../doc/1.7/book/app_server/launching_app.rst:203
msgid ""
"box.cfg {\n"
"   listen = 3301\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:212
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:220
msgid ""
"Tarantool executes our script, gets detached from the current shell session (you "
"won't see it with ``ps | grep \"tarantool\"``) and continues working in the "
"background as a daemon attached to the global session (with SID = 0):"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:230
msgid ""
"Now that we have discussed how to create and launch a Lua application for "
"Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:33
msgid "Transaction control"
msgstr "Контроль транзакций"

#: ../doc/1.7/book/box/atomic.rst:35
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. That is "
"why Tarantool has a guarantee of execution atomicity. That requires emphasis."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:43
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:45
#, fuzzy
msgid ""
"How does Tarantool process a basic operation? As an example, let's take this "
"query:"
msgstr ""
"Как Tarantool выполняет основные операции? Давайте рассмотрим это на следующем "
"примере:"

#: ../doc/1.7/book/box/atomic.rst:47
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/atomic.rst:51
#, fuzzy
msgid "This is equivalent to an SQL statement like:"
msgstr "Это аналогично следующему выражению на языке SQL:"

#: ../doc/1.7/book/box/atomic.rst:53
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"
msgstr ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE \"field[[1]\" = 3"

#: ../doc/1.7/book/box/atomic.rst:57
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:59
msgid ""
"If we issue the query on a remote client, then the **network thread** on the "
"server side receives the query, parses the statement and changes it to a server "
"executable message which has already been checked, and which the server instance "
"can understand without parsing everything again."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:64
msgid ""
"The network thread ships this message to the instance's **\"transaction processor"
"\" thread** using a lock-free message bus. Lua programs execute directly in the "
"transaction processor thread, and do not require parsing and preparation."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:69
#, fuzzy
msgid ""
"The instance's transaction processor thread uses the primary-key index on "
"field[1] to find the location of the tuple. It determines that the tuple can be "
"updated (not much can go wrong when you're merely changing an unindexed field "
"value to something shorter)."
msgstr ""
"Поток, выполняющий обработку транзакций на стороне сервера, использует первичный "
"индекс по полю field[1], чтобы найти нужный кортеж в памяти. Он проверяет, что "
"данный кортеж можно обновить (мы хотим лишь изменить значение не "
"индексированного поля, и вряд ли что-то пойдет не так в таком простом случае)."

#: ../doc/1.7/book/box/atomic.rst:74
msgid ""
"The transaction processor thread sends a message to the **write-ahead logging "
"(WAL) thread** to commit the transaction. When done, the WAL thread replies with "
"a COMMIT or ROLLBACK result, which is returned to the client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:79
#, fuzzy
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. Some "
"people are used to the idea that there can be multiple threads operating on the "
"database, with (say) thread #1 reading row #x, while thread #2 writes row #y. "
"With Tarantool, no such thing ever happens. Only the transaction processor "
"thread can access the database, and there is only one transaction processor "
"thread for each Tarantool instance."
msgstr ""
"В Tarantool'е есть только один поток обработки транзакций. Многие люди уже "
"привыкли к мысли, что потоков для обработки данных может быть много (например, "
"поток #1 читает данные из строки #x, в то время как поток #2 записывает данные в "
"столбец #y). В случае с Tarantool'ом такого не происходит. доступ к базе есть "
"только у потока обработки транзакций, и на каждый экземпляр Tarantool'а есть "
"только один такой поток."

#: ../doc/1.7/book/box/atomic.rst:86
#, fuzzy
msgid ""
"Like any other Tarantool thread, the transaction processor thread can handle "
"many **fibers**. A fiber is a set of computer instructions that may contain "
"\"**yield**\" signals. The transaction processor thread will execute all "
"computer instructions until a yield, then switch to execute the instructions of "
"a different fiber. Thus (say) the thread reads row #x for the sake of fiber #1, "
"then writes row #y for the sake of fiber #2."
msgstr ""
"Поток обработки транзакций может управлять множеством *файберов*. Файбер — это "
"набор инструкций, среди которых могут быть и сигналы \"передать управление\". "
"Поток обработки транзакций выполняет инструкции, пока не увидит такой сигнал, и "
"тогда он переключается на выполнение инструкций из другого файбера. Например, "
"таким образом поток обработки транзакций сначала выполняет чтение данных из "
"строки #x для файбера #1, а затем выполняет запись в строку #y для файбер #2."

#: ../doc/1.7/book/box/atomic.rst:93
msgid ""
"Yields must happen, otherwise the transaction processor thread would stick "
"permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:96
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change operation or "
"network-access causes an implicit yield, and every statement that goes through "
"the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:100
msgid ""
"explicit yields: in a Lua function, you can (and should) add “yield” statements "
"to prevent hogging. This is called **cooperative multitasking**."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:107
#, fuzzy
msgid "Cooperative multitasking"
msgstr "Среда взаимной многозадачности"

#: ../doc/1.7/book/box/atomic.rst:109
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately yields "
"control, it is not preempted by some other fiber. But a running fiber will "
"deliberately yield when it encounters a “yield point”: a transaction commit, an "
"operating system call, or an explicit ``yield()`` request. Any system call which "
"can block will be performed asynchronously, and any running fiber which must "
"wait for a system call will be preempted, so that another ready-to-run fiber "
"takes its place and becomes the new running fiber."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:117
msgid ""
"This model makes all programmatic locks unnecessary: cooperative multitasking "
"ensures that there will be no concurrency around a resource, no race conditions, "
"and no memory consistency issues."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:121
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or "
"SELECT, fiber scheduling is fair: it takes only a little time to process the "
"request, schedule a disk write, and yield to a fiber serving the next client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:125
msgid ""
"However, a function might perform complex computations or might be written in "
"such a way that yields do not occur for a long time. This can lead to unfair "
"scheduling, when a single client throttles the rest of the system, or to "
"apparent stalls in request processing. Avoiding this situation is the "
"responsibility of the function’s author."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:135
#, fuzzy
msgid "Transactions"
msgstr "Контроль транзакций"

#: ../doc/1.7/book/box/atomic.rst:137
msgid ""
"In the absence of transactions, any function that contains yield points may see "
"changes in the database state caused by fibers that preempt. Multi-statement "
"transactions exist to provide isolation: each transaction sees a consistent "
"database state and commits all its changes atomically. At commit time, a yield "
"happens and all transaction changes are written to the write ahead log in a "
"single batch."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:144
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the first "
"transaction to commit wins. If a concurrent active transaction has read a value "
"modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:148
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-statement "
"transaction is not preempted and hence is never aborted. Therefore, "
"understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:154
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:160
#, fuzzy
msgid "Implicit yields"
msgstr "Правила неявной передачи управления"

#: ../doc/1.7/book/box/atomic.rst:162
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() <fiber-"
"sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other requests \"imply"
"\" yields because Tarantool is designed to avoid blocking."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:166
msgid "Database operations usually do not yield, but it depends on the engine:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:168
msgid "In memtx, reads or writes do not require I/O and do not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:170
msgid ""
"In vinyl, not all data is in memory, and SELECT often incurs a disc I/O, and "
"therefore yields, while a write may stall waiting for memory to free up, thus "
"also causing a yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:174
msgid ""
"In the \"autocommit\" mode, all data change operations are followed by an "
"automatic commit, which yields. So does an explicit commit of a multi-statement "
"transaction, :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:178
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box <net_box-"
"module>`, :ref:`console <console-module>` and :ref:`socket <socket-module>` (the "
"\"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:182 ../doc/1.7/book/box/authentication.rst:180
#: ../doc/1.7/book/box/box_session.rst:209
#, fuzzy
msgid "**Example #1**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/atomic.rst:184
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write to the "
"WAL and so does not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:188
msgid ""
"*Engine = vinyl* |br| ``select() insert()`` has between one and three yields, "
"since ``select()`` may yield if the data is not in cache, ``insert()`` may yield "
"waiting for available memory, and there is an implicit yield at commit."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:193
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit if the "
"engine is memtx, and can yield up to 3 times if the engine is vinyl."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:196 ../doc/1.7/book/box/authentication.rst:188
#: ../doc/1.7/book/box/box_session.rst:218
#, fuzzy
msgid "**Example #2**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/atomic.rst:198
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw from "
"tuple#1, deposit in tuple#2, and end the transaction, making its effects "
"permanent."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:203
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:219
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then "
"implicit yielding at commit time does not take place, because there are no "
"writes to the WAL."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:223
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an implicit "
"yield, even if the request that is sent to the server is not itself an implicit "
"yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:231
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:235
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program being "
"executed on the server instance, but causes yielding (in both memtx and vinyl) "
"if it is done as a series of transmissions from a client, including a client "
"which operates via telnet, via one of the connectors, or via the MySQL and "
"PostgreSQL rocks, or via the interactive mode when :ref:`using Tarantool as a "
"client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:242
msgid ""
"After a fiber has yielded and then has regained control, it immediately issues :"
"ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:33
msgid "Access control"
msgstr "Ограничение доступа"

#: ../doc/1.7/book/box/authentication.rst:35
msgid ""
"Understanding security details is primarily an issue for administrators. "
"Meanwhile, ordinary users should at least skim this section to get an idea of "
"how Tarantool makes it possible for administrators to prevent unauthorized "
"access to the database and to certain functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:40
msgid "In a nutshell:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:42
msgid ""
"There is a method to guarantee with password checks that users really are who "
"they say they are (“authentication”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:45
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames and "
"password-hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:48
msgid ""
"There are functions for saying that certain users are allowed to do certain "
"things (“privileges”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:51
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges are "
"stored. Whenever a user tries to do an operation, there is a check whether the "
"user has the privilege to do the operation (“access control”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:55
msgid "Further on, we explain all of this in more detail."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:61
msgid "Users"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:63
msgid ""
"There is a **current user** for any program working with Tarantool, local or "
"remote. If a remote connection is using a :ref:`binary port <admin-security>`, "
"the current user, by default, is '**guest**'. If the connection is using an :ref:"
"`admin-console port <admin-security>`, the current user is '**admin**'. When "
"executing a :ref:`Lua initialization script <index-init_label>`, the current "
"user is also ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:72
msgid ""
"The current user name can be found with :ref:`box.session.user() <box_session-"
"user>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:74
msgid "The current user can be changed:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:76
msgid ""
"For a binary port connection -- with AUTH protocol command, supported by most "
"clients;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:79
msgid ""
"For an admin-console connection and in a Lua initialization script -- with :ref:"
"`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:82
msgid ""
"For a stored function invoked with CALL command over a binary port -- with :ref:"
"`SETUID <box_schema-func_create>` property enabled for the function, which makes "
"Tarantool temporarily replace the current user with the function’s creator, with "
"all creator's privileges, during function execution."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:91
msgid "Passwords"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:93
msgid "Each user may have a **password**. The password is any alphanumeric string."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:95
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` system space "
"with a `cryptographic hash function <https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function>`_ so that, if the password is ‘x’, the stored hash-"
"password is a long string like ‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client "
"connects to a Tarantool instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the client must "
"mix with the hashed-password before sending to the instance. Thus the original "
"value ‘x’ is never stored anywhere except in the user’s head, and the hashed "
"value is never passed down a network wire except when mixed with a random salt."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:109
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose of "
"writing a new client application), read the `scramble.h <https://github.com/"
"tarantool/tarantool/blob/1.7/src/scramble.h>`_ header file."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:114
msgid ""
"This system prevents malicious onlookers from finding passwords by snooping in "
"the log files or snooping on the wire. It is the same system that `MySQL "
"introduced several years ago <http://dev.mysql.com/doc/refman/5.7/en/password-"
"hashing.html>`_, which has proved adequate for medium-security installations. "
"Nevertheless, administrators should warn users that no system is foolproof "
"against determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long unobvious "
"passwords, but it is ultimately up to the users to choose or change their own "
"passwords."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:124
msgid ""
"There are two functions for managing passwords in Tarantool: :ref:`box.schema."
"user.password() <box_schema-user_password>` for changing a user's password and :"
"ref:`box.schema.user.passwd() <box_schema-user_passwd>` for getting a hash-"
"password."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:133
msgid "Owners and privileges"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:135
msgid ""
"In Tarantool, all objects are organized into a hierarchy of ownership. "
"Ordinarily the **owner** of every object is its creator. The creator of the "
"initial database state (we call it ‘universe’) --  including the database "
"itself, the system spaces, the users -- is ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:140
msgid ""
"An object's owner can share some rights on the object by **granting privileges** "
"to other users. The following privileges are implemented:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:143
msgid "Read an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:144
msgid "Write, i.e. modify contents of an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:145
msgid ""
"Execute, i.e. use an object (if the privilege makes sense for the object; for "
"example, spaces can not be \"executed\", but functions can)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:150
msgid ""
"Currently, \"drop\" and \"grant\" privileges can not be granted to other users. "
"This possibility will be added in future versions of Tarantool."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:153
msgid ""
"This is how the privilege system works under the hood. To be able to create "
"objects, a user needs to have write access to Tarantool's system spaces. The "
"'admin' user, who is at the top of the hierarchy and who is the ultimate source "
"of privileges, shares write access to a system space (e.g. :ref:`_space "
"<box_space-space>`) with some users. Now the users can insert data into the "
"system space (e.g. creating new spaces) and themselves become creators/definers "
"of new objects. For the objects they created, the users can in turn share "
"privileges with other users."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:162
msgid ""
"This is why only an object's owner can drop the object, but not other ordinary "
"users. Meanwhile, 'admin' can drop any object or delete any other user, because "
"'admin' is the creator and ultimate owner of them all."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:166
msgid ""
"The syntax of all :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() "
"<box_schema-user_revoke>` commands in Tarantool follows this basic idea."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:170
msgid "Their first argument is \"who gets\" or \"who is revoked\" a grant."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:172
msgid ""
"Their second argument is the type of privilege granted, or a list of privileges."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:174
msgid "Their third argument is the object type on which the privilege is granted."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:176
msgid ""
"Their fourth and optional argument is the object name (‘universe' has no name, "
"because there is only one ‘universe’, but you need to specify names for "
"functions/users/spaces/etc)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:182
msgid ""
"Here we disable all privileges and run Tarantool in the ‘no-privilege’ mode."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:184
#, fuzzy
msgid "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""
"tarantool> box.schema.user.grant('guest', 'read,write,execute', 'universe')"

#: ../doc/1.7/book/box/authentication.rst:190
msgid ""
"Here we create a Lua function that will be executed under the user id of its "
"creator, even if called by another user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:193
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function ('read_and_modify') "
"and the no-password user becomes this function's creator. Finally, we grant "
"another user ('public_user') access to execute Lua functions created by the no-"
"password user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:198
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.schema.space.u:create_index('pk')\n"
"box.schema.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create(‘internal’)\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil\n"
"        u:put{key, box.session.uid()}\n"
"        i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', 'read_and_modify')"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:231
msgid "Roles"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:233
msgid ""
"A **role** is a container for privileges which can be granted to regular users. "
"Instead of granting or revoking individual privileges, you can put all the "
"privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:237
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, but the "
"third field in the tuple -- the type field -- is ‘role’ rather than ‘user’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:240
msgid ""
"An important feature in role management is that roles can be **nested**. For "
"example, role R1 can be granted a privilege \"role R2\", so users with the role "
"R1 will subsequently get all privileges from both roles R1 and R2. In other "
"words, a user gets all the privileges that are granted to a user’s roles, "
"directly or indirectly."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:248
msgid ""
"-- This example will work for a user with many privileges, such as 'admin'\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:271
msgid ""
"For details about Tarantool functions related to role management, see reference "
"on :ref:`box.schema <box_schema>` submodule."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:278
msgid "Sessions and security"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:280
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:282
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:283
msgid ""
"the :ref:`current user <authentication-users>` associated with the connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:284
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:285
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:287
msgid ""
"In Tarantool, a single session can execute multiple concurrent transactions. "
"Each transaction is identified by a unique integer id, which can be queried at "
"start of the transaction using :ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:293
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:33 ../doc/1.7/book/box/box_introspection.rst:33
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:37 ../doc/1.7/book/box/box_introspection.rst:37
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server "
"configuration parameters (see \"Configuration reference\" for :ref:`a complete "
"description of all configuration parameters <box_cfg_params>`). Use ``box.cfg`` "
"without braces to get read-only access to those parameters."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:42 ../doc/1.7/book/box/box_index.rst:61
#: ../doc/1.7/book/box/box_index.rst:461 ../doc/1.7/book/box/box_index.rst:597
#: ../doc/1.7/book/box/box_index.rst:625 ../doc/1.7/book/box/box_index.rst:653
#: ../doc/1.7/book/box/box_index.rst:685 ../doc/1.7/book/box/box_index.rst:709
#: ../doc/1.7/book/box/box_index.rst:785 ../doc/1.7/book/box/box_index.rst:808
#: ../doc/1.7/book/box/box_index.rst:828 ../doc/1.7/book/box/box_info.rst:122
#: ../doc/1.7/book/box/box_introspection.rst:42
#: ../doc/1.7/book/box/box_introspection.rst:106
#: ../doc/1.7/book/box/box_introspection.rst:168
#: ../doc/1.7/book/box/box_schema.rst:204 ../doc/1.7/book/box/box_schema.rst:241
#: ../doc/1.7/book/box/box_schema.rst:274 ../doc/1.7/book/box/box_schema.rst:311
#: ../doc/1.7/book/box/box_schema.rst:333 ../doc/1.7/book/box/box_schema.rst:355
#: ../doc/1.7/book/box/box_schema.rst:378 ../doc/1.7/book/box/box_schema.rst:397
#: ../doc/1.7/book/box/box_schema.rst:412 ../doc/1.7/book/box/box_schema.rst:442
#: ../doc/1.7/book/box/box_schema.rst:472 ../doc/1.7/book/box/box_schema.rst:489
#: ../doc/1.7/book/box/box_schema.rst:526 ../doc/1.7/book/box/box_schema.rst:547
#: ../doc/1.7/book/box/box_schema.rst:562 ../doc/1.7/book/box/box_slab.rst:55
#: ../doc/1.7/book/box/box_slab.rst:114 ../doc/1.7/book/box/box_slab.rst:156
#: ../doc/1.7/book/box/box_space.rst:171 ../doc/1.7/book/box/box_space.rst:193
#: ../doc/1.7/book/box/box_space.rst:219 ../doc/1.7/book/box/box_space.rst:416
#: ../doc/1.7/book/box/box_space.rst:449 ../doc/1.7/book/box/box_space.rst:480
#: ../doc/1.7/book/box/box_space.rst:503 ../doc/1.7/book/box/box_space.rst:521
#: ../doc/1.7/book/box/box_space.rst:624 ../doc/1.7/book/box/box_space.rst:667
#: ../doc/1.7/book/box/box_space.rst:703 ../doc/1.7/book/box/box_space.rst:721
#: ../doc/1.7/book/box/box_space.rst:758 ../doc/1.7/book/box/box_space.rst:830
#: ../doc/1.7/book/box/box_space.rst:907 ../doc/1.7/book/box/box_space.rst:1012
#: ../doc/1.7/book/box/box_space.rst:1048 ../doc/1.7/book/box/box_space.rst:1067
#: ../doc/1.7/book/box/box_space.rst:1084 ../doc/1.7/book/box/box_space.rst:1134
#: ../doc/1.7/book/box/box_space.rst:1250 ../doc/1.7/book/box/box_space.rst:1470
#: ../doc/1.7/book/box/box_tuple.rst:62
msgid "**Example:**"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:44 ../doc/1.7/book/box/box_introspection.rst:44
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:33
msgid "Submodule `box.index`"
msgstr "Вложенный модуль `box.index`"

#: ../doc/1.7/book/box/box_index.rst:35
msgid ""
"The ``box.index`` submodule provides read-only access for index definitions and "
"index keys. Indexes are contained in :samp:`box.space.{space-name}.index` array "
"within each space object. They provide an API for ordered iteration over tuples. "
"This API is a direct binding to corresponding methods of index objects of type "
"``box.index`` in the storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:47
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_introspection.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_slab.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
msgid "rtype"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:49 ../doc/1.7/book/box/box_schema.rst:65
#: ../doc/1.7/book/box/box_schema.rst:83 ../doc/1.7/book/box/box_space.rst:264
#: ../doc/1.7/book/box/box_space.rst:266 ../doc/1.7/book/box/data_model.rst:183
msgid "boolean"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:53
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:57
msgid "An array describing index key fields."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:59 ../doc/1.7/book/box/box_info.rst:120
#: ../doc/1.7/book/box/box_introspection.rst:104
#: ../doc/1.7/book/box/box_schema.rst:97 ../doc/1.7/book/box/box_slab.rst:53
#: ../doc/1.7/book/box/box_slab.rst:112 ../doc/1.7/book/box/box_slab.rst:154
#: ../doc/1.7/book/box/box_space.rst:1082
msgid "table"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:63
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:81
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow iterating "
"over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:84
msgid ""
"The :samp:`{key}` parameter specifies what must match within the index. The :"
"samp:`{iterator}` parameter specifies the rule for matching and ordering. "
"Different index types support different iterators. For example, a TREE index "
"maintains a strict order of keys and can return all tuples in ascending or "
"descending order, starting from the specified key. Other index types, however, "
"do not support ordering."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:91
msgid ""
"To understand consistency of tuples returned by an iterator, it's essential to "
"know the principles of the Tarantool transaction processing subsystem. An "
"iterator in Tarantool does not own a consistent read view. Instead, each "
"procedure is granted exclusive access to all tuples and spaces until there is a "
"\"context switch\": which may happen due to :ref:`the implicit yield rules "
"<atomic-implicit-yields>`, or by an explicit call to :ref:`fiber.yield <fiber-"
"yield>`. When the execution flow returns to the yielded procedure, the data set "
"could have changed significantly. Iteration, resumed after a yield point, does "
"not preserve the read view, but continues with the new content of the database. "
"The tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be used "
"together."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
msgid "Parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:105 ../doc/1.7/book/box/box_index.rst:450
#: ../doc/1.7/book/box/box_index.rst:585 ../doc/1.7/book/box/box_index.rst:612
#: ../doc/1.7/book/box/box_index.rst:640 ../doc/1.7/book/box/box_index.rst:671
#: ../doc/1.7/book/box/box_index.rst:701 ../doc/1.7/book/box/box_index.rst:730
#: ../doc/1.7/book/box/box_index.rst:751 ../doc/1.7/book/box/box_index.rst:769
#: ../doc/1.7/book/box/box_index.rst:800 ../doc/1.7/book/box/box_index.rst:820
#: ../doc/1.7/book/box/box_index.rst:842
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:107 ../doc/1.7/book/box/box_space.rst:606
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:109
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_introspection.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_slab.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
msgid "return"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:113 ../doc/1.7/book/box/box_space.rst:611
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a for/end "
"loop or with `totable() <https://rtsisyk.github.io/luafun/reducing.html#fun."
"totable>`_"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:117
msgid ""
"**Possible errors:** No such space; wrong type; Selected iteration type is not "
"supported for the index type; or key is not supported for the iteration type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:121
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:124
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for example "
"``'abcd'``), or a table of numbers and strings (for example ``{1234, 'abcd'}``). "
"Each part of a key will be compared to each part of an index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:129
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
#: ../doc/1.7/book/box/box_space.rst:1384
msgid "Type"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
msgid "Arguments"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
#: ../doc/1.7/book/box/box_space.rst:1384
msgid "Description"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140 ../doc/1.7/book/box/box_index.rst:245
#: ../doc/1.7/book/box/box_index.rst:278 ../doc/1.7/book/box/box_index.rst:313
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140 ../doc/1.7/book/box/box_index.rst:146
#: ../doc/1.7/book/box/box_index.rst:151 ../doc/1.7/book/box/box_index.rst:158
#: ../doc/1.7/book/box/box_index.rst:165 ../doc/1.7/book/box/box_index.rst:169
#: ../doc/1.7/book/box/box_index.rst:175 ../doc/1.7/book/box/box_index.rst:245
#: ../doc/1.7/book/box/box_index.rst:251 ../doc/1.7/book/box/box_index.rst:313
#: ../doc/1.7/book/box/box_index.rst:321 ../doc/1.7/book/box/box_index.rst:326
#: ../doc/1.7/book/box/box_index.rst:331 ../doc/1.7/book/box/box_index.rst:336
#: ../doc/1.7/book/box/box_index.rst:346
msgid "search value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. Tuples are returned in ascending order by index key. This is "
"the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:151 ../doc/1.7/book/box/box_index.rst:251
#: ../doc/1.7/book/box/box_index.rst:321
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:151
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater than a "
"search value, it matches. Tuples are returned in ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:158 ../doc/1.7/book/box/box_index.rst:326
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:158
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index key is "
"greater than or equal to a search value, it matches. Tuples are returned in "
"ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:165 ../doc/1.7/book/box/box_index.rst:274
#: ../doc/1.7/book/box/box_index.rst:310
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:165
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:169 ../doc/1.7/book/box/box_index.rst:331
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:169
msgid ""
"The comparison operator is '<' (less than). If an index key is less than a "
"search value, it matches. Tuples are returned in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:175 ../doc/1.7/book/box/box_index.rst:336
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:175
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key is less "
"than or equal to a search value, it matches. Tuples are returned in descending "
"order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:184
msgid ""
"Informally, we can state that searches with TREE indexes are generally what "
"users will find is intuitive, provided that there are no nils and no missing "
"parts. Formally, the logic is as follows. A search key has zero or more parts, "
"for example {}, {1,2,3},{1,nil,3}. An index key has one or more parts, for "
"example {1}, {1,2,3},{1,2,3}. An search key may contain nil (but not msgpack."
"NULL, which is the wrong type). An index key may not contain nil or msgpack."
"NULL, although a later version of Tarantool will have different rules --  the "
"behavior of searches with nil is subject to change. Possible iterators are LT, "
"LE, EQ, REQ, GE, GT. A search key is said to \"match\" an index key if the "
"following statements, which are pseudocode for the comparison operation, return "
"TRUE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:231
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240
msgid "box.index.ALL"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240 ../doc/1.7/book/box/box_index.rst:274
#: ../doc/1.7/book/box/box_index.rst:310
msgid "none"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of index "
"key, which will appear to be random."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:245
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a search "
"value, it matches. The number of returned tuples will be 0 or 1. This is the "
"default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:251
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key is "
"greater than a hash of a search value, it matches. Tuples are returned in "
"ascending order by hash of index key, which will appear to be random. Provided "
"that the space is not being updated, one can retrieve all the tuples in a space, "
"N tuples at a time, by using {iterator='GT', limit=N} in each search, and using "
"the last returned value from the previous result as the start search value for "
"the next search."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:265
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:274
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:278 ../doc/1.7/book/box/box_index.rst:283
#: ../doc/1.7/book/box/box_index.rst:288 ../doc/1.7/book/box/box_index.rst:293
msgid "bitset value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:278
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are returned in "
"their order within the space. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:283
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:283
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:288
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:288
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:293
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:293
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index key, it "
"matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:301
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:310
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:313
msgid ""
"If all points of the rectangle-or-box defined by the search value are the same "
"as the rectangle-or-box defined by the index key, it matches. Tuples are "
"returned in their order within the space. \"Rectangle-or-box\" means \"rectangle-"
"or-box as explained in section about :ref:`RTREE <box_index-rtree>`\". This is "
"the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:321
msgid ""
"If all points of the rectangle-or-box defined by the search value are within the "
"rectangle-or-box defined by the index key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:326
msgid ""
"If all points of the rectangle-or-box defined by the search value are within, or "
"at the side of, the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:331
msgid ""
"If all points of the rectangle-or-box defined by the index key are within the "
"rectangle-or-box defined by the search key, it matches. Tuples are returned in "
"their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:336
msgid ""
"If all points of the rectangle-or-box defined by the index key are within, or at "
"the side of, the rectangle-or-box defined by the search key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid "search values"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid ""
"If some points of the rectangle-or-box defined by the search value are within "
"the rectangle-or-box defined by the index key, it matches. Tuples are returned "
"in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:346
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:346
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key are "
"within, or at the side of, defined by the index key, it matches. Tuples are "
"returned in order: nearest neighbor first."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:352
msgid "**First Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:354
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:356
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:402
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:404
msgid ""
"This Lua code finds all the tuples whose primary key values begin with 'XY'. The "
"assumptions include that there is a one-part primary-key TREE index on the first "
"field, which must be a string. The iterator loop ensures that the search will "
"return tuples where the first value is greater than or equal to 'XY'. The "
"conditional statement within the loop ensures that the looping will stop when "
"the first two letters are not 'XY'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:412
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:420
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:422
msgid ""
"This Lua code finds all the tuples whose primary key values are greater than or "
"equal to 1000, and less than or equal to 1999 (this type of request is sometimes "
"called a \"range search\" or a \"between search\"). The assumptions include that "
"there is a one-part primary-key TREE index on the first field, which must be a "
"number. The iterator loop ensures that the search will return tuples where the "
"first value is greater than or equal to 1000. The conditional statement within "
"the loop ensures that the looping will stop when the first value is greater than "
"1999."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:432
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:444
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` which "
"goes via a particular index and can make use of additional parameters that "
"specify the iterator type, and the limit (that is, the maximum number of tuples "
"to return) and the offset (that is, which tuple to start with in the list)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:452 ../doc/1.7/book/box/box_index.rst:587
#: ../doc/1.7/book/box/box_index.rst:614 ../doc/1.7/book/box/box_index.rst:642
#: ../doc/1.7/book/box/box_index.rst:703 ../doc/1.7/book/box/box_index.rst:732
#: ../doc/1.7/book/box/box_index.rst:753
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:453
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:454
msgid "type of iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:455
#, fuzzy
msgid "maximum number of tuples"
msgstr "Количество обращений к кортежам"

#: ../doc/1.7/book/box/box_index.rst:456
msgid "start tuple number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:458
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:459 ../doc/1.7/book/box/box_space.rst:752
msgid "array of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:463
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:489
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:491
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:500
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the assumed index "
"is the first (primary-key) index. Therefore, for the example above, ``box.space."
"tester:select({1}, {iterator = 'GT'})`` would have returned the same two rows, "
"via the 'primary' index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:507
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:512
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is omitted, then "
"every key in the index is considered to be a match, regardless of iterator type. "
"Therefore, for the example above, ``box.space.tester:select{}`` will select "
"every tuple in the tester space via the first (primary-key) index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:522
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be "
"replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. That is, "
"``get`` can be used as a convenient shorthand to get the first tuple in the "
"tuple set that would be returned by ``select``. However, if there is more than "
"one tuple in the tuple set, then ``get`` returns an error."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:530
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:532
msgid ""
"The following script shows creation and search with a BITSET index. Notice: "
"BITSET cannot be unique, so first a primary-key index is created. Notice: bit "
"values are entered as hexadecimal literals for easier reading."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:536
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:583
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier <box_index-"
"note>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:589
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:590 ../doc/1.7/book/box/box_index.rst:619
#: ../doc/1.7/book/box/box_index.rst:647 ../doc/1.7/book/box/box_index.rst:676
#: ../doc/1.7/book/box/box_index.rst:741 ../doc/1.7/book/box/box_index.rst:756
#: ../doc/1.7/book/box/box_space.rst:164 ../doc/1.7/book/box/box_space.rst:407
#: ../doc/1.7/book/box/box_space.rst:467 ../doc/1.7/book/box/box_space.rst:498
#: ../doc/1.7/book/box/box_space.rst:694 ../doc/1.7/book/box/box_space.rst:888
#: ../doc/1.7/book/box/box_tuple.rst:56 ../doc/1.7/book/box/box_tuple.rst:200
#: ../doc/1.7/book/box/box_tuple.rst:201 ../doc/1.7/book/box/box_tuple.rst:320
msgid "tuple"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:592
msgid ""
"**Possible errors:** No such index; wrong type; more than one tuple matches."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:594
msgid ""
"**Complexity factors:** Index size, Index type. See also :ref:`space_object:"
"get() <box_space-get>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:599
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:610
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:616
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is supplied, "
"returns the first key which is greater than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:621 ../doc/1.7/book/box/box_index.rst:649
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:623 ../doc/1.7/book/box/box_index.rst:651
#: ../doc/1.7/book/box/box_index.rst:678 ../doc/1.7/book/box/box_space.rst:617
#: ../doc/1.7/book/box/box_space.rst:756
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:627
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:638
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:644
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is supplied, "
"returns the last key which is less than or equal to ``key-value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:655
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:666
msgid ""
"Find a random value in the specified index. This method is useful when it's "
"important to get insight into data distribution in an index without having to "
"iterate over the entire data set."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:673
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:675
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_space.rst
#, fuzzy
msgid "Note re storage engine:"
msgstr "Дисковый движок vinyl"

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``random()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:687
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:698
msgid ""
"Iterate over an index, counting the number of tuples which match the key-value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:704 ../doc/1.7/book/box/box_space.rst:215
msgid "comparison method"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:706
msgid "the number of matching index keys."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:707 ../doc/1.7/book/box/box_index.rst:846
#: ../doc/1.7/book/box/box_schema.rst:73 ../doc/1.7/book/box/box_schema.rst:77
#: ../doc/1.7/book/box/box_session.rst:46 ../doc/1.7/book/box/box_session.rst:51
#: ../doc/1.7/book/box/box_session.rst:77 ../doc/1.7/book/box/box_space.rst:262
#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:279
#: ../doc/1.7/book/box/box_space.rst:281 ../doc/1.7/book/box/box_space.rst:283
#: ../doc/1.7/book/box/box_space.rst:285 ../doc/1.7/book/box/box_space.rst:287
#: ../doc/1.7/book/box/box_tuple.rst:88 ../doc/1.7/book/box/box_tuple.rst:113
#: ../doc/1.7/book/box/box_tuple.rst:162
msgid "number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:711
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:724 ../doc/1.7/book/box/box_space.rst:846
#: ../doc/1.7/book/box/box_tuple.rst:301
msgid "Update a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:726
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is searched in "
"this index instead of primary key. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:733 ../doc/1.7/book/box/box_space.rst:880
#: ../doc/1.7/book/box/box_space.rst:997
msgid "operation type represented in string"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:734 ../doc/1.7/book/box/box_space.rst:881
#: ../doc/1.7/book/box/box_space.rst:998 ../doc/1.7/book/box/box_tuple.rst:313
msgid ""
"what field the operation will apply to. The field number can be negative, "
"meaning the position from the end of tuple. (#tuple + negative field number + 1)"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:738 ../doc/1.7/book/box/box_space.rst:885
#: ../doc/1.7/book/box/box_space.rst:1002 ../doc/1.7/book/box/box_tuple.rst:317
msgid "what value will be applied"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:740 ../doc/1.7/book/box/box_space.rst:887
msgid "the updated tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:745
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:747
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is searched in "
"this index instead of in the primary-key index. This index ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:755
msgid "the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:767
msgid "Alter an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:771
#, fuzzy
msgid ""
"options list, same as the options list for :ref:`create_index <box_space-"
"create_index>`"
msgstr ""
"Подробнее о других типах индексов см. в описании функции :ref:`create_index "
"<box_space-create_index>`."

#: ../doc/1.7/book/box/box_index.rst:774 ../doc/1.7/book/box/box_index.rst:824
#: ../doc/1.7/book/box/box_schema.rst:162 ../doc/1.7/book/box/box_schema.rst:376
#: ../doc/1.7/book/box/box_schema.rst:524 ../doc/1.7/book/box/box_space.rst:442
#: ../doc/1.7/book/box/box_space.rst:663 ../doc/1.7/book/box/box_space.rst:719
#: ../doc/1.7/book/box/box_space.rst:821 ../doc/1.7/book/box/data_model.rst:181
msgid "nil"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:776
msgid ""
"**Possible errors:** Index does not exist, or the first index cannot be changed "
"to {unique = false}, or the alter function is only applicable for the memtx "
"storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``alter()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:787
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:797
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples are "
"deleted."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:803
msgid "nil."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:805
msgid ""
"**Possible errors:** Index does not exist, or a primary-key index cannot be "
"dropped while a secondary-key index exists."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:810
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:818
msgid "Rename an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:822
msgid "new name for index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:826
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:830
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:836 ../doc/1.7/book/box/box_space.rst:819
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:840
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:845 ../doc/1.7/book/box/box_tuple.rst:112
msgid "number of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:850
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:852
msgid ""
"This example will work with the sandbox configuration described in the preface. "
"That is, there is a space named tester with a numeric primary key. The example "
"function will:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:856
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:857
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:860
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:859
msgid "field[1] = 1000"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:860
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:861
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:862
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:863
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:864
msgid "Return the formatted value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:866
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select <box_space-"
"select>`, :ref:`box.space...replace <box_space-replace>`, :ref:`fiber.time "
"<fiber-time>`, :ref:`uuid.str <uuid-str>`. The function uses Lua functions `os."
"date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:875
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:900 ../doc/1.7/book/box/box_tuple.rst:369
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:902
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:919
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:921
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators and "
"Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated retrievals, "
"that is, it returns 10 tuples at a time from a table named \"t\", whose primary "
"key was defined with ``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:928
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:942
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they only "
"need to know that, if they call it within a loop, they will get 10 tuples at a "
"time until there are no more tuples. In this example the tuples are merely "
"printed, a page at a time. But it should be simple to change the functionality, "
"for example by yielding after each retrieval, or by breaking when the tuples "
"fail to match some additional criteria."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:949
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:962
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:964
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial searches if "
"the index type is RTREE. There are operations for searching *rectangles* "
"(geometric objects with 4 corners and 4 sides) and *boxes* (geometric objects "
"with more than 4 corners and more than 4 sides, sometimes called "
"hyperrectangles). This manual uses the term *rectangle-or-box* for the whole "
"class of objects that includes both rectangles and boxes. Only rectangles will "
"be illustrated."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:972
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and Y-axis "
"(vertical axis) coordinates in a grid of arbitrary size. Here is a picture of "
"four rectangles on a grid with 11 horizontal points and 11 vertical points:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:978
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           <-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   <-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   <-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               <-Rectangle#4"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:992
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate of top "
"left, Y-axis coordinate of top left, X-axis coordinate of bottom right, Y-axis "
"coordinate of bottom right} -- or more succinctly: {x1,y1,x2,y2}. So in the "
"picture ... Rectangle#1 starts at position 1 on the X axis and position 2 on the "
"Y axis, and ends at position 3 on the X axis and position 4 on the Y axis, so "
"its coordinates are {1,2,3,4}. Rectangle#2's coordinates are {3,5,9,10}. "
"Rectangle#3's coordinates are {4,7,5,9}. And finally Rectangle#4's coordinates "
"are {10,11,10,11}. Rectangle#4 is actually a \"point\" since it has zero width "
"and zero height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1002
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest neighbor "
"is Rectangle#2\", and \"Rectangle#3 is entirely inside Rectangle#2\"."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1005
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1007
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1020
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key index. "
"(RTREE indexes cannot be unique and therefore cannot be primary-key indexes.) "
"The second field must be an \"array\", which means its values must represent {x,"
"y} points or {x1,y1,x2,y2} rectangles. Now let us populate the table by "
"inserting two tuples, containing the coordinates of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1026
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1031
msgid ""
"And now, following the description of `RTREE iterator types`_, we can search the "
"rectangles with these requests:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1036
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1052
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the rectangle "
"{10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 returns 1 tuple "
"because the rectangle {4,7,5,9}, which was \"Rectangle#3\" in the picture, is "
"entirely within{3,5,9,10} which was Rectangle#2. Request#3 returns 2 tuples, "
"because the NEIGHBOR iterator always returns all tuples, and the first returned "
"tuple will be {3,5,9,10} (\"Rectangle#2\" in the picture) because it is the "
"closest neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1060
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-boxes "
"that have 6 corners and 6 sides."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1063
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1074
msgid ""
"The additional option here is ``dimension=3``. The default dimension is 2, which "
"is why it didn't need to be specified for the examples of rectangle. The maximum "
"dimension is 20. Now for insertions and selections there will usually be 6 "
"coordinates. For example:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1079
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1084
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, which "
"are rectangle-or-boxes that have a different way to calculate neighbors."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1087
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1098
msgid ""
"The additional option here is ``distance='manhattan'``. The default distance "
"calculator is 'euclid', which is the straightforward as-the-crow-flies method. "
"The optional distance calculator is 'manhattan', which can be a more appropriate "
"method if one is following the lines of a grid rather than traveling in a "
"straight line."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1104
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1110
msgid ""
"More examples of spatial searching are online in the file `R tree index quick "
"start and usage`_."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:33 ../doc/1.7/book/box/box_introspection.rst:60
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:37 ../doc/1.7/book/box/box_introspection.rst:64
msgid ""
"The ``box.info`` submodule provides access to information about server instance "
"variables."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:40
msgid ""
"**version** is the Tarantool version. This value is also shown by :ref:"
"`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:42
msgid "**id** corresponds to **replication.id** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:43
msgid ""
"**ro** is ``true`` if the instance is in \"read-only\" mode (same as :ref:"
"`read_only <cfg_basic-read_only>` in ``box.cfg{}``)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:45
msgid "**vclock** corresponds to **replication.downstream.vclock** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:46
msgid ""
"**uptime** is the number of seconds since the instance started. This value can "
"also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:48
msgid "**lsn** corresponds to **replication.lsn** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:49
msgid "**vinyl** returns runtime statistics for vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:50
msgid ""
"**cluster.uuid** is the UUID of the replica set. Every instance in a replica set "
"will have the same ``cluster.uuid`` value. This value is also stored in :ref:"
"`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:54
msgid ""
"**pid** is the process ID. This value is also shown by :ref:`tarantool "
"<tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:57
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:58
msgid ""
"**signature** is the sum of all **lsn** values from the vector clocks "
"(**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:60
msgid "**uuid** corresponds to **replication.uuid**  (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:64
msgid ""
"**replication** part contains statistics for all instances in the replica set in "
"regard to the current instance (see an example in the section :ref:`\"Monitoring "
"a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:68
msgid ""
"**replication.id** is a short numeric identifier of the instance within the "
"replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:70
msgid ""
"**replication.uuid** is a globally unique identifier of the instance. This value "
"is also stored in :ref:`box.space._cluster <box_space-cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:73
msgid ""
"**replication.lsn** is the :ref:`log sequence number <replication-mechanism>` "
"(LSN) for the latest entry in the instance's :ref:`write ahead log <index-"
"box_persistence>` (WAL)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:76
msgid ""
"**replication.upstream** contains statistics for the replication data uploaded "
"by the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:78
msgid "**replication.upstream.status** is the replication status of the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:80
msgid ""
"``auth`` means that the instance is getting authenticated to connect to a "
"replication source."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:82
msgid ""
"``connecting`` means that the instance is trying to connect to the replications "
"source(s) listed in its :ref:`replication <cfg_replication-replication>` "
"parameter."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:85
msgid ""
"``disconnected`` means that the instance is not connected to the replica set "
"(due to network problems, not replication errors)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:87
msgid ""
"``follow`` means that the instance's role is \"replica\" (read-only) and "
"replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:89
msgid ""
"``running`` means the instance's role is \"master\" (non read-only) and "
"replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:91
msgid ""
"``stopped`` means that replication was stopped due to a replication error (e.g. "
"duplicate key)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:94
msgid ""
"**replication.upstream.idle** is the time (in seconds) since the instance "
"received the last event from a master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:96
msgid ""
"**replication.upstream.lag** is the time difference between the local time at "
"the instance, recorded when the event was received, and the local time at "
"another master recorded when the event was written to the write ahead log on "
"that master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:101
msgid ""
"Since ``lag`` calculation uses operating system clock from two different "
"machines, don’t be surprised if it’s negative: a time drift may lead to the "
"remote master clock being consistently behind the local instance's clock."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:105
msgid "For multi-master configurations, this is the maximal lag."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:107
msgid ""
"**replication.downstream** contains statistics for the replication data "
"requested and downloaded from the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:109
msgid ""
"**replication.downstream.vclock** is the instance's :ref:`vector clock "
"<internals-vector>`, which contains a pair '**id**, **lsn**'."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:114
#: ../doc/1.7/book/box/box_introspection.rst:98
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate over keys "
"with the Lua ``pairs()`` function. For this purpose, ``box.info()`` builds and "
"returns a Lua table with all keys and values provided in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:119
#: ../doc/1.7/book/box/box_introspection.rst:103
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:124
msgid ""
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 1\n"
"  ro: false\n"
"  vclock: {1: 8}\n"
"  uptime: 7280\n"
"  lsn: 8\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: f7c0c1c6-f9d8-4df7-82ff-d4bd00610a6c\n"
"  pid: 16162\n"
"  status: running\n"
"  signature: 8\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"      lsn: 8\n"
"    2:\n"
"      id: 2\n"
"      uuid: bd949e5d-7ff9-413e-b4f2-c9b0149fdda6\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7256.7571430206\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"    3:\n"
"      id: 3\n"
"      uuid: c5cb61d5-fa48-460d-abd7-3f13709d07a7\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7255.7510120869\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"  uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:66
msgid "**server.lsn** Log Sequence Number for the latest entry in the WAL."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:67
msgid ""
"**server.ro**  True if the instance is in \"read_only\" mode (same as :ref:"
"`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:69
msgid ""
"**server.uuid** The unique identifier of this instance, as stored in the "
"database. This value is also in the :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:72
msgid "**server.id** The number of this server's instance within a replica set."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:73
msgid ""
"**version** Tarantool version. This value is also shown by :ref:`tarantool --"
"version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:75
msgid ""
"**status** Usually this is 'running', but it can be 'loading', 'orphan', or "
"'hot_standby'."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:76
msgid "**vclock** Same as replication.vclock."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:77
msgid ""
"**pid** Process ID. This value is also shown by the :ref:`tarantool <tarantool-"
"build>` module. This value is also shown by the Linux \"ps -A\" command."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:80
msgid ""
"**cluster.uuid** UUID of the replica set. Every instance in a replica set will "
"have the same cluster.uuid value. This value is also in the :ref:`box.space."
"_schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:82
msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:83
msgid ""
"**replication.lag** Number of seconds that the replica is behind the master."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:84
msgid ""
"**replication.status** Usually this is 'follow', but it can be 'off', 'stopped', "
"'connecting', 'auth', or 'disconnected'."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:86
msgid "**replication.idle** Number of seconds that the instancehas been idle."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:87
msgid ""
"**replication.vclock** See the :ref:`discussion of \"vector clock\" <internals-"
"vector>` in the Internals section."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:88
msgid ""
"**replication.uuid** The unique identifier of a master to which this instance is "
"connected."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:89
msgid ""
"**replication.uptime** Number of seconds since the instance started. This value "
"can also be retrieved with :ref:`tarantool.uptime() <tarantool-build>`."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:92
msgid ""
"The replication fields are blank unless the instance is a :ref:`replica <index-"
"box_replication>`. The replication fields are in an array if the instance is a "
"replica for more than one master."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:108
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:147
#: ../doc/1.7/book/box/box_slab.rst:33
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:151
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store tuples. This can be used to "
"monitor the total memory use and memory fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:155
msgid ""
"The display of slabs is broken down by the slab size -- 64-byte, 136-byte, and "
"so on. The example omits the slabs which are empty. The example display is "
"saying that: * there are 16 items stored in the 64-byte slab (and 16*64=102 so "
"bytes_used = 1024); * there is 1 item stored in the 136-byte slab (and 136*1=136 "
"so bytes_used = 136); * the ``arena_used`` value is the total of all the "
"bytes_used values (1024+136 = 1160); * the ``arena_size`` value is the "
"``arena_used`` value plus the total of all the"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:162
msgid "bytes_free values (1160+4193200+4194088 = 8388448)."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:164
#, python-format
msgid ""
"The ``arena_size`` and ``arena_used`` values are the amount of the % of :ref:"
"`memtx_memory <cfg_storage-memtx_memory>` that is already distributed to the "
"slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:170
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:210
#: ../doc/1.7/book/box/box_stat.rst:33
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:212
#: ../doc/1.7/book/box/box_stat.rst:35
msgid ""
"The ``box.stat`` submodule provides access to request and network statistics. "
"Show the average number of requests per second, and the total number of requests "
"since startup, broken down by request type and network events statistics."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:216
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:33
msgid "Submodule `box.schema`"
msgstr "Вложенный модуль `box.schema`"

#: ../doc/1.7/book/box/box_schema.rst:37
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, users, "
"roles, and function tuples."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:44
msgid "Create a space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:46
msgid ""
"name of space, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:48
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:50
msgid "space object"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:51
msgid "userdata"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:55
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:52
#: ../doc/1.7/book/box/box_space.rst:256 ../doc/1.7/book/box/box_space.rst:1384
msgid "Name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
msgid "Default"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65
msgid "temporary"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-ahead "
"log <internals-wal>` and there is no :ref:`replication <replication>`. Note re "
"storage engine: vinyl does not support temporary spaces."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65 ../doc/1.7/book/box/box_schema.rst:83
msgid "false"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73 ../doc/1.7/book/box/box_space.rst:262
msgid "id"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73
msgid ""
"unique identifier: users can refer to spaces with the id instead of the name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73
msgid "last space's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid "field_count"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid ""
"fixed count of fields: for example if field_count=5, it is illegal to insert a "
"tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83 ../doc/1.7/book/box/box_space.rst:266
msgid "if_not_exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "engine"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "storage engine: 'memtx' or 'vinyl'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89 ../doc/1.7/book/box/box_schema.rst:92
#: ../doc/1.7/book/box/box_schema.rst:309 ../doc/1.7/book/box/box_session.rst:66
#: ../doc/1.7/book/box/box_session.rst:85 ../doc/1.7/book/box/data_model.rst:185
msgid "string"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "'memtx'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92 ../doc/1.7/book/box/box_space.rst:1386
#: ../doc/1.7/book/box/box_space.rst:1389
msgid "user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92
msgid ""
"name of the user who is considered to be the space's :ref:`owner <authentication-"
"owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92
msgid "current user's name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid "format"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid ""
"field names and types: For an illustration with the ``format`` option, see the :"
"ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid "(blank)"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:104
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` for "
"object references targeting space objects, for example :samp:`box.schema.space."
"drop({space-id})` will drop a space. However, the common approach is to use "
"functions attached to the space objects, for example :ref:`space_object:drop() "
"<box_space-drop>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:113
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:131
msgid ""
"After a space is created, usually the next step is to :ref:`create an index "
"<box_space-create_index>` for it, and then it is available for insert, select, "
"and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:139
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:144 ../doc/1.7/book/box/box_schema.rst:235
#: ../doc/1.7/book/box/box_schema.rst:506
msgid "The possible options are:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:146
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user already exists,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:149
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform Resource "
"Identifier) it is usually illegal to include a user-name without a password."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:156 ../doc/1.7/book/box/box_space.rst:1468
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:158
msgid ""
"name of user, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:160
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:164 ../doc/1.7/book/box/box_schema.rst:185
msgid "**Examples:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_schema.rst:166
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:176
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see section :"
"ref:`Users <authentication-users>` and reference on :ref:`_user <box_space-"
"user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:181 ../doc/1.7/book/box/box_schema.rst:201
#: ../doc/1.7/book/box/box_schema.rst:219 ../doc/1.7/book/box/box_schema.rst:260
msgid "the name of the user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:182
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the user does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:187
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:196
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not exist. For "
"explanation of how Tarantool maintains user data, see section :ref:`Users "
"<authentication-users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:202 ../doc/1.7/book/box/box_schema.rst:410
#: ../doc/1.7/book/box/box_schema.rst:560
msgid "bool"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:206
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:216
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or to "
"another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:220
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:221
msgid "'space' or 'function'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:222
msgid "name of object to grant permissions to"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:223
msgid "name of role to grant to user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:224
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:226
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple with that "
"object-name must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:229
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'. In this case, object name is omitted."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:232 ../doc/1.7/book/box/box_schema.rst:271
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:237
msgid "``grantor`` = *grantor_name_or_id* -- string or number, for custom grantor,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:238
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user already has the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:243
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:257
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user or from "
"another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:261 ../doc/1.7/book/box/box_schema.rst:427
#: ../doc/1.7/book/box/box_schema.rst:459
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:262 ../doc/1.7/book/box/box_schema.rst:428
#: ../doc/1.7/book/box/box_schema.rst:460
msgid "'space' or 'function'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:263 ../doc/1.7/book/box/box_schema.rst:429
#: ../doc/1.7/book/box/box_schema.rst:461
msgid "the name of a function or space"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:265
msgid ""
"The user must exist, and the object must exist, but it is not an error if the "
"user does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:268 ../doc/1.7/book/box/box_schema.rst:436
#: ../doc/1.7/book/box/box_schema.rst:466
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' which "
"means 'all object-types and all objects'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:276
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:287
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool maintains "
"passwords, see section :ref:`Passwords <authentication-passwords>` and reference "
"on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:293
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not usable "
"from a remote connection. Such users can be useful if they have defined some "
"procedures with the :ref:`SETUID <box_schema-func_create>` option, on which "
"privileges are granted to externally-connectable users. This way, external users "
"cannot create/drop objects, they can only invoke procedures."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:300
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established connection "
"over a :ref:`binary port <admin-security>`, and Tarantool does not require a "
"password to establish a binary connection. It is, however, possible to change "
"the current user to ‘guest’ by providing the AUTH packet with no password at all "
"or an empty password. This feature is useful for connection pools, which want to "
"reuse a connection for a different user without re-establishing it."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:308
msgid "password to be hashed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:313
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:321
msgid ""
"Associate a password with the user who is currently logged in, or with another "
"user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:324
msgid ""
"Users who wish to change their own passwords should use ``box.schema.user."
"passwd(password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:327
msgid ""
"Administrators who wish to change passwords of other users should use ``box."
"schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:330
msgid "user-name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:331
msgid "password"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:335
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:344
msgid ""
"Return a description of a user's privileges. For explanation of how Tarantool "
"maintains user data, see section :ref:`Users <authentication-users>` and "
"reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:349
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:357
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:366
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:370
msgid ""
"name of role, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:372
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role already exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:380
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:389
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see section :"
"ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:393 ../doc/1.7/book/box/box_schema.rst:409
#: ../doc/1.7/book/box/box_schema.rst:426 ../doc/1.7/book/box/box_schema.rst:458
msgid "the name of the role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:394
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:399
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:407
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:414
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:424
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:430
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role already has the privilege"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:434
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:439
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name`` -- to grant a role to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:444
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:456
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:463
msgid ""
"The role must exist, and the object must exist, but it is not an error if the "
"role does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:469
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say ``role-"
"name``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:474
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:485
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:487
msgid "the name of the role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:491
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:499
msgid ""
"Create a function tuple. This does not create the function itself -- that is "
"done with Lua -- but if it is necessary to grant privileges for a function, box."
"schema.func.create must be done first. For explanation of how Tarantool "
"maintains function data, see reference on :ref:`_func <box_space-func>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:508
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the ``_func`` tuple already exists."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:511
msgid ""
"``setuid`` = ``true|false`` (default = false) - with ``true`` to make Tarantool "
"treat the function’s caller as the function’s creator, with full privileges. "
"Remember that SETUID works only over :ref:`binary ports <admin-security>`. "
"SETUID doesn't work if you invoke a function via an admin console or inside a "
"Lua script."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:518
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:520
msgid ""
"name of function, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:522
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:528
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:539
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains function data, "
"see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:543 ../doc/1.7/book/box/box_schema.rst:559
msgid "the name of the function"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:544
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` means "
"there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:549
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:557
msgid ""
"Return true if a function tuple exists; return false if a function tuple does "
"not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:564
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:33
msgid "Submodule `box.session`"
msgstr "Вложенный модуль `box.session`"

#: ../doc/1.7/book/box/box_session.rst:35
msgid ""
"The ``box.session`` submodule allows querying the session state, writing to a "
"session-specific temporary Lua table, or setting up triggers which will fire "
"when a session starts or ends. A *session* is an object associated with each "
"client connection."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:44
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 meaning "
"there is no session."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:50
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:55
msgid ""
"This function works only if there is a peer, that is, if a connection has been "
"made to a separate Tarantool instance."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:58
msgid ""
"The host address and port of the session peer, for example \"127.0.0.1:55457\". "
"If the session exists but there is no connection to a separate instance, the "
"return is null. The command is executed on the server instance, so the \"local "
"name\" is the server instance's host and port, and the \"peer name\" is the "
"client's host and port."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:68
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:74
msgid ""
"the value of the :code:`sync` integer constant used in the `binary protocol "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:83
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:91
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:94
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current user "
"<authentication-users>` temporarily while executing the function -- this is "
"analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:99
msgid "name of a target user"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:100
msgid ""
"name of a function, or definition of a function. Additional parameters may be "
"passed to ``box.session.su``, they will be interpreted as parameters of function-"
"to-execute."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:107
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:129
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and values, "
"which will last until the session ends. For example, this table could be useful "
"to store current tasks when working with a `Tarantool queue manager <https://"
"github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:136
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:165
msgid ""
"Define a trigger for execution when a new session is created due to an event "
"such as :ref:`console.connect <console-connect>`. The trigger function will be "
"the first thing executed after a new session is created. If the trigger "
"execution fails and raises an error, the error is sent to the client and the "
"connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:170 ../doc/1.7/book/box/box_session.rst:201
#: ../doc/1.7/book/box/box_session.rst:274 ../doc/1.7/book/box/box_space.rst:542
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:171 ../doc/1.7/book/box/box_session.rst:202
#: ../doc/1.7/book/box/box_session.rst:275 ../doc/1.7/book/box/box_space.rst:544
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:172 ../doc/1.7/book/box/box_session.rst:203
#: ../doc/1.7/book/box/box_session.rst:276 ../doc/1.7/book/box/box_space.rst:547
msgid "nil or function pointer"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:174 ../doc/1.7/book/box/box_session.rst:205
#: ../doc/1.7/book/box/box_session.rst:278
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger is "
"deleted."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:176 ../doc/1.7/book/box/box_session.rst:207
#: ../doc/1.7/book/box/box_session.rst:280
#, fuzzy
msgid ""
"Details about trigger characteristics are in the :ref:`triggers <triggers-"
"box_triggers>` section."
msgstr ""
"См. подробности о работе потока записи в WAL в разделе  :ref:`Детали реализации "
"<b_internals>`."

#: ../doc/1.7/book/box/box_session.rst:180
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:189
msgid ""
"If a trigger always results in an error, it may become impossible to connect to "
"a server to reset it."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:196
msgid ""
"Define a trigger for execution after a client has disconnected. If the trigger "
"function causes an error, the error is logged but otherwise is ignored. The "
"trigger is invoked while the session associated with the client still exists and "
"can access session properties, such as box.session.id."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:211
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:220
msgid ""
"After the following series of requests, a Tarantool instance will write a "
"message using the :ref:`log <log-module>` module whenever any user connects or "
"disconnects."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:223
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. box.session."
"id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. box."
"session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:240
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:242
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:253
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:255
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:257
msgid ""
"The :ref:`console.connect <console-connect>` function includes an authentication "
"check for all users except 'guest'. For this case, the ``on_auth`` trigger "
"function is invoked after the ``on_connect`` trigger function, if and only if "
"the connection has succeeded so far."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:262
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate :ref:`authentication "
"packet <box_protocol-authentication>`. For this case, connection and "
"authentication are considered to be separate steps."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:266
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked **before** "
"the event. Therefore a trigger function like :code:`function auth_function () v "
"= box.session.user(); end` will set :code:`v` to \"guest\", the user name before "
"the authentication is done. To get the user name **after** the authentication is "
"done, use the special syntax: :code:`function auth_function (user_name) v = "
"user_name; end`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:272
msgid ""
"If the trigger fails by raising an error, the error is sent to the client and "
"the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:284
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:37
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. The "
"slab allocator is the main allocator used to store tuples. This can be used to "
"monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:57
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:74
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:76
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are high if "
"both ``arena_used_ratio`` and ``quota_used_ratio`` are high (90-95%)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:79
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. the "
"memory is used efficiently)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:83
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily fragmentized. "
"Most probably, there is no immediate out-of-memory risk in this case, but "
"generally this is an issue to consider. For example, probable risks are that the "
"entire memory quota is used for tuples, and there is are no slabs left for a "
"piece of an index. Or that all slabs are allocated for storing tuples, but in "
"fact all the slabs are half-empty."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:93
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:95
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` (these "
"are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:97
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator can use "
"for both tuples and indexes (as configured in :ref:`memtx_memory <cfg_storage-"
"memtx_memory>` parameter, e.g. the default is 1 gigabyte = 2^30 bytes = "
"1,073,741,824 bytes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:103
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:105
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the slab "
"allocator;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:107
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together "
"(including allocated, but currently free slabs);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:109
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and indexes "
"together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:116
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:140
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. The "
"report is broken down into groups by *data item size* as well as by *slab size* "
"(64-byte, 136-byte, etc). The report includes the memory allocated for storing "
"both tuples and indexes."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:147
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:148
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:149
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:150
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:151
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:152
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:158
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:160
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:172
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) stored in "
"one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so ``mem_used`` = 2 "
"* 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of which 16384 - 48 = 16232 "
"bytes are free (``mem_free``)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:177
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:179
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:210
msgid ""
"The total ``mem_used`` for all groups in this report equals ``arena_used`` in :"
"ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:33
msgid "Submodule `box.space`"
msgstr "Вложенный модуль `box.space`"

#: ../doc/1.7/book/box/box_space.rst:35
msgid ""
"The ``box.space`` submodule has the data-manipulation functions ``select``, "
"``insert``, ``replace``, ``update``, ``upsert``, ``delete``, ``get``, ``put``. "
"It also has members, such as id, and whether or not a space is enabled. "
"Submodule source code is available in file `src/box/lua/schema.lua <https://"
"github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:41
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all ``box."
"space`` members."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:44
msgid "**The functions and members of box.space**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:52
msgid "Use"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:54
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:54
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:57
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:57
msgid "Get count of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60 ../doc/1.7/book/box/box_space.rst:78
msgid "Get count of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid "Create an index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66
msgid "Delete a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid "Destroy a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid "Select a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid "Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:78
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid "Create a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid "Prepare for iterating"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87 ../doc/1.7/book/box/box_space.rst:93
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid "Rename a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:93
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid "Select one or more tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid "Delete all tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105 ../doc/1.7/book/box/box_space.rst:108
msgid "Update a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid "Required number of fields"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid "Container of space's indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:153
msgid ""
"Insert a new tuple using an auto-increment primary key. The space specified by "
"space_object must have an ``unsigned`` or ``integer`` or ``numeric`` primary key "
"index of type ``TREE``. The primary-key field will be incremented before the "
"insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:158 ../doc/1.7/book/box/box_space.rst:188
#: ../doc/1.7/book/box/box_space.rst:211 ../doc/1.7/book/box/box_space.rst:237
#: ../doc/1.7/book/box/box_space.rst:401 ../doc/1.7/book/box/box_space.rst:439
#: ../doc/1.7/book/box/box_space.rst:461 ../doc/1.7/book/box/box_space.rst:493
#: ../doc/1.7/book/box/box_space.rst:516 ../doc/1.7/book/box/box_space.rst:604
#: ../doc/1.7/book/box/box_space.rst:659 ../doc/1.7/book/box/box_space.rst:689
#: ../doc/1.7/book/box/box_space.rst:742 ../doc/1.7/book/box/box_space.rst:816
#: ../doc/1.7/book/box/box_space.rst:876 ../doc/1.7/book/box/box_space.rst:993
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:160
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:163 ../doc/1.7/book/box/box_space.rst:693
msgid "the inserted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:166 ../doc/1.7/book/box/box_space.rst:446
#: ../doc/1.7/book/box/box_space.rst:471 ../doc/1.7/book/box/box_space.rst:700
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:169
msgid ""
"**Possible errors:** index has wrong type or primary-key indexed field is not a "
"number."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:173
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:191
msgid "Number of bytes in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:195
#, fuzzy
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/box_space.rst:202
#, fuzzy
msgid "Note re storage engine: vinyl does not support ``bsize()``."
msgstr ""
"Примечание про движок: при организации резервирования для баз данных на движке "
"vinyl понадобятся дополнительные действия."

#: ../doc/1.7/book/box/box_space.rst:213 ../doc/1.7/book/box/box_space.rst:403
#: ../doc/1.7/book/box/box_space.rst:878
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:217
msgid "Number of tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:221
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:232
msgid ""
"Create an index. It is mandatory to create an index for a space before trying to "
"insert tuples into it, or select tuples from it. The first created index, which "
"will be used as the primary-key index, must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:239
msgid ""
"name of index, which should not be a number and should not contain special "
"characters"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:243
msgid "index object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:244
msgid "index_object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:248
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "type of index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "'TREE'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:262
msgid "unique identifier"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:262
msgid "last index's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "index is unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "``true``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:266
msgid "no error if duplicate name"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:266
msgid "``false``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "parts"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "field-numbers  + types"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'array' or "
"'scalar'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274
msgid "dimension"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:276
msgid "affects RTREE only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:1392
msgid "2"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "distance"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "'euclid'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "bloom_fpr"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279 ../doc/1.7/book/box/box_space.rst:281
#: ../doc/1.7/book/box/box_space.rst:283 ../doc/1.7/book/box/box_space.rst:285
#: ../doc/1.7/book/box/box_space.rst:287
msgid "affects vinyl only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
#, fuzzy
msgid "``vinyl_bloom_fpr``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:281
msgid "page_size"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:281
#, fuzzy
msgid "``vinyl_page_size``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:283
#, fuzzy
msgid "range_size"
msgstr "Размер индекса"

#: ../doc/1.7/book/box/box_space.rst:283
#, fuzzy
msgid "``vinyl_range_size``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:285
msgid "run_count_per_level"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:287
msgid "run_size_ratio"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:287
#, fuzzy
msgid "``vinyl_run_size_ratio``"
msgstr "``vinyl_dir``"

#: ../doc/1.7/book/box/box_space.rst:290
msgid ""
"Note re storage engine: vinyl has extra options which by default are based on "
"configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`, :"
"ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, :ref:`vinyl_range_size "
"<cfg_storage-vinyl_range_size>`, :ref:`vinyl_run_count_per_level <cfg_storage-"
"vinyl_run_count_per_level>`, and :ref:`vinyl_run_size_ratio <cfg_storage-"
"vinyl_run_size_ratio>` -- see the description of those parameters. The current "
"values can be seen by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:301
msgid ""
"**Possible errors:** too many parts. Index '...' already exists. Primary key "
"must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:303
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, 'unsigned', 2, "
"'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:314
#, fuzzy
msgid "Details about index field types:"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/box_space.rst:316
msgid ""
"The six index field types (unsigned | string | integer | number | array | "
"scalar) differ depending on what values are allowed, and what index types are "
"allowed."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:320
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about 18 "
"quintillion. May also be called 'uint' or 'num', but 'num' is deprecated. Legal "
"in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:324
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in memtx TREE "
"or HASH or BITSET indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:327
msgid ""
"**integer**: integers between -9223372036854775808 and 18446744073709551615. May "
"also be called 'int'. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:330
msgid ""
"**number**: integers between -9223372036854775808 and 18446744073709551615, "
"single-precision floating point numbers, or double-precision floating point "
"numbers. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:334
#, fuzzy
msgid ""
"**array**: array of integers between -9223372036854775808 and "
"9223372036854775807. Legal in memtx RTREE indexes."
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до "
"9,223,372,036,854,775,807)"

#: ../doc/1.7/book/box/box_space.rst:336
msgid ""
"**scalar**: null (input with msgpack.NULL or yaml.NULL or json.NULL), booleans "
"(true or false), or integers between -9223372036854775808 and "
"18446744073709551615, or single-precision floating point numbers, or double-"
"precison floating-point numbers, or strings. When there is a mix of types, the "
"key order is: null, then booleans, then numbers, then strings. Legal in memtx "
"TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:346
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "Index field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/box_space.rst:355
msgid "What can be in it"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "Where is it legal"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355 ../doc/1.7/book/box/data_model.rst:275
msgid "Examples"
msgstr "Примеры:"

#: ../doc/1.7/book/box/box_space.rst:357
msgid "**unsigned**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357 ../doc/1.7/book/box/box_space.rst:364
#: ../doc/1.7/book/box/box_space.rst:368 ../doc/1.7/book/box/box_space.rst:380
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "123456 |br|"
msgstr "123456 |br|"

#: ../doc/1.7/book/box/box_space.rst:361
msgid "**string**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "**integer**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "-2^63 |br|"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368 ../doc/1.7/book/box/data_model.rst:288
msgid "**number**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-precision "
"floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376 ../doc/1.7/book/box/data_model.rst:302
msgid "**array**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:380 ../doc/1.7/book/box/data_model.rst:307
msgid "**scalar**"
msgstr "**scalar**"

#: ../doc/1.7/book/box/box_space.rst:380
msgid ""
"null, booleans (true or false), integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, double-precision "
"floating point numbers, strings"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:380
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:391
msgid ""
"Note re storage engine: vinyl supports only the TREE index type, and vinyl "
"secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:399
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:406
msgid "the deleted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:409
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst
msgid "vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:418
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:437
msgid "Drop a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:444
msgid "**Possible errors:** If ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:451
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:459
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:463 ../doc/1.7/book/box/box_space.rst:744
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:466
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:469
msgid "**Possible errors:** If space_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:474
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua table; the "
"``box.space...get`` function returns at most a single tuple. And it is possible "
"to get the first tuple in a space by appending ``[1]``. Therefore ``box.space."
"tester:get{1}`` has the same effect as ``box.space.tester:select{1}[1]``, if "
"exactly one tuple is found."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:482
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:491
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:495
msgid "tuple to be inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:497
msgid "the inserted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:500
msgid ""
"**Possible errors:** If a tuple with the same unique-key value already exists, "
"returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:505
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:519
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:523
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:530
msgid ""
"Note re storage engine: vinyl does not support ``len()``. One possible "
"workaround is to say ``#select(...)``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:538
msgid ""
"Create a \"replace trigger\". The ``trigger-function`` will be executed whenever "
"a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` or ``delete()`` "
"happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:549
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger is "
"deleted. Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:553 ../doc/1.7/book/box/box_space.rst:1281
#, fuzzy
msgid "**Example #1:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_space.rst:555
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:562
msgid ""
"The ``trigger-function`` can have two parameters: old tuple, new tuple. For "
"example, the following code causes nil to be printed when the insert request is "
"processed, and causes [1, 'Hi'] to be printed when the delete request is "
"processed:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:567
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:576 ../doc/1.7/book/box/box_space.rst:1326
#, fuzzy
msgid "**Example #2:**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/box_space.rst:578
msgid ""
"The following series of requests will create a space, create an index, create a "
"function which increments a counter, create a trigger, do two inserts, drop the "
"space, and display the counter value - which is 2, because the function is "
"executed once after each insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:583
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:601
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow iterating "
"over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:608
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:615 ../doc/1.7/book/box/box_space.rst:754
msgid "**Possible errors:** No such space; wrong type."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:619
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which index to "
"search and what condition to use (for example \"greater than\" instead of "
"\"equal to\"), see the later section :ref:`index_object:pairs <box_index-"
"index_pairs>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:626
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:657
msgid "Rename a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:661
msgid "new name for space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:665
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:669
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:683
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already "
"exists, ``box.space...:replace()`` replaces the existing tuple with a new one. "
"The syntax variants ``box.space...:replace()`` and ``box.space...:put()`` have "
"the same effect; the latter is sometimes used to show that the effect is the "
"converse of ``box.space...:get()``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:691
msgid "tuple to be inserted"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:696
msgid ""
"**Possible errors:** If a different tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen if there is a "
"unique secondary index.)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:705
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:714
msgid ""
"At the time that a trigger is defined, it is automatically enabled - that is, it "
"will be executed. Replace triggers can be disabled with :samp:`box.space.{space-"
"name}:run_triggers(false)` and re-enabled with :samp:`box.space.{space-name}:"
"run_triggers(true)`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:723
msgid ""
"The following series of requests will associate an existing function named F "
"with an existing space named T, associate the function a second time with the "
"same space (so it will be called twice), disable all triggers of T, and delete "
"each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:728
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:740
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:747
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed key. "
"If the number of passed fields is less than the number of fields in the primary "
"key, then only the passed fields are compared, so ``select{1,2}`` will match a "
"tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:760
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, 'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:805
msgid ""
"For examples of complex ``select`` requests, where one can specify which index "
"to search and what condition to use (for example \"greater than\" instead of "
"\"equal to\") and how many tuples to return, see the later section :ref:"
"`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:814
msgid "Deletes all tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:825
msgid ""
"Note that ``truncate`` must be called only by the user who created the space OR "
"under a `setuid` function created by that user. Read more about `setuid` "
"functions in reference on :ref:`box.schema.func.create() <box_schema-"
"func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:832
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:848
msgid ""
"The ``update`` function supports operations on fields — assignment, arithmetic "
"(if the field is numeric), cutting and pasting fragments of a field, deleting or "
"inserting a field. Multiple operations can be combined in a single update "
"request, and in this case they are performed atomically and sequentially. Each "
"operation requires specification of a field number. When multiple operations are "
"present, the field number for each operation is assumed to be relative to the "
"most recent state of the tuple, that is, as if all previous operations in a "
"multi-operation update have already been applied. In other words, it is always "
"safe to merge multiple ``update`` invocations into a single invocation, with no "
"change in semantics."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:860
msgid "Possible operators are:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:862
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:863
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:864
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:865
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:866
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:868
msgid "``:`` for string splice"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:869
msgid "``!`` for insertion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:870
msgid "``#`` for deletion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:871
msgid "``=`` for assignment"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:873
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning the last "
"field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:890
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:892 ../doc/1.7/book/box/box_space.rst:1009
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes accessed, WAL "
"settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:895
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:897
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:901
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` meaning "
"*add a value to a field and then assign a value to a field*, the first affected "
"field is field ``1`` and the value which will be added to it is ``55``, the "
"second affected field is field ``3`` and the value which will be assigned to it "
"is ``'x'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:909
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-key index "
"whose type is ``unsigned``. There is one tuple, with ``field[1]`` = ``999`` and "
"``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:913
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` |br| The "
"first argument is ``tester``, that is, the affected space is ``tester``. The "
"second argument is ``999``, that is, the affected tuple is identified by primary "
"key value = 999. The third argument is ``=``, that is, there is one operation — "
"*assignment to a field*. The fourth argument is ``2``, that is, the affected "
"field is ``field[2]``. The fifth argument is ``'B'``, that is, ``field[2]`` "
"contents change to ``'B'``. Therefore, after this update, ``field[1]`` = ``999`` "
"and ``field[2]`` = ``'B'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:924
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` |br| the "
"arguments are the same, except that the key is passed as a Lua table (inside "
"braces). This is unnecessary when the primary key has only one field, but would "
"be necessary if the primary key had more than one field. Therefore, after this "
"update, ``field[1]`` = ``999`` and ``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:931
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` |br| the "
"arguments are the same, except that the fourth argument is ``3``, that is, the "
"affected field is ``field[3]``. It is okay that, until now, ``field[3]`` has not "
"existed. It gets added. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``1``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:938
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` |br| the "
"arguments are the same, except that the third argument is ``'+'``, that is, the "
"operation is addition rather than assignment. Since ``field[3]`` previously "
"contained ``1``, this means we're adding ``1`` to ``1``. Therefore, after this "
"update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:946
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, "
"'C'}})`` |br| the idea is to modify two fields at once. The formats are ``'|'`` "
"and ``=``, that is, there are two operations, OR and assignment. The fourth and "
"fifth arguments mean that ``field[3]`` gets OR'ed with ``1``. The seventh and "
"eighth arguments mean that ``field[2]`` gets assigned ``'C'``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'C'``, ``field[3]`` = "
"``3``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:955
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, "
"3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` from "
"``field[3]``. But after the delete, there is a renumbering, so ``field[3]`` "
"becomes ``field[2]``` before we subtract ``3`` from it, and that's why the "
"seventh argument is ``2``, not ``3``. Therefore, after this update, ``field[1]`` "
"= ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:963
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})`` |br| "
"we're making a long string so that splice will work in the next example. "
"Therefore, after this update, ``field[1]`` = ``999``, ``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:968
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, '!!'}})`` |"
"br| The third argument is ``':'``, that is, this is the example of splice. The "
"fourth argument is ``2`` because the change will occur in ``field[2]``. The "
"fifth argument is 2 because deletion will begin with the second byte. The sixth "
"argument is 1 because the number of bytes to delete is 1. The seventh argument "
"is ``'!!'``, because ``'!!'`` is to be added at this position. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:981
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:983
msgid ""
"If there is an existing tuple which matches the key fields of ``tuple_value``, "
"then the request has the same effect as :ref:`space_object:update() <box_space-"
"update>` and the ``{{operator, field_no, value}, ...}`` parameter is used. If "
"there is no existing tuple which matches the key fields of ``tuple_value``, then "
"the request has the same effect as :ref:`space_object:insert() <box_space-"
"insert>` and the ``{tuple_value}`` parameter is used. However, unlike ``insert`` "
"or ``update``, ``upsert`` will not read a tuple and perform error checks before "
"returning -- this is a design feature which enhances throughput but requires "
"more caution on the part of the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:995
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1004
msgid "null"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1006
msgid ""
"**Possible errors:** it is illegal to modify a primary-key field. It is illegal "
"to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1014
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1027
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space has no "
"index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1034
msgid ""
"The required field count for all tuples in this space. The field_count can be "
"set initially with:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1040
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1046
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1050
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1062
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. Thus, "
"if space ``tester`` has ``id = 800``, then ``box.space.tester:insert{0}`` and "
"``box.space[800]:insert{0}`` are equivalent requests."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1069
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1078
msgid ""
"A container for all defined indexes. There is a Lua object of type :ref:`box."
"index <box_index>` with methods to search tuples and iterate over them in "
"predefined order."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1086
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1101
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication feature "
"<replication>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1108
msgid ""
"``_func`` is a system space with function tuples made by :ref:`box.schema.func."
"create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1111 ../doc/1.7/book/box/box_space.rst:1163
#: ../doc/1.7/book/box/box_space.rst:1201 ../doc/1.7/book/box/box_space.rst:1271
#: ../doc/1.7/book/box/box_space.rst:1365
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1113
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1114
msgid "the function name,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1115
msgid "flag,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1116
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1118
msgid ""
"The ``_func`` space does not include the function’s body. You continue to create "
"Lua functions in the usual way, by saying ``function function_name () ... end``, "
"without adding anything in the ``_func`` space. The ``_func`` space only exists "
"for storing function tuples so that their names can be used within grant/revoke "
"functions."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1125 ../doc/1.7/book/box/box_space.rst:1210
msgid "You can:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1127
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1129
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-func_drop>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1131
msgid ""
"Check whether a ``_func`` tuple exists with :ref:`box.schema.func.exists() "
"<box_schema-func_exists>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1136
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this function to "
"'guest' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1140
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1161
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1165
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1166
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1167
#, fuzzy
msgid "``name``,"
msgstr "``username``"

#: ../doc/1.7/book/box/box_space.rst:1168
msgid "``type``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1169
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` ...]."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1171
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1173
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1198
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1203
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1204
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1205
msgid "the type of object: 'space', 'function' or 'universe',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1206
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1207
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, or a "
"combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1212
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-user_grant>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1213
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-user_revoke>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1217
msgid ""
"Generally, privileges are granted or revoked by the owner of the object (the "
"user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1220
msgid ""
"Before dropping any objects or users, make sure that all their associated "
"privileges have been revoked."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1223
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1225
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or truncate the "
"space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1228
msgid ""
"Only the 'admin' user or the creator of a user can change a different user’s "
"password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1235
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1237
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1239
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1240
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1241
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1242
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-once>` "
"blocks from the instance's :ref:`initialization file <index-init_label>`. The "
"first field in these tuples contains the ``key`` value from the corresponding "
"``box.once()`` block prefixed with 'once' (e.g. `oncehello`), so you can easily "
"find a tuple that corresponds to a specific ``box.once()`` block."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1252
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the tuples "
"for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1255
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1269
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1273
#, fuzzy
msgid "``id``,"
msgstr "``pid_file``"

#: ../doc/1.7/book/box/box_space.rst:1274
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1275
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1276
msgid "``flags`` (e.g. temporary), ``format``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1278
msgid ""
"These fields are established by :ref:`space.create() <box_schema-space_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1283
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1286
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1305
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1307
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1328
msgid ""
"The following requests will create a space using ``box.schema.space.create()`` "
"with a ``format`` clause. Then it retrieves the ``_space`` tuple for the new "
"space. This illustrates the typical use of the ``format`` clause, it shows the "
"recommended names and data types for the fields."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1334
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1363
msgid ""
"``_user`` is a system space where user-names and password hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1367
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1368
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1369
#, fuzzy
msgid "the name,"
msgstr "telnet,"

#: ../doc/1.7/book/box/box_space.rst:1370
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1371
msgid "optional password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1373
msgid ""
"There are four special tuples in the ``_user`` space: 'guest', 'admin', 'public' "
"and 'replication'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1384
msgid "ID"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid "guest"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid "0"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few "
"privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid "admin"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid "1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid ""
"Default user when using Tarantool as a console. Usually an administrative user "
"with all privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
msgid "public"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392 ../doc/1.7/book/box/box_space.rst:1400
msgid "role"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically assigned to new "
"users when they are created with ``box.schema.user.create(user-name)``. "
"Therefore, a convenient way to grant 'read' on space 't' to every user that will "
"ever exist is with ``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid "replication"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid "3"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, assigned by the 'admin' user to "
"users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1405
msgid ""
"To select a tuple from the ``_user`` space, use ``box.space._user:select()``. "
"For example, here is what happens with a select for user id = 0, which is the "
"'guest' user, which by default has no password:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1409
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1418
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary ``box.space`` "
"functions for insert or update or delete. The ``_user`` space is special, so "
"there are special functions which have appropriate error checking."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1422
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1427
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1431
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() <box_schema-"
"user_password>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1436
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1444
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1449
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1451
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() <box_schema-"
"user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1457
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1459
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() <box_schema-"
"user_info>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1464
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1472
msgid ""
"Here is a session which creates a new user with a strong password, selects a "
"tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1475
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = 'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': 't3xjUpQdrt857O"
"+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1491
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1493
msgid ""
"This function will illustrate how to look at all the spaces, and for each "
"display: approximately how many tuples it contains, and the first field of its "
"first tuple. The function uses Tarantool ``box.space`` functions ``len()`` and "
"``pairs()``. The iteration through the spaces is coded as a scan of the "
"``_space`` system space, which contains metadata. The third field in ``_space`` "
"contains the space name, so the key instruction ``space_name = v[3]`` means "
"``space_name`` is the ``space_name`` field in the tuple of ``_space`` that we've "
"just fetched with ``pairs()``. The function returns a table:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1503
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1527
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1529
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1549
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1551
msgid ""
"The objective is to display field names and field types of a system space -- "
"using metadata to find metadata."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1554
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1556
msgid ""
"A simple way is to look at the constants in box.schema, which tell us that there "
"is an item named SPACE_ID == 288, so these statements will retrieve the correct "
"tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1560
msgid "``box.space._space:select{ 288 }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1561
msgid "or"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1562
msgid "``box.space._space:select{ box.schema.SPACE_ID }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1564
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us that "
"there is a secondary index named 'name' for space number 288, so this statement "
"also will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1568
msgid "``box.space._space.index.name:select{ '_space' }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1570
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1572
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, {'name': "
"'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': 'engine', "
"'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': 'str'}, "
"{\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1582
msgid ""
"It looks disorganized because field number 7 has been formatted with recommended "
"names and data types. How can one get those specific sub-fields? Since it's "
"visible that field number 7 is an array of maps, this `for` loop will do the "
"organizing:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1587
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:39
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: &0 []\n"
"- *0\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:33
msgid "Submodule `box.tuple`"
msgstr "Вложенный модуль `box.tuple`"

#: ../doc/1.7/book/box/box_tuple.rst:37
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` userdata "
"type. It allows, for a single tuple: selective retrieval of the field contents, "
"retrieval of information about size, iteration over all the fields, and "
"conversion to a Lua table."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:46
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively, one "
"can get new tuples from tarantool's :ref:`select <box_space-select>` or :ref:"
"`insert <box_space-insert>` or :ref:`replace <box_space-replace>` or :ref:"
"`update <box_space-update>` requests, which can be regarded as statements that "
"do ``new()`` implicitly."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:53
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:55
msgid "a new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:58
msgid ""
"In the following example, ``x`` will be a new table object containing one tuple "
"and ``t`` will be a new tuple object. Saying ``t`` returns the entire tuple "
"``t``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:64
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:85
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if ``t`` is "
"a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:90
msgid ""
"In the following example, a tuple named ``t`` is created and then the number of "
"fields in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:93
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:105
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of bytes in "
"the tuple. With the memtx storage engine the default maximum number is :ref:`one "
"megabyte <cfg_storage-memtx_max_tuple_size>`. Every field has one or more "
"\"length\" bytes preceding the actual contents, so ``bsize()`` returns a value "
"which is slightly greater than the sum of the lengths of the contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:115
msgid ""
"In the following example, a tuple named ``t`` is created which has three fields, "
"and for each field it takes one byte to store the length and three bytes to "
"store the contents, and a bit for overhead, so ``bsize()`` returns ``3*(1+3)+1``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:120
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:132
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field numbered "
"field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:135
msgid "field value."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:136
msgid "lua-value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:138
msgid ""
"In the following example, a tuple named ``t`` is created and then the second "
"field in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:141
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:154
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the number of "
"the first field in ``t`` that matches the search value, and ``t:findall(search-"
"value [, search-value ...])`` will return numbers of all fields in ``t`` that "
"match the search value. Optionally one can put a numeric argument ``field-"
"number`` before the search-value to indicate “start searching at field number "
"``field-number``.”"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:161
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:164
msgid ""
"In the following example, a tuple named ``t`` is created and then: the number of "
"the first field in ``t`` which matches 'a' is returned, then the numbers of all "
"the fields in ``t`` which match 'a' are returned, then the numbers of all the "
"fields in t which match 'a' and are at or after the second field are returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:170
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:191
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number},{fields-to-"
"remove})` will return a tuple where, starting from field ``start-field-number``, "
"a number of fields (``fields-to-remove``) are removed. Optionally one can add "
"more arguments after ``fields-to-remove`` to indicate new values that will "
"replace what was removed."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:197
msgid "base 1, may be negative"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:203
msgid ""
"In the following example, a tuple named ``t`` is created and then, starting from "
"the second field, two fields are removed but one new one is added, then the "
"result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:207
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:219
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, ``t:"
"unpack(1)`` will return all fields starting with field number 1, ``t:"
"unpack(1,5)`` will return all fields between field number 1 and field number 5."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:223
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:224
msgid "lua-value(s)"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:226
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:229
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:245
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, ``t:"
"totable(1)`` will return all fields starting with field number 1, ``t:"
"totable(1,5)`` will return all fields between field number 1 and field number 5. "
"It is preferable to use ``t:totable()`` rather than ``t:unpack()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:250
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:251
#, fuzzy
msgid "lua-table"
msgstr "Lua table"

#: ../doc/1.7/book/box/box_tuple.rst:253
msgid ""
"In the following example, a tuple named ``t`` is created, then all its fields "
"are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:256
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:269
msgid ""
"In Lua, ``lua-table-value:pairs()`` is a method which returns: ``function``, "
"``lua-table-value``, ``nil``. Tarantool has extended this so that ``tuple-value:"
"pairs()`` returns: ``function``, ``tuple-value``, ``nil``. It is useful for Lua "
"iterators, because Lua iterators traverse a value's components until an end "
"marker is reached."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:275
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:276
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:278
msgid ""
"In the following example, a tuple named ``t`` is created and then all its fields "
"are selected using a Lua for-end loop."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:281
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:303
msgid ""
"This function updates a tuple which is not in a space. Compare the function :"
"extsamp:`box.space.{*{space-name}*}:update({*{key}*}, {{{*{format}*}, "
"{*{field_no}*}, {*{value}*}}, ...})` which updates a tuple in a space."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:307
msgid ""
"For details: see the description for ``operator``, ``field_no``, and ``value`` "
"in the section :ref:`box.space.space-name:update{key, format, {field_number, "
"value}...) <box_space-update>`."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:311
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:319
msgid "new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:322
msgid ""
"In the following example, a tuple named ``t`` is created and then its second "
"field is updated to equal 'B'."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:325
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:337
msgid "Example"
msgstr "Пример"

#: ../doc/1.7/book/box/box_tuple.rst:339
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables and lists "
"of scalars:"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:342
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua table\n"
"lua_table = tuple:totable()                             -- tuple to Lua table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:350
msgid ""
"Then it will find the field that contains 'b', remove that field from the tuple, "
"and display how many bytes remain in the tuple. The function uses Tarantool "
"``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, ``transform()``, "
"``bsize()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:355
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:371
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:33
#, fuzzy
msgid "Functions for transaction management"
msgstr "Управление экземплярами"

#: ../doc/1.7/book/box/box_txn_management.rst:35
msgid ""
"For general information and examples, see section :ref:`Transaction control "
"<atomic-atomic_execution>`."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:38
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:40
msgid "Rule #1"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:43
msgid ""
"The requests in a transaction must be sent to a server as a single block. It is "
"not enough to enclose them between begin and commit or rollback. To ensure they "
"are sent as a single block: put them in a function, or put them all on one line, "
"or use a delimiter so that multi-line requests are handled together."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:49
msgid "Rule #2"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:52
msgid ""
"All database operations in a transaction should use the same storage engine. It "
"is not safe to access tuple sets that are defined with ``{engine='vinyl'}`` and "
"also access tuple sets that are defined with ``{engine='memtx'}``, in the same "
"transaction."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:61
msgid ""
"Begin the transaction. Disable implicit yields until the transaction ends. "
"Signal that writes to the write-ahead log will be deferred until the transaction "
"ends. In effect the fiber which executes ``box.begin()`` is starting an \"active "
"multi-request transaction\", blocking all other fibers."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:70
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:76
msgid ""
"End the transaction, but cancel all its data-change operations. An explicit call "
"to functions outside ``box.space`` that always yield, such as :ref:`fiber."
"sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-yield>`, will have the same "
"effect."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:33
msgid "Data model"
msgstr "Модель данных"

#: ../doc/1.7/book/box/data_model.rst:35
msgid ""
"This section describes how Tarantool stores values and what operations with data "
"it supports."
msgstr ""
"В этом разделе описывается то, как в Tarantool'е организовано хранение данных и "
"какие операции с данным он поддерживает."

#: ../doc/1.7/book/box/data_model.rst:38
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting started\" "
"exercises <getting_started>`, then your test database now looks like this:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:48
msgid "Space"
msgstr "Пространство"

#: ../doc/1.7/book/box/data_model.rst:50
#, fuzzy
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr "*Пространство* с именем 'tester' в нашем примере — это контейнер."

#: ../doc/1.7/book/box/data_model.rst:52
msgid ""
"When Tarantool is being used to store data, there is always at least one space. "
"Each space has a unique **name** specified by the user. Besides, each space has "
"a unique **numeric identifier** which can be specified by the user, but usually "
"is assigned automatically by Tarantool. Finally, a space always has an "
"**engine**: *memtx* (default) -- in-memory engine, fast but limited in size, or "
"*vinyl* -- on-disk engine for huge data sets."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:59
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be functional, it "
"needs to have a :ref:`primary index <index-box_index>`. It can also have "
"secondary indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:67
#, fuzzy
msgid "Tuple"
msgstr "true"

#: ../doc/1.7/book/box/data_model.rst:69
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the components of "
"a tuple (which we call “fields”) play the same role as a “row column” or “record "
"field”, except that:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:73
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:74
msgid "fields don't need to have names."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:76
#, fuzzy
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field is the "
"field's number, base 1 (in Lua and other 1-based languages) or base 0 (in PHP or "
"C/C++). For example, “1” or \"0\" can be used in some contexts to refer to the "
"first field of a tuple."
msgstr ""
"Кортеж может иметь любое количество полей, и это могут быть поля разных типов. "
"Идентификатором поля является его номер. Поля нумеруются, начиная с 1. Так, "
"например, “1” может использоваться в некоторых контекстах для обозначения "
"первого поля кортежа."

#: ../doc/1.7/book/box/data_model.rst:83
msgid ""
"Tuples in Tarantool are stored as `MsgPack <https://en.wikipedia.org/wiki/"
"MessagePack>`_ arrays."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:86
msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML <https://en."
"wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of Base', 1993]``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:94
msgid "Index"
msgstr "Индекс"

#: ../doc/1.7/book/box/data_model.rst:96
#, fuzzy
msgid "An **index** is a group of key values and pointers."
msgstr ""
"*Индекс* — в нашем примере он первичный — это совокупность значений ключей и "
"указателей."

#: ../doc/1.7/book/box/data_model.rst:98
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool come up "
"with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:101
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE indexes "
"are provided by all Tarantool engines, can index unique and non-unique values, "
"support partial key searches, comparisons and ordered results. Additionally, "
"memtx engine supports HASH, RTREE and BITSET indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:106
msgid ""
"An index may be **multi-part**, that is, you can declare that an index key value "
"is composed of two or more fields in the tuple, in any order. For example, for "
"an ordinary TREE index, the maximum number of parts is 255."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:110
msgid ""
"An index may be **unique**, that is, you can declare that it would be illegal to "
"have the same key value twice."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:113
#, fuzzy
msgid ""
"The first index defined on a space is called the **primary key index**, and it "
"must be unique. All other indexes are called **secondary indexes**, and they may "
"be non-unique."
msgstr ""
"Первичный индекс для кортежа должен строиться по уникальным значениям полей, но "
"остальные (вторичные) индексы могут строиться по неуникальным значениям."

#: ../doc/1.7/book/box/data_model.rst:117
#, fuzzy
msgid ""
"An index definition may include identifiers of tuple fields and their expected "
"**types** (see allowed :ref:`indexed field types <index-box_indexed-field-"
"types>` below)."
msgstr ""
"Индекс может содержать идентификаторы полей кортежа и типы данных для этих "
"полей. Индексированные поля могут содержать данные следующих типов:"

#: ../doc/1.7/book/box/data_model.rst:121
msgid ""
"In our example, we first defined the primary index (named 'primary') based on "
"field #1 of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:124
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/box/data_model.rst:128
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist and "
"must contain an unsigned integer. The index type is 'hash', so values in field "
"#1 must be unique, because keys in HASH indexes are unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:133
msgid ""
"After that, we defined a secondary index (named 'secondary') based on field #2 "
"of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:136
#, fuzzy
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"
msgstr ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"

#: ../doc/1.7/book/box/data_model.rst:140
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist and "
"must contain a string. The index type is 'tree', so values in field #2 must not "
"be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:147
msgid ""
"Space definitions and index definitions are stored permanently in Tarantool's "
"system spaces :ref:`_space <box_space-space>` and :ref:`_index <box_space-"
"index>` (for details, see reference on :ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:151
msgid ""
"You can add, drop, or alter the definitions at runtime, with some restrictions. "
"See syntax details in reference on :ref:`box <box-module>` module."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:158
msgid "Data types"
msgstr "Типы данных"

#: ../doc/1.7/book/box/data_model.rst:160
msgid ""
"Tarantool is both a database and an application server. Hence a developer often "
"deals with two type sets: the programming language types (e.g. Lua) and the "
"types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:169
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
#, fuzzy
msgid "Scalar / compound"
msgstr "compound"

#: ../doc/1.7/book/box/data_model.rst:179
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
#, fuzzy
msgid "Lua type"
msgstr "Типы данных"

#: ../doc/1.7/book/box/data_model.rst:179
#, fuzzy
msgid "Example value"
msgstr "Пример 2"

#: ../doc/1.7/book/box/data_model.rst:181 ../doc/1.7/book/box/data_model.rst:183
#: ../doc/1.7/book/box/data_model.rst:185 ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/book/box/data_model.rst:189
msgid "scalar"
msgstr "scalar"

#: ../doc/1.7/book/box/data_model.rst:181
msgid "\"`nil`_\""
msgstr "\"`nil`_\""

#: ../doc/1.7/book/box/data_model.rst:181 ../doc/1.7/book/box/data_model.rst:307
msgid "msgpack.NULL"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:183
msgid "\"`boolean`_\""
msgstr "\"`boolean`_\""

#: ../doc/1.7/book/box/data_model.rst:183 ../doc/1.7/book/box/data_model.rst:309
msgid "true"
msgstr "true"

#: ../doc/1.7/book/box/data_model.rst:185
msgid "\"`string`_\""
msgstr "\"`string`_\""

#: ../doc/1.7/book/box/data_model.rst:185
msgid "'A B C'"
msgstr "'A B C'"

#: ../doc/1.7/book/box/data_model.rst:187
msgid "integer"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:187 ../doc/1.7/book/box/data_model.rst:189
msgid "\"`number`_\""
msgstr "\"`number`_\""

#: ../doc/1.7/book/box/data_model.rst:187
msgid "12345"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:189
msgid "double"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:189
#, fuzzy
msgid "1,2345"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:191 ../doc/1.7/book/box/data_model.rst:193
#: ../doc/1.7/book/box/data_model.rst:195
msgid "compound"
msgstr "compound"

#: ../doc/1.7/book/box/data_model.rst:191
msgid "map"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "table: 0x410f8b10"
msgstr "table: 0x410f8b10"

#: ../doc/1.7/book/box/data_model.rst:193 ../doc/1.7/book/box/data_model.rst:195
msgid "array"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:195
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:195
#, fuzzy
msgid "[12345, 'A B C']"
msgstr "12345: {'A B C'}"

#: ../doc/1.7/book/box/data_model.rst:205
#, fuzzy
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* (displayed "
"as **null** on Tarantool's command line, since the output is in the YAML "
"format). Nils may be compared to values of any types with == (is-equal) or ~= "
"(is-not-equal), but other operations will not work. Nils may not be used in Lua "
"tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""
"Тип *nil* (нулевой) может иметь только одно значение, также называемое *nil*, но "
"часто отображаемое как *null*. Нулевое значение можно сравнивать со значениями "
"любых типов с помощью операторов == (равен) или ~= (не равен), но никакие другие "
"операции для нулевых значений не доступны. Нулевые значения также нельзя "
"использовать в Lua-таблицах; вместо нулевого значения в таком случае можно "
"указать :ref:`yaml.NULL <yaml-null>`, либо :ref:`json.NULL <json-null>`, либо :"
"ref:`msgpack.NULL <msgpack-null>`."

#: ../doc/1.7/book/box/data_model.rst:213
#, fuzzy
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../doc/1.7/book/box/data_model.rst:215
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented with "
"alphanumeric characters inside single quotes. In both Lua and MsgPack, strings "
"are treated as binary data, with no attempts to determine a string's character "
"set or to perform any string conversion. So, string sorting and comparison are "
"done byte-by-byte, without any special collation rules applied. (Example: "
"numbers are ordered by their point on the number line, so 2345 is greater than "
"500; meanwhile, strings are ordered by the encoding of the first byte, then the "
"encoding of the second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:225
#, fuzzy
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool allows "
"both integer and floating-point values. Tarantool will try to store a Lua number "
"as floating-point if the value contains a decimal point or is very large "
"(greater than 100 trillion = 1e14), otherwise Tarantool will store it as an "
"integer. To ensure that even very large numbers are stored as integers, use the :"
"ref:`tonumber64 <other-tonumber64>` function, or the LL (Long Long) suffix, or "
"the ULL (Unsigned Long Long) suffix. Here are examples of numbers using regular "
"notation, exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""
"В языке Lua тип *number* (число) — это число с плавающей точкой двойной "
"точности, но в Tarantool'е можно использовать как целые числа, так и числа с "
"плавающей запятой. Tarantool по возможности сохраняет числовые значения в виде "
"чисел с плавающей точкой, если числовое значение содержит десятичную запятую или "
"если оно очень велико (более 100 триллионов = 1e14). Если в формате с плавающей "
"точкой сохранить не удается, то Tarantool сохраняет такое значение в виде целого "
"числа. Чтобы даже очень большие величины гарантированно обрабатывались как целые "
"числа, используйте функцию :ref:`tonumber64 <other-tonumber64>`, либо "
"приписывайте в конце суффикс LL (Long Long) или ULL (Unsigned Long Long). Вот "
"примеры записи чисел в различных представлениях (обычном, экспоненциальном, с "
"суффиксом ULL и с использованием функции tonumber64): ``-55``, ``-2.7e+20``, "
"``100000000000000ULL``, ``tonumber64('18446744073709551615')``."

#: ../doc/1.7/book/box/data_model.rst:236
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables with "
"integer keys starting with 1 -- as MsgPack arrays. Nils may not be used in Lua "
"tables; the workaround is to use :ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:241
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the database. It "
"is a special type (cdata) to avoid conversion to a Lua table on retrieval. A few "
"functions may return tables with multiple tuples. For more tuple examples, see :"
"ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:248
msgid ""
"Tarantool uses the MsgPack format for database storage, which is variable-"
"length. So, for example, the smallest number requires only one byte, but the "
"largest number requires nine bytes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:256
#, fuzzy
msgid "Indexed field types"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/data_model.rst:258
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is why, for "
"example, 'unsigned' is a separate **indexed field type**, compared to ‘integer’ "
"data type in MsgPack: they both store ‘integer’ values, but an 'unsigned' index "
"contains only *non-negative* integer values and an ‘integer’ index contains "
"*all* integer values."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:264
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:275
#, fuzzy
msgid "Indexed field type"
msgstr "Тип поля для индексирования"

#: ../doc/1.7/book/box/data_model.rst:275
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:275 ../doc/1.7/book/box/data_model.rst:642
msgid "Index type"
msgstr "Тип индекса"

#: ../doc/1.7/book/box/data_model.rst:278
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
#, fuzzy
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""
"``unsigned`` (беззнаковое целое число в диапазоне от 0 до "
"18,446,744,073,709,551,615)"

#: ../doc/1.7/book/box/data_model.rst:278
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
#, fuzzy
msgid "123456"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:283
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283 ../doc/1.7/book/box/data_model.rst:288
#: ../doc/1.7/book/box/data_model.rst:312
#, fuzzy
msgid "**integer** (integer between -9223372036854775808 and 18446744073709551615)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до "
"9,223,372,036,854,775,807)"

#: ../doc/1.7/book/box/data_model.rst:283 ../doc/1.7/book/box/data_model.rst:288
#: ../doc/1.7/book/box/data_model.rst:298 ../doc/1.7/book/box/data_model.rst:307
msgid "TREE or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
msgid "-2^63"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:293 ../doc/1.7/book/box/data_model.rst:317
msgid ""
"**double** (single-precision floating point number or double-precision floating "
"point number)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:288 ../doc/1.7/book/box/data_model.rst:313
#, fuzzy
msgid "1.234"
msgstr "12345"

#: ../doc/1.7/book/box/data_model.rst:290
msgid "-44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:292
msgid "1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "‘A B C’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:300
msgid "‘\\65 \\66 \\67’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302
#, fuzzy
msgid ""
"**array** (arrays of integers between -9223372036854775808 and "
"9223372036854775807)"
msgstr ""
"``integer`` (знаковое целое число в диапазоне от -9,223,372,036,854,775,808 до "
"9,223,372,036,854,775,807)"

#: ../doc/1.7/book/box/data_model.rst:302
#, fuzzy
msgid "RTREE"
msgstr "true"

#: ../doc/1.7/book/box/data_model.rst:302
msgid "{10, 11}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:304
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:307
msgid "**null**"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:309
#, fuzzy
msgid "**boolean** (true or false)"
msgstr ""
"Тип *boolean* (логический) может иметь только значения ``true`` или ``false``."

#: ../doc/1.7/book/box/data_model.rst:322
#, fuzzy
msgid "**string** (any set of octets)"
msgstr "``string`` (строковое значение, т.е. любая последовательность октетов)"

#: ../doc/1.7/book/box/data_model.rst:324
msgid ""
"Note: When there is a mix of types, the key order is: null, then booleans, then "
"numbers, then strings."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:311
msgid "-1"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:315
msgid "‘’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:317
msgid "‘ру’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:334
msgid "Persistence"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:336
msgid ""
"In Tarantool, updates to the database are recorded in the so-called **write "
"ahead log (WAL)** files. This ensures data persistence. When a power outage "
"occurs or the Tarantool instance is killed incidentally, the in-memory database "
"is lost. In this situation, WAL files are used to restore the data. Namely, "
"Tarantool reads the WAL files and redoes the requests (this is called the "
"\"recovery process\"). You can change the timing of the WAL writer, or turn it "
"off, by setting :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:345
#, fuzzy
msgid ""
"Tarantool also maintains a set of **snapshot files**. These files contain an on-"
"disk copy of the entire data set for a given moment. Instead of reading every "
"WAL file since the databases were created, the recovery process can load the "
"latest snapshot file and then read only those WAL files that were produced after "
"the snapshot file was made. After checkpointing, old WAL files can be removed to "
"free up space."
msgstr ""
"Tarantool также сохраняет ряд файлов со статическими снимками данных "
"(snapshots). Файл со снимком — это дисковая копия всех данных в базе на какой-то "
"момент. Вместо того, чтобы зачитывать все WAL-файлы, появившиеся с момента "
"создания базы, Tarantool в процессе восстановления может загрузить самый свежий "
"снимок и затем зачитать только те WAL-файлы, которые были сделаны с момента "
"сохранения снимка. Снимки могут делаться автоматически, или же пользователи "
"могут создавать их сами в любой момент с помощью запроса :ref:`box.snapshot() "
"<admin-snapshot>`."

#: ../doc/1.7/book/box/data_model.rst:352
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's :ref:"
"`box.snapshot() <box-snapshot>` request. To enable automatic creation of "
"snapshot files, you can use Tarantool's :ref:`checkpoint daemon "
"<book_cfg_checkpoint_daemon>`. The checkpoint daemon sets intervals for forced "
"checkpoints. It makes sure that the states of both memtx and vinyl storage "
"engines are synchronized and saved to disk, and automatically removes old WAL "
"files."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:360
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:364
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in :ref:"
"`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:367
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:369
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more details "
"about the WAL writer and the recovery process."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:374
msgid "Operations"
msgstr "Операции"

#: ../doc/1.7/book/box/data_model.rst:380
#, fuzzy
msgid "Data operations"
msgstr "Операции с индексами"

#: ../doc/1.7/book/box/data_model.rst:382
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:384
msgid "one data-retrieval operation (SELECT), and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:385
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, REPLACE)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:387
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:389 ../doc/1.7/book/box/data_model.rst:560
#, fuzzy
msgid "**Examples**"
msgstr "**Примеры:**"

#: ../doc/1.7/book/box/data_model.rst:391
msgid "INSERT: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:393
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:395
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:397
#, fuzzy
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:401
msgid "UPDATE: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:403
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the tuple's "
"primary-key field, is mandatory, because ``update()`` requests must always have "
"a clause that specifies a unique key, which in this case is field[1]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:407
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will happen to "
"field[2] with the new value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:410
#, fuzzy
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/data_model.rst:414
msgid "UPSERT: Upsert the tuple, changing field field[2] again."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:416
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. However, "
"the execution logic of these two requests is different. UPSERT is either UPDATE "
"or INSERT, depending on the database's state. Also, UPSERT execution is "
"postponed after transaction commit, so, unlike ``update()``, ``upsert()`` "
"doesn't return data back."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:422
#, fuzzy
msgid "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/box/data_model.rst:426
msgid "REPLACE: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:428
msgid ""
"This is also possible with the ``update()`` request, but the ``update()`` "
"request is usually more complicated."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:431
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:435
msgid "SELECT: Retrieve the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:437
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to mention "
"the primary key."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:439
#, fuzzy
msgid "tarantool> box.space.tester:select{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:442
msgid "DELETE: Delete the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:444
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:446
#, fuzzy
msgid "tarantool> box.space.tester:delete{999}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/box/data_model.rst:450
msgid ""
"All the functions operate on tuples and accept only unique key values. So, the "
"number of tuples in the space is always 0 or 1, since the keys are unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:453
msgid ""
"Functions ``insert()``, ``upsert()`` and ``replace()`` accept only primary-key "
"values. Functions ``select()``, ``delete()`` and ``update()`` may accept either "
"a primary-key value or a secondary-key value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:459
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming language "
"connectors <index-box_connectors>`. The client server protocol is open and "
"documented. See this :ref:`annotated BNF <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:466
msgid "Index operations"
msgstr "Операции с индексами"

#: ../doc/1.7/book/box/data_model.rst:468
#, fuzzy
msgid ""
"Index operations are automatic: if a data-manipulation request changes a tuple, "
"then it also changes the index keys defined for the tuple."
msgstr ""
"Операции с индексами производятся автоматически. Если запрос по манипулированию "
"данными меняет данные в кортеже, то меняются и ключи в индексе для данного "
"кортежа. Поэтому пользователю нужно знать только как и зачем задавать индексы."

#: ../doc/1.7/book/box/data_model.rst:471
#, fuzzy
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""
"Простая операция для создания индекса, которую мы рассматривали ранее, имела "
"следующий вид:"

#: ../doc/1.7/book/box/data_model.rst:476
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ":samp:`box.space.{имя-пространства}:create_index('{имя-индекса}')`"

#: ../doc/1.7/book/box/data_model.rst:478
#, fuzzy
msgid ""
"This creates a unique TREE index on the first field of all tuples (often called "
"\"Field#1\"), which is assumed to be numeric."
msgstr ""
"По умолчанию, при этом создается TREE-индекс по первому полю (обычно его "
"называют \"Field#1\") для всех кортежей в пространстве. Предполагается, что "
"индексируемое поле является числовым."

#: ../doc/1.7/book/box/data_model.rst:481
#, fuzzy
msgid "The simple SELECT request that we've illustrated before is:"
msgstr "Вот простой SELECT-запрос, который мы рассматривали ранее:"

#: ../doc/1.7/book/box/data_model.rst:486
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ":extsamp:`box.space.{*{имя-пространства}*}:select({*{значение}*})`"

#: ../doc/1.7/book/box/data_model.rst:488
#, fuzzy
msgid ""
"This looks for a single tuple via the first index. Since the first index is "
"always unique, the maximum number of returned tuples will be: one."
msgstr ""
"По умолчанию, такой запрос ищет нужный кортеж по значению в первом (первичном) "
"индексе. Поскольку первичный индекс всегда уникален, то данный запрос вернет не "
"более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:491
#, fuzzy
msgid "The following SELECT variations exist:"
msgstr "Также возможны следующие варианты:"

#: ../doc/1.7/book/box/data_model.rst:493
msgid "The search can use comparisons other than equality."
msgstr ""
"Помимо условия равенства, при поиске могут использоваться и другие условия "
"сравнения."

#: ../doc/1.7/book/box/data_model.rst:500
#, fuzzy
msgid ""
"The comparison operators are LT, LE, EQ, REQ, GE, GT (for \"less than\", \"less "
"than or equal\", \"equal\", \"reversed equal\", \"greater than or equal\", "
"\"greater than\" respectively). Comparisons make sense if and only if the index "
"type is ‘TREE'."
msgstr ""
"Можно использовать следующие операторы сравнения: LT (меньше), LE (меньше или "
"равно), EQ (равно), REQ (неравно), GE (больше или равно), GT (больше). Сравнения "
"имеют смысл только для индексов типа 'tree'."

#: ../doc/1.7/book/box/data_model.rst:505
msgid ""
"This type of search may return more than one tuple; if so, the tuples will be in "
"descending order by key when the comparison operator is LT or LE or REQ, "
"otherwise in ascending order."
msgstr ""
"Этот вариант поиска может вернуть более одного кортежа. В таком случае кортежи "
"будут отсортированы в порядке убывания по ключу (если использовался оператор LT, "
"LE или REQ), либо в порядке возрастания (во всех остальных случаях)."

#: ../doc/1.7/book/box/data_model.rst:509
msgid "The search can use a secondary index."
msgstr "Поиск может производиться по вторичному индексу."

#: ../doc/1.7/book/box/data_model.rst:516
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""
"При поиске по первичному индексу имя индекса можно не указывать. При поиске же "
"по вторичному индексу имя индекса указывать необходимо."

#: ../doc/1.7/book/box/data_model.rst:519
msgid "The search may be for some or all key parts."
msgstr "Поиск может производиться как по всему ключу, так и по его частям."

#: ../doc/1.7/book/box/data_model.rst:540
#, fuzzy
msgid "The search may be for all fields, using a table for the value:"
msgstr ""
"Поиск может производиться по всем полям (в этом случае используется таблица "
"значений):"

#: ../doc/1.7/book/box/data_model.rst:547
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""
"Либо же по одному полю (в этом случае используется таблица или скалярное "
"значение):"

#: ../doc/1.7/book/box/data_model.rst:554
#, fuzzy
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1, 'B'}``."
msgstr ""
"Во втором случае Tarantool вернет два кортежа: ``{1, 'A'}`` и ``{1, 'B'}``. При "
"необходимости можно задать даже нулевые поля, в результате чего Tarantool вернет "
"все три кортежа."

#: ../doc/1.7/book/box/data_model.rst:557
msgid ""
"You can specify even zero fields, causing all three tuples to be returned. "
"(Notice that partial key searches are available only in TREE indexes.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:562
msgid "BITSET example:"
msgstr "Пример работы с BITSET-индексом:"

#: ../doc/1.7/book/box/data_model.rst:564
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> box.space.bitset_example:create_index('bitset',{unique=false,"
"type='BITSET', parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"

#: ../doc/1.7/book/box/data_model.rst:575 ../doc/1.7/book/box/data_model.rst:597
msgid "The result will be:"
msgstr "Мы получим следующий результат:"

#: ../doc/1.7/book/box/data_model.rst:577
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."

#: ../doc/1.7/book/box/data_model.rst:584
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr "поскольку (7 AND 2) не равно 0 и (3 AND 2) не равно 0."

#: ../doc/1.7/book/box/data_model.rst:586
msgid "RTREE example:"
msgstr "Пример работы с RTREE-индексом:"

#: ../doc/1.7/book/box/data_model.rst:588
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"
msgstr ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> box.space.rtree_example:create_index('rtree',{unique=false,"
"type='RTREE', parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, {iterator = "
"'GT'})"

#: ../doc/1.7/book/box/data_model.rst:599
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."

#: ../doc/1.7/book/box/data_model.rst:605
#, fuzzy
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is entirely "
"within a rectangle whose corners are at coordinates ``3,5,9,10``."
msgstr ""
"поскольку прямоугольник с углами в координатах 4,7,5,9 лежит целиком внутри "
"прямоугольника с углами в координатах 3,5,9,10."

#: ../doc/1.7/book/box/data_model.rst:608
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index iterators "
"are for traversing indexes one key at a time, taking advantage of features that "
"are specific to an index type, for example evaluating Boolean expressions when "
"traversing BITSET indexes, or going in descending order when traversing TREE "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:614
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and :ref:"
"`drop() <box_index-drop>` in reference for :ref:`box.index <box_index>` "
"submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:619
msgid "Complexity factors"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:621
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index <box_index>` "
"submodules, there are notes about which complexity factors might affect the "
"resource usage of each function."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:631
msgid "Complexity factor"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:634
msgid "Index size"
msgstr "Размер индекса"

#: ../doc/1.7/book/box/data_model.rst:634
#, fuzzy
msgid ""
"The number of index keys is the same as the number of tuples in the data set. "
"For a TREE index, if there are more keys, then the lookup time will be greater, "
"although of course the effect is not linear. For a HASH index, if there are more "
"keys, then there is more RAM used, but the number of low-level steps tends to "
"remain constant."
msgstr ""
"Количество ключей в индексе равно количеству кортежей в наборе данных. В случае "
"с TREE-индексом: с ростом количества ключей увеличивается время поиска, хотя "
"зависимость здесь, конечно же, не линейная. В случае с HASH-индексом: с ростом "
"количества ключей увеличивается объем используемой памяти, но количество "
"низкоуровневых шагов остается примерно тем же."

#: ../doc/1.7/book/box/data_model.rst:642
#, fuzzy
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of tuples in "
"the space is greater than one."
msgstr ""
"Как правило, поиск по HASH-индексу работает быстрее, чем по TREE-индексу, если в "
"наборе есть более одного кортежа."

#: ../doc/1.7/book/box/data_model.rst:646
msgid "Number of indexes accessed"
msgstr "Количество обращений к индексам"

#: ../doc/1.7/book/box/data_model.rst:646
#, fuzzy
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to update the "
"tuple, there must be N accesses if the space has N different indexes."
msgstr ""
"Обычно для выборки значений одного кортежа используется только один индекс. Но "
"при обновлении значений в кортеже требуется N обращений, если у набора кортежей "
"есть N индексов."

#: ../doc/1.7/book/box/data_model.rst:650
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary index "
"fields are unchanged by the update. So, this complexity factor applies only to "
"memtx, since it always makes a full-tuple copy on every update."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:656
msgid "Number of tuples accessed"
msgstr "Количество обращений к кортежам"

#: ../doc/1.7/book/box/data_model.rst:656
#, fuzzy
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This factor is "
"usually less important than the others."
msgstr ""
"Некоторые запросы, например SELECT, могут возвращать несколько кортежей. Как "
"правило, это наименее важный фактор из всех."

#: ../doc/1.7/book/box/data_model.rst:660
msgid "WAL settings"
msgstr "Настройки WAL"

#: ../doc/1.7/book/box/data_model.rst:660
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no writing or "
"delayed writing, this factor is unimportant. If the setting causes every data-"
"change request to wait for writing to finish on a slow device, this factor is "
"more important than all the others."
msgstr ""
"Важным параметром для записи в WAL является :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. Если запись в WAL отключена или задана "
"запись с задержкой, но этот фактор не так важен. Если же запись в WAL "
"производится при каждом запросе на изменение данных, то при каждом таком запросе "
"приходится ждать, пока отработает обращение к более медленному диску, и данный "
"фактор становится важнее всех остальных."

#: ../doc/1.7/book/box/index.rst:33
msgid "Database"
msgstr "Функционал СУБД"

#: ../doc/1.7/book/box/index.rst:35
msgid ""
"In this chapter, we introduce the basic concepts of working with Tarantool as a "
"database manager."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:33
msgid "Limitations"
msgstr "Ограничения"

#: ../doc/1.7/book/box/limitations.rst:35
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:37
msgid ""
"For TREE or HASH indexes, the maximum is 255 (``box.schema.INDEX_PART_MAX``). "
"For RTREE indexes, the maximum is 1 but the field is an ARRAY of up to 20 "
"dimensions. For BITSET indexes, the maximum is 1."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:44
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:46
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:50
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:52
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's :ref:`field_count "
"<box_space-field_count>` member, or the maximal tuple length."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:59
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:61
msgid ""
"The maximal number of bytes in a tuple is roughly equal to :ref:"
"`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` (with a metadata "
"overhead of about 20 bytes per tuple, which is added on top of useful bytes). By "
"default, the value of ``memtx_max_tuple_size`` is 1,048,576. To increase it, "
"specify a larger value when starting the Tarantool instance. For example, ``box."
"cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:70
#, fuzzy
msgid "**Slab size**"
msgstr "**scalar**"

#: ../doc/1.7/book/box/limitations.rst:72
msgid ""
"The maximal size of an allocatable memory unit (slab) is equal to one quarter "
"of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` (by default, "
"approximately 262,000 bytes). To see memory usage statistics broken down by slab "
"size, use :ref:`box.slab.stats() <box_slab_stats>`."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:79
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:81
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can "
"contain a million bytes, so the maximum is determined by factors such as :ref:"
"`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by the index "
"support."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:88
msgid "**Number of spaces**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:90
msgid "The theoretical maximum is 65,000 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:94
msgid "**Number of connections**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:96
msgid ""
"The practical limit is the number of file descriptors that one can set with the "
"operating system."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:101
msgid "**Space size**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:103
msgid ""
"The total maximum size for all spaces is in effect set by :ref:`memtx_memory "
"<cfg_storage-memtx_memory>`, which in turn is limited by the total available "
"memory."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:109
msgid "**Update operations count**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:111
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:116
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:118
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:122
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:124
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:128
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:130
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:34
msgid "Triggers"
msgstr "Триггеры"

#: ../doc/1.7/book/box/triggers.rst:36
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server "
"executes when certain events happen."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:39
msgid "There are three types of triggers in Tarantool:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:41
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed when a "
"session begins or ends,"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:44
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed during "
"authentication, and"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:47
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database events."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:50
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:52
msgid ""
"Triggers associate a function with an event. The request to \"define a trigger\" "
"implies passing the trigger’s function to one of the \"on_event-name()\" "
"functions: :ref:`box.session.on_connect() <box_session-on_connect>`, :ref:`box."
"session.on_auth() <box_session-on_auth>`, :ref:`box.session.on_disconnect() "
"<box_session-on_disconnect>`, or :ref:`space_object:on_replace() <box_space-"
"on_replace>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:60
msgid "Triggers are defined only by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:62
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the database. "
"Therefore triggers disappear when the instance is shut down. To make them "
"permanent, put function definitions and trigger settings into Tarantool's :ref:"
"`initialization script <index-init_label>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:67
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the overhead is "
"minimal: merely a pointer dereference and check. If a trigger is defined, then "
"its overhead is equivalent to the overhead of calling a function."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:71
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:74
msgid ""
"Triggers must work within the event context. However, effects are undefined if a "
"function contains requests which normally could not occur immediately after the "
"event, but only before the return from the event. For example, putting `os."
"exit() <http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or :ref:`box."
"rollback() <box-rollback>` in a trigger function would be bringing in requests "
"outside the event context."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:81
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies passing "
"a new trigger function and an old trigger function to one of the \"on_event-"
"name()\" functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:85
msgid ""
"The \"on_event_name()\" functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua function "
"definition such as \"function f() x = x + 1 end\" is the same as \"f = function "
"() x = x + 1 end\" -- in both cases ``f`` gets a function pointer. And \"trigger "
"= box.session.on_connect(f)\" is the same as \"trigger = box.session."
"on_connect(function () x = x + 1 end)\" -- in both cases ``trigger`` gets the "
"function pointer which was passed."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:93
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:95
msgid ""
"on_connect() – with no arguments – to return a table of all connect-trigger "
"functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:96
msgid "on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:97
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:98
msgid "on_replace() to return all replace-trigger functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:102
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:104
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:31
msgid ""
"A storage engine is a set of very-low-level routines which actually store and "
"retrieve tuple values. Tarantool offers a choice of two storage engines:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:34
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to arrive."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:37
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will "
"especially appeal to users who like to see data go directly to disk, so that "
"recovery time might be shorter and database size might be larger. On the other "
"hand, vinyl lacks some functions and options that are available with memtx. "
"Where that is the case, the relevant description in this manual will contain a "
"note beginning with the words \"Note re storage engine\". See also a coverage "
"for all :ref:`the differences between memtx and vinyl <vinyl_diff>` further on "
"this page."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:46
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = 'vinyl'`` "
"when creating a space, for example: ``space = box.schema.space.create('name', "
"{engine='vinyl'})``."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:54
msgid "Differences between memtx and vinyl storage engines"
msgstr "Различия между движками memtx и vinyl"

#: ../doc/1.7/book/box/vinyl.rst:56
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-memory\" "
"engine while vinyl is an \"on-disk\" engine. An in-memory storage engine is "
"generally faster, and the memtx engine is justifiably the default for Tarantool, "
"but there are two situations where an on-disk engine such as vinyl would be "
"preferable:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:62
msgid ""
"when the database is larger than the available memory and adding more memory is "
"not a realistic option;"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:64
msgid ""
"when the server frequently goes down due to errors or a simple desire to save "
"power -- bringing the server back up and restoring a memtx database into memory "
"takes time."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:68
msgid ""
"Here are behavior differences which affect programmers. All of these differences "
"have been noted elsewhere in sentences that begin with the words \"Note re "
"storage engine: vinyl\"."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, the index type can be TREE or HASH or RTREE or BITSET."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, the only index type is TREE."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
#, fuzzy
msgid ""
"With memtx, :ref:`create_index <box_space-create_index>` can be done at any time."
msgstr ""
"Подробнее о других типах индексов см. в описании функции :ref:`create_index "
"<box_space-create_index>`."

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, for index searches, ``nil`` may be allowed within a search key."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, ``nil`` is only allowed at the end of a search key."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, temporary spaces are supported."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, they are not."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() <box_space-"
"len>` and :ref:`random() <box_index-random>` functions are supported."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, the :ref:`count() <box_index-count>` function takes a constant "
"amount of time."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, it takes a variable amount of time depending on index size."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, delete will return deleted tuple, if any."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, delete will always return nil."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:95
msgid ""
"It was explained :ref:`earlier <index-yields_must_happen>` that memtx does not "
"\"yield\" on a select request, it yields only on data-change requests. However, "
"vinyl does yield on a select request, or on an equivalent such as ``get()`` or "
"``pairs()``. This has significance for :ref:`cooperative multitasking <atomic-"
"cooperative_multitasking>`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:103
msgid "Vinyl features"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:105
msgid "Full ACID compliance"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:106
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:107
msgid "Pure Append-Only"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:108
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:109
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:110
msgid ""
"Multi-Statement and Single-Statement Transactions (Snapshot Isolation (SI), "
"multi-databases)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:112
msgid ""
"Asynchronous or synchronous transaction execution (Callback triggered versus "
"blocking)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:114
msgid ""
"Separate storage formats: key-value (Default), or document (Keys are part of "
"value)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:116
msgid "Update without read"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:117
msgid "Consistent Cursors"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:118
msgid "Prefix search"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:119
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:120
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:121
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:122
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:123
msgid "Metadata Compression (By default)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:124
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:125
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:126
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:127
msgid ""
"Easy to write bindings (Very FFI-friendly, API designed to be stable in future)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:128
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:129
msgid "Event loop friendly"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:130
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:131
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:132
msgid "BSD Licensed"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:134
msgid ""
"It is appropriate for databases that cannot fit in memory, where access via "
"secondary keys is not required."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:137
msgid "In vinyl terminology:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:139
msgid "There is one **Environment**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:140
msgid ""
"An Environment has N **Databases** - a vinyl database is like a Tarantool "
"`space`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:141
msgid "A Database has N **Ranges**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:142
msgid "A Range has one **Range File**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:143
msgid "A Range File has N **Runs**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:144
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:145
msgid ""
"A Region has **keys** and **values** - a vinyl key-value is like a Tarantool "
"`tuple`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:147
msgid ""
"A key and its associated value are together, so when one accesses a key one gets "
"the whole tuple. In other words, in vinyl the data is stored in the index. There "
"are up to two in-memory copies of an index, as well as the copy in the Range "
"File."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:151
msgid ""
"For operations that insert or update tuples - called Set operations in vinyl - "
"vinyl makes changes to in-memory copies of the index, and writes to Tarantool's "
"Write-ahead Log. A scheduler assigns tasks to multiple background threads for "
"transferring index data from memory to disk, and for reorganizing Runs. To "
"support transactions, Set operations can be delayed until an explicit commit. If "
"multiple users access the same tuples simultaneously, the concurrency control "
"method is `MVCC`_ and the isolation level is `Snapshot`_."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:162
msgid ""
"Formally, in terms of disk accesses, vinyl has the following algorithmic "
"complexity:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:164
msgid ""
"**Set** - the worst case is O(*1*) append-only key writes to the Write-Ahead Log "
"+ in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:166
msgid ""
"**Delete** - the worst case is O(*1*) key writes and in-memory index inserts "
"(the same as **Set**)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:168
msgid ""
"**Get** - the worst case is `amortized`_ O(*max\\_run\\_count\\_per\\_node*) "
"random Region reads from a single Range file, which itself does in-memory index "
"search + in-memory Region search"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:171
msgid ""
"**Range** - queries, the worst case of full Database scan is amortized O(*total"
"\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:178
msgid "Under the hood"
msgstr "А что там \"под капотом\"?"

#: ../doc/1.7/book/box/vinyl.rst:180
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:182
msgid ""
"filling an empty database with one million tuples (we'll call them \"keys\" to "
"emphasize the indexed nature)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:184
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:188
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:190
msgid ""
"During the first 200,000 Set operations, inserted keys first go to the in-memory "
"index. To maintain persistence, information about each Set operation is written "
"to Tarantool's Write-ahead Log."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:198
msgid ""
"At this point, we have keys in an in-memory index and records in the Write-ahead "
"Log."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:202
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:204
msgid ""
"As the in-memory index becomes too large for available memory, the index must be "
"copied from memory to disk. The on-disk copy of the in-memory index is called a "
"Run. To save the Run, a new file is created, the Range File. We will call it "
"**db file** for this example."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:209
msgid ""
"The scheduler wakes a worker thread in the background, a Run Creation Thread. "
"The thread creates a second in-memory index. If there are Set operations taking "
"place while the thread is working, their contention effect will be small because "
"they will operate on the second in-memory index."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:218
msgid ""
"When the Run Creation Thread finishes the task, the first in-memory index is "
"freed."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:227
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:229
msgid ""
"Several times, the in-memory index becomes too large and a Run Creation Thread "
"transfers the keys to a Run. The Runs have been appended to the end of db file. "
"The number of created Runs becomes large."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:237
msgid ""
"There is a user-settable maximum number of Runs per Range. When the number of "
"Runs reaches this maximum, the vinyl scheduler wakes a **Compaction Thread** for "
"the db file. The Compaction Thread merges the keys in all the Runs, and creates "
"one or more new db files."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:246
msgid ""
"Now there are multiple pairs of in-memory indexes, and each pair has an "
"associated db file. The combination of the in-memory indexes and the db file is "
"called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:254
msgid ""
"Thus the contents of a Range are: a range of sorted key values, stored in Runs "
"of a Range File and (when necessary) in memory. Since the ranges do not overlap, "
"each Range can be handled independently. Therefore, while one of the background "
"threads is working on Range 1, another background thread can be working on Range "
"2, without contention. That means that all the background operations (Run "
"Creation, Compaction, Garbage Collection, and Backup) can take place in parallel "
"on multiple threads."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:262
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:264
msgid ""
"Before the Compaction there was one Range, which was created automatically when "
"the Database was initialized. The Range had:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:267
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:268
msgid "a Range File with several Runs,"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:269
msgid ""
"a Write-Ahead Log file recording the Set operations, in the order they happened."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:271
msgid ""
"The number of Runs became too big, so the vinyl scheduler starts the Compaction "
"Thread and creates two new Ranges."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:278
msgid ""
"So, each of the two new Range Files contains half of the keys that were in the "
"original Range. The Range's in-memory indexes are split in the same way."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:281
msgid ""
"After the splitting, vinyl must take into account that: while the Compaction was "
"going on in the background, there might have been more Set operations taking "
"place in parallel. These Set operations would have changed one of the in-memory "
"indexes, and these changes too will be merged."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:286
msgid ""
"When the Compaction Thread finishes, the original Range is deleted, and "
"information about the new Ranges is inserted into an in-memory **Range Index**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:293
msgid ""
"This Range Index is used for all Set operations and all searches. Since the "
"Range Index has the minimum and maximum key values that are in each Range, it is "
"straightforward to scan it to find what Range would contain a particular key "
"value."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:303
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:305
msgid ""
"The final 300,000 Set operations take place; the background threads continue to "
"create new Runs and do more Compactions. After the millionth insertion, the "
"Database has four Ranges."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:313
msgid ""
"The inserting is done. Now, because the words \"memory\" and \"disk\" have "
"appeared in this explanation several times, here are a few words about how vinyl "
"is designed to use these resources most efficiently:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:317
msgid ""
"If there is more memory available, then Run Creation and Compaction will be less "
"frequent, and there will be fewer disk accesses."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:319
msgid ""
"The best vinyl performance will occur if there is no setting of a memory limit, "
"but this must be balanced against other considerations, such as requirements for "
"the memtx storage engine. If there is a setting of a memory limit, the vinyl "
"scheduler will give priority to the Ranges that have the largest in-memory "
"indexes, so that the largest memory blocks are freed first."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:324
msgid ""
"To make the most of hard drives and Flash, vinyl will delay operations that "
"require disk access (except the writing of the Write-ahead Log which is "
"specially tunable), so that the accesses are done in large sequential blocks."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:327
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:331
msgid "Reading million keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:333
msgid ""
"We will now start to read the million rows in the order that they were inserted, "
"which was random."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:340
msgid ""
"During the Get (search), vinyl first finds the correct Range by looking in the "
"Range Index. Then it searches the Range's first in-memory index, and/or the "
"Range's second in-memory index, and/or each Run of the Range, starting from the "
"end of the Range File."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:345
msgid ""
"Remember that a Run is divided into Regions, which are like what would be called "
"\"pages\" or \"blocks\" in a B-tree. For each Run, there is a list of the "
"Regions and their minimum/maximum key values - the Region Index - as well as "
"some metadata."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:354
msgid ""
"Region Indexes are loaded into memory when the Database is opened. Since the "
"Database's Range Index and the Region Indexes are normally in-memory, searching "
"and retrieving a tuple might require only zero or one disk accesses. However, "
"when memory is limited and there are many Runs, search time may rise. For each "
"additional Run there is a possible additional disk access during a search. Also, "
"it is impossible to maintain memory limits without doing a Run Creation process, "
"because new Set operations might occur more quickly than the Compaction process "
"can run."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:367
msgid ""
"Vinyl is read optimized. It is very likely that the most recently created Runs "
"(hot data) will be in the file system cache. The scheduler will give priority to "
"the Ranges which have the largest in-memory indexes and the most Runs."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:372
msgid ""
"The scheduler may also try to arrange that a Range will have only one Run, which "
"will ensure the average number of disk seeks for each search is O(*1*)."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:3 ../doc/1.7/book/connectors/__c.rst:31
msgid "C"
msgstr "C"

#: ../doc/1.7/book/connectors/__c.rst:5 ../doc/1.7/book/connectors/__c.rst:33
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""
"В этом разделе даны два примера использования высокоуровневого API для "
"Tarantool'а и языка C."

#: ../doc/1.7/book/connectors/__c.rst:9 ../doc/1.7/book/connectors/__c.rst:37
msgid "Example 1"
msgstr "Пример 1"

#: ../doc/1.7/book/connectors/__c.rst:11 ../doc/1.7/book/connectors/__c.rst:39
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space :code:"
"`examples` via the high-level C API."
msgstr ""
"Далее приводится пример полноценной программы на языке C, которая осуществляет "
"вставку кортежа ``[99999,'B']`` в пространство ``examples`` с помощью "
"высокоуровневого Tarantool API для языка C. "

#: ../doc/1.7/book/connectors/__c.rst:14 ../doc/1.7/book/connectors/__c.rst:42
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE REQUEST "
"*/\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND REQUEST "
"*/\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* См. ниже = НАСТРОЙКА */\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* См. ниже = СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* См. ниже = СОЗДАНИЕ "
"ЗАПРОСА */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* См. ниже = ОТПРАВКА "
"ЗАПРОСА */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* См. ниже = ПОЛУЧЕНИЕ "
"ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* См. ниже = ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__c.rst:44 ../doc/1.7/book/connectors/__c.rst:72
msgid ""
"Paste the code into a file named :file:`example.c` and install ``tarantool-c``. "
"One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""
"Скопируйте исходный код программы в файл с именем :file:`example.c` и установите "
"коннектор ``tarantool-c``. Вот один из способов установки ``tarantool-c`` (под "
"Ubuntu):"

#: ../doc/1.7/book/connectors/__c.rst:47 ../doc/1.7/book/connectors/__c.rst:75
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"

#: ../doc/1.7/book/connectors/__c.rst:57 ../doc/1.7/book/connectors/__c.rst:85
#: ../doc/1.7/book/connectors/__c.rst:288 ../doc/1.7/book/connectors/__c.rst:316
msgid "To compile and link the program, say:"
msgstr ""
"Чтобы скомпилировать и слинковать тестовую программу, выполните следующую "
"команду:"

#: ../doc/1.7/book/connectors/__c.rst:59 ../doc/1.7/book/connectors/__c.rst:87
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""
"$ # иногда это необходимо:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:65 ../doc/1.7/book/connectors/__c.rst:93
#, fuzzy
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as :ref:`described "
"earlier <index-connector_setting>`. To run the program, say :samp:`./example`. "
"The program will connect to the Tarantool instance, and will send the request. "
"If Tarantool is not running on localhost with listen address = 3301, the program "
"will print “Connection refused”. If the insert fails, the program will print "
"\"Insert failed\" and an error number (see all error codes in the source file `/"
"src/box/errcode.h <https://github.com/tarantool/tarantool/blob/1.7/src/box/"
"errcode.h>`_)."
msgstr ""
"Перед запуском программы проверьте, что ваше тестовое окружение настроено так, "
"как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера задан "
"порт для прослушивания и в базе создано пространство ``examples``). Чтобы "
"запустить тестовую программу, выполните команду :samp:`./example`. Программа "
"установит соединение с Tarantool-сервером и пошлет запрос. Если окажется, что "
"Tarantool-сервер не запущен на прослушивание по указанному адресу, то программа "
"выдаст сообщение об ошибке “Connection refused”. А если не пройдет INSERT-"
"запрос, то программа выдаст сообщение \"Insert failed\" и код ошибки (все коды "
"ошибок в Tarantool'е см. в исходном файле `/src/box/errcode.h <https://github."
"com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."

#: ../doc/1.7/book/connectors/__c.rst:77 ../doc/1.7/book/connectors/__c.rst:105
msgid "Here are notes corresponding to comments in the example program."
msgstr ""
"Далее следуют примечания, на которые мы ссылались в комментариях к исходному "
"коду тестовой программы."

#: ../doc/1.7/book/connectors/__c.rst:79 ../doc/1.7/book/connectors/__c.rst:107
msgid "**SETUP:** The setup begins by creating a stream."
msgstr "**НАСТРОЙКА:** Настройка начинается с создания потока (``tnt_stream``)."

#: ../doc/1.7/book/connectors/__c.rst:81 ../doc/1.7/book/connectors/__c.rst:109
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"

#: ../doc/1.7/book/connectors/__c.rst:86 ../doc/1.7/book/connectors/__c.rst:114
#, fuzzy
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on the "
"``tnt`` stream, some options may have to be set. The most important option is "
"TNT_OPT_URI. In this program, the URI is ``localhost:3301``, since that is where "
"the Tarantool instance is supposed to be listening."
msgstr ""
"В нашей тестовой программе поток назван ``tnt``. Перед установкой соединения "
"нужно задать ряд настроечных опций. Самая важная из них — TNT_OPT_URI. Для этой "
"опции указана URI-строка ``localhost:3301``, т.е. адрес, по которому должно быть "
"настроено прослушивание на стороне Tarantool-сервера."

#: ../doc/1.7/book/connectors/__c.rst:92 ../doc/1.7/book/connectors/__c.rst:108
#: ../doc/1.7/book/connectors/__c.rst:120 ../doc/1.7/book/connectors/__c.rst:136
#: ../doc/1.7/book/connectors/__c.rst:156 ../doc/1.7/book/connectors/__c.rst:164
#: ../doc/1.7/book/connectors/__c.rst:181 ../doc/1.7/book/connectors/__c.rst:184
#: ../doc/1.7/book/connectors/__c.rst:200 ../doc/1.7/book/connectors/__c.rst:209
#: ../doc/1.7/book/connectors/__c.rst:228
msgid "Function description:"
msgstr "Описание функции:"

#: ../doc/1.7/book/connectors/__c.rst:125 ../doc/1.7/book/connectors/__c.rst:574
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"

#: ../doc/1.7/book/connectors/__c.rst:100 ../doc/1.7/book/connectors/__c.rst:128
#, fuzzy
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated with a "
"URI, this example program can connect to a server."
msgstr ""
"**СОЕДИНЕНИЕ:** Теперь когда мы создали поток с именем ``tnt`` и связали его с "
"конкретным URI, наша программа может устанавливать соединение с Tarantool-"
"сервером."

#: ../doc/1.7/book/connectors/__c.rst:103 ../doc/1.7/book/connectors/__c.rst:131
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"

#: ../doc/1.7/book/connectors/__c.rst:141 ../doc/1.7/book/connectors/__c.rst:590
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr "int tnt_connect(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:115 ../doc/1.7/book/connectors/__c.rst:143
msgid ""
"The connection might fail for a variety of reasons, such as: the server is not "
"running, or the URI contains an invalid password. If the connection fails, the "
"return value will be -1."
msgstr ""
"Попытка соединения может и не удаться, например если Tarantool-сервер не запущен "
"или в URI-строке указан неверный пароль. В случае неудачи функция "
"``tnt_connect()`` вернет -1."

#: ../doc/1.7/book/connectors/__c.rst:119 ../doc/1.7/book/connectors/__c.rst:147
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such as the "
"contents of a tuple."
msgstr ""
"**СОЗДАНИЕ ЗАПРОСА:** В большинстве запросов требуется передавать "
"структурированные данные, например содержимое кортежа."

#: ../doc/1.7/book/connectors/__c.rst:122 ../doc/1.7/book/connectors/__c.rst:150
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"

#: ../doc/1.7/book/connectors/__c.rst:127 ../doc/1.7/book/connectors/__c.rst:155
#, python-format
msgid ""
"In this program, the request will be an INSERT, and the tuple contents will be "
"an integer and a string. This is a simple serial set of values, that is, there "
"are no sub-structures or arrays. Therefore it is easy in this case to format "
"what will be passed using the same sort of arguments that one would use with a C "
"``printf()`` function: ``%d`` for the integer, ``%s`` for the string, then the "
"integer value, then a pointer to the string value."
msgstr ""
"В данной программе мы используем запрос INSERT, а кортеж содержит целое число и "
"строку.  Это простой набор значений без каких-либо вложенных структур или "
"массивов. И передаваемые значения мы можем указать самым простым образом — "
"аналогично тому, как это сделано в стандартной C-функции ``printf()``: ``%d`` "
"для обозначения целого числа, ``%s`` для обозначения строки, затем числовое "
"значение, затем указатель на строковое значение."

#: ../doc/1.7/book/connectors/__c.rst:169 ../doc/1.7/book/connectors/__c.rst:618
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"

#: ../doc/1.7/book/connectors/__c.rst:143 ../doc/1.7/book/connectors/__c.rst:171
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the "
"requests in the box library."
msgstr ""
"**ОТПРАВКА ЗАПРОСА:** Отправка запросов на изменение данных в базе делается "
"аналогично тому, как это делается в Tarantool-библиотеке ``box``."

#: ../doc/1.7/book/connectors/__c.rst:146 ../doc/1.7/book/connectors/__c.rst:174
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:151 ../doc/1.7/book/connectors/__c.rst:179
msgid ""
"In this program, the choice is to do an INSERT request, so the program passes "
"the ``tnt_stream`` that was used for connection (``tnt``) and the ``tnt_stream`` "
"that was set up with :c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""
"В данной программе мы делаем INSERT-запрос. В этом запросе мы передаем поток "
"``tnt``, который ранее использовали для установки соединения, и поток :code:"
"`tuple`, который также ранее настроили с помощью функции :c:func:`tarantoolc:"
"tnt_object_format`."

#: ../doc/1.7/book/connectors/__c.rst:189 ../doc/1.7/book/connectors/__c.rst:638
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct tnt_stream "
"\\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"

#: ../doc/1.7/book/connectors/__c.rst:169 ../doc/1.7/book/connectors/__c.rst:197
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply containing "
"some indication whether the result was successful, and a set of tuples."
msgstr ""
"**ПОЛУЧЕНИЕ ОТВЕТА:** На большинство запросов клиент получает ответ, который "
"содержит информацию о том, был ли данный запрос успешно выполнен, а также "
"содержит набор кортежей."

#: ../doc/1.7/book/connectors/__c.rst:172 ../doc/1.7/book/connectors/__c.rst:200
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"

#: ../doc/1.7/book/connectors/__c.rst:179 ../doc/1.7/book/connectors/__c.rst:207
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""
"Данная программа проверяет, был ли запрос выполнен успешно, но никак не "
"интерпретирует оставшуюся часть ответа."

#: ../doc/1.7/book/connectors/__c.rst:214 ../doc/1.7/book/connectors/__c.rst:663
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"

#: ../doc/1.7/book/connectors/__c.rst:190 ../doc/1.7/book/connectors/__c.rst:218
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with :c:func:"
"`tarantoolc:tnt_connect()` should be closed, and the objects that were made in "
"the setup should be destroyed."
msgstr ""
"**ЗАВЕРШЕНИЕ:** По окончании сессии нам нужно закрыть соединение, созданное с "
"помощью функции :c:func:`tarantoolc:tnt_connect()`, и удалить объекты, созданные "
"на этапе настройки."

#: ../doc/1.7/book/connectors/__c.rst:194 ../doc/1.7/book/connectors/__c.rst:222
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"

#: ../doc/1.7/book/connectors/__c.rst:233 ../doc/1.7/book/connectors/__c.rst:682
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"

#: ../doc/1.7/book/connectors/__c.rst:210 ../doc/1.7/book/connectors/__c.rst:238
msgid "Example 2"
msgstr "Пример 2"

#: ../doc/1.7/book/connectors/__c.rst:212 ../doc/1.7/book/connectors/__c.rst:240
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, from "
"space ``examples`` via the high-level C API. To display the results, the program "
"uses functions in the `MsgPuck <http://rtsisyk.github.io/msgpuck/>`_ library "
"which allow decoding of `MessagePack <https://en.wikipedia.org/wiki/"
"MessagePack>`_  arrays."
msgstr ""
"Далее приводится еще один пример полноценной программы на языке C, которая "
"осуществляет выборку по индекс-ключу ``[99999]`` из пространства ``examples`` с "
"помощью высокоуровневого Tarantool API для языка C. Для вывода результатов в "
"этой программе используются функции из библиотеки `MsgPuck <http://rtsisyk."
"github.io/msgpuck/>`_. Эти функции нужны для декодирования массивов значений в "
"формате `MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_."

#: ../doc/1.7/book/connectors/__c.rst:218 ../doc/1.7/book/connectors/__c.rst:246
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* кортеж tuple = ключ для поиска "
"*/\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, &str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__c.rst:285 ../doc/1.7/book/connectors/__c.rst:313
msgid ""
"Similarly to the first example, paste the code into a file named :file:`example2."
"c`."
msgstr ""
"Аналогично первому примеру, сохраните исходный код программы в файле с именем :"
"file:`example2.c`."

#: ../doc/1.7/book/connectors/__c.rst:290 ../doc/1.7/book/connectors/__c.rst:318
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr "$ gcc -o example2 example2.c -ltarantool"

#: ../doc/1.7/book/connectors/__c.rst:294 ../doc/1.7/book/connectors/__c.rst:322
msgid "To run the program, say :samp:`./example2`."
msgstr "Для запуска программы выполните команду :samp:`./example2`."

#: ../doc/1.7/book/connectors/__c.rst:296 ../doc/1.7/book/connectors/__c.rst:324
msgid ""
"The two example programs only show a few requests and do not show all that's "
"necessary for good practice. See more in the `tarantool-c documentation at "
"GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""
"В этих двух программах мы привели пример использования лишь двух запросов. Для "
"полноценной работы с Tarantool'ом с помощью C API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-c на GitHub <http://github.com/tarantool/"
"tarantool-c>`_."

#: ../doc/1.7/book/connectors/__csharp.rst:3
#: ../doc/1.7/book/connectors/__csharp.rst:31
msgid "C#"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:5
#: ../doc/1.7/book/connectors/__csharp.rst:33
msgid ""
"The most commonly used C# driver is `progaudi.tarantool <https://github.com/"
"progaudi/progaudi.tarantool>`_, previously named ``tarantool-csharp``. It is not "
"supplied as part of the Tarantool repository; it must be installed separately. "
"The makers recommend `cross-platform installation using Nuget <https://www.nuget."
"org/packages/progaudi.tarantool>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:11
#: ../doc/1.7/book/connectors/__csharp.rst:39
msgid ""
"To be consistent with the other instructions in this chapter, here is a way to "
"install the driver directly on Ubuntu 16.04."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:14
#: ../doc/1.7/book/connectors/__csharp.rst:42
msgid ""
"Install .net core from Microsoft. Follow `.net core installation instructions "
"<https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:19
#: ../doc/1.7/book/connectors/__csharp.rst:47
msgid ""
"Mono will not work, nor will .Net from xbuild. Only .net core supported on Linux "
"and Mac."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:21
#: ../doc/1.7/book/connectors/__csharp.rst:49
msgid ""
"Read the Microsoft End User License Agreement first, because it is not an "
"ordinary open-source agreement and there will be a message during installation "
"saying \"This software may collect information about you and your use of the "
"software, and send that to Microsoft.\" Still you can `set environment variables "
"<https://docs.microsoft.com/en-us/dotnet/core/tools/telemetry#behavior>`_ to opt "
"out from telemetry."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:29
#: ../doc/1.7/book/connectors/__csharp.rst:57
msgid "Create a new console project."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:31
#: ../doc/1.7/book/connectors/__csharp.rst:59
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:38
#: ../doc/1.7/book/connectors/__csharp.rst:66
msgid "Add ``progaudi.tarantool`` reference."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:40
#: ../doc/1.7/book/connectors/__csharp.rst:68
msgid "$ dotnet add package progaudi.tarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:44
#: ../doc/1.7/book/connectors/__csharp.rst:72
msgid "Change code in ``Program.cs``."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:46
#: ../doc/1.7/book/connectors/__csharp.rst:74
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:69
#: ../doc/1.7/book/connectors/__csharp.rst:97
msgid "Build and run your application."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:71
#: ../doc/1.7/book/connectors/__csharp.rst:99
msgid ""
"Before trying to run, check that the server is listening at ``localhost:3301`` "
"and that the space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:75
#: ../doc/1.7/book/connectors/__csharp.rst:103
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:80
#: ../doc/1.7/book/connectors/__csharp.rst:108
msgid "The program will:"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:82
#: ../doc/1.7/book/connectors/__csharp.rst:110
msgid "connect using an application-specific definition of the space,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:83
#: ../doc/1.7/book/connectors/__csharp.rst:111
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:84
#: ../doc/1.7/book/connectors/__csharp.rst:112
msgid "send an INSERT request, and — if all is well — end without saying anything."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:86
#: ../doc/1.7/book/connectors/__csharp.rst:114
msgid ""
"If Tarantool is not running on localhost with listen port = 3301, or if user "
"'guest' does not have authorization to connect, or if the INSERT request fails "
"for any reason, the program will print an error message, among other things "
"(stacktrace, etc)."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:91
#: ../doc/1.7/book/connectors/__csharp.rst:119
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that’s "
"necessary for good practice. For that, please see the `progaudi.tarantool driver "
"repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__erlang.rst:3
#: ../doc/1.7/book/connectors/__erlang.rst:31
#, fuzzy
msgid "Erlang"
msgstr "Perl"

#: ../doc/1.7/book/connectors/__erlang.rst:5
#: ../doc/1.7/book/connectors/__erlang.rst:33
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__go.rst:3 ../doc/1.7/book/connectors/__go.rst:31
msgid "Go"
msgstr "Go"

#: ../doc/1.7/book/connectors/__go.rst:5 ../doc/1.7/book/connectors/__go.rst:33
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr "См. https://github.com/mialinx/go-tarantool."

#: ../doc/1.7/book/connectors/__java.rst:3 ../doc/1.7/book/connectors/__java.rst:31
msgid "Java"
msgstr "Java"

#: ../doc/1.7/book/connectors/__java.rst:5 ../doc/1.7/book/connectors/__java.rst:33
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr "См. http://github.com/tarantool/tarantool-java/."

#: ../doc/1.7/book/connectors/__nodejs.rst:3
#: ../doc/1.7/book/connectors/__nodejs.rst:31
msgid "Node.js"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:5
#: ../doc/1.7/book/connectors/__nodejs.rst:33
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver <https://"
"github.com/KlonD90/node-tarantool-driver>`_. It is not supplied as part of the "
"Tarantool repository; it must be installed separately. The most common way to "
"install it is with `npm <https://www.sitepoint.com/beginners-guide-node-package-"
"manager/>`_. For example, on Ubuntu, the installation could look like this after "
"npm has been installed:"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:13
#: ../doc/1.7/book/connectors/__nodejs.rst:41
msgid "npm install tarantool-driver --global"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:17
#: ../doc/1.7/book/connectors/__nodejs.rst:45
#, fuzzy
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the server "
"instance is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.rs` and say ``node example.rs``. The "
"program will connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — end "
"after saying \"Insert succeeded\". If Tarantool is not running on ``localhost`` "
"with listen port = 3301, the program will print “Connect failed”. If user "
"``guest`` does not have authorization to connect, the program will print \"Auth "
"failed\". If the insert request fails for any reason, for example because the "
"tuple already exists, the program will print \"Insert failed\"."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с "
"помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, "
"что ваше тестовое окружение настроено так, как :ref:`описано выше <index-"
"connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе "
"создано пространство ``examples``). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.pl` и выполните "
"команду :samp:`perl example.pl`. Программа установит соединение, используя "
"указанное в ней описание пространства, откроет сокет для соединения с Tarantool-"
"сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-"
"сервер не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”."

#: ../doc/1.7/book/connectors/__nodejs.rst:31
#: ../doc/1.7/book/connectors/__nodejs.rst:59
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); });\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); });\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:45
#: ../doc/1.7/book/connectors/__nodejs.rst:73
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__perl.rst:3 ../doc/1.7/book/connectors/__perl.rst:31
msgid "Perl"
msgstr "Perl"

#: ../doc/1.7/book/connectors/__perl.rst:5 ../doc/1.7/book/connectors/__perl.rst:33
msgid ""
"The most commonly used Perl driver is `DR::Tarantool <http://search.cpan.org/"
"~unera/DR-Tarantool/>`_. It is not supplied as part of the Tarantool repository; "
"it must be installed separately. The most common way to install it is with "
"`CPAN, the Comprehensive Perl Archive Network <https://en.wikipedia.org/wiki/"
"Cpan>`_. ``DR::Tarantool`` requires other modules which should be installed "
"first. For example, on Ubuntu, the installation could look like this:"
msgstr ""
"Наиболее популярным Tarantool-коннектором для языка Perl является `DR::Tarantool "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_. Он устанавливается отдельно от "
"Tarantool'а, например с помощью :program:`cpan` (см. `CPAN, the Comprehensive "
"Perl Archive Network <https://en.wikipedia.org/wiki/Cpan>`_), и требует "
"предварительной установки еще несколько зависимых модулей. Вот пример установки "
"этого коннектора под Ubuntu:"

#: ../doc/1.7/book/connectors/__perl.rst:13
#: ../doc/1.7/book/connectors/__perl.rst:41
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"

#: ../doc/1.7/book/connectors/__perl.rst:24
#: ../doc/1.7/book/connectors/__perl.rst:52
#, fuzzy
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the server "
"instance is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.pl` and say :samp:`perl example.pl`. The "
"program will connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — end "
"without displaying any messages. If Tarantool is not running on ``localhost`` "
"with listen port = 3301, the program will print “Connection refused”."
msgstr ""
"Далее приводится пример полноценной программы на языке Perl, которая "
"осуществляет вставку кортежа ``[99999,'BB']`` в пространство ``space[999]`` с "
"помощью Tarantool API для языка Perl. Перед запуском данной программы проверьте, "
"что ваше тестовое окружение настроено так, как :ref:`описано выше <index-"
"connector_setting>` (у Tarantool-сервера задан порт для прослушивания и в базе "
"создано пространство ``examples``). Чтобы запустить тестовую программу, "
"сохраните ее исходный код в файл с именем :file:`example.pl` и выполните "
"команду :samp:`perl example.pl`. Программа установит соединение, используя "
"указанное в ней описание пространства, откроет сокет для соединения с Tarantool-"
"сервером по адресу ``localhost:3301``, пошлет INSERT-запрос, а затем — если всё "
"хорошо — закончит работу без каких-либо сообщений. Если окажется, что Tarantool-"
"сервер не запущен на прослушивание по указанному адресу, то программа выдаст "
"сообщение об ошибке “Connection refused”."

#: ../doc/1.7/book/connectors/__perl.rst:36
#: ../doc/1.7/book/connectors/__perl.rst:64
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also say "
"'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999] ...\n"
"      name => 'examples',                      #   space[999] name = 'examples'\n"
"      default_type => 'STR',                   #   space[999] field type is "
"'STR' if undefined\n"
"      fields => [ {                            #   definition of space[999]."
"fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of space[999] "
"indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # поиск Tarantool-сервера по "
"адресу localhost\n"
"  port    => 3301,                             # на порту 3301\n"
"  user    => 'guest',                          # имя пользователя; здесь же "
"можно добавить 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # определение пространства "
"space[999] ...\n"
"      name => 'examples',                      # имя пространства space[999] = "
"'examples'\n"
"      default_type => 'STR',                   # если тип поля в space[999] не "
"задан, то = 'STR'\n"
"      fields => [ {                            # определение полей в "
"пространстве space[999] ...\n"
"          name => 'field1', type => 'NUM' } ], # имя поля space[999]."
"field[1]='field1', тип ='NUM'\n"
"      indexes => {                             # определение индексов "
"пространства space[999] ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"

#: ../doc/1.7/book/connectors/__perl.rst:60
#: ../doc/1.7/book/connectors/__perl.rst:88
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of 'string' "
"and 'unsigned', due to a temporary Perl limitation."
msgstr ""
"Из-за существующих ограничений в языке Perl, вместо полей типа 'string' и "
"'unsigned' в тестовой программе указаны поля типа 'STR' и 'NUM'."

#: ../doc/1.7/book/connectors/__perl.rst:63
#: ../doc/1.7/book/connectors/__perl.rst:91
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `DR::Tarantool CPAN repository "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Perl API, пожалуйста, обратитесь к "
"документации из `CPAN-репозитория DR::Tarantool <http://search.cpan.org/~unera/"
"DR-Tarantool/>`_."

#: ../doc/1.7/book/connectors/__php.rst:3 ../doc/1.7/book/connectors/__php.rst:31
msgid "PHP"
msgstr "PHP"

#: ../doc/1.7/book/connectors/__php.rst:5 ../doc/1.7/book/connectors/__php.rst:33
msgid ""
"The most commonly used PHP driver is `tarantool-php <https://github.com/"
"tarantool/tarantool-php>`_. It is not supplied as part of the Tarantool "
"repository; it must be installed separately, for example with :program:`git`. "
"See `installation instructions <https://github.com/tarantool/tarantool-php/blob/"
"master/#installing-and-building>`_. in the driver's :file:`README` file."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:12 ../doc/1.7/book/connectors/__php.rst:40
#, fuzzy
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space named "
"``examples`` via the PHP API. Before trying to run, check that the server "
"instance is listening at ``localhost:3301`` and that the space ``examples`` "
"exists, as :ref:`described earlier <index-connector_setting>`. To run, paste the "
"code into a file named :file:`example.php` and say ``php -d extension=~/"
"tarantool-php/modules/tarantool.so example.php``. The program will open a socket "
"connection with the Tarantool instance at ``localhost:3301``, then send an "
"INSERT request, then — if all is well — print \"Insert succeeded\". If the tuple "
"already exists, the program will print “Duplicate key exists in unique index "
"'primary' in space 'examples'”."
msgstr ""
"Далее приводится пример полноценной программы на языке PHP, которая осуществляет "
"вставку кортежа ``[99999,'BB']`` в пространство ``examples`` с помощью Tarantool "
"API для языка PHP. Перед запуском данной программы проверьте, что ваше тестовое "
"окружение настроено так, как :ref:`описано выше <index-connector_setting>` (у "
"Tarantool-сервера задан порт для прослушивания и в базе создано пространство "
"``examples``). Чтобы запустить тестовую программу, сохраните ее исходный код в "
"файл с именем :file:`example.php` и выполните команду :samp:`php -d extension=~/"
"tarantool-php/modules/tarantool.so example.php`. Программа откроет сокет для "
"соединения с Tarantool-сервером по адресу ``localhost:3301``, пошлет INSERT-"
"запрос, а затем — если всё хорошо — выдаст сообщение \"Insert succeeded\". Если "
"окажется, что такой кортеж уже существует, то программа выдаст сообщение об "
"ошибке “Duplicate key exists in unique index 'primary' in space 'examples'”."

#: ../doc/1.7/book/connectors/__php.rst:23 ../doc/1.7/book/connectors/__php.rst:51
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"

#: ../doc/1.7/book/connectors/__php.rst:35 ../doc/1.7/book/connectors/__php.rst:63
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-php "
"<https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью PHP API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-php на GitHub <https://github.com/tarantool/"
"tarantool-php>`_."

#: ../doc/1.7/book/connectors/__php.rst:40 ../doc/1.7/book/connectors/__php.rst:68
msgid ""
"Besides, you can use an alternative PHP driver from another GitHub project: it "
"includes a *client* (see `tarantool-php/client <https://github.com/tarantool-php/"
"client>`_) and a *mapper* for that client (see `tarantool-php/mapper <https://"
"github.com/tarantool-php/mapper>`_)."
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:3
#: ../doc/1.7/book/connectors/__python.rst:31
msgid "Python"
msgstr "Python"

#: ../doc/1.7/book/connectors/__python.rst:5
#: ../doc/1.7/book/connectors/__python.rst:33
msgid ""
"Here is a complete Python program that inserts ``[99999,'Value','Value']`` into "
"space ``examples`` via the high-level Python API."
msgstr ""
"Далее приводится пример полноценной программы на языке Python, которая "
"осуществляет вставку кортежа ``[99999,'Value','Value']`` в пространство "
"``examples`` с помощью высокоуровневого Tarantool API для языка Python. "

#: ../doc/1.7/book/connectors/__python.rst:8
#: ../doc/1.7/book/connectors/__python.rst:36
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"

#: ../doc/1.7/book/connectors/__python.rst:17
#: ../doc/1.7/book/connectors/__python.rst:45
#, fuzzy
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and install the "
"``tarantool-python`` connector with either :samp:`pip install tarantool\\>0.4` "
"to install in :file:`/usr` (requires **root** privilege) or :samp:`pip install "
"tarantool\\>0.4 --user` to install in :file:`~` i.e. user's default directory. "
"Before trying to run, check that the server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as :ref:`described "
"earlier <index-connector_setting>`. To run the program, say :samp:`python "
"example.py`. The program will connect to the Tarantool server, will send the "
"request, and will not throw any exception if all went well. If the tuple already "
"exists, the program will throw ``tarantool.error.DatabaseError: (3, \"Duplicate "
"key exists in unique index 'primary' in space 'examples'\")``."
msgstr ""
"Перед запуском данной программы проверьте, что ваше тестовое окружение настроено "
"так, как :ref:`описано выше <index-connector_setting>` (у Tarantool-сервера "
"задан порт для прослушивания и в базе создано пространство ``examples``), и "
"установите коннектор ``tarantool-python``. Для установки коннектора "
"воспользуйтесь либо командой :samp:`pip install tarantool\\>0.4` (для установки "
"в директорию :file:`/usr`; вам потребуются права уровня  **root**), либо "
"командой :samp:`pip install tarantool\\>0.4 --user` (для установки в директорию :"
"file:`~`, т.е. в используемую по умолчанию директорию текущего пользователя). "
"Чтобы запустить тестовую программу, сохраните ее исходный код в файл с именем :"
"file:`example.py` и выполните команду :samp:`python example.py`. Программа "
"установит соединение с Tarantool-сервером, пошлет запрос и не сгенерирует "
"никакого исключения, если всё прошло хорошо. Если окажется, что такой кортеж уже "
"существует, то программа сгенерирует исключение :samp:`tarantool.error."
"DatabaseError: (3, \"Duplicate key exists in unique index 'primary' in space "
"'examples'\")`."

#: ../doc/1.7/book/connectors/__python.rst:29
#: ../doc/1.7/book/connectors/__python.rst:57
#, fuzzy
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python <http://"
"github.com/tarantool/tarantool-python>`_ project at GitHub. For an example of "
"using Python API with `queue managers for Tarantool <https://github.com/"
"tarantool/queue>`_, see `queue-python <https://github.com/tarantool/queue-"
"python>`_ project at GitHub."
msgstr ""
"В этой программе мы привели пример использования лишь одного запроса. Для "
"полноценной работы с Tarantool'ом с помощью Python API, пожалуйста, обратитесь к "
"документации из `проекта tarantool-python на GitHub <http://github.com/tarantool/"
"tarantool-python>`_. А на странице `проекта queue-python на GitHub <https://"
"github.com/tarantool/queue-python>`_ вы сможете найти примеры использования "
"Python API для работы с `очередями сообщений в Tarantool'е <https://github.com/"
"tarantool/queue>`_."

#: ../doc/1.7/book/connectors/__r.rst:3 ../doc/1.7/book/connectors/__r.rst:31
msgid "R"
msgstr "R"

#: ../doc/1.7/book/connectors/__r.rst:5 ../doc/1.7/book/connectors/__r.rst:33
msgid "See https://github.com/thekvs/tarantoolr."
msgstr "См. https://github.com/thekvs/tarantoolr."

#: ../doc/1.7/book/connectors/__results.rst:4
#: ../doc/1.7/book/connectors/__results.rst:32
msgid "Interpreting function return values"
msgstr "Интерпретация возвращаемых значений"

#: ../doc/1.7/book/connectors/__results.rst:6
#: ../doc/1.7/book/connectors/__results.rst:34
msgid ""
"For all connectors, calling a function via Tarantool causes a return in the "
"MsgPack format. If the function is called using the connector's API, some "
"conversions may occur. All scalar values are returned as tuples (with a MsgPack "
"type-identifier followed by a value); all non-scalar values are returned as a "
"group of tuples (with a MsgPack array-identifier followed by the scalar values). "
"If the function is called via the binary protocol command layer -- \"eval\" -- "
"rather than via the connector's API, no conversions occur."
msgstr ""
"При работе с любым Tarantool-коннектором функции, вызванные с помощью "
"Tarantool'а, возвращают значения в формате MsgPack. Если функция была вызвана "
"через API коннектора, то формат возвращаемых значений будет следующим: скалярные "
"значения возвращаются в виде кортежей (сначала идет идентификатор типа из "
"формата MsgPack, а затем идет значение); все прочие (не скалярные) значения "
"возвращаются в виде групп кортежей (сначала идет идентификатор массива в формате "
"MsgPack, а затем идут скалярные значения). Но если функция была вызвана в рамках "
"бинарного протокола (с помощью команды ``eval``), а не через API коннектора, то "
"подобных изменений формата возвращаемых значений не происходит."

#: ../doc/1.7/book/connectors/__results.rst:14
#: ../doc/1.7/book/connectors/__results.rst:42
msgid ""
"In the following example, a Lua function will be created. Since it will be "
"accessed externally by a 'guest' user, a ``grant`` of an execute privilege will "
"be necessary. The function returns an empty array, a scalar string, two "
"booleans, and a short integer. The values are the ones described in the table :"
"ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Далее приводится пример создания Lua-функции. Поскольку эту функцию будет "
"вызывать внешний пользователь 'guest', то нужно настроить привилегии на "
"исполнение с помощью ``grant``. Эта функция возвращает пустой массив, строку-"
"скаляр, два логических значения и короткое целое число. Значение будут теми же, "
"что описаны в разделе про MsgPack в таблице :ref:`Стандартные типы в MsgPack-"
"кодировке <msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/connectors/__results.rst:20
#: ../doc/1.7/book/connectors/__results.rst:48
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."

#: ../doc/1.7/book/connectors/__results.rst:36
#: ../doc/1.7/book/connectors/__results.rst:64
msgid ""
"Here is a C program which calls the function. Although C is being used for the "
"example, the result would be precisely the same if the calling program was "
"written in Perl, PHP, Python, Go, or Java."
msgstr ""
"Далее идет пример программы на C, из который мы вызываем эту Lua-функцию. Хотя в "
"примере использован код на C, результат будет одинаковым, на каком бы языке ни "
"была написана вызываемая программа: Perl, PHP, Python, Go или Java."

#: ../doc/1.7/book/connectors/__results.rst:40
#: ../doc/1.7/book/connectors/__results.rst:68
#, fuzzy, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);            /* НАСТРОЙКА */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                        /* СОЕДИНЕНИЕ */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);       /* СОЗДАНИЕ ЗАПРОСА */\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL); /* ВЫЗОВ function f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   tnt_request_set_tuple(req1, arg);\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                    /* ОТПРАВКА ЗАПРОСА */\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);   /* ПОЛУЧЕНИЕ ОТВЕТА */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data;/* ВЫВОД ОТВЕТА */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                    /* ЗАВЕРШЕНИЕ */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"

#: ../doc/1.7/book/connectors/__results.rst:78
#: ../doc/1.7/book/connectors/__results.rst:106
msgid "When this program is executed, it will print:"
msgstr "По завершении программа выведет на экран следующие значения:"

#: ../doc/1.7/book/connectors/__results.rst:80
#: ../doc/1.7/book/connectors/__results.rst:108
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"

#: ../doc/1.7/book/connectors/__results.rst:84
#: ../doc/1.7/book/connectors/__results.rst:112
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for \"32-bit "
"array header with value 5\" (see `MsgPack specification <http://github.com/"
"msgpack/msgpack/blob/master/spec.md>`_). The rest are as described in the table :"
"ref:`Common Types and MsgPack Encodings <msgpack-"
"common_types_and_msgpack_encodings>`."
msgstr ""
"Первые пять байт — ``dd 0 0 0 5`` — это фрагмент данных в формате MsgPack, "
"означающий \"32-битный заголовок массива со значением 5\" (см. `спецификацию на "
"формат MsgPack <http://github.com/msgpack/msgpack/blob/master/spec.md>`_). "
"Остальные значения описаны в таблице :ref:`Стандартные типы в MsgPack-кодировке "
"<msgpack-common_types_and_msgpack_encodings>`."

#: ../doc/1.7/book/connectors/index.rst:33
msgid "Connectors"
msgstr "Коннекторы"

#: ../doc/1.7/book/connectors/index.rst:35
msgid "This chapter documents APIs for various programming languages."
msgstr "В этой главе описаны API для различных языков программирования."

#: ../doc/1.7/book/connectors/index.rst:39
msgid "Protocol"
msgstr "Протокол"

#: ../doc/1.7/book/connectors/index.rst:41
#, fuzzy
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O and "
"easy integration with proxies. Each client request starts with a variable-length "
"binary header, containing request id, request type, instance id, log sequence "
"number, and so on."
msgstr ""
"Бинарный протокол для передачи данных в Tarantool'е был разработан с учетом "
"потребностей асинхронного ввода-вывода. Основная его задача — облегчить "
"интеграцию Tarantool'а с клиентскими приложениями. Клиентский запрос в Tarantool-"
"протоколе начинается с бинарного заголовка переменной длины. В заголовке "
"указывается идентификатор и тип запроса, идентификатор сервера, номер записи в "
"журнале и т.д."

#: ../doc/1.7/book/connectors/index.rst:46
msgid ""
"The mandatory length, present in request header simplifies client or proxy I/O. "
"A response to a request is sent to the client as soon as it is ready. It always "
"carries in its header the same type and id as in the request. The id makes it "
"possible to match a request to a response, even if the latter arrived out of "
"order."
msgstr ""
"Также в заголовке обязательно указывается длина запроса, что облегчает обработку "
"данных. Ответ на запрос посылается по мере готовности. В заголовке ответа "
"указывается тот же идентификатор и тип запроса, что и в изначальном запросе. По "
"идентификатору можно легко соотнести запрос с ответом, даже если ответ был "
"получен не в порядке отсылки запросов."

#: ../doc/1.7/book/connectors/index.rst:52
msgid ""
"Unless implementing a client driver, you needn't concern yourself with the "
"complications of the binary protocol. Language-specific drivers provide a "
"friendly way to store domain language data structures in Tarantool. A complete "
"description of the binary protocol is maintained in annotated Backus-Naur form "
"in the source tree: please see the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>`."
msgstr ""
"Вдаваться в тонкости реализации Tarantool-протокола нужно только при разработке "
"нового коннектора для Tarantool'а — см. :ref:`полное описание бинарного "
"протокола в Tarantool'е <box_protocol-iproto_protocol>` в виде аннотированных "
"BNF-диаграмм (Backus-Naur Form). В остальных случаях достаточно взять уже "
"существующий коннектор для нужного вам языка программирования. Такие коннекторы "
"позволяют легко хранить структуры данных из разных языков в формате Tarantool'а."

#: ../doc/1.7/book/connectors/index.rst:61
msgid "Packet example"
msgstr "Пример пакета данных"

#: ../doc/1.7/book/connectors/index.rst:63
#, fuzzy
msgid ""
"The Tarantool API exists so that a client program can send a request packet to a "
"server instance, and receive a response. Here is an example of a what the client "
"would send for ``box.space[513]:insert{'A', 'BB'}``. The BNF description of the "
"components is on the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>`."
msgstr ""
"С помощью Tarantool API клиентские программы могут посылать в адрес Tarantool-"
"сервера пакеты с запросами и получать на них ответы. Вот пример исходящего "
"пакета, который будет сформирован для запроса :code:`box.space[513]:insert{'A', "
"'BB'}`. Описания компонентов запроса (в виде BNF-диаграмм) вы найдете на "
"странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`."

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Component"
msgstr "Компонент"

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #0"
msgstr "Байт #0"

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #1"
msgstr "Байт #1"

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #2"
msgstr "Байт #2"

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #3"
msgstr "Байт #3"

#: ../doc/1.7/book/connectors/index.rst:81
msgid "code for insert"
msgstr "код для вставки"

#: ../doc/1.7/book/connectors/index.rst:81 ../doc/1.7/book/connectors/index.rst:85
msgid "02"
msgstr "02"

#: ../doc/1.7/book/connectors/index.rst:83
msgid "rest of header"
msgstr "остаток заголовка"

#: ../doc/1.7/book/connectors/index.rst:83
msgid "..."
msgstr "..."

#: ../doc/1.7/book/connectors/index.rst:85
msgid "2-digit number: space id"
msgstr "число из 2 цифр: ID пространства"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "cd"
msgstr "cd"

#: ../doc/1.7/book/connectors/index.rst:85
msgid "01"
msgstr "01"

#: ../doc/1.7/book/connectors/index.rst:87
msgid "code for tuple"
msgstr "код для кортежа"

#: ../doc/1.7/book/connectors/index.rst:87
msgid "21"
msgstr "21"

#: ../doc/1.7/book/connectors/index.rst:89
msgid "1-digit number: field count = 2"
msgstr "число из 1 цифры: количество полей = 2"

#: ../doc/1.7/book/connectors/index.rst:89
msgid "92"
msgstr "92"

#: ../doc/1.7/book/connectors/index.rst:91
msgid "1-character string: field[1]"
msgstr "строка из 1 символа: поле[1]"

#: ../doc/1.7/book/connectors/index.rst:91
msgid "a1"
msgstr "a1"

#: ../doc/1.7/book/connectors/index.rst:91
msgid "41"
msgstr "41"

#: ../doc/1.7/book/connectors/index.rst:93
msgid "2-character string: field[2]"
msgstr "строка из 2 символов: поле[2]"

#: ../doc/1.7/book/connectors/index.rst:93
msgid "a2"
msgstr "a2"

#: ../doc/1.7/book/connectors/index.rst:93
msgid "42"
msgstr "42"

#: ../doc/1.7/book/connectors/index.rst:96
#, fuzzy
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret the "
"response (the page about :ref:`Tarantool's binary protocol <box_protocol-"
"iproto_protocol>` has a description of the packet format for responses as well "
"as requests). But it would be easier, and less error-prone, if you could invoke "
"a routine that formats the packet according to typed parameters. Something like "
"``response = tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is "
"why APIs exist for drivers for Perl, Python, PHP, and so on."
msgstr ""
"Теперь получившийся пакет можно послать Tarantool-серверу и затем "
"проинтерпретировать полученный ответ (описания компонентов ответа вы найдете на "
"той же странице о :ref:`бинарном протоколе в Tarantool'е <box_protocol-"
"iproto_protocol>`). Но более простым и верным способом будет вызвать процедуру, "
"которая за вас сформирует готовый пакет с заданными параметрами. Что-то вроде :"
"samp:`response=tarantool_routine(\"insert\",513,\"A\",\"B\");`. Для этого в "
"Tarantool'е существуют API для Perl, Python, PHP и других программных языков."

#: ../doc/1.7/book/connectors/index.rst:109
msgid "Setting up the server for connector examples"
msgstr "Настройка окружения для примеров работы с коннекторами"

#: ../doc/1.7/book/connectors/index.rst:111
#, fuzzy
msgid ""
"This chapter has examples that show how to connect to a Tarantool instance via "
"the Perl, PHP, Python, node.js, and C connectors. The examples contain hard code "
"that will work if and only if the following conditions are met:"
msgstr ""
"В этой главе приводятся примеры того, как можно установить соединение с "
"Tarantool-сервером с помощью коннекторов для языков Perl, PHP, Python и C. "
"Обратите внимание, что в примерах исходного кода указаны фиксированные значения "
"для элементов тестового окружения, поэтому для корректной работы всех примеров "
"нужно соблюсти следующие условия:"

#: ../doc/1.7/book/connectors/index.rst:115
#, fuzzy
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) and is "
"listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""
"Tarantool-сервер запущен на локальной машине (``localhost = 127.0.0.1``), а "
"прослушивание для него настроено на порту 3301 (:samp:`box.cfg.listen = '3301'`),"

#: ../doc/1.7/book/connectors/index.rst:118
#, fuzzy
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has a "
"primary-key index for a numeric field (``box.space[999].index[0].parts[1].type = "
"\"unsigned\"``),"
msgstr ""
"в базе есть пространство ``examples`` с идентификатором 999 (:samp:`box.space."
"examples.id = 999`) и у него есть первичный индекс, построенный по ключу "
"числового типа (:samp:`box.space[999].index[0].parts[1].type = \"unsigned\"`),"

#: ../doc/1.7/book/connectors/index.rst:122
msgid "user 'guest' has privileges for reading and writing."
msgstr "для пользователя 'guest' настроены привилегии на чтение и запись."

#: ../doc/1.7/book/connectors/index.rst:124
#, fuzzy
msgid ""
"It is easy to meet all the conditions by starting the instance and executing "
"this script:"
msgstr ""
"Такое тестовое окружение легко настроить, запустив Tarantool-сервер локально и "
"выполнив следующие запросы:"

#: ../doc/1.7/book/connectors/index.rst:127
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"

#: ../doc/1.7/book/faq.rst:33
msgid "FAQ"
msgstr "Вопросы и ответы"

#: ../doc/1.7/book/faq.rst
msgid "Q"
msgstr ""

#: ../doc/1.7/book/faq.rst:37
#, fuzzy
msgid "Why Tarantool?"
msgstr "Утилита tarantoolctl"

#: ../doc/1.7/book/faq.rst
#, fuzzy
msgid "A"
msgstr "a2"

#: ../doc/1.7/book/faq.rst:38
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience and "
"trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/1.7/book/faq.rst:42
msgid "Why Lua?"
msgstr ""

#: ../doc/1.7/book/faq.rst:43
#, fuzzy
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also happens "
"to be very easy to embed. Lua coroutines relate very closely to Tarantool "
"fibers, and Lua architecture works well with Tarantool internals. Lua acts well "
"as a stored program language for Tarantool, although connecting with other "
"languages is also easy."
msgstr ""
"Почему Lua? |br| Lua — это легкий, быстрый и расширяемый язык, позволяющий "
"использовать различные парадигмы программирования. Lua также легко встраивается "
"в различные приложения. Ко-рутины (coroutines) в Lua близко соотносятся с "
"файберами (fibers) в Tarantool'е, а вся Lua-архитектура гладко ложится на его "
"внутреннюю реализацию. Lua — это первый язык, на котором можно писать хранимые "
"процедуры для Tarantool'а. В будущем список поддерживаемых языков планируется "
"расширить."

#: ../doc/1.7/book/faq.rst:49
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET "
"indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable in-"
"memory data server which handles non-trivial application-specific logic. The "
"advantage over traditional SQL servers is in performance: low-overhead, lock-"
"free architecture means Tarantool can serve an order of magnitude more requests "
"per second, on comparable hardware. The advantage over NoSQL alternatives is in "
"flexibility: Lua allows flexible processing of data stored in a compact, "
"denormalized format."
msgstr ""

#: ../doc/1.7/book/faq.rst:63
msgid "What are your development plans?"
msgstr ""

#: ../doc/1.7/book/faq.rst:64
msgid ""
"We continuously improve server performance. On the feature front, automatic "
"sharding and synchronous replication, and a subset of SQL are the major goals "
"for 2016-2018. We have an open roadmap to which we encourage anyone to add "
"feature requests."
msgstr ""

#: ../doc/1.7/book/faq.rst:69
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:70
#, fuzzy
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit logs on "
"`github.com/tarantool <http://github.com/tarantool/>`_. The development is fully "
"open. Most of the connectors' authors, and the maintainers for different "
"distributions, come from the wider community."
msgstr ""
"Кто разрабатывает Tarantool? |br| Во-первых, этим занимается команда разработки "
"в Mail.Ru — см. историю коммитов на `github.com/tarantool <http://github.com/"
"tarantool/>`_. Вся разработка ведется открытым образом. Кроме того, активную "
"роль играют члены сообщества разработчиков Tarantool'а. Их силами было создано "
"большинство коннекторов и ведутся доработки под разные дистрибутивы."

#: ../doc/1.7/book/faq.rst:75
msgid "How serious is Mail.Ru about Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:76
msgid ""
"Tarantool is an open source project, distributed under a BSD license, so it does "
"not depend on any one sponsor. However, it is an integral part of the Mail.Ru "
"backbone, so it gets a lot of support from Mail.Ru."
msgstr ""

#: ../doc/1.7/book/faq.rst:80
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/1.7/book/faq.rst:81
#, fuzzy
msgid ""
"The principal storage engine is designed for RAM plus persistent storage. It is "
"immune to data loss because there is a write-ahead log. Its memory-allocation "
"and compression techniques ensure there is no waste. And if Tarantool runs out "
"of memory, then it will stop accepting updates until more memory is available, "
"but will continue to handle read and delete requests without difficulty. "
"However, for databases which are much larger than the available RAM space, "
"Tarantool has a second storage engine which is only limited by the available "
"disk space."
msgstr ""
"Возникают ли проблемы из-за того, что Tarantool является in-memory решением? |"
"br| Основной движок баз данных в Tarantool'е работает с оперативной памятью, но "
"при этом он гарантирует сохранность данных благодаря механизму WAL (write ahead "
"log), т.е. журналу упреждающей записи. Также в Tarantool'е используются "
"технологии сжатия и распределения данных, которые позволяют использовать все "
"виды памяти наиболее эффективно. Если Tarantool сталкивается с нехваткой "
"оперативной памяти, то он приостанавливает прием запросов на изменение данных до "
"тех пор, пока не появится свободная память, но при этом с успехом продолжает "
"обработку запросов на чтение и удаление данных. А для больших баз, где объем "
"данных значительно превосходит имеющийся объем оперативной памяти, у Tarantool'а "
"есть второй движок, чьи возможности ограничены лишь размером жесткого диска."

#: ../doc/1.7/book/getting_started/index.rst:33
msgid "Getting started"
msgstr "Начало работы"

#: ../doc/1.7/book/getting_started/index.rst:35
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, and how "
"to create a simple database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:33
#, fuzzy
msgid "Using a binary package"
msgstr "Скачивание и установка бинарного пакета"

#: ../doc/1.7/book/getting_started/using_binary.rst:35
msgid ""
"For production purposes, we recommend `official binary packages <http://"
"tarantool.org/download.html>`_. You can choose from three Tarantool versions: "
"1.6 (stable), 1.7 (release candidate) or 1.8 (alpha). An automatic build system "
"creates, tests and publishes packages for every push into a corresponding branch "
"(``1.6``, ``1.7`` or ``1.8``) at `Tarantool's GitHub repository <https://github."
"com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:43
#, fuzzy
msgid ""
"To download and install the package that’s appropriate for your OS, start a "
"shell (terminal) and enter the command-line instructions provided for your OS at "
"Tarantool's `download page <http://tarantool.org/download.html>`_."
msgstr ""
"Чтобы скачать и установить бинарный пакет для вашей операционной системы, "
"откройте терминал с командной строкой и введите инструкции, которые даны для "
"вашей операционной системы на странице http://tarantool.org/download.html."

#: ../doc/1.7/book/getting_started/using_binary.rst:49
#, fuzzy
msgid "Starting Tarantool"
msgstr "Утилита tarantoolctl"

#: ../doc/1.7/book/getting_started/using_binary.rst:51
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:53
#, fuzzy
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""
"$ # Если вы скачали бинарный пакет с помощью apt-get или yum, введите:\n"
"$ /usr/bin/tarantool\n"
"$ # Если вы скачали бинарный пакет в формате TAR\n"
"$ # и разархивировали его в директорию ~/tarantool, введите:\n"
"$ ~/tarantool/bin/tarantool\n"
"$ # Если вы собрали Tarantool из исходных файлов, введите:\n"
"$ ~/tarantool/src/tarantool"

#: ../doc/1.7/book/getting_started/using_binary.rst:60
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:62
#, fuzzy
msgid "tarantool>"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_binary.rst:66
#: ../doc/1.7/book/getting_started/using_docker.rst:112
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:70
#: ../doc/1.7/book/getting_started/using_docker.rst:116
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, because the "
"interactive mode is convenient for learning."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:76
#: ../doc/1.7/book/getting_started/using_docker.rst:122
msgid "Creating a database"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:78
msgid "Here is how to create a simple test database after installing."
msgstr ""
"Далее рассказывается, как создать простую тестовую базу данных после установки "
"Tarantool'а."

#: ../doc/1.7/book/getting_started/using_binary.rst:80
#, fuzzy
msgid ""
"Create a new directory (it’s just for tests, so you can delete it when the tests "
"are over):"
msgstr ""
"Создайте новую директорию. Она понадобится только для тестовых целей, и ее можно "
"будет удалить по окончании экспериментов."

#: ../doc/1.7/book/getting_started/using_binary.rst:83
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"

#: ../doc/1.7/book/getting_started/using_binary.rst:88
msgid ""
"To start Tarantool's database module and make the instance accept TCP requests "
"on port 3301, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:91
msgid "tarantool> box.cfg{listen = 3301}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/getting_started/using_binary.rst:95
#: ../doc/1.7/book/getting_started/using_docker.rst:126
#, fuzzy
msgid ""
"First, create the first :ref:`space <index-box_space>` (named 'tester') and the "
"first :ref:`index <index-box_index>` (named 'primary'):"
msgstr "Создайте первое пространство и первый :ref:`индекс <box_index>`:"

#: ../doc/1.7/book/getting_started/using_binary.rst:98
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.7/book/getting_started/using_binary.rst:106
#: ../doc/1.7/book/getting_started/using_docker.rst:137
#, fuzzy
msgid ""
"Next, insert three :ref:`tuples <index-box_tuple>` (our name for \"records\") "
"into the space:"
msgstr ""
"Выполните вставку трех \"кортежей\" (tuple) в первое \"пространство\" (space) из "
"вашей базы данных:"

#: ../doc/1.7/book/getting_started/using_binary.rst:109
#, fuzzy
msgid ""
"tarantool> t = s:insert({1, 'Roxette'})\n"
"tarantool> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.7/book/getting_started/using_binary.rst:116
#: ../doc/1.7/book/getting_started/using_docker.rst:146
#, fuzzy
msgid ""
"To select a tuple from the first space of the database, using the first defined "
"key, say:"
msgstr ""
"Произведите выборку кортежа из первого пространства в базе по первому указанному "
"ключу:"

#: ../doc/1.7/book/getting_started/using_binary.rst:119
msgid "tarantool> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_binary.rst:123
#: ../doc/1.7/book/getting_started/using_docker.rst:153
#, fuzzy
msgid "The terminal screen now looks like this:"
msgstr "Теперь вывод на экране выглядит следующим образом:"

#: ../doc/1.7/book/getting_started/using_binary.rst:125
#, fuzzy
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.7/book/getting_started/using_binary.rst:151
msgid "Connecting remotely"
msgstr "Установка удаленного соединения"

#: ../doc/1.7/book/getting_started/using_binary.rst:153
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the ``listen`` "
"value can be any form of a :ref:`URI <index-uri>` (uniform resource identifier). "
"In this case, it’s just a local port: port 3301. You can send requests to the "
"listen URI via:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:158
#, fuzzy
msgid "``telnet``,"
msgstr "telnet,"

#: ../doc/1.7/book/getting_started/using_binary.rst:159
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:160
#, fuzzy
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""
"другого экземпляра Tarantool'а с помощью :ref:`console module <console-module>`, "
"либо"

#: ../doc/1.7/book/getting_started/using_binary.rst:161
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:163
#, fuzzy
msgid "Let’s try (4)."
msgstr "Давайте попробуем вариант с ``tarantoolctl connect``."

#: ../doc/1.7/book/getting_started/using_binary.rst:165
#, fuzzy
msgid ""
"Switch to another terminal. On Linux, for example, this means starting another "
"instance of a Bash shell. You can switch to any working directory in the new "
"terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""
"Переключитесь на другой терминал. Например, в Linux-системе для этого нужно "
"запустить новый экземпляр Bash. При этом вам не потребуется вызывать cd, чтобы "
"переключиться на директорию :code:`~/tarantool_sandbox`."

#: ../doc/1.7/book/getting_started/using_binary.rst:169
#, fuzzy
msgid "Start the ``tarantoolctl`` utility:"
msgstr "Запустите утилиту ``tarantoolctl``:"

#: ../doc/1.7/book/getting_started/using_binary.rst:171
#, fuzzy
msgid "$ tarantoolctl connect '3301'"
msgstr ":extsamp:`$ {**{tarantoolctl connect '3301'}**}`"

#: ../doc/1.7/book/getting_started/using_binary.rst:175
#, fuzzy
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool instance "
"that’s listening on ``localhost:3301``\"."
msgstr ""
"Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
"<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
"который слушает на ``localhost:3301``.\""

#: ../doc/1.7/book/getting_started/using_binary.rst:178
msgid "Try this request:"
msgstr "Введите следующий запрос:"

#: ../doc/1.7/book/getting_started/using_binary.rst:180
#, fuzzy
msgid "tarantool> box.space.tester:select{2}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/getting_started/using_binary.rst:184
#, fuzzy
msgid ""
"This means \"send a request to that Tarantool instance, and display the result"
"\". The result in this case is one of the tuples that was inserted earlier. Your "
"terminal screen should now look like this:"
msgstr ""
"Это означает \"послать запрос тому Tarantool-серверу и вывести результат на "
"экран.\" Результатом в данном случае будет один из кортежей, что вы вставляли "
"ранее. На терминале теперь должно отображаться примерно следующее:"

#: ../doc/1.7/book/getting_started/using_binary.rst:188
#, fuzzy
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Music']\n"
"...\n"
"\n"
"localhost:3301>"

#: ../doc/1.7/book/getting_started/using_binary.rst:199
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:202
msgid "When the testing is over:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:204
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:205
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:206
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() <http://"
"www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:208
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:209
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:33
msgid "Using a Docker image"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:35
msgid ""
"For trial and test purposes, we recommend using `official Tarantool images for "
"Docker <https://github.com/tarantool/docker>`_. An official image contains a "
"particular Tarantool version (1.6 or 1.7) and all popular external modules for "
"Tarantool. Everything is already installed and configured in Linux. These images "
"are the easiest way to install and use Tarantool."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:44
msgid ""
"If you're new to Docker, we recommend going over `this tutorial <https://docs."
"docker.com/engine/getstarted/step_one/>`_ before proceeding with this chapter."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:52
msgid "Launching a container"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:54
msgid ""
"If you don't have Docker installed, please follow the official `installation "
"guide <https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-docker>`_ "
"for your OS."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:58
msgid ""
"To start a fully functional Tarantool instance, run a container with minimal "
"options:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:61
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1.7"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:69
msgid ""
"This command runs a new container named 'mytarantool'. Docker starts it from an "
"official image named 'tarantool/tarantool:1.7', with Tarantool version 1.7 and "
"all external modules already installed."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:73
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. You may "
"start using it as a key-value storage right away."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:76
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the container. To "
"make your test data available after you stop the container, this command also "
"mounts the host's directory ``/data/dir/on/host`` (you need to specify here an "
"absolute path to an existing local directory) in the container's directory ``/"
"var/lib/tarantool`` (by convention, Tarantool in a container uses this directory "
"to persist data). So, all changes made in the mounted directory on the "
"container's side are applied to the host's disk."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:85
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, unless you "
"use Tarantool as an :ref:`application server <app_server>` and run it with an "
"application."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:92
#, fuzzy
msgid "Attaching to Tarantool"
msgstr "Подсоединение к экземплярам"

#: ../doc/1.7/book/getting_started/using_docker.rst:94
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:96
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:100
msgid "This command:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:102
msgid ""
"Instructs Tarantool to open an interactive console port for incoming connections."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:103
msgid ""
"Attaches to the Tarantool server inside the container under 'admin' user via a "
"standard Unix socket."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:106
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:108
msgid "tarantool.sock>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:124
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:129
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"tarantool.sock> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"         >   type = 'hash',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })"

#: ../doc/1.7/book/getting_started/using_docker.rst:140
#, fuzzy
msgid ""
"tarantool.sock> t = s:insert({1, 'Roxette'})\n"
"tarantool.sock> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool.sock> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""
"tarantool> t = s:insert({1})\n"
"tarantool> t = s:insert({2, 'Music'})\n"
"tarantool> t = s:insert({3, 'Length', 93})"

#: ../doc/1.7/book/getting_started/using_docker.rst:149
#, fuzzy
msgid "tarantool.sock> s:select{3}"
msgstr "tarantool> s:select{3}"

#: ../doc/1.7/book/getting_started/using_docker.rst:155
#, fuzzy
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock>"
msgstr ""
"tarantool> s = box.schema.space.create('tester')\n"
"2015-06-10 12:04:18.158 ... creating './00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Music'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Length', 93}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Length', 93]\n"
"...\n"
"tarantool>"

#: ../doc/1.7/book/getting_started/using_docker.rst:181
#, fuzzy
msgid "Stopping a container"
msgstr "Остановка всех экземпляров:"

#: ../doc/1.7/book/getting_started/using_docker.rst:183
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:185
#, fuzzy
msgid "$ docker stop mytarantool"
msgstr "$ systemctl stop tarantool@example"

#: ../doc/1.7/book/getting_started/using_docker.rst:189
msgid ""
"This was a temporary container, and its disk/memory data were flushed when you "
"stopped it. But since you mounted a data directory from the host in the "
"container, Tarantool's data files were persisted to the host's disk. Now if you "
"start a new container and mount that data directory in it, Tarantool will "
"recover all data from disk and continue working with the persisted data."
msgstr ""

#: ../doc/1.7/book/index.rst:33
msgid "User's Guide"
msgstr "Руководство пользователя"

#: ../doc/1.7/book/intro.rst:31
msgid "Preface"
msgstr "Предисловие"

#: ../doc/1.7/book/intro.rst:33
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it first, "
"and consulting :ref:`Reference <reference>` materials for more detail "
"afterwards, if needed."
msgstr ""
"Добро пожаловать в мир Tarantool! Сейчас вы читаете \"Руководство пользователя"
"\". Мы советуем начинать именно с него, а затем переходить к :ref:`\"Справочникам"
"\" <reference>`, если вам понадобятся более подробные сведения."

#: ../doc/1.7/book/intro.rst:39
msgid "How to read the documentation"
msgstr "Как пользоваться документацией"

#: ../doc/1.7/book/intro.rst:41
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker "
"container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at http://try."
"tarantool.org. Either way, as the first tryout, you can follow the introductory "
"exercises from :ref:`Chapter 2 \"Getting started\" <getting_started>`. If you "
"want more hands-on experience, proceed to :ref:`Tutorials <tutorials>` after you "
"are through with Chapter 2."
msgstr ""

#: ../doc/1.7/book/intro.rst:50
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool as a "
"NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" <app_server>` is "
"about using Tarantool as an application server."
msgstr ""
"В :ref:`главе 3 \"Функционал СУБД\" <database-chapter>` рассказано о "
"возможностях Tarantool'а как NoSQL СУБД, а в :ref:`главе 4 \"Сервер приложений\" "
"<app_server>` — о возможностях Tarantool'а как сервера приложений Lua."

#: ../doc/1.7/book/intro.rst:54
#, fuzzy
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <replication>` are primarily for administrators."
msgstr ""
":ref:`Глава 5 \"Администрирование серверной части\" <server_admin>` "
"предназначена в первую очередь для системных администраторов."

#: ../doc/1.7/book/intro.rst:57
#, fuzzy
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for users who "
"are connecting from a different language such as C or Perl or Python — other "
"users will find no immediate need for this chapter."
msgstr ""
":ref:`Глава 6 \"Коннекторы\" <index-box_connectors>` актуальна только для тех "
"пользователей, которые хотят устанавливать соединение с Tarantool'ом с помощью "
"программ на других языках программирования (например C, Perl или Python) — для "
"прочих пользователей эта глава неактуальна."

#: ../doc/1.7/book/intro.rst:61
#, fuzzy
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked questions "
"about Tarantool."
msgstr ""
":ref:`Глава 7 \"Вопросы и ответы\" <faq>` содержит ответы на некоторые часто "
"задаваемые вопросы о Tarantool'е."

#: ../doc/1.7/book/intro.rst:64
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` materials, a :"
"ref:`Contributor's Guide <contrib_guide>` and an extensive set of comments in "
"the source code."
msgstr ""
"Опытным же пользователям будут полезны :ref:`\"Справочники\" <reference>`, :ref:`"
"\"Руководство участника проекта\" <contrib_guide>` и комментарии в исходном коде."

#: ../doc/1.7/book/intro.rst:70
msgid "Getting in touch with the Tarantool community"
msgstr "Как связаться с сообществом разработчиков Tarantool'а"

#: ../doc/1.7/book/intro.rst:72
msgid ""
"Please report bugs or make feature requests at http://github.com/tarantool/"
"tarantool/issues."
msgstr ""
"Оставить сообщение о найденых дефектах или сделать запрос на новый функционал "
"можно тут: http://github.com/tarantool/tarantool/issues"

#: ../doc/1.7/book/intro.rst:74
msgid ""
"You can contact developers directly in `telegram <http://telegram.me/"
"tarantool>`_ or in a Tarantool discussion group (`English <https://groups.google."
"com/forum/#!forum/tarantool>`_ or `Russian <https://googlegroups.com/group/"
"tarantool-ru>`_)."
msgstr ""
"Пообщаться напрямую с командой разработки Tarantool'а можно в `telegram <http://"
"telegram.me/tarantool>`_ или на форумах (`англоязычном <https://groups.google."
"com/forum/#!forum/tarantool>`_ или `русскоязычном <https://googlegroups.com/"
"group/tarantool-ru>`_)."

#: ../doc/1.7/book/intro.rst:81
#, fuzzy
msgid "Conventions used in this manual"
msgstr "Условные обозначения, используемые в этом разделе"

#: ../doc/1.7/book/intro.rst:83
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/1.7/book/intro.rst:85
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/1.7/book/intro.rst:87
msgid ""
"A vertical bar | means the preceding and following tokens are mutually exclusive "
"alternatives."
msgstr ""

#: ../doc/1.7/book/replication/1_1.rst:29
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."

#: ../doc/1.7/book/replication/1_2.rst:29
msgid "$"
msgstr "$"

#: ../doc/1.7/book/replication/2_1.rst:29
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/1.7/book/replication/2_2.rst:29 ../doc/1.7/book/replication/3_2.rst:29
#, fuzzy
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication_source = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot from "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot `./00000000000000000000.snap."
"inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating `./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."

#: ../doc/1.7/book/replication/3_1.rst:29 ../doc/1.7/book/replication/4_1.rst:29
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/1.7/book/replication/4_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."

#: ../doc/1.7/book/replication/5_1.rst:29 ../doc/1.7/book/replication/6_1.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"

#: ../doc/1.7/book/replication/5_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"

#: ../doc/1.7/book/replication/6_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."

#: ../doc/1.7/book/replication/7_1.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."

#: ../doc/1.7/book/replication/7_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"

#: ../doc/1.7/book/replication/8_1.rst:29
#, fuzzy
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008."
"xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication_source='replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication_source' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at 127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'\n"
"[22612] relay/127.0.0.1:33510/102/main I> done `./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from `./00000000000000000008."
"xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."

#: ../doc/1.7/book/replication/8_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"

#: ../doc/1.7/book/replication/index.rst:33
msgid "Replication"
msgstr "Репликация"

#: ../doc/1.7/book/replication/index.rst:35
#, fuzzy
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the same "
"databases. The databases are kept in sync because each instance can communicate "
"its changes to all the other instances."
msgstr ""
"Механизм репликации позволяет сразу многим Tarantool-серверам работать с копиями "
"одних и тех же баз данных. При этом все базы остаются в синхронизированном "
"состоянии благодаря тому, что каждый сервер может сообщать другим серверам о "
"совершенных им изменениях. Сервера, которые работают над одними и теми же "
"базами, представляют собой \"кластер\". У каждого сервера в кластере есть "
"числовой идентификатор (server id), уникальный в рамках кластера."

#: ../doc/1.7/book/replication/repl_add_instances.rst:33
#, fuzzy
msgid "Adding instances"
msgstr "Запуск экземпляров"

#: ../doc/1.7/book/replication/repl_add_instances.rst:39
#, fuzzy
msgid "Adding a replica"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_add_instances.rst:44
msgid ""
"To add a second **replica** instance to the **master-replica** set from our :ref:"
"`bootstrapping example <replication-master_replica_bootstrap>`, we need an "
"analog of the instance file that we created for the first replica in that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:48
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = ('replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1 URI\n"
"                 'replicator:password@192.168.0.103:3301'), -- replica #2 URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:66
msgid ""
"Here we add replica #2 URI to :ref:`replication <cfg_replication-replication>` "
"parameter, so now it contains three URIs."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:69
msgid ""
"After we launch the new replica instance, it gets connected to the master "
"instance and retrieves the master's write ahead log and snapshot files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:72
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping replica "
"from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:91
msgid ""
"Since we're adding a read-only instance, there is no need to dynamically update "
"``replication`` parameter on the other running instances. This update would be "
"required if we :ref:`added a master instance <replication-add_master>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:95
msgid ""
"However, we recommend to specify replica #3 URI in all instance files of the "
"replica set. This will keep all the files consistent with each other and with "
"the current replication topology, and so will help to avoid configuration errors "
"in case of further reconfigurations and replica set restart."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:104
#, fuzzy
msgid "Adding a master"
msgstr "Настройка главного сервера"

#: ../doc/1.7/book/replication/repl_add_instances.rst:109
msgid ""
"To add a third master instance to the **master-master** set from our :ref:"
"`bootstrapping example <replication-master_master_bootstrap>`, we need an analog "
"of the instance files that we created to bootstrap the other master instances in "
"that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:114
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant \"replication\" "
"role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:131
msgid "Here we make the following changes:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:133
#, fuzzy
msgid ""
"Add master#3 URI to :ref:`replication <cfg_replication-replication>` parameter."
msgstr ""
"Этот запрос можно выполнить в любой момент, т.к. параметр :ref:"
"`replication_source <cfg_replication-replication_source>` можно задавать на ходу."

#: ../doc/1.7/book/replication/repl_add_instances.rst:135
msgid ""
"Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to disable data-"
"change operations on the instance. After launch, master #3 will act as a replica "
"until it retrieves all data from the other masters in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:139
msgid ""
"After we launch the third master instance, it gets connected to the other master "
"instances and retrieves their write ahead logs and snapshot files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:142
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping replica "
"from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master3_dir/00000000000000000009.snap."
"inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:165
msgid ""
"Next, we add master#3 URI to ``replication`` parameter on the existing two "
"masters. Replication-related parameters are dynamic, so we only need to make a "
"``box.cfg{}`` request on each of the running instances:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:169
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:179
msgid ""
"When master #3 catches up with the other masters' state, we can disable read-"
"only mode for this instance:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:182
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:189
msgid ""
"We also recommend to specify master #3 URI in all instance files in order to "
"keep all the files consistent with each other and with the current replication "
"topology."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:33
msgid "Replication architecture"
msgstr "Архитектура механизма репликации"

#: ../doc/1.7/book/replication/repl_architecture.rst:39
#, fuzzy
msgid "Replication mechanism"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_architecture.rst:41
msgid ""
"A pack of instances which operate on copies of the same databases make up a "
"**replica set**. Each instance in a replica set has a role, **master** or "
"**replica**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:45
msgid ""
"A replica gets all updates from the master by continuously fetching and applying "
"its write ahead log (**WAL**). Each record in the WAL represents a single "
"Tarantool data-change request such as INSERT, UPDATE or DELETE, and is assigned "
"a monotonically growing log sequence number (**LSN**). In essence, Tarantool "
"replication is **row-based**: each data-change request is fully deterministic "
"and operates on a single tuple. However, unlike a classical row-based log, which "
"contains entire copies of the changed rows, Tarantool's WAL contains copies of "
"the requests. For example, for UPDATE requests, Tarantool only stores the "
"primary key of the row and the update operations, to save space."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:55
msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, records "
"of the actual **data-change requests, performed by the Lua code**, are written "
"to the WAL. This ensures that possible non-determinism of Lua does not cause "
"replication to go out of sync."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:60
msgid ""
"Data definition operations on **temporary spaces**, such as creating/dropping, "
"adding indexes, truncating, etc., are written to the WAL, since information "
"about temporary spaces is stored in non-temporary system spaces, such as :ref:"
"`box.space._space <box_space-space>`. Data change operations on temporary spaces "
"are not written to the WAL and are not replicated."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:66
msgid ""
"To create a valid initial state, to which WAL changes can be applied, every "
"instance of a replica set requires a start set of :ref:`checkpoint files <index-"
"box_persistence>`, such as .snap files for memtx and .run files for vinyl. A "
"replica joining an existing replica set, chooses an existing master and "
"automatically downloads the initial state from it. This is called an **initial "
"join**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:73
msgid ""
"When an entire replica set is bootstrapped for the first time, there is no "
"master which could provide the initial checkpoint. In such case, replicas "
"connect to each other, elect a master, which then creates the starting set of "
"checkpoint files, and distributes it across all other replicas. This is called "
"an **automatic bootstrap** of a replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:79
msgid ""
"When a replica contacts a master (there can be many masters) for the first time, "
"it becomes part of a replica set. On subsequent occasions, it should always "
"contact a master in the same replica set. Once connected to the master, the "
"replica requests all changes that happened after the latest local LSN (there can "
"be many LSNs -- each master has its own LSN)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:85
msgid ""
"Each replica set is identified by a globally unique identifier, called **replica "
"set UUID**. The identifier is created by the master which creates the very first "
"checkpoint, and is part of the checkpoint file. It is stored in system space :"
"ref:`box.space._schema <box_space-schema>`. For example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:90
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:97
msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, when it "
"joins the replica set. It is called an **instance UUID** and is a globally "
"unique identifier. This UUID is used to ensure that instances do not join a "
"different replica set, e.g. because of a configuration error. A unique instance "
"identifier is also necessary to apply rows originating from different masters "
"only once, that is, implement multi-master replication. This is why each row in "
"the write ahead log, in addition to its log sequence number, stores the instance "
"identifier of the instance on which it was created. But using UUID as such an "
"identifier would take too much space in the write ahead log, thus a shorter "
"integer number is assigned to the instance when it joins a replica set. This "
"number is then used to refer to the instance in the write ahead log. It is "
"called **instance id**. All identifiers are stored in system space :ref:`box."
"space._cluster <box_space-cluster>`. For example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:118
msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the instance "
"UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally unique)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:121
msgid ""
"Using shorter numeric identifiers is also handy to track the state of the entire "
"replica set. For example, :ref:`box.info.vclock <box_introspection-box_info>` "
"describes the state of replication in regard to each connected peer."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:125
msgid ""
"box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:132
msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances with "
"short identifiers 1 and 2."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:139
#, fuzzy
msgid "Replication setup"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_architecture.rst:141
msgid ""
"To enable replication, you need to specify two parameters in a ``box.cfg{}`` "
"request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:144
msgid ""
":ref:`replication <cfg_replication-replication>` parameter which defines the "
"replication source(s), and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:146
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter which is ``true`` for a replica "
"and ``false`` for a master."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:149
#, fuzzy
msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a master "
"and vice versa on the fly with the help of a ``box.cfg{}`` request."
msgstr ""
"Параметры репликации можно менять на лету, что позволяет назначать реплику на "
"роль главного сервера и наоборот. Для этого используется запрос :ref:`box.cfg "
"<box_introspection-box_cfg>`."

#: ../doc/1.7/book/replication/repl_architecture.rst:152
msgid ""
"Further we're giving a detailed example of :ref:`bootstrapping a replica set "
"<replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:159
msgid "Replication roles: master and replica"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:161
msgid ""
"Replication role (master or replica) is set in :ref:`read_only <cfg_basic-"
"read_only>` configuration parameter. The recommended role for **all-but-one** "
"instances in a replica set is \"read-only\" (replica)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:165
msgid ""
"In a master-replica configuration, every change that happens on the master will "
"be visible on the replicas, but not vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:171
msgid ""
"A simple two-instance replica set with the master on one machine and the replica "
"on a different machine provides two benefits:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:174
msgid ""
"**failover**, because if the master goes down then the replica can take over, and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:176
msgid ""
"**load balancing**, because clients can connect to either the master or the "
"replica for read requests."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:179
msgid ""
"In a **master-master** configuration (also called \"multi-master\"), every "
"change that happens on either instance will be visible on the other one."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:185
msgid ""
"The failover benefit in this case is still present, and the load-balancing "
"benefit is enhanced, because any instance can handle both read and write "
"requests. Meanwhile, for multi-master configurations, it is necessary to "
"understand the **replication guarantees** provided by the asynchronous protocol "
"that Tarantool implements."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:191
msgid ""
"Tarantool multi-master replication guarantees that each change on each master is "
"propagated to all instances and is applied only once. Changes from the same "
"instance are applied in the same order as on the originating instance. Changes "
"from different instances, however, can mix and apply in a different order on "
"different instances. This may lead to replication going out of sync in certain "
"cases."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:198
msgid ""
"For example, assuming the database is only appended to (i.e. it contains only "
"insertions), it is safe to set each instance to a master. If there are also "
"deletions, but it is not mission critical that deletion happens in the same "
"order on all replicas (e.g. the DELETE is used to prune expired data), a master-"
"master configuration is also safe."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:204
msgid ""
"UPDATE operations, however, can easily go out of sync. For example, assignment "
"and increment are not commutative, and may yield different results if applied in "
"different order on different instances."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:208
msgid ""
"More generally, it is only safe to use Tarantool master-master replication if "
"all database changes are **commutative**: the end result does not depend on the "
"order in which the changes are applied. You can start learning more about "
"conflict-free replicated data types `here <https://en.wikipedia.org/wiki/"
"Conflict-free_replicated_data_type>`_."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:218
msgid "Replication topologies: cascade, ring and full mesh"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:220
msgid ""
"Replication topology is set in :ref:`replication <cfg_replication-replication>` "
"configuration parameter. The recommended topology is a **full mesh**, because it "
"makes potential failover easy."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:224
msgid ""
"Some database products offer **cascading replication** topologies: creating a "
"replica on a replica. Tarantool does not recommend such setup."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:230
msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a replica set "
"is an entry in ``box.space._cluster`` system space with replica set UUID. "
"Without knowing a replica set UUID, a master refuses to accept connections from "
"such instances when replication topology changes. Here is how this can happen:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:240
msgid ""
"We have a chain of three instances. Instance #1 contains entries for instances "
"#1 and #2 in its ``_cluster`` space. Instances #2 and #3 contain entries for "
"instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:247
msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as its "
"new master, but the master refuses the connection since it has no entry for "
"instance #3."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:251
msgid "**Ring replication** topology is, however, supported:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:256
msgid ""
"So, if you need a cascading topology, you may first create a ring to ensure all "
"instances know each other’s UUID, and then disconnect the chain in the place you "
"desire."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:260
msgid ""
"A stock recommendation for a master-master replication topology, however, is a "
"**full mesh**:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:266
msgid ""
"You then can decide where to locate instances of the mesh -- within the same "
"data center, or spread across a few data centers. Tarantool will automatically "
"ensure that each row is applied only once on each instance. To remove a degraded "
"instance from a mesh, simply change ``replication`` configuration parameter."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:271
msgid ""
"This ensures full cluster availability in case of a local failure, e.g. one of "
"the instances failing in one of the data centers, as well as in case of an "
"entire data center failure."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:275
msgid "The maximal number of replicas in a mesh is 32."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:33
#, fuzzy
msgid "Bootstrapping a replica set"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:39
msgid "Master-replica bootstrap"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:41
msgid ""
"Let's first bootstrap a simple **master-replica** set containing two instances, "
"each located on its own machine. For easier administration, we make the :ref:"
"`instance files <admin-instance_file>` almost identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:48
msgid "Here is an example of the master's instance file:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:50
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:69
msgid ""
":ref:`listen <cfg_basic-listen>` parameter from ``box.cfg{}`` defines a URI "
"(port 3301 in our example), on which the master can accept connections from "
"replicas."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:72
msgid ""
":ref:`replication <cfg_replication-replication>` parameter defines the URIs at "
"which all instances in the replica set can accept connections. It includes the "
"replica's URI as well, although the replica is not a replication source right "
"now."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:79
msgid ""
"For security reasons, we recommend to prevent unauthorized replication sources "
"by associating a password with every user that has a replication :ref:`role "
"<authentication-roles>`. That way, the :ref:`URI <index-uri>` for "
"``replication`` parameter must have the long form ``username:password@host:"
"port``."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:85
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter enables data-change operations "
"on the instance and makes this Tarantool instance act as a master, not as a "
"replica. *That's the only parameter in our instance files that will differ.*"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:89
msgid ""
":ref:`box.once() <box-once>` function contains database initialization logic "
"that should be executed only once during the replica set lifetime."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:92
msgid ""
"In this example, we create a space with a primary index, and a user for "
"replication purposes. We also say ``print('box.once executed on master')`` to "
"see later in console whether ``box.once()`` is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:98
#, fuzzy
msgid ""
"Replication requires privileges. We can grant privileges for accessing spaces "
"directly to the user who will start the instance. However, it is more usual to "
"grant privileges for accessing spaces to a :ref:`role <authentication-roles>`, "
"and then grant the role to the user who will start the replica."
msgstr ""
"Репликация требует настройки привилегий. Привилегии для доступа к пространствам "
"можно задать напрямую для пользователя, под чьим именем запущен сервер-реплика. "
"Но обычно привилегии на доступ к пространствам задаются с помощью :ref:`роли "
"<authentication-rep_role>`, которая затем присваивается пользователю, под чьим "
"именем запущен сервер-реплика."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:104
msgid ""
"Here we use Tarantool's predefined role named \"replication\" which by default "
"grants \"read\" privileges for all database objects (\"universe\"), and we can "
"further set up privileges for this role as required."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:108
msgid ""
"In the replica's instance file, we only set read-only parameter to \"true\", and "
"say ``print('box.once executed on replica')`` to make sure that box.once() is "
"not executed more than once. Otherwise the replica's instance file is fully "
"identical to the master's instance file."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:113
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') - grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:132
#, fuzzy
msgid ""
"The replica does not inherit the master’s configuration parameters, such as "
"those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` run on "
"the master. To get the same behavior, please set the relevant parameters "
"explicitly so that they are the same on both master and replica."
msgstr ""
"Реплика не берет настройки конфигурации с главного сервера, например настройки "
"запуска :ref:`фоновой программы для работы со снимками "
"<book_cfg_snapshot_daemon>` на главном сервере. Чтобы получить те же настройки "
"на реплике, нужно задать их явным образом."

#: ../doc/1.7/book/replication/repl_bootstrap.rst:137
msgid "Now we can launch the two instances. The master..."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:139
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> can't "
"connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. coio."
"cc:105 !> SystemError connect, called on fd 14, aka 192.168.0.102:56736: "
"Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an empty "
"data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:162
msgid "... (yep, ``box.once()`` got executed on the master) -- and the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:164
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to [::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:177
msgid ""
"In both logs, there are messages saying that the replica got bootstrapped from "
"the master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:179
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:189
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I> "
"authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping replica "
"from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> "
"initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I> final "
"data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:204
msgid ""
"Notice that ``box.once()`` was executed only at the master, although we added "
"``box.once()`` to both instance files."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:207
msgid "We could as well launch the replica first:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:209
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> can't "
"connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. coio."
"cc:105 !> SystemError connect, called on fd 13, aka 192.168.0.101:56820: "
"Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:222
msgid "... and the master later:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:224
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an empty "
"data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I> failed "
"to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. xrow."
"cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:249
msgid ""
"In this case, the replica would wait for the master to become available, so the "
"launch order doesn't matter. Our ``box.once()`` logic would also be executed "
"only once, at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:253
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> remote "
"master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I> "
"authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping replica "
"from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I> "
"initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I> final "
"data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot `/var/lib/"
"tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:273
msgid "Controlled failover"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:275
msgid ""
"To perform a **controlled failover**, that is, swap the roles of the master and "
"replica, all we need to do is to set ``read_only=true`` at the master, and "
"``read_only=false`` at the replica. The **order of actions** is important here. "
"If a system is running in production, we don’t want concurrent writes happen "
"both at the replica and the master. Nor do we want the new replica to accept any "
"writes until it has finished fetching all replication data from the old master. "
"To compare replica and master state, we can use :ref:`box.info.signature "
"<box_introspection-box_info>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:284
msgid "Set ``read_only=true`` at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:286
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:291
msgid ""
"Record the master’s current position with ``box.info.signature``, containing the "
"sum of all LSNs in the master’s vector clock."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:294
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:299
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:301
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:306
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:308
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:313
msgid ""
"These 4 steps ensure that the replica doesn’t accept new writes until it’s done "
"fetching writes from the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:320
#, fuzzy
msgid "Master-master bootstrap"
msgstr "Репликация по схеме master-master"

#: ../doc/1.7/book/replication/repl_bootstrap.rst:322
msgid ""
"Now let's bootstrap a two-instance **master-master** set. For easier "
"administration, we make master#1 and master#2 instance files fully identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:328
msgid ""
"We re-use the master's instance file from the :ref:`master-replica example "
"<replication-master_replica_bootstrap>` above."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:331
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:348
msgid ""
"In :ref:`replication <cfg_replication-replication>` parameter, we define the "
"URIs of both masters in the replica set and say ``print('box.once executed on "
"master #1')`` to see when and where the ``box.once()`` logic is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:353
msgid ""
"Now we can launch the two masters. Again, the launch order doesn't matter. The "
"``box.once()`` logic will also be executed only once, at the master which is "
"elected as the replica set leader at bootstrap."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:357
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> "
"can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 coio."
"cc:107 !> SystemError connect, called on fd 14, aka 192.168.0.102:57110: "
"Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 I> will "
"retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 I> "
"authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping replica "
"from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 I> "
"initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 I> "
"final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master1_dir/00000000000000000008.snap."
"inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:381
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version 1.7.4-52-"
"g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456 bytes "
"for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to [::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 I> "
"remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 I> "
"remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an empty "
"data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot `/Users/e."
"shebunyaeva/work/tarantool-test-repl/master2_dir/00000000000000000000.snap."
"inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I> "
"recover from `/Users/e.shebunyaeva/work/tarantool-test-repl/"
"master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 I> "
"authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:33
msgid "Preventing duplicate actions"
msgstr "Предотвращение дублирующихся действий"

#: ../doc/1.7/book/replication/repl_duplicates.rst:35
msgid ""
"Tarantool guarantees that every update is applied only once at every replica. "
"However, due to asynchronous nature of the replication, the order of updates is "
"not guaranteed. Further we analyse this problem in more details, provide "
"examples of replication going out of sync, and suggest solutions."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:44
#, fuzzy
msgid "Replication stops"
msgstr "Репликация"

#: ../doc/1.7/book/replication/repl_duplicates.rst:46
msgid ""
"In a replica set of two masters, suppose master #1 tries to do something that "
"master #2 has already done. For example, try to simultaneously insert a tuple "
"with the same unique key:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:50
#, fuzzy
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr "tarantool> {**{box.space.tester:select{2}}**}"

#: ../doc/1.7/book/replication/repl_duplicates.rst:54
msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:57
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I> can't "
"read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C> "
"exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I> can't "
"read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C> "
"exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:73
msgid ""
"If we check replication statuses with ``box.info``, we'll see that replication "
"at master #1 is stopped (``1.upstream.status = stopped``). Additionally, no data "
"is replicated from that master (section ``1.downstream`` is missing in the "
"report), because the downstream has encountered the same error:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:78
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"        lag: 0.00050592422485352\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:122
msgid "When replication is later manually resumed:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:124
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:131
msgid "... the faulty row in the write ahead log files is skipped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:137
msgid "Replication runs out of sync"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:139
msgid ""
"In a master-master cluster of two instances, suppose we make the following "
"operation:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:142
#, fuzzy
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:146
msgid "When we get this operation applied on both instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:148
msgid ""
"-- at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"-- at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:155
msgid "... we can have the following results, depending on the order of execution:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:157
msgid "each master’s row contains the uuid from master #1,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:158
msgid "each master’s row contains the uuid from master #2,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:159
msgid "master #1 has the uuid of master #2, and vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:165
msgid "Commutative changes"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:167
msgid ""
"The cases described in previous paragraphs represent examples of **non-"
"commutative** operations, i.e. operations, which result depends on the execution "
"order. On the contrary, for **commutative operations**, the execution order "
"doesn’t matter."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:172
msgid "Consider for example the following command:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:174
#, fuzzy
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"

#: ../doc/1.7/book/replication/repl_duplicates.rst:178
msgid ""
"This operation is commutative: we get the same result no matter in which order "
"the update is applied on the other masters."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:33
#, fuzzy
msgid "Monitoring a replica set"
msgstr "Мониторинг действий реплики"

#: ../doc/1.7/book/replication/repl_monitoring.rst:35
msgid ""
"To learn what instances belong in the replica set, and obtain statistics for all "
"these instances, use ``box.info.replication`` request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:38
msgid ""
"box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:69
msgid ""
"This report is for a master-master replica set of three instances, each having "
"its own instance id, UUID and log sequence number."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:75
msgid ""
"The request was issued at master #1, and the reply includes statistics for the "
"other two masters, given in regard to master #1."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:78
msgid ""
"The primary indicators of replication health are ``idle`` and ``lag`` parameters "
"(see reference on :ref:`box.info.replication <box_info_replication>` for "
"details)."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:33
msgid "Recovering from a degraded state"
msgstr "Восстановление после сбоя"

#: ../doc/1.7/book/replication/repl_recover.rst:35
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable -- due to "
"hardware or network failure, or due to a programming bug."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:41
msgid ""
"In a master-replica set, if a master disappears, error messages appear on the "
"replicas stating that the connection is lost:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:44
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> can't "
"read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. coio."
"cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I> will "
"retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I> the "
"replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C> "
"exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:55
msgid "... and the master's status is reported as \"disconnected\":"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:57
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"      lag: 0.00026607513427734\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:83
msgid ""
"# report from replica #2\n"
"box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"      lag: 0.00027203559875488\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:111
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:113
msgid "Make sure that the old master is gone for good:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:115
msgid ""
"change network routing rules to avoid any more packets being delivered to the "
"master, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:117
msgid "shut down the master instance, if you have access to the machine, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:118
msgid "power off the container or the machine."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:120
msgid ""
"Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and ``box."
"cfg{replication=URI}`` on the other replicas in the set."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:125
msgid ""
"If there are updates on the old master that were not propagated before the old "
"master went down, :ref:`re-apply them manually <admin-disaster_recovery-"
"master_replica>` to the new master using ``tarantoolctl cat`` and ``tarantoolctl "
"play`` commands."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:130
#, fuzzy
msgid ""
"There is no automatic way for a replica to detect that the master is gone "
"forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires an external observer."
msgstr ""
"\"Сбой\" — это ситуация, когда главный сервер становится недоступен вследствие "
"проблем с оборудованием, сетевых неполадок или программной ошибки. У реплики нет "
"способа автоматически обнаружить, что связь с главным сервером утеряна насовсем, "
"поскольку причины сбоя и окружение, в котором развернута репликация, могут быть "
"очень разными. Поэтому обнаруживать сбой должен человек."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:33
#, fuzzy
msgid "Removing instances"
msgstr "Создание экземпляров"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:35
msgid "To politely remove an instance from a replica set, follow these steps:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:37
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:39
#, fuzzy
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:45
#, fuzzy
msgid ""
"The other instances in the replica set will carry on. If later the removed "
"instance rejoins, it will receive all the updates that the other instances made "
"while it was away."
msgstr ""
"Вопрос: Что если какой-то сервер вдруг выбывает из кластера? |br| Ответ: "
"Остальные сервера продолжают работать. Если выбывший сервер снова возвращается в "
"кластер, то он получит информацию о всех изменениях, которые произошли на "
"остальных серверах за время его отсутствия."

#: ../doc/1.7/book/replication/repl_remove_instances.rst:49
msgid ""
"If the instance is decommissioned forever, delete the instance's record from the "
"following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:52
msgid ""
":ref:`replication <cfg_replication-replication>` parameter at all running "
"instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:55
#, fuzzy
msgid "tarantool> box.cfg{replication=...}"
msgstr "tarantool> box.cfg{listen = 3301}"

#: ../doc/1.7/book/replication/repl_remove_instances.rst:59
msgid ""
":ref:`box.space._cluster <box_space-cluster>` on any master instance in the "
"replica set. For example, a record with instance id = 3:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:62
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:33
#, fuzzy
msgid "Reseeding a replica"
msgstr "Настройка сервера-реплики"

#: ../doc/1.7/book/replication/repl_reseed.rst:35
msgid ""
"If any of a replica's .xlog/.snap/.run files are corrupted or deleted, you can "
"\"re-seed\" the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:38
msgid ""
"Stop the replica and destroy all local database files (the ones with extensions ."
"xlog/.snap/.run/.inprogress)."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:41
msgid "Delete the replica's record from the following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:43
msgid "``replication`` parameter at all running instances in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:44
msgid "``box.space._cluster`` on the master instance."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:46
msgid ""
"See section :ref:`Removing instances <replication-remove_instances>` for details."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:49
msgid ""
"Restart the replica with the same instance file to contact the master again. The "
"replica will then catch up with the master by retrieving all the master’s tuples."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:55
msgid ""
"Remember that this procedure works only if the master’s WAL files are present."
msgstr ""

#~ msgid ""
#~ "The two ordinary index types are 'tree' which is the default, and 'hash' "
#~ "which must be unique and which may be faster or smaller. The third type is "
#~ "'bitset' which is not unique and which works best for combinations of binary "
#~ "values. The fourth type is 'rtree' which is not unique and which works with "
#~ "arrays, instead of 'string' or 'unsigned' values."
#~ msgstr ""
#~ "Чаще всего индекс — это дерево (по умолчанию) или хеш (в этом случае индекс "
#~ "должен быть уникальным; в определенных случаях такой индекс занимает меньше "
#~ "места и поиск по нему работает быстрее). Третий тип индекса — это набор битов "
#~ "(bitset); это неуникальный индекс, предназначенный для работы с различными "
#~ "бинарными значениями. Четвертый тип индекса — это R-дерево; это тоже "
#~ "неуникальный индекс, предназначенный для работы с массивами, а не со строками "
#~ "или беззнаковыми числами."

#~ msgid ""
#~ "**To review...** If you followed all the instructions in this chapter, then "
#~ "so far you have: installed Tarantool from either a binary or a source "
#~ "repository, started up the Tarantool server, inserted and selected tuples."
#~ msgstr ""
#~ "Если вы выполнили все инструкции из этой главы, то к данному моменту вы уже "
#~ "установили Tarantool (из бинарного пакета, либо из исходных файлов), "
#~ "запустили Tarantool-сервер, а также выполнили вставку и выборку кортежей."

#~ msgid ""
#~ "Typical server administration tasks include starting and stopping the server, "
#~ "reloading configuration, taking snapshots, log rotation."
#~ msgstr ""
#~ "Типичные задачи администрирования серверной части включают в себя запуск и "
#~ "остановку сервера, перезагрузку настроек, создание снимков, ротацию логов."

#~ msgid ""
#~ "If :program:`tarantool` is started without an :ref:`initialization file "
#~ "<index-init_label>`, or if the initialization file contains :ref:`console."
#~ "start() <console-start>`, then :program:`tarantool` enters interactive mode. "
#~ "There will be a prompt (\"``tarantool>``\") and it will be possible to enter "
#~ "requests. When used this way, :program:`tarantool` can be a client for a "
#~ "remote server."
#~ msgstr ""
#~ "Если :program:`tarantool` запущен без :ref:`файла инициализации <index-"
#~ "init_label>`, или же в файле инициализации указана функция :ref:`console."
#~ "start() <console-start>`, то :program:`tarantool` стартует в интерактивном "
#~ "режиме: он выводит приглашение командной строки (\"``tarantool>``\"), и "
#~ "запросы можно вводить прямо в консоли. В таком режиме :program:`tarantool` "
#~ "можно использовать в качестве клиента для удаленного сервера."

#~ msgid ""
#~ "This section shows all legal syntax for the :program:`tarantool` program, "
#~ "with short notes and examples. Other client programs may have similar options "
#~ "and request syntaxes. Some of the information in this section is duplicated "
#~ "in the chapter :ref:`Configuration reference <index-book_cfg>`."
#~ msgstr ""
#~ "В этом разделе описаны синтаксические правила для ввода запросов в консоли "
#~ "Tarantool'а, с примечаниями и примерами. Другие клиентские программы могут "
#~ "иметь схожие параметры и синтаксис запросов. Некоторые сведения из этого "
#~ "раздела дублируются в главе :ref:`Справочник по конфигурированию <index-"
#~ "book_cfg>`."

#~ msgid ""
#~ "Tokens are character sequences which are treated as syntactic units within "
#~ "requests. Square brackets [ and ] enclose optional syntax. Three dots in a "
#~ "row ... mean the preceding tokens may be repeated. A vertical bar | means the "
#~ "preceding and following tokens are mutually exclusive alternatives."
#~ msgstr ""
#~ "Токены — это последовательности символов, которые рассматриваются как "
#~ "синтаксические единицы в рамках запроса. Квадратные скобки [ и ] используются "
#~ "для обозначения необязательных токенов. Три точки в строке ... означают, что "
#~ "предыдущие токены могут повторяться. Вертикальная черта | означает, что "
#~ "предыдущие и последующие токены являются взаимоисключающими альтернативами."

#~ msgid "Options when starting client from the command line"
#~ msgstr "Параметры запуска клиента из командной строки"

#~ msgid "General form:"
#~ msgstr "Общий вид:"

#~ msgid ""
#~ "$ **tarantool**\n"
#~ "OR\n"
#~ "$ **tarantool** *options*\n"
#~ "OR\n"
#~ "$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "ИЛИ\n"
#~ "$ tarantool опции\n"
#~ "ИЛИ\n"
#~ "$ tarantool файл-инициализации-на-lua [ аргументы ]"

#~ msgid ""
#~ "Here *lua-initialization-file* can be any script containing code for "
#~ "initializing. Effect: The code in the file is executed during startup. "
#~ "Example: :samp:`init.lua`. |br| Notes: If a script is used, there will be no "
#~ "prompt. The script should contain configuration information including :samp:"
#~ "`box.cfg{...listen=...}` or :samp:`box.listen(...)` so that a separate "
#~ "program can connect to the server via one of the ports."
#~ msgstr ""
#~ "*файл-инициализации-на-lua* — это любой скрипт, содержащий логику "
#~ "инициализации. Код из этого файла выполняется при запуске Tarantool'а.  "
#~ "Например: :samp:`init.lua`. |br| Примечания: При использовании скрипта, "
#~ "Tarantool не выводит приглашение командной строки. Скрипт должен содержать "
#~ "конфигурационные настройки, в т.ч. :samp:`box.cfg{...listen=...}` или :samp:"
#~ "`box.listen(...)`, чтобы внешние программы могли установить соединение с "
#~ "Tarantool-сервером на одном из указанных портов."

#~ msgid ""
#~ "*Option* is one of the following (in alphabetical order by the long form of "
#~ "the option):"
#~ msgstr ""
#~ "*Опция* — это одно из следующих значений (указаны в алфавитном порядке, по "
#~ "полному имени опции):"

#~ msgid ""
#~ "Client displays a help message including a list of options. Example: :samp:"
#~ "`tarantool --help` The program stops after displaying the help."
#~ msgstr ""
#~ "Tarantool-клиент выводит краткую справку, включая список всех параметров. "
#~ "Например: :samp:`tarantool --help`. Вывод останавливается после показа "
#~ "справки."

#~ msgid ""
#~ "Client displays version information. Example: :samp:`tarantool --version`. "
#~ "The program stops after displaying the version."
#~ msgstr ""
#~ "Tarantool-клиент выводит свой номер версии. Например: :samp:`tarantool --"
#~ "version`. Вывод останавливается после показа номера версии."

#~ msgid "Tokens, requests, and special key combinations"
#~ msgstr "Токены, запросы и специальные комбинации клавиш"

#~ msgid ""
#~ "Procedure identifiers are: Any sequence of letters, digits, or underscores "
#~ "which is legal according to the rules for Lua identifiers. Procedure "
#~ "identifiers are also called function names. |br| Note: function names are "
#~ "case sensitive so ``insert`` and ``Insert`` are not the same thing."
#~ msgstr ""
#~ "Идентификатором процедуры может быть любая последовательность букв, цифр и/"
#~ "или подчеркиваний, которая отвечает правилам именования идентификаторов в "
#~ "Lua. Термин \"идентификаторы процедур\" также применяют к именам функций. |"
#~ "br| Примечание: в случае с именами функций регистр имеет значение, поэтому "
#~ "``insert`` и ``Insert`` — это не одно и то же."

#~ msgid ""
#~ "String literals are: Any sequence of zero or more characters enclosed in "
#~ "single quotes. Double quotes are legal but single quotes are preferred. "
#~ "Enclosing in double square brackets is good for multi-line strings as "
#~ "described in `Lua documentation <http://www.lua.org/pil/2.4.html>`_. |br| "
#~ "Examples: 'Hello, world', 'A', [[A\\\\B!]]."
#~ msgstr ""
#~ "Строковым литералом может быть любая последовательность из нуля и более "
#~ "символов, которая заключена в *одинарные кавычки*. *Двойные кавычки* также "
#~ "допустимы, но предпочтительным вариантом являются одинарные кавычки. А "
#~ "*двойные квадратные скобки* нужны для многострочных литералов (см. "
#~ "`документацию по языку Lua <http://www.lua.org/pil/2.4.html>`_). |br| "
#~ "Например: 'Hello, world', 'A', [[A\\\\B!]]."

#~ msgid ""
#~ "Numeric literals are: Any sequence of one or more digits, not enclosed in "
#~ "quotes, optionally preceded by - (minus sign). Large or floating-point "
#~ "numeric literals may include decimal points, exponential notation, or "
#~ "suffixes.|br| Examples: 500, -500, 5e2, 500.1, 5LL, 5ULL."
#~ msgstr ""
#~ "Числовым литералом может быть любая последовательность символов, состоящая из "
#~ "одной и более цифр с необязательным знаком + или - в начале. В состав больших "
#~ "числовых литералов, а также числовых литералов с плавающей точкой может "
#~ "входить десятичный разделитель (запятая или точка), символы для "
#~ "экспоненциального представления и суффиксы. |br| Например: 500, -500, 5e2, "
#~ "500.1, 5LL, 5ULL."

#~ msgid ""
#~ "Single-byte tokens are: , or ( or ) or arithmetic operators. |br| Examples: "
#~ "* , ( )."
#~ msgstr ""
#~ "Однобайтовым символом может быть запятая, открывающая или закрывающая круглая "
#~ "скобка, а также арифметический оператор. |br| Например: * , ( )."

#~ msgid ""
#~ "Tokens must be separated from each other by one or more spaces, except that "
#~ "spaces are not necessary around single-byte tokens or string literals."
#~ msgstr ""
#~ "Токены должны разделяться одним или бОльшим количеством пробелов. Исключением "
#~ "являются однобайтовые токены и строковые литералы — вокруг них пробелы не "
#~ "нужны."

#~ msgid "Requests"
#~ msgstr "Запросы"

#~ msgid ""
#~ "Generally requests are entered following the prompt in interactive mode "
#~ "while :program:`tarantool` is running. (A prompt will be the word 'tarantool' "
#~ "and a greater-than sign, for example :samp:`tarantool>`). The end-of-request "
#~ "marker is by default a newline (line feed)."
#~ msgstr ""
#~ "Запросы вводятся после приглашения командной строки, когда Tarantool работает "
#~ "в интерактивном режиме. (Приглашение — это слово tarantool и знак \"больше\", "
#~ "вот так: :samp:`tarantool>`). Маркером конца запроса по умолчанию является "
#~ "перевод строки."

#~ msgid ""
#~ "For multi-line requests, it is possible to change the end-of-request marker. "
#~ "Syntax: :samp:`console = require('console'); console.delimiter({string-"
#~ "literal})`. The string-literal must be a value in single quotes. Effect: "
#~ "string becomes end-of-request delimiter, so newline alone is not treated as "
#~ "end of request. To go back to normal mode: :samp:`console.delimiter('')"
#~ "{string-literal}`. Delimiters are usually not necessary because Tarantool can "
#~ "tell when a multi-line request has not ended (for example, if it sees that a "
#~ "function declaration does not have an :samp:`end` keyword). Example:"
#~ msgstr ""
#~ "Для ввода многострочных запросов можно задать другой маркер конца запроса. "
#~ "Для этого введите команду следующего вида: :samp:`console = "
#~ "require('console'); console.delimiter({новый-маркер})`. В качестве нового "
#~ "маркера укажите строковый литерал в одинарных кавычках. После этого вам нужно "
#~ "будет вводить указанный маркер в конце каждого запроса, потому что Tarantool "
#~ "перестанет интерпретировать перевод строки как конец запроса. Чтобы вернуться "
#~ "к обычному режиму, введите: :samp:`console.delimiter(''){string-literal}`. "
#~ "Как правило, задавать свой маркер нет необходимости, поскольку Tarantool сам "
#~ "распознает, что запрос введен не полностью (скажем, когда Tarantool не "
#~ "встречает слова :samp:`end` в объявлении функции). Например:"

#~ msgid ""
#~ "console = require('console'); console.delimiter('!')\n"
#~ "function f ()\n"
#~ "  statement_1 = 'a'\n"
#~ "  statement_2 = 'b'\n"
#~ "end!\n"
#~ "console.delimiter('')!"
#~ msgstr ""
#~ "console = require('console'); console.delimiter('!')\n"
#~ "function f ()\n"
#~ "  statement_1 = 'a'\n"
#~ "  statement_2 = 'b'\n"
#~ "end!\n"
#~ "console.delimiter('')!"

#~ msgid ""
#~ "See :ref:`here <box_protocol-iproto_protocol>` a condensed Backus-Naur Form "
#~ "[BNF] description of the suggested form of client requests."
#~ msgstr ""
#~ "См. также :ref:`описание формата клиентских запросов <box_protocol-"
#~ "iproto_protocol>` в виде аннотированных BNF-диаграмм (Backus-Naur Form)."

#~ msgid ""
#~ "In *interactive* mode, one types requests and gets results. Typically the "
#~ "requests are typed in by the user following prompts. Here is an example of an "
#~ "interactive-mode Tarantool client session:"
#~ msgstr ""
#~ "Работая в  *интерактивном* режиме, Tarantool-сервер принимает введенные "
#~ "запросы и выводит результаты. Запросы, как правило, вводит пользователь. Вот "
#~ "пример интерактивной пользовательской сессии:"

#~ msgid ""
#~ "$ tarantool\n"
#~ "[ tarantool will display an introductory message\n"
#~ "  including version number here ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ tarantool will display configuration information here ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ tarantool may display an in-progress message here ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
#~ "$"
#~ msgstr ""
#~ "$ tarantool\n"
#~ "[ здесь tarantool выводит приветствие и номер версии ]\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "[ здесь tarantool выводит свои текущие настройки ]\n"
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "[ здесь tarantool может вывести сообщение о том,\n"
#~ "  что идет обработка запроса ]\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> s:create_index('primary', {type = 'hash', parts = {1, "
#~ "'unsigned'}})\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> box.space.tester:insert{1,'My first tuple'}\n"
#~ "---\n"
#~ "- [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "---\n"
#~ "- - [1, 'My first tuple']\n"
#~ "...\n"
#~ "tarantool> box.space.tester:drop()\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> os.exit()\n"
#~ "2014-04-30 10:28:00.886 [20436] main/101/spawner I> Exiting: master shutdown\n"
#~ "$"

#~ msgid "Explanatory notes about what Tarantool displayed in the above example:"
#~ msgstr "Пояснения к приведенному выше примеру:"

#~ msgid ""
#~ "Many requests return typed objects. In the case of :samp:`box.cfg{listen=3301}"
#~ "`, this result is displayed on the screen. If the request had assigned the "
#~ "result to a variable, for example :samp:`c = box.cfg{listen=3301}`, then the "
#~ "result would not have been displayed on the screen."
#~ msgstr ""
#~ "На многие запросы Tarantool возвращает типизированные объекты. В ответ на "
#~ "запрос :samp:`box.cfg{listen=3301}` Tarantool выведет результат на экран. "
#~ "Если в запросе задано, что его результат должен быть записан в некоторую "
#~ "переменную, например :samp:`c = box.cfg{listen=3301}`, то в таком случае "
#~ "вывода результата на экран не происходит."

#~ msgid ""
#~ "A display of an object always begins with \"``---``\" and ends with \"``...``"
#~ "\"."
#~ msgstr ""
#~ "Вывод объекта в Tarantool'е всегда начинается со строки \"``---``\" и "
#~ "заканчивается строкой \"``...``\"."

#~ msgid ""
#~ "The insert request returns an object of type = tuple, so the object display "
#~ "line begins with a single dash ('``-``'). However, the select request returns "
#~ "an object of type = table of tuples, so the object display line begins with "
#~ "two dashes ('``- -``')."
#~ msgstr ""
#~ "По запросу на вставку данных возвращается объект типа кортеж (tuple), и в "
#~ "этом случае перед выводом будет стоять одиночное тире ('``-``'). А по запросу "
#~ "на выборку данных возвращается объект типа таблица кортежей (table of "
#~ "tuples), и в этом случае перед выводом будут стоять два тире ('``- -``')."

#~ msgid ""
#~ "Also, you can use :program:`tarantoolctl` :ref:`as a client <administration-"
#~ "tarantoolctl_connect>` to connect to another instance of Tarantool server and "
#~ "pass requests."
#~ msgstr ""
#~ "Данная команда означает \"использовать утилиту :ref:`tarantoolctl "
#~ "<administration-tarantoolctl_connect>` для соединения с Tarantool-сервером, "
#~ "который слушает на ``localhost:3301``.\""

#~ msgid "Configuration for tarantoolctl"
#~ msgstr "Конфигурирование tarantoolctl"

#~ msgid ""
#~ "The :program:`tarantoolctl` script will look for a configuration file in the "
#~ "current directory (:file:`$PWD/.tarantoolctl`). If that fails, it looks in "
#~ "the current user's home directory (:file:`$HOME/.config/tarantool/"
#~ "tarantool`). If that fails, it looks in the SYSCONFDIR directory (usually :"
#~ "file:`/etc/sysconfig/tarantool`, but it may be different on some platforms). "
#~ "Most of the settings are similar to the settings used by :samp:`box.cfg{...}"
#~ "`; however, :program:`tarantoolctl` adjusts some of them by adding an "
#~ "application name. A copy of :file:`usr/local/etc/default/tarantool`, with "
#~ "defaults for all settings, would look like this:"
#~ msgstr ""
#~ "Скрипт :program:`tarantoolctl` сначала проверяет наличие файла конфигурации в "
#~ "текущей директории (:file:`$PWD/.tarantoolctl`). Если не находит, то "
#~ "проверяет домашнюю директорию текущего пользователя (:file:`$HOME/.config/"
#~ "tarantool/tarantool`). Если опять не находит, то проверяет директорию, "
#~ "указанную в переменной SYSCONFDIR (обычно это :file:`/etc/sysconfig/"
#~ "tarantool`, но на разных платформах этот путь может различаться). Большинство "
#~ "параметров :program:`tarantoolctl` аналогичны тем, что задаются в запросе :"
#~ "samp:`box.cfg{...}`; однако :program:`tarantoolctl` меняет значение некоторых "
#~ "параметров, дописывая к ним имя приложения. Далее приводится копия файла :"
#~ "file:`usr/local/etc/default/tarantool`, где для всех параметров указаны их "
#~ "значения по умолчанию:"

#~ msgid "The settings in the above script are:"
#~ msgstr "Комментарии к параметрам в приведенном выше скрипте:"

#~ msgid "``snap_dir``"
#~ msgstr "``snap_dir``"

#~ msgid ""
#~ "The directory for the vinyl-storage-engine files. The script will add \":samp:"
#~ "`/vinyl/{instance-name}`\" to the directory-name."
#~ msgstr ""
#~ "Директория, где хранятся файлы движка vinyl. Скрипт :program:`tarantoolctl` "
#~ "добавляет \":samp:`/{instance-name}`\" к имени директории."

#~ msgid ""
#~ "The user that runs the Tarantool server. This is the operating-system user "
#~ "name rather than the Tarantool-client user name."
#~ msgstr ""
#~ "Имя пользователя, из-под которого запущен Tarantool-сервер. Это имя "
#~ "пользователя в операционной системе, а не в Tarantool-клиенте."

#~ msgid ""
#~ "The directory where all applications for this host are stored. The user who "
#~ "writes an application for :program:`tarantoolctl` must put the application's "
#~ "source code in this directory, or a symbolic link. For examples in this "
#~ "section the application name ``my_app`` will be used, and its source will "
#~ "have to be in :samp:`{instance_dir}/my_app.lua`."
#~ msgstr ""
#~ "Имя директории, где хранятся исходные файлы всех Tarantool-приложений для "
#~ "данного хоста. Пользователю, который пишет приложение для :program:"
#~ "`tarantoolctl`, нужно положить исходный код своего приложения в эту "
#~ "директорию или настроить симлинк. Далее для примеров в этом разделе мы "
#~ "используем Tarantool-приложение с именем ``my_app``, и его исходный код "
#~ "должен лежать в файле :samp:`{instance_dir}/my_app.lua`."

#~ msgid "Commands for tarantoolctl"
#~ msgstr "Команды для tarantoolctl"

#~ msgid ""
#~ "The command format is :samp:`tarantoolctl {operation} {application_name}`, "
#~ "where operation is one of: start, stop, enter, logrotate, status, eval. "
#~ "Thus ..."
#~ msgstr ""
#~ "Команды для :program:`tarantoolctl` имеют вид :samp:`tarantoolctl {операция} "
#~ "{имя_приложения}`. В качестве *операции* можно указать одно из следующих "
#~ "значений: start, stop, enter, logrotate, status, eval."

#~ msgid "Start application *<application>*"
#~ msgstr "Запустить приложение с именем *<application>*"

#~ msgid "Show application's admin console"
#~ msgstr "Вывести консоль для управления приложением"

#~ msgid "Check application's status"
#~ msgstr "Проверить статус приложения"

#~ msgid "Execute code from *<scriptname>* on an instance of application"
#~ msgstr ""
#~ "Выполнить код из файла *<scriptname>* от имени запущенного экземпляра "
#~ "приложения *<application>*"

#~ msgid "Typical code snippets for tarantoolctl"
#~ msgstr "Примеры кода для tarantoolctl"

#~ msgid "A user can check whether ``my_app`` is running with these lines:"
#~ msgstr "Проверить, запущено ли приложение ``my_app``:"

#~ msgid ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"
#~ msgstr ""
#~ "if tarantoolctl status my_app; then\n"
#~ "...\n"
#~ "fi"

#~ msgid ""
#~ "A user can initiate, for boot time, an :file:`init.d` set of instructions:"
#~ msgstr ""
#~ "Выполнить инструкции из файла :file:`init.d` во время запуска приложения:"

#~ msgid ""
#~ "for (each file mentioned in the instance_dir directory):\n"
#~ "    tarantoolctl start `basename $ file .lua`"
#~ msgstr ""
#~ "for (каждый файл в директории instance_dir):\n"
#~ "    tarantoolctl start `basename $ file .lua`"

#~ msgid ""
#~ "A user can set up a further configuration file for log rotation, like this:"
#~ msgstr "Указать файл конфигурации для ротации журнала, например:"

#~ msgid "A detailed example for tarantoolctl"
#~ msgstr "Подробный пример для tarantoolctl"

#~ msgid ""
#~ "The example's objective is to make a temporary directory where :program:"
#~ "`tarantoolctl` can start a long-running application and monitor it."
#~ msgstr ""
#~ "В этом примере мы создадим временную директорию, в которой :program:"
#~ "`tarantoolctl` сможет запускать и мониторить некое долго работающее "
#~ "приложение."

#~ msgid ""
#~ "The assumptions are: the root password is known, the computer is only being "
#~ "used for tests, the Tarantool server is ready to run but is not currently "
#~ "running, tarantoolctl is installed along the user's path, and there currently "
#~ "is no directory named :file:`tarantool_test`."
#~ msgstr ""
#~ "Итак, наши исходные условия: нам известен пароль root-пользователя; компьютер "
#~ "используется только для тестирования; Tarantool-сервер настроен и готов к "
#~ "запуску, но пока еще не запущен ;программа :program:`tarantoolctl` "
#~ "установлена в пользовательском окружении; пока не существует директории с "
#~ "именем :file:`tarantool_test`."

#~ msgid "Create a directory named :file:`/tarantool_test`:"
#~ msgstr "Создадим директорию с именем :file:`/tarantool_test`:"

#~ msgid ""
#~ "Edit :file:`/usr/local/etc/default/tarantool`. It might be necessary to say :"
#~ "samp:`sudo mkdir /usr/local/etc/default` first. Let the new file contents be:"
#~ msgstr ""
#~ "Отредактируем файл :file:`/usr/local/etc/default/tarantool`. Для этого нам "
#~ "сначала может понадобиться выполнить команду :samp:`sudo mkdir /usr/local/etc/"
#~ "default`. Указанный файл будет содержать следующие настройки:"

#~ msgid ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""
#~ msgstr ""
#~ "default_cfg = {\n"
#~ "    pid_file = \"/tarantool_test/my_app.pid\",\n"
#~ "    wal_dir = \"/tarantool_test\",\n"
#~ "    snap_dir = \"/tarantool_test\",\n"
#~ "    vinyl_dir = \"/tarantool_test\",\n"
#~ "    logger = \"/tarantool_test/log\",\n"
#~ "    username = \"tarantool\",\n"
#~ "}\n"
#~ "instance_dir = \"/tarantool_test\""

#~ msgid ""
#~ "Clean up. Restore the original contents of :file:`/usr/local/etc/default/"
#~ "tarantool`, and ..."
#~ msgstr ""
#~ "Почистим систему после тестирования. Приведем содержимое файла :file:`/usr/"
#~ "local/etc/default/tarantool` к исходному виду и удалим нашу тестовую "
#~ "директорию:"

#~ msgid ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"
#~ msgstr ""
#~ "$ cd /\n"
#~ "$ sudo rm -R tarantool_test"

#~ msgid "An example for tarantoolctl connect"
#~ msgstr "Подробный пример для tarantoolctl"

#~ msgid "$ tarantoolctl connect username:password@127.0.0.1:3306"
#~ msgstr "$ tarantoolctl connect username:password@127.0.0.1:3306"

#~ msgid ""
#~ "There are alternatives to :program:`tarantoolctl connect` -- you can use the :"
#~ "ref:`console module <console-module>` or the :ref:`net.box module <net_box-"
#~ "module>` from a Tarantool server. Also, you can write your client programs "
#~ "with any of the Connectors. However, most of the examples in this manual "
#~ "illustrate usage with either :program:`tarantoolctl connect` or with :ref:"
#~ "`using the Tarantool server as a client <administration-"
#~ "using_tarantool_as_a_client>`."
#~ msgstr ""
#~ "Вместо :program:`tarantoolctl connect` вы можете использовать модули :ref:"
#~ "`console <console-module>` или :ref:`net.box <net_box-module>` из библиотеки "
#~ "Tarantool'а. Еще одна альтернатива — это написать клиентскую программу под "
#~ "любой из существующих Tarantool-коннекторов. Но для большинства примеров в "
#~ "текущей документации мы используем :program:`tarantoolctl connect` или :ref:"
#~ "`Tarantool-сервер в качестве клиента <administration-"
#~ "using_tarantool_as_a_client>`."

#~ msgid "Administrative ports"
#~ msgstr "Служебные порты"

#~ msgid ""
#~ "\"Admin port\", \"admin console\", and \"text protocol\" all refer to the "
#~ "same thing: a connection which is set up with :ref:`console.listen(...) "
#~ "<console-listen>` for entry of requests by administrators."
#~ msgstr ""
#~ "Термины \"порт для администрирования\", \"консоль для администрирования\", "
#~ "\"текстовый протокол\" относятся к установке соединения с помощью :ref:"
#~ "`console.listen(...) <console-listen>` для ввода запросов от администраторов."

#~ msgid ""
#~ "\"Binary port\", \"binary protocol\", and \"primary port\" all refer to a "
#~ "different thing: a connection which is set up with :ref:`box.cfg{listen=...} "
#~ "<cfg_basic-listen>` for entry of requests by anyone."
#~ msgstr ""
#~ "Термины \"бинарный порт\", \"бинарный протокол\", \"первичный порт\" "
#~ "относятся к другому виду соединения — тому, что устанавливается с помощью "
#~ "параметра :ref:`box.cfg{listen=...} <cfg_basic-listen>` и предназначено для "
#~ "ввода запросов от любых пользователей."

#~ msgid ""
#~ "Ordinary connections to the Tarantool server should go via a binary port. But "
#~ "admin ports are useful for special cases involving security."
#~ msgstr ""
#~ "Для обычных соединений с Tarantool-сервером должен использоваться бинарный "
#~ "протокол. А порты для администрирования нужны для особых случаев, когда "
#~ "повышены требования к безопасности."

#~ msgid ""
#~ "if the listener has the privilege to write on :file:`/var/lib/tarantool` and "
#~ "the connector has the privilege to read on :file:`/var/lib/tarantool`. "
#~ "Alternatively both setup and connection can be done with :ref:`tarantoolctl "
#~ "<administration-tarantoolctl>`."
#~ msgstr ""
#~ "Это в том случае, если у сервера (listener'а) есть привилегии на запись в "
#~ "файл :file:`/var/lib/tarantool`, а на стороне клиента (connector'а) есть "
#~ "привилегии на чтение из того же файла. Аналогично можно установить соединение "
#~ "и задать настройки с помощью :ref:`tarantoolctl <administration-"
#~ "tarantoolctl>`."

#~ msgid ""
#~ "If no administrator password exists which could be given out to users, and "
#~ "admin ports are restricted or are sockets, then requests which require "
#~ "'admin' privileges can only occur locally, and are subject to Unix security "
#~ "and monitoring."
#~ msgstr ""
#~ "Если не задан пароль администратора, который можно сообщить пользователям, а "
#~ "порты для администрирования настроены с ограничением доступа по IP либо через "
#~ "сокеты, то запросы, требующие привилегий администратора, можно делать только "
#~ "локально, где вопросы безопасности и мониторинга регулируются с помощью "
#~ "средств Unix-системы."

#~ msgid ""
#~ "For additional security, some requests are illegal. For example, :ref:`\"conn:"
#~ "eval\" <net_box-eval>`  will result in the error message \"- error: console "
#~ "does not support this request type\" because ``conn:eval`` requires the "
#~ "binary protocol."
#~ msgstr ""
#~ "В целях дополнительной безопасности некоторые запросы на портах для "
#~ "администрирования запрещены. Например, :ref:`conn:eval <net_box-eval>` вернет "
#~ "сообщение об ошибке ``- error: console does not support this request type``, "
#~ "поскольку запрос ``conn:eval`` должен осуществляться в рамках бинарного "
#~ "протокола."

#~ msgid ""
#~ "If security via admin ports is not necessary, it is still possible to be an "
#~ "admin user by :ref:`using the tarantool server as a client <administration-"
#~ "using_tarantool_as_a_client>`, or by connecting to a binary port with a valid "
#~ "password."
#~ msgstr ""
#~ "Если вопросы безопасности на портах для администрирования неактуальны, то "
#~ "стать пользователем с правами администратора можно, :ref:`используя Tarantool-"
#~ "сервер в качестве клиента <administration-using_tarantool_as_a_client>` или "
#~ "указав администраторский пароль при установке соединения по бинарному "
#~ "протоколу."

#~ msgid "Administrative requests"
#~ msgstr "Служебные запросы"

#~ msgid ""
#~ "To set up replication, it's necessary to set up the master servers which make "
#~ "the original data-change requests, set up the replica servers which copy data-"
#~ "change requests from masters, and establish procedures for recovery from a "
#~ "degraded state."
#~ msgstr ""
#~ "Чтобы настроить репликацию, необходимо настроить главные сервера (master), "
#~ "которые первыми обрабатывают запросы на изменение данных, затем настроить "
#~ "сервера-реплики (replica), которые копируют к себе запросы на изменение "
#~ "данных с главных серверов, и прописать процедуры для восстановления после "
#~ "сбоя."

#~ msgid ""
#~ "A replica gets all updates from the master by continuously fetching and "
#~ "applying its write-ahead log (WAL). Each record in the WAL represents a "
#~ "single Tarantool data-change request such as INSERT or UPDATE or DELETE, and "
#~ "is assigned a monotonically growing log sequence number (LSN). In essence, "
#~ "Tarantool replication is row-based: each data change command is fully "
#~ "deterministic and operates on a single tuple."
#~ msgstr ""
#~ "Чтобы знать о всех изменениях на стороне главного сервера, каждая реплика "
#~ "непрерывно опрашивает главный сервер на предмет обновлений в его WAL-файле "
#~ "(write ahead log) и применяет эти обновления на своей стороне. Каждая запись "
#~ "в WAL-файле представляет собой один запрос на изменение данных (например, "
#~ "INSERT, UPDATE или DELETE) и присвоенный данной записи номер (LSN = log "
#~ "sequence number). Номера присваиваются в порядке возрастания. По сути, "
#~ "репликация в Tarantool'е является построчной: все команды на изменение данных "
#~ "полностью детерминированы, и каждая такая команда относится только к одному "
#~ "кортежу."

#~ msgid ""
#~ "A stored program invocation is not written to the write-ahead log. Instead, "
#~ "log events for actual data-change requests, performed by the Lua code, are "
#~ "written to the log. This ensures that possible non-determinism of Lua does "
#~ "not cause replication to go out of sync."
#~ msgstr ""
#~ "Вызовы хранимых Lua-процедур фиксируются не в WAL-файле, а в журнале событий "
#~ "(event log). Таким образом гарантируется, что не детерминированное поведение "
#~ "логики на Lua не приведет к рассинхронизации реплицированных данных."

#~ msgid ""
#~ "To prepare the master for connections from the replica, it's only necessary "
#~ "to include \":ref:`listen <cfg_basic-listen>`\" in the initial ``box.cfg`` "
#~ "request, for example ``box.cfg{listen=3301}``. A master with enabled \"listen"
#~ "\" URI can accept connections from as many replicas as necessary on that URI. "
#~ "Each replica has its own :ref:`replication state <index-"
#~ "monitoring_replica_actions>`."
#~ msgstr ""
#~ "Чтобы настроить возможность установки соединения для реплик, на стороне "
#~ "главного сервера требуется лишь указать значение для параметра \":ref:`listen "
#~ "<cfg_basic-listen>`\" в init-запросе ``box.cfg``. Например, ``box."
#~ "cfg{listen=3301}``. Когда URI для прослушивания задан, главный сервер готов "
#~ "принимать запросы на соединение от любого количества реплик. Каждая реплика "
#~ "при этом находится в некотором :ref:`статусе репликации <index-"
#~ "monitoring_replica_actions>`."

#~ msgid ""
#~ "A server requires a valid snapshot (.snap) file. A snapshot file is created "
#~ "for a server the first time that ``box.cfg`` occurs for it. If this first "
#~ "``box.cfg`` request occurs without a \"replication source\" clause, then the "
#~ "server is a master and starts its own new cluster with a new unique UUID. If "
#~ "this first ``box.cfg`` request occurs with a \"replication source\" clause, "
#~ "then the server is a replica and its snapshot file, along with the cluster "
#~ "information, is constructed from the write-ahead logs of the master. "
#~ "Therefore, to start replication, specify :ref:`replication_source "
#~ "<cfg_replication-replication_source>` in a ``box.cfg`` request. When a "
#~ "replica contacts a master for the first time, it becomes part of a cluster. "
#~ "On subsequent occasions, it should always contact a master in the same "
#~ "cluster."
#~ msgstr ""
#~ "Каждому Tarantool-серверу необходим корректный файл со статическим снимком "
#~ "данных (.snap-файл). Файл-снимок создается на сервере при первом запросе "
#~ "``box.cfg``. Если при первом таком запросе на сервере не определен источник "
#~ "репликации (replication source), то сервер стартует в режиме главного сервера "
#~ "и создает для себя новый кластер с новым уникальными UUID. Если же источник "
#~ "репликации при первом ``box.cfg``-запросе определен, то сервер стартует в "
#~ "режиме реплики, а файл-снимок и информация о кластере берутся из WAL-файлов "
#~ "на главном сервере. Поэтому при настройке репликации нужно указать параметр :"
#~ "ref:`replication_source <cfg_replication-replication_source>` в запросе ``box."
#~ "cfg``. При первом соединении с главным сервером сервер-реплика включается в "
#~ "состав кластера. В дальнейшем такая реплика общается только с главным "
#~ "сервером из данного кластера."

#~ msgid ""
#~ "Once connected to the master, the replica requests all changes that happened "
#~ "after the latest local LSN. It is therefore necessary to keep WAL files on "
#~ "the master host as long as there are replicas that haven't applied them yet. "
#~ "A replica can be \"re-seeded\" by deleting all its files (the snapshot .snap "
#~ "file and the WAL .xlog files), then starting replication again - the replica "
#~ "will then catch up with the master by retrieving all the master's tuples. "
#~ "Again, this procedure works only if the master's WAL files are present."
#~ msgstr ""
#~ "После установки соединения с главным сервером реплика запрашивает у него все "
#~ "изменения, чьи LSN-номера в WAL-файле больше номера последнего локального "
#~ "изменения на реплике. Поэтому WAL-файлы на главном сервере нужно хранить до "
#~ "тех пор, пока все реплики не применят изменения из этих WAL-файлов на своей "
#~ "стороне. Состояние реплики можно \"обнулить\", удалив все файлы репликации (."
#~ "snap-файл со снимком и .xlog-файлы с записями WAL) и запустив сервер снова. "
#~ "Реплика при этом возьмет все кортежи с главного сервера и придет в "
#~ "синхронизированное состояние. Обратите внимание, что такая процедура "
#~ "\"обнуления\" сработает, только если на главном сервере будут доступны все "
#~ "нужные WAL-файлы."

#~ msgid ""
#~ "However, once a master failure is detected, the recovery is simple: declare "
#~ "that the replica is now the new master, by saying :codenormal:`box.cfg{... "
#~ "listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. Then, if there are "
#~ "updates on the old master that were not propagated before the old master went "
#~ "down, they would have to be re-applied manually."
#~ msgstr ""
#~ "Но когда сбой уже обнаружен, процедура восстановления проста. Сначала нужно "
#~ "назначить одну из реплик на роль нового главного сервера, задав параметр :"
#~ "codenormal:`box.cfg{... listen=`:codeitalic:`URI <index-uri>`:codenormal:`}`. "
#~ "Затем, если на прежнем главном сервере остались изменения, которые не успели "
#~ "примениться на выбранной реплике перед сбоем, нужно применить эти изменения "
#~ "вручную."

#~ msgid "Quick startup of a new simple two-server cluster"
#~ msgstr ""
#~ "Инструкции по быстрому запуску простого кластера из двух серверов с нуля"

#~ msgid "Step 1. Start the first server thus:"
#~ msgstr "Шаг 1. Запустите первый сервер со следующими настройками:"

#~ msgid ""
#~ "box.cfg{listen = *uri#1*}\n"
#~ "-- replace with more restrictive request\n"
#~ "box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
#~ "box.snapshot()"
#~ msgstr ""
#~ "box.cfg{listen = *uri#1*}\n"
#~ "-- в этом запросе можно задать больше ограничений\n"
#~ "box.schema.user.grant('guest', 'read,write,execute', 'universe')\n"
#~ "box.snapshot()"

#~ msgid "... Now a new cluster exists."
#~ msgstr "... Итак, создался новый кластер."

#~ msgid ""
#~ "Step 2. Check where the second server's files will go by looking at its "
#~ "directories (:ref:`snap_dir <cfg_basic-snap_dir>` for snapshot files, :ref:"
#~ "`wal_dir <cfg_basic-wal_dir>` for .xlog files). They must be empty - when the "
#~ "second server joins for the first time, it has to be working with a clean "
#~ "state so that the initial copy of the first server's databases can happen "
#~ "without conflicts."
#~ msgstr ""
#~ "Шаг 2. На втором сервере проверьте пути, по которым будут храниться файлы "
#~ "репликации. Эти пути задаются в параметрах :ref:`snap_dir <cfg_basic-"
#~ "snap_dir>` (для .snap-файлов) и :ref:`wal_dir <cfg_basic-wal_dir>` (для .xlog-"
#~ "файлов). В указанных директориях должно быть пусто, чтобы не случилось "
#~ "конфликта с теми начальными данными, что придут с первого сервера, когда "
#~ "второй сервер присоединится к кластеру."

#~ msgid "Step 3. Start the second server thus:"
#~ msgstr "Step 3. Запустите второй сервер со следующими настройками:"

#~ msgid ""
#~ "box.cfg{\n"
#~ "  listen = *uri#2*,\n"
#~ "  replication_source = *uri#1*\n"
#~ "}"
#~ msgstr ""
#~ "box.cfg{\n"
#~ "  listen = *uri#2*,\n"
#~ "  replication_source = *uri#1*\n"
#~ "}"

#~ msgid ""
#~ "... where ``uri#1`` = the :ref:`URI <index-uri>` that the first server is "
#~ "listening on."
#~ msgstr ""
#~ "... где ``uri#1`` = :ref:`URI <index-uri>`, на котором включено прослушивание "
#~ "у первого сервера."

#~ msgid "That's all."
#~ msgstr "Вот и всё."

#~ msgid ""
#~ "In this configuration, the first server is the \"master\" and the second "
#~ "server is the \"replica\". Henceforth every change that happens on the master "
#~ "will be visible on the replica. A simple two-server cluster with the master "
#~ "on one computer and the replica on a different computer is very common and "
#~ "provides two benefits: FAILOVER (because if the master goes down then the "
#~ "replica can take over), or LOAD BALANCING (because clients can connect to "
#~ "either the master or the replica for select requests). Sometimes the replica "
#~ "may be configured with the additional parameter :ref:`read_only = true "
#~ "<cfg_basic-read_only>`."
#~ msgstr ""
#~ "В описанной выше конфигурации первый сервер выполняет роль \"главного\", а "
#~ "второй служит \"репликой\". Далее все изменения, происходящие на стороне "
#~ "главного сервера, будут доступны с реплики. Простой кластер из двух серверов, "
#~ "где главный сервер запущен на одном компьютере, а сервер-реплика — на другом, "
#~ "встречается очень часто и обладает двумя важными преимуществами: FAILOVER (т."
#~ "е. отказоустойчивость, поскольку в случае отключения главного сервера его "
#~ "место может занять сервер-реплика) и LOAD BALANCING (т.е. балансировка "
#~ "нагрузки, поскольку клиенты могут обращаться с SELECT-запросами как к "
#~ "главному серверу, так и к реплике). При необходимости в настройках реплики "
#~ "можно задать параметр :ref:`read_only = true <cfg_basic-read_only>`."

#~ msgid ""
#~ "In :ref:`box.info <box_introspection-box_info>` there is a ``box.info."
#~ "replication.status`` field: \"off\", \"stopped\", \"connecting\", \"auth\", "
#~ "\"follow\", or \"disconnected\". |br| If a replica's status is \"follow\", "
#~ "then there will be two more fields: |br| ``box.info.replication.idle`` = the "
#~ "number of seconds the replica has been idle, |br| ``box.info.replication."
#~ "lag`` = the number of seconds the replica is behind the master."
#~ msgstr ""
#~ "В пакете :ref:`box.info <box_introspection-box_info>` есть поле :code:`box."
#~ "info.replication.status`, которое отражает статус репликации для данной "
#~ "реплики: \"off\", \"stopped\", \"connecting\", \"auth\", \"follow\" или "
#~ "\"disconnected\". |br| Если реплика имеет статус \"follow\", то можно "
#~ "получить уточняющую информацию из еще двух полей: |br| :code:`box.info."
#~ "replication.idle` = время (в секундах), которое реплика провела в состоянии "
#~ "бездействия, |br| :code:`box.info.replication.lag` = время (в секундах), на "
#~ "которое реплика отстает от главного сервера."

#~ msgid ""
#~ "In the :ref:`log <log>` there is a record of replication activity. If a "
#~ "primary server is started with:"
#~ msgstr ""
#~ "В :ref:`журнале <log>` ведется запись о действиях, связанных с репликацией. "
#~ "Если главный сервер запущен со следующими настройками:"

#~ msgid ""
#~ "box.cfg{\n"
#~ "  <...>,\n"
#~ "  logger = *log file name*,\n"
#~ "  <...>\n"
#~ "}"
#~ msgstr ""
#~ "box.cfg{\n"
#~ "  <...>,\n"
#~ "  logger = *имя_файла_для_ведения_журнала*,\n"
#~ "  <...>\n"
#~ "}"

#~ msgid ""
#~ "then there will be lines in the log file, containing the word \"relay\", when "
#~ "a replica connects or disconnects."
#~ msgstr ""
#~ "то на каждую установку/потерю соединения реплики с главным сервером в журнале "
#~ "будут появляться строчки со словом \"relay\"."

#~ msgid ""
#~ "Suppose that the replica tries to do something that the master has already "
#~ "done. For example: |br| ``box.schema.space.create('X')`` |br| This would "
#~ "cause an error, \"Space X exists\". For this particular situation, the code "
#~ "could be changed to: |br| ``box.schema.space.create('X', "
#~ "{if_not_exists=true})`` |br| But there is a more general solution: the :samp:"
#~ "`box.once({key}, {function})` method. If ``box.once()`` has been called "
#~ "before with the same :samp:`{key}` value, then :samp:`{function}` is ignored; "
#~ "otherwise :samp:`{function}` is executed. Therefore, actions which should "
#~ "only occur once during the life of a replicated session should be placed in a "
#~ "function which is executed via ``box.once()``. For example:"
#~ msgstr ""
#~ "Предположим, что реплика пытается сделать нечто, что уже было сделано на "
#~ "главном сервере. Например: |br| :code:`box.schema.space.create('X')` |br| Это "
#~ "приведет к ошибке \"Space X exists\" (\"Пространство X уже существует\"). В "
#~ "данном частном случае можно скорректировать инструкцию следующим образом: |"
#~ "br| :code:`box.schema.space.create('X', {if_not_exists=true})` |br| Но "
#~ "существует и более общее решение: использовать метод :samp:`box.once({key}, "
#~ "{function})`. Если :code:`box.once()` был вызван ранее с тем же значением "
#~ "параметра :samp:`{key}`, то функция :samp:`{function}` игнорируется; в "
#~ "противном случае функция :samp:`{function}` будет выполнена. Поэтому "
#~ "действия, которые должны совершаться только один раз за время текущей сессии "
#~ "репликации, нужно помещать в функцию и вызывать ее с помощью метода :code:"
#~ "`box.once()`. Например:"

#~ msgid ""
#~ "function f()\n"
#~ "  box.schema.space.create('X')\n"
#~ "end\n"
#~ "box.once('space_creator', f)"
#~ msgstr ""
#~ "function f()\n"
#~ "  box.schema.space.create('X')\n"
#~ "end\n"
#~ "box.once('space_creator', f)"

#~ msgid ""
#~ "In the simple master-replica configuration, the master's changes are seen by "
#~ "the replica, but not vice versa, because the master was specified as the sole "
#~ "replication source. In the master-master configuration, also sometimes called "
#~ "multi-master configuration, it's possible to go both ways. Starting with the "
#~ "simple configuration, the first server has to say:"
#~ msgstr ""
#~ "В случае настройки репликации по схеме master-replica изменения на главном "
#~ "сервере доступны для просмотра с реплики, но не наоборот, потому как главный "
#~ "сервер в такой схеме указан в качестве единственного источника репликации. В "
#~ "случае схемы master-master (иногда ее также называет multi-master) просмотр "
#~ "изменений возможен в любом направлении. В простом случае (master-master с "
#~ "двумя серверами) на первом сервере нужно задать следующие настройки:"

#~ msgid "box.cfg{ replication_source = *uri#2* }"
#~ msgstr "box.cfg{ replication_source = *uri#2* }"

#~ msgid ""
#~ "In this configuration, both servers are \"masters\" and both servers are "
#~ "\"replicas\". Henceforth every change that happens on either server will be "
#~ "visible on the other. The failover benefit is still present, and the load-"
#~ "balancing benefit is enhanced (because clients can connect to either server "
#~ "for data-change requests as well as select requests)."
#~ msgstr ""
#~ "В данном примере оба сервера являются одновременно и \"главными\", и "
#~ "\"репликами\". Поэтому каждое изменение, которое случается на одном сервере, "
#~ "становится доступно для просмотра с другого сервера. Отказоустойчивость в "
#~ "такой конфигурации сохраняется, а возможности по балансировке нагрузки "
#~ "становятся еще шире (теперь клиенты могут обращаться к обоим серверам со "
#~ "всеми типами запросов — как на чтение данных, так и на изменение)."

#~ msgid ""
#~ "If two operations for the same tuple take place \"concurrently\" (which can "
#~ "involve a long interval because replication is asynchronous), and one of the "
#~ "operations is ``delete`` or ``replace``, there is a possibility that servers "
#~ "will end up with different contents."
#~ msgstr ""
#~ "Если две операции над одним и тем же кортежем производятся \"параллельно\" (а "
#~ "это может потребовать много времени, поскольку репликация — это асинхронный "
#~ "процесс), причем одна из операций — это ``delete``, а вторая — ``replace``, "
#~ "то существует вероятность, что данные на серверах станут различаться."

#~ msgid "All the \"What If?\" questions"
#~ msgstr "Ответы на вопросы \"Что если?\""

#~ msgid ""
#~ "Q: What if there are more than two servers with master-master? |br| A: On "
#~ "each server, specify the :ref:`replication_source <cfg_replication-"
#~ "replication_source>` for all the others. For example, server #3 would have a "
#~ "request: |br| :codenormal:`box.cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:"
#~ "`replication_source = {`:codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :"
#~ "codenormal:`}`"
#~ msgstr ""
#~ "Вопрос: Что если в кластере вида master-master более двух серверов? |br| "
#~ "Ответ: На каждом сервере нужно задать параметр :ref:`replication_source "
#~ "<cfg_replication-replication_source>` и указать в нем все остальные сервера. "
#~ "Например, для сервера #3 настройки будут следующими: |br| :codenormal:`box."
#~ "cfg{` |br| |nbsp| |nbsp| |nbsp| :codenormal:`replication_source = {`:"
#~ "codeitalic:`uri#1, uri#2`:codenormal:`}` |br| :codenormal:`}`"

#~ msgid ""
#~ "Q: What if a server should be taken out of the cluster? |br| A: For a "
#~ "replica, run ``box.cfg{}`` again specifying a blank replication source: |br| "
#~ "``box.cfg{replication_source=''}``"
#~ msgstr ""
#~ "Вопрос: Что если какой-то сервер нужно убрать из кластера? |br| Ответ: Для "
#~ "реплики — выполните запрос ``box.cfg{}``, указав пустой источник репликации: |"
#~ "br| ``box.cfg{replication_source=''}``"

#~ msgid ""
#~ "Q: What if two servers both change the same tuple? |br| A: The last changer "
#~ "wins. For example, suppose that server#1 changes the tuple, then server#2 "
#~ "changes the tuple. In that case server#2's change overrides whatever server#1 "
#~ "did. In order to keep track of who came last, Tarantool implements a `vector "
#~ "clock <https://en.wikipedia.org/wiki/Vector_clock>`_."
#~ msgstr ""
#~ "Вопрос: Что если два сервера совершают изменения, связанные с одним и тем же "
#~ "кортежем? |br| Ответ: Применятся последние из совершенных изменений. Для "
#~ "примера предположим, что сервер #1 меняет некоторый кортеж, а затем сервер #2 "
#~ "меняет тот же кортеж. В данном случае изменения сервера #2 затрут изменения "
#~ "сервера #1. Чтобы отслеживать, кто был последним, в Tarantool'е используются "
#~ "`векторные часы <https://en.wikipedia.org/wiki/Vector_clock>`_."

#~ msgid ""
#~ "Q: What if two servers both insert the same tuple? |br| A: If a master tries "
#~ "to insert a tuple which a replica has inserted already, this is an example of "
#~ "a severe error. Replication stops. It will have to be restarted manually."
#~ msgstr ""
#~ "Вопрос: Что если оба сервера выполняют вставку одного и того же кортежа? |br| "
#~ "Ответ: Если главный сервер попытается вставить кортеж, который уже был "
#~ "вставлен на реплике, то это будет пример серьезной ошибки. Репликация "
#~ "остановится, и ее придется перезапускать в ручную."

#~ msgid ""
#~ "Q: What if a master disappears and the replica must take over? |br| A: A "
#~ "message will appear on the replica stating that the connection is lost. The "
#~ "replica must now become independent, which can be done by saying ``box."
#~ "cfg{replication_source=''}``."
#~ msgstr ""
#~ "Вопрос: Что если главный сервер становится недоступен и пользователям "
#~ "приходится переключаться реплику? |br| Ответ: Реплика получает сообщение, что "
#~ "связь потеряна. Теперь реплика должна начать работать независимо. Для этого "
#~ "ей нужно задать пустой источник репликации, выполнив на стороне реплики "
#~ "запрос ``box.cfg{replication_source=''}``."

#~ msgid ""
#~ "Q: What if it's necessary to know what cluster a server is in? |br| A: The "
#~ "identification of the cluster is a UUID which is generated when the first "
#~ "master starts for the first time. This UUID is stored in a tuple of the :ref:"
#~ "`box.space._schema <box_space-schema>` system space. So to see it, say: ``box."
#~ "space._schema:select{'cluster'}``"
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, к какому кластеру принадлежит данный "
#~ "сервер? |br| Ответ: Идентификатором кластера является UUID, который "
#~ "генерируется при первом запуске главного сервера. Данный UUID хранится в "
#~ "системном пространстве :ref:`box.space._schema <box_space-schema>`. Чтобы "
#~ "посмотреть UUID кластера, введите запрос ``box.space._schema:select{'cluster'}"
#~ "``"

#~ msgid ""
#~ "Q: What if it's necessary to know what other servers belong in the cluster? |"
#~ "br| A: The universal identification of a server is a UUID in ``box.info."
#~ "server.uuid``. The ordinal identification of a server within a cluster is a "
#~ "number in ``box.info.server.id``. To see all the servers in the cluster, say: "
#~ "``box.space._cluster:select{}``. This will return a table with all {server."
#~ "id, server.uuid} tuples for every server that has ever joined the cluster."
#~ msgstr ""
#~ "Вопрос: Что если нужно посмотреть, какие сервера входят в кластер? |br| "
#~ "Ответ: У каждого сервера есть универсальный идентификатор — это его UUID в "
#~ "поле ``box.info.server.uuid``. Также у сервера есть его порядковый "
#~ "идентификатор в кластере — это номер в поле ``box.info.server.id``. Чтобы "
#~ "увидеть номера всех серверов в кластере, введите запрос: ``box.space._cluster:"
#~ "select{}``. Данный запрос возвращает таблицу со всеми кортежами вида {server."
#~ "id, server.uuid} для всех серверов, что когда-либо входили в данный кластер."

#~ msgid ""
#~ "Q: What if one of the server's files is corrupted or deleted? |br| A: Stop "
#~ "the server, destroy all the database files (the ones with extension \"snap\" "
#~ "or \"xlog\" or \".inprogress\"), restart the server, and catch up with the "
#~ "master by contacting it again (just say ``box.cfg{...replication_source=...}"
#~ "``)."
#~ msgstr ""
#~ "Вопрос: Что если какой-то из файлов репликации на реплике поврежден или "
#~ "удален? |br| Ответ: Нужно остановить сервер, удалить все файлы, относящиеся к "
#~ "базе данных (это файлы с расширениями \"snap\", \"xlog\" и \".inprogress\"), "
#~ "снова запустить сервер и ввести запрос ``box.cfg{...replication_source=...}"
#~ "``, чтобы восстановить соединение с главным сервером и загрузить данные с "
#~ "него."

#~ msgid ""
#~ "Q: What if replication causes security concerns? |br| A: Prevent unauthorized "
#~ "replication sources by associating a password with every user that has access "
#~ "privileges for the relevant spaces, and every user that has a replication :"
#~ "ref:`role <authentication-rep_role>`. That way, the :ref:`URI <index-uri>` "
#~ "for the :ref:`replication_source <cfg_replication-replication_source>` "
#~ "parameter will always have to have the long form |br| "
#~ "``replication_source='username:password@host:port'``"
#~ msgstr ""
#~ "Вопрос: Что если при репликации возникают вопросы, связанные с безопасностью? "
#~ "|br| Ответ: Чтобы предотвратить появление несанкционированных источников "
#~ "репликации, нужно задать пароль для каждого пользователя, у которого есть "
#~ "привилегии доступа к соответствующим пространствам, а также для каждого "
#~ "пользователя, у которого настроена :ref:`репликационная роль <authentication-"
#~ "rep_role>`. Заметьте, что :ref:`URI <index-uri>` для параметра :ref:"
#~ "`replication_source <cfg_replication-replication_source>` теперь нужно всегда "
#~ "указывать в полном виде: |br| ``replication_source='username:password@host:"
#~ "port'``"

#~ msgid ""
#~ "Q: What if advanced users want to understand better how it all works? |br| A: "
#~ "See the description of server startup with replication in the :ref:`Internals "
#~ "<b_internals-replication>` appendix."
#~ msgstr ""
#~ "Вопрос: Что если продвинутые пользователи хотят глубже разобраться с тем, как "
#~ "работает репликация? |br| Ответ: См. информацию о запуске сервера с "
#~ "репликацией в Приложении B. :ref:`Детали реализации <b_internals-"
#~ "replication>`."

#~ msgid "Hands-on replication tutorial"
#~ msgstr "Практическое руководство по репликации"

#~ msgid ""
#~ "After following the steps here, an administrator will have experience "
#~ "creating a cluster and adding a replica."
#~ msgstr ""
#~ "Ниже приводятся пошаговые инструкции, которые помогут вам получить "
#~ "практический опыт администрирования кластера, а именно опыт создания кластера "
#~ "и добавления реплики."

#~ msgid ""
#~ "Start two shells. Put them side by side on the screen. (This manual has a "
#~ "tabbed display showing \"Terminal #1\". Click the \"Terminal #2\" tab to "
#~ "switch to the display of the other shell.)"
#~ msgstr ""
#~ "Запустите два терминала, каждый в своем окне, и расположите их рядом на "
#~ "экране. (Далее в примерах оба терминала показаны в виде закладок. Щелкните на "
#~ "заголовок закладки — \"Terminal #1\" или \"Terminal #2\", — чтобы увидеть "
#~ "вывод на соответствующем терминале.)"

#~ msgid ""
#~ "On the first shell, which we'll call Terminal #1, execute these commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие команды:"

#~ msgid ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_1/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ # Terminal 1\n"
#~ "$ mkdir -p ~/tarantool_test_node_1\n"
#~ "$ cd ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_1/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
#~ "tarantool> box.schema.user."
#~ "grant('replicator','execute','role','replication')\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "The result is that a new cluster is set up, and the server's UUID is "
#~ "displayed. Now the screen looks like this: (except that UUID values are "
#~ "always different):"
#~ msgstr ""
#~ "В результате были заданы настройки нового кластера, а на экране был выведен "
#~ "UUID текущего сервера. Теперь вывод на экране выглядит следующим образом (за "
#~ "тем исключением, что UUID у вас будут другие):"

#~ msgid ""
#~ "On the second shell, which we'll call Terminal #2, execute these commands:"
#~ msgstr "Во втором терминале (Terminal #2) выполните следующие команды:"

#~ msgid ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ~/tarantool_test_node_2/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ # Terminal 2\n"
#~ "$ mkdir -p ~/tarantool_test_node_2\n"
#~ "$ cd ~/tarantool_test_node_2\n"
#~ "$ rm -R ~/tarantool_test_node_2/*\n"
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{\n"
#~ "         >   listen = 3302,\n"
#~ "         >   replication_source = 'replicator:password@localhost:3301'\n"
#~ "         > }\n"
#~ "tarantool> box.space._cluster:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "The result is that a replica is set up. Messages appear on Terminal #1 "
#~ "confirming that the replica has connected and that the WAL contents have been "
#~ "shipped to the replica. Messages appear on Terminal #2 showing that "
#~ "replication is starting. Also on Terminal#2 the _cluster UUID values are "
#~ "displayed, and one of them is the same as the _cluster UUID value that was "
#~ "displayed on Terminal #1, because both servers are in the same cluster."
#~ msgstr ""
#~ "В результате были заданы настройки сервера-реплики. На экране первого "
#~ "терминала (Terminal #1) появились сообщения с подтверждениями, что реплика "
#~ "установила соединение с главным сервером и что содержимое WAL-файла было "
#~ "отправлено на реплику. На экране второго терминала (Terminal #2) появились "
#~ "сообщения о том, что репликация начинается, а также там были выведены UUID из "
#~ "системного пространства _cluster (один из них совпадает с UUID в первом "
#~ "терминале, поскольку оба сервера входят в общий кластер)."

#~ msgid "On Terminal #1, execute these requests:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"
#~ msgstr ""
#~ "tarantool> s = box.schema.space.create('tester')\n"
#~ "tarantool> i = s:create_index('primary', {})\n"
#~ "tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}"

#~ msgid "Now the screen looks like this:"
#~ msgstr "Теперь вывод на экране выглядит следующим образом:"

#~ msgid ""
#~ "The creation and insertion were successful on Terminal #1. Nothing has "
#~ "happened on Terminal #2."
#~ msgstr ""
#~ "В первом терминале успешно отработали операции CREATE и INSERT. Но во втором "
#~ "терминале ничего не произошло."

#~ msgid "On Terminal #2, execute these requests:"
#~ msgstr "Во втором терминале (Terminal #2) выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"
#~ msgstr ""
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select({1}, {iterator = 'GE'})\n"
#~ "tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}"

#~ msgid ""
#~ "Now the screen looks like this (remember to click on the \"Terminal #2\" tab "
#~ "when looking at Terminal #2 results):"
#~ msgstr "Теперь вывод на экране выглядит следующим образом:"

#~ msgid ""
#~ "The selection and insertion were successful on Terminal #2. Nothing has "
#~ "happened on Terminal #1."
#~ msgstr ""
#~ "Во втором терминале успешно отработали операции SELECT и INSERT. Но в первом "
#~ "терминале ничего не произошло."

#~ msgid "On Terminal #1, execute these Tarantool requests and shell commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы и команды:"

#~ msgid ""
#~ "$ os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "$ ls -l ~/tarantool_test_node_2"
#~ msgstr ""
#~ "$ os.exit()\n"
#~ "$ ls -l ~/tarantool_test_node_1\n"
#~ "$ ls -l ~/tarantool_test_node_2"

#~ msgid ""
#~ "Now Tarantool #1 is stopped. Messages appear on Terminal #2 announcing that "
#~ "fact. The ``ls -l`` commands show that both servers have made snapshots, "
#~ "which have similar sizes because they both contain the same tuples."
#~ msgstr ""
#~ "Теперь Tarantool-сервер в первом терминале остановлен. В окне второго "
#~ "терминала появились сообщения об этом событии. С помощью команд ``ls -l`` мы "
#~ "убедились, что на обоих серверах создались файлы-снимки с одинаковыми "
#~ "размерами, поскольку там содержатся одни и те же кортежи."

#~ msgid "On Terminal #2, ignore the error messages, and execute these requests:"
#~ msgstr ""
#~ "Во втором терминале (Terminal #2) проигнорируйте сообщения об ошибках и "
#~ "выполните следующие запросы:"

#~ msgid ""
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}"
#~ msgstr ""
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
#~ "tarantool> box.space.tester:insert{3, 'Another'}"

#~ msgid "Now the screen looks like this (ignoring the error messages):"
#~ msgstr ""
#~ "Теперь вывод на экране выглядит следующим образом (сообщения об ошибках мы не "
#~ "приводим):"

#~ msgid ""
#~ "Terminal #2 has done a select and an insert, even though Terminal #1 is down."
#~ msgstr ""
#~ "Запросы SELECT и INSERT во втором терминале отработали несмотря на то, что "
#~ "сервер в первом терминале остановлен."

#~ msgid "On Terminal #1 execute these commands:"
#~ msgstr "В первом терминале (Terminal #1) выполните следующие запросы:"

#~ msgid ""
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "$ ~/tarantool/src/tarantool\n"
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "The master has reconnected to the cluster, and has NOT found what the replica "
#~ "wrote while the master was away. That is not a surprise -- the replica has "
#~ "not been asked to act as a replication source."
#~ msgstr ""
#~ "Главный сервер снова установил соединение с кластером и НЕ обнаружил "
#~ "изменения, сделанные репликой за время его недоступности. Это и не "
#~ "удивительно: мы же не просили реплику выступать в качестве источника "
#~ "репликации."

#~ msgid "On Terminal #1, say:"
#~ msgstr "В первом терминале (Terminal #1) введите:"

#~ msgid ""
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source = 'replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
#~ msgstr ""
#~ "tarantool> box.cfg{\n"
#~ "         >   replication_source = 'replicator:password@localhost:3302'\n"
#~ "         > }\n"
#~ "tarantool> box.space.tester:select({0}, {iterator = 'GE'})"

#~ msgid ""
#~ "This shows that the two servers are once again in synch, and that each server "
#~ "sees what the other server wrote."
#~ msgstr ""
#~ "Тут мы видим, что оба сервера снова синхронизовались и что каждый из них "
#~ "видит те записи, которые сделал другой."

#~ msgid ""
#~ "To clean up, say \"``os.exit()``\" on both Terminal #1 and Terminal #2, and "
#~ "then on either terminal say:"
#~ msgstr ""
#~ "Чтобы удалить все тестовые данные, выполните \"``os.exit()``\" на обоих "
#~ "терминалах, а затем на каждом из них выполните следующие команды:"

#~ msgid ""
#~ "$ cd ~\n"
#~ "$ rm -R ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_2"
#~ msgstr ""
#~ "$ cd ~\n"
#~ "$ rm -R ~/tarantool_test_node_1\n"
#~ "$ rm -R ~/tarantool_test_node_2"

#~ msgid ""
#~ "The exact procedure for backing up a database depends on: how up-to-date the "
#~ "database must be, how frequently backups must be taken, whether it is okay to "
#~ "disrupt other users, and whether the procedure should be optimized for size "
#~ "(saving disk space) or for speed (saving time). So there is a spectrum of "
#~ "possible policies, ranging from cold-and-simple to hot-and-difficult."
#~ msgstr ""
#~ "При выборе конкретной процедуры для резервного копирования базы данных нужно "
#~ "учитывать следующие требования: насколько актуальной должна быть копия, можно "
#~ "ли временно отключать других пользователей, а также нужна ли оптимизация "
#~ "размера копии (чтобы копия занимала меньше места на диске) или скорости самой "
#~ "процедуры (чтобы процедура занимала меньше времени). Выбирать можно из "
#~ "нескольких вариантов в диапазоне от \"простого и холодного\" до \"трудного и "
#~ "горячего\"."

#~ msgid "Cold backup"
#~ msgstr "**\"Холодное\" резервирование**"

#~ msgid ""
#~ "Prevent all users from writing to the database. This can be done by shutting "
#~ "down the server, or by saying ``box.cfg{read_only=true}`` and then ensuring "
#~ "that all earlier writes are complete (:program:`fsync` can be used for this "
#~ "purpose)."
#~ msgstr ""
#~ "Временно запретите всем пользователям делать записи в базе. Для этого можно "
#~ "остановить Tarantool-сервер, либо ввести запрос ``box.cfg{read_only=true}`` и "
#~ "убедиться, что все обращения на запись завершились (для этого можно "
#~ "использовать :program:`fsync`)."

#~ msgid "If this is a backup of the whole database, say :samp:`box.snapshot()`."
#~ msgstr ""
#~ "Если вы хотите создать резеврную копию для всей базы целиком, введите запрос :"
#~ "samp:`box.snapshot()`."

#~ msgid ""
#~ "In essence: :ref:`replication <index-box_replication>` is useful for backup "
#~ "as well as for load balancing. Therefore taking a backup is a matter of "
#~ "ensuring that any given replica is up to date, and doing a cold backup on it. "
#~ "Since all the other replicas continue to operate, this is not a cold backup "
#~ "from the end user's point of view. This could be done on a regular basis, "
#~ "with a cron job or with a Tarantool fiber."
#~ msgstr ""
#~ "Суть процедуры: для резервирования (а также для балансирования нагрузки) "
#~ "можно использовать :ref:`репликацию <index-box_replication>`. Процедура "
#~ "резервирования в рамках репликационного кластера сводится к тому, чтобы "
#~ "держать все реплики в актуальном состоянии и периодически делать с них "
#~ "\"холодные\" копии. Поскольку во время снятия копии с какой-либо одной "
#~ "реплики все остальные реплики продолжают синхронизироваться с главным "
#~ "сервером, то эта процедура несколько отличается от описанной выше процедуры "
#~ "\"холодного\" резервирования. Регулярное резервирование в кластере можно "
#~ "настроить с помощью планировщика :program:`cron` или Tarantool-файбера."

#~ msgid ""
#~ "First, put your application's business logic in a Tarantool-Lua module that "
#~ "exports its functions for CALL."
#~ msgstr ""
#~ "Во-первых, вынесите всю бизнес-логику своего приложения в отдельный Tarantool-"
#~ "модуль на языке Lua так, чтобы все нужные функции были доступны для вызова "
#~ "извне (CALL)."

#~ msgid "For example, :file:`/usr/share/tarantool/myapp.lua`:"
#~ msgstr "Вот пример такого модуля, файл :file:`/usr/share/tarantool/myapp.lua`:"

#~ msgid ""
#~ "local function start()\n"
#~ "  -- Initial version\n"
#~ "  box.once(\"myapp:.1.0\", function()\n"
#~ "  box.schema.space.create(\"somedata\")\n"
#~ "  box.space.somedata:create_index(\"primary\")\n"
#~ "  ...\n"
#~ "\n"
#~ "  -- migration code from 1.0 to 1.1\n"
#~ "  box.once(\"myapp:.v1.1\", function()\n"
#~ "  box.space.somedata.index.primary:alter(...)\n"
#~ "  ...\n"
#~ "\n"
#~ "  -- migration code from 1.1 to 1.2\n"
#~ "  box.once(\"myapp:.v1.2\", function()\n"
#~ "  box.space.somedata.space:alter(...)\n"
#~ "  box.space.somedata:insert(...)\n"
#~ "  ...\n"
#~ "end\n"
#~ "\n"
#~ "-- start some background fibers if you need\n"
#~ "\n"
#~ "local function stop()\n"
#~ "  -- stop all background fibers and cleanup resources\n"
#~ "end\n"
#~ "\n"
#~ "local function api_for_call(xxx)\n"
#~ "  -- do some business\n"
#~ "end\n"
#~ "\n"
#~ "return {\n"
#~ "  start = start;\n"
#~ "  stop = stop;\n"
#~ "  api_for_call = api_for_call;\n"
#~ "}"
#~ msgstr ""
#~ "local function start()\n"
#~ "-- Первоначальная версия\n"
#~ "box.once(\"myapp:.1.0\", function()\n"
#~ "box.schema.space.create(\"somedata\")\n"
#~ "box.space.somedata:create_index(\"primary\")\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Код для миграции с 1.0 на 1.1\n"
#~ "box.once(\"myapp:.v1.1\", function()\n"
#~ "box.space.somedata.index.primary:alter(...)\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Код для миграции с 1.1 на 1.2\n"
#~ "box.once(\"myapp:.v1.2\", function()\n"
#~ "box.space.somedata.space:alter(...)\n"
#~ "box.space.somedata:insert(...)\n"
#~ "...\n"
#~ "end\n"
#~ "\n"
#~ "-- Если нужно, запустить файберы в фоновом режиме\n"
#~ "\n"
#~ "local function stop()\n"
#~ "-- Остановить все фоновые файберы и освободить ресурсы\n"
#~ "end\n"
#~ "\n"
#~ "local function api_for_call(xxx)\n"
#~ "-- Сделать что-то полезное\n"
#~ "end\n"
#~ "\n"
#~ "return {\n"
#~ "start = start;\n"
#~ "stop = stop;\n"
#~ "api_for_call = api_for_call;\n"
#~ "}"

#~ msgid ""
#~ "This file is maintained by the application's developers. On its side, "
#~ "Tarantool Team provides templates for you to `assemble deb/rpm packages "
#~ "<https://github.com/tarantool/modulekit>`_ and utilities to quickly `assemble "
#~ "packages for specific platforms <https://github.com/tarantool/build>`_. If "
#~ "needed, you can split applications into standalone files and/or modules."
#~ msgstr ""
#~ "Поддержка этого файла лежит на стороне разработчиков приложения. А команда "
#~ "разработки Tarantool'а со своей стороны предлагает шаблоны, для того чтобы вы "
#~ "могли `создать у себя deb/rpm-сборку <https://github.com/tarantool/"
#~ "modulekit>`_, а также утилиты для быстрого `создания сборок под разные "
#~ "платформы <https://github.com/tarantool/build>`_. Если понадобится, вы можете "
#~ "разбить приложения на отдельные файлы и/или модули."

#~ msgid ""
#~ "Second, put an initialization script to the :file:`/etc/tarantool/instances."
#~ "available` directory."
#~ msgstr ""
#~ "Во вторых, положите скрипт инициализации в директорию :file:`/etc/tarantool/"
#~ "instances.available`."

#~ msgid "For example, :file:`/etc/tarantool/instances.available/myappcfg.lua`:"
#~ msgstr ""
#~ "Вот пример такого скрипта, файл :file:`/etc/tarantool/instances.available/"
#~ "myappcfg.lua`:"

#~ msgid ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "  listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "  -- hot code reload using tarantoolctl or dofile()\n"
#~ "\n"
#~ "  -- unload old application\n"
#~ "  myapp.stop()\n"
#~ "  -- clear cache for loaded modules and dependencies\n"
#~ "  package.loaded['myapp'] = nil\n"
#~ "  package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- load a new version of app and all dependencies\n"
#~ "myapp = require('myapp').start({some app options controlled by sysadmins})"
#~ msgstr ""
#~ "#!/usr/bin/env tarantool\n"
#~ "\n"
#~ "box.cfg {\n"
#~ "listen = 3301;\n"
#~ "}\n"
#~ "\n"
#~ "if myapp ~= nil then\n"
#~ "-- \"Горячая\" загрузка кода с помощью tarantoolctl или dofile()\n"
#~ "\n"
#~ "-- Выгрузка старого приложения\n"
#~ "myapp.stop()\n"
#~ "-- Очистка кеша от загруженных модулей и зависимостей\n"
#~ "package.loaded['myapp'] = nil\n"
#~ "package.loaded['somedep'] = nil; -- dependency of 'myapp'\n"
#~ "end\n"
#~ "\n"
#~ "-- Загрузка новой версии приложения и всех зависимостей\n"
#~ "myapp = require('myapp').start({some app options controlled by sysadmins})"

#~ msgid ""
#~ "As a more detailed example, you can take the :file:`example.lua` script that "
#~ "ships with Tarantool and defines all configuration options."
#~ msgstr ""
#~ "Более детальный пример (со всеми настройками) содержится в файле :file:"
#~ "`example.lua`, который входит в состав дистрибутива Tarantool'а."

#~ msgid ""
#~ "This initialization script is actually a configuration file and should be "
#~ "maintained by system administrators, while developers only provide a template."
#~ msgstr ""
#~ "Этот скрипт инициализации по сути является конфигурационным файлом. Его "
#~ "поддержкой должны заниматься системные администраторы, в то время как "
#~ "разработчики только предоставляют им шаблон."

#~ msgid ""
#~ "Now update your app file in :file:`/usr/share/tarantool`. Replace your "
#~ "application file (for example, :file:`/usr/share/tarantool/myapp.lua`) and "
#~ "manually reload the :file:`myappcfg.lua` initialization script using :program:"
#~ "`tarantoolctl`:"
#~ msgstr ""
#~ "Теперь обновите файл с вашим приложением в директории :file:`/usr/share/"
#~ "tarantool`. Замените старую версию файла (например, :file:`/usr/share/"
#~ "tarantool/myapp.lua`) и вручную загрузите скрипт инициализации :file:"
#~ "`myappcfg.lua` с помощью утилиты :program:`tarantoolctl`:"

#~ msgid ""
#~ "After that, you need to manually flush the cache of ``package.loaded`` "
#~ "modules."
#~ msgstr "После этого вам нужно вручную очистить кеш модулей ``package.loaded``."

#~ msgid ""
#~ "For deb/rpm packages, you can add the ``tarantoolctl eval`` instruction "
#~ "directly into Tarantool's specification in :file:`RPM.spec` and the :file:`/"
#~ "debian` directory."
#~ msgstr ""
#~ "Чтобы создать deb/rpm-сборку, вы можете добавить инструкцию ``tarantoolctl "
#~ "eval`` прямо в спецификацию Tarantool'а в файле :file:`RPM.spec` и в "
#~ "директории :file:`/debian`."

#~ msgid ""
#~ "Finally, clients make a CALL to ``myapp.api_for_call`` and other API "
#~ "functions."
#~ msgstr ""
#~ "В итоге клиенты делают вызов (CALL) функции ``myapp.api_for_call`` и других "
#~ "функций из API."

#~ msgid ""
#~ "In the case of ``tarantool-http``, there is no need to start the binary "
#~ "protocol at all."
#~ msgstr ""
#~ "Если вы используете ``tarantool-http``, то запускать бинарный протокол не "
#~ "нужно."

#~ msgid ""
#~ "This information applies for users who created databases with older versions "
#~ "of the Tarantool server, and have now installed a newer version. The request "
#~ "to make in this case is: :samp:`box.schema.upgrade()`."
#~ msgstr ""
#~ "Эта информация полезна в том случае, если у вас есть база данных, работающая "
#~ "на какой-либо старой версии Tarantool'а, а теперь вы установили Tarantool "
#~ "новой версии. В этом случае выполните запрос :samp:`box.schema.upgrade()`."

#~ msgid "SIGINT"
#~ msgstr "SIGINT"

#~ msgid ""
#~ "Other signals will result in behavior defined by the operating system. "
#~ "Signals other than SIGKILL may be ignored, especially if the server is "
#~ "executing a long-running procedure which prevents return to the main thread "
#~ "event loop."
#~ msgstr ""
#~ "Действие других сигналов определяется операционной системой. Все сигналы, "
#~ "кроме SIGKILL, могут быть проигнорированы, особенно если Tarantool-сервер "
#~ "выполняет длительную процедуру, которая позволяет вернуться к главному циклу."

#~ msgid "Process title"
#~ msgstr "Название процесса"

#~ msgid ""
#~ "Linux and FreeBSD operating systems allow a running process to modify its "
#~ "title, which otherwise contains the program name. Tarantool uses this feature "
#~ "to help meet the needs of system administration, such as figuring out what "
#~ "services are running on a host, their status, and so on."
#~ msgstr ""
#~ "Операционные системы Linux и FreeBSD позволяют запущенному процессу менять "
#~ "его название (title), в котором изначально содержится имя программы (name). "
#~ "Tarantool использует эту возможность, чтобы упростить работу системного "
#~ "администратора, например посмотреть, какие службы запущены на хосте, их "
#~ "статус и т.д."

#~ msgid "A Tarantool server's process title has these components:"
#~ msgstr "Название процесса Tarantool-сервера состоит из следующих частей:"

#~ msgid ""
#~ ":extsamp:`{**{program_name}**} [{**{initialization_file_name}**}] "
#~ "{**{<role_name>}**} [{**{custom_proc_title}**}]`"
#~ msgstr ""
#~ ":extsamp:`{**{имя_программы}**} [{**{имя_файла_инициализации}**}] "
#~ "{**{<имя_роли>}**} [{**{название_процесса}**}]`"

#~ msgid "**program_name** is typically \"tarantool\"."
#~ msgstr "**имя_программы** — это, как правило, \"tarantool\"."

#~ msgid ""
#~ "**initialization_file_name** is the name of an :ref:`initialization file "
#~ "<index-init_label>`, if one was specified."
#~ msgstr ""
#~ "**имя_файла_инициализации** — это имя  :ref:`файла инициализации на Lua "
#~ "<index-init_label>`, если этот файл был указан при запуске."

#~ msgid "**role_name** is:"
#~ msgstr "**имя_роли** — это может быть один из следующих вариантов:"

#~ msgid "\"running\" (ordinary node \"ready to accept requests\"),"
#~ msgstr "\"running\" (узел находится в режиме \"готов к принятию запросов\"),"

#~ msgid "\"loading\" (ordinary node recovering from old snap and wal files),"
#~ msgstr ""
#~ "\"loading\" (узел, который загружает данные из ранее сохраненного снимка и "
#~ "WAL-файла),"

#~ msgid "\"orphan\" (not in a cluster),"
#~ msgstr "\"orphan\" (узел не входит в состав кластера),"

#~ msgid "\"dumper\" + process-id (saving a snapshot)."
#~ msgstr "\"dumper\" + process-id (идет сохранение снимка)."

#~ msgid ""
#~ "**custom_proc_title** is taken from the :ref:`custom_proc_title <cfg_basic-"
#~ "custom_proc_title>` configuration parameter, if one was specified."
#~ msgstr ""
#~ "**название_процесса** — это необязательное название Tarantool-процесса в "
#~ "системе, которое берется из конфигурационного параметра :ref:"
#~ "`custom_proc_title <cfg_basic-custom_proc_title>`, если он указан."

#~ msgid ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"
#~ msgstr ""
#~ "$ ps -AF | grep tarantool\n"
#~ "1000     17337 16716  1 91362  6916   0 11:07 pts/5    00:00:13 tarantool "
#~ "script.lua <running>"

#~ msgid "System-specific administration notes"
#~ msgstr "Заметки по администрированию для разных платформ"

#~ msgid ""
#~ "This section will contain information about issues or features which exist on "
#~ "some platforms but not others - for example, on certain versions of a "
#~ "particular Linux distribution."
#~ msgstr ""
#~ "В этом разделе приводится информация по проблемам и особенностям, которые "
#~ "относятся только к конкретным платформам. Например, к определенным версиям "
#~ "Linux-систем."

#~ msgid "Debian GNU/Linux and Ubuntu"
#~ msgstr "Debian GNU/Linux and Ubuntu"

#~ msgid ""
#~ "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
#~ "instances.enabled/"
#~ msgstr ""
#~ "$ ln -s /etc/tarantool/instances.available/*instance-name.cfg* /etc/tarantool/"
#~ "instances.enabled/"

#~ msgid "Starting all instances:"
#~ msgstr "Запуск всех экземпляров:"

#~ msgid "$ service tarantool start"
#~ msgstr "$ service tarantool start"

#~ msgid "$ service tarantool stop"
#~ msgstr "$ service tarantool stop"

#~ msgid "$ service tarantool-instance-name start/stop"
#~ msgstr "$ service tarantool-instance-name start/stop"

#~ msgid "Fedora, RHEL, CentOS"
#~ msgstr "Fedora, RHEL, CentOS"

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"RHEL\" or \"CentOS\" or "
#~ "\"Fedora\" or \"Red Hat\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"RHEL\", \"CentOS\", \"Fedora\" или \"Red Hat\"."

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"FreeBSD\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данной платформы нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"FreeBSD\"."

#~ msgid "Mac OS X"
#~ msgstr "Mac OS X"

#~ msgid ""
#~ "There are no known permanent issues. For transient issues, go to http://"
#~ "github.com/tarantool/tarantool/issues and enter \"OS X\" in the search box."
#~ msgstr ""
#~ "Известных воспроизводящихся дефектов для данных платформ нет. Если вы "
#~ "столкнулись с плавающим дефектом, посмотрите описания проблем на странице "
#~ "http://github.com/tarantool/tarantool/issues, введя в строке поиска слово "
#~ "\"OS X\"."

#~ msgid ""
#~ "Tarantool fully supports :program:`systemd` for managing instances and "
#~ "supervising database daemons."
#~ msgstr ""
#~ "Tarantool полностью поддерживает работу с :program:`systemd` как со средством "
#~ "для управления экземплярами и контроля за фоновыми программами базы данных."

#~ msgid ""
#~ "Tarantool was designed to have multiple running instances of Tarantool on the "
#~ "same machine. Use :samp:`systemctl {start|stop|restart|status} tarantool@"
#~ "${MYAPP}` to manage your databases and Lua applications."
#~ msgstr ""
#~ "В архитектуре Tarantool'а заложена возможность запуска сразу многих "
#~ "экземпляров Tarantool-сервера на одной машине. С помощью :samp:`systemctl "
#~ "{start|stop|restart|status} tarantool@${MYAPP}` можно управлять базами данных "
#~ "и Lua-приложениями."

#~ msgid ""
#~ "Simply put your Lua configuration to :file:`/etc/tarantool/instances."
#~ "available/${MYAPP}.lua`:"
#~ msgstr ""
#~ "Задайте все настройки в виде Lua-скрипта и поместите их в файл :file:`/etc/"
#~ "tarantool/instances.available/${MYAPP}.lua`:"

#~ msgid ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"
#~ msgstr ""
#~ "box.cfg{listen = 3313}\n"
#~ "require('myappcode').start()"

#~ msgid "(this minimal example is sufficient)."
#~ msgstr "(это пример минимально достаточной конфигурации)."

#~ msgid ""
#~ "Another starting point could be the :file:`example.lua` script that ships "
#~ "with Tarantool and defines all options."
#~ msgstr ""
#~ "Также вы можете посмотреть пример Lua-скрипт в файле :file:`example.lua`, "
#~ "который входит в состав дистрибутива Tarantool'а и содержит значения всех "
#~ "опций."

#~ msgid ""
#~ "Use :samp:`systemctl start tarantool@${MYAPP}` to start ``${MYAPP}`` instance:"
#~ msgstr ""
#~ "Для запуска экземпляра ``${MYAPP}`` выполните команду :samp:`systemctl start "
#~ "tarantool@${MYAPP}`:"

#~ msgid "Monitoring instances"
#~ msgstr "Мониторинг экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl status tarantool@${MYAPP}` to check information about ``"
#~ "${MYAPP}`` instance:"
#~ msgstr ""
#~ "Для проверки информации об экземпляре ``${MYAPP}`` выполните команду :samp:"
#~ "`systemctl status tarantool@${MYAPP}`:"

#~ msgid "Use :samp:`journalctl -u tarantool@${MYAPP}` to check the boot log:"
#~ msgstr ""
#~ "Для проверки журнала загрузки выполните команду :samp:`journalctl -u "
#~ "tarantool@${MYAPP}`:"

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> 1 + 1\n"
#~ "---\n"
#~ "- 2\n"
#~ "...\n"
#~ "unix/:/var/run/tarantool/example.control>"

#~ msgid "Checking logs"
#~ msgstr "Проверка журнала"

#~ msgid ""
#~ "Tarantool logs important events to :file:`/var/log/tarantool/${MYAPP}.log`."
#~ msgstr ""
#~ "Tarantool ведет записи о важных событиях в файле :file:`/var/log/tarantool/"
#~ "${MYAPP}.log`."

#~ msgid ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
#~ "README.systemd readers\")\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('log').info(\"Hello for "
#~ "README.systemd readers\")\n"
#~ "---\n"
#~ "..."

#~ msgid ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
#~ "requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
#~ "tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
#~ "UNIX socket: /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
#~ "started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
#~ "systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
#~ "disconnected"
#~ msgstr ""
#~ "$ tail /var/log/tarantool/example.log\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: started\n"
#~ "2016-01-21 21:09:45.982 [5914] iproto I> binary: bound to 0.0.0.0:3301\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/tarantoolctl I> ready to accept "
#~ "requests\n"
#~ "2016-01-21 21:09:45.983 [5914] main/101/example I> Run console at /var/run/"
#~ "tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/101/example I> tcp_server: remove dead "
#~ "UNIX socket: /var/run/tarantool/example.control\n"
#~ "2016-01-21 21:09:45.984 [5914] main/104/console/unix/:/var/run/tarant I> "
#~ "started\n"
#~ "2016-01-21 21:09:45.985 [5914] main C> entering the event loop\n"
#~ "2016-01-21 21:14:43.320 [5914] main/105/console/unix/: I> client unix/: "
#~ "connected\n"
#~ "2016-01-21 21:15:07.115 [5914] main/105/console/unix/: I> Hello for README."
#~ "systemd readers\n"
#~ "2016-01-21 21:15:09.250 [5914] main/105/console/unix/: I> client unix/: "
#~ "disconnected"

#~ msgid ""
#~ "Log rotation is enabled by default if you have :program:`logrotate` "
#~ "installed. Please configure :file:`/etc/logrotate.d/tarantool` to change the "
#~ "default behavior."
#~ msgstr ""
#~ "Для ротации журнала нужно установить программу :program:`logrotate`. "
#~ "Настройки для ротации можно задать в файле :file:`/etc/logrotate.d/tarantool`."

#~ msgid "Stopping instances"
#~ msgstr "Остановка экземпляров"

#~ msgid ""
#~ "Use :samp:`systemctl stop tarantool@${MYAPP}` to see information about the "
#~ "running ``${MYAPP}`` instance."
#~ msgstr ""
#~ "Для просмотра информации о запущенном экземпляре ``${MYAPP}`` выполните "
#~ "команду :samp:`systemctl stop tarantool@${MYAPP}`."

#~ msgid ""
#~ "All instances are automatically restarted by :program:`systemd` in case of "
#~ "failure."
#~ msgstr ""
#~ "Если какой-либо экземпляр Tarantool-сервера выходит из строя, :program:"
#~ "`systemd` автоматически перезапускает его."

#~ msgid "Let's try to destroy an instance:"
#~ msgstr "Давайте попробуем вывести из строя один экземпляр:"

#~ msgid ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"
#~ msgstr ""
#~ "$ systemctl status tarantool@example|grep PID\n"
#~ "Main PID: 5885 (tarantool)\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> os.exit(-1)\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"

#~ msgid "Customizing the service file"
#~ msgstr "Правка настроек сервисного файла"

#~ msgid ""
#~ "Please don't modify the :file:`tarantool@.service` file in-place, because it "
#~ "will be overwritten during package upgrades. It is recommended to copy this "
#~ "file to :file:`/etc/systemd/system` and then modify the required settings. "
#~ "Alternatively, you can create a directory named :file:`unit.d/` within :file:"
#~ "`/etc/systemd/system` and put there a drop-in file :file:`name.conf` that "
#~ "only changes the required settings. Please see ``systemd.unit(5)`` manual "
#~ "page for additional information."
#~ msgstr ""
#~ "Пожалуйста, не редактируйте файл :file:`tarantool@.service` по месту, "
#~ "поскольку все ваши изменения будут перезаписаны при последующих обновлениях "
#~ "Tarantool'а. Мы рекомендуем скопировать этот файл в :file:`/etc/systemd/"
#~ "system` и править настройки уже в копии. Либо вы можете создать поддиректорию "
#~ "с именем :file:`unit.d/` в директории :file:`/etc/systemd/system` и положить "
#~ "туда drop-in файл с именем :file:`name.conf`, в котором будут указаны только "
#~ "те настройки, которые нужно поменять. См. подробности в ``systemd.unit(5)``."

#~ msgid ""
#~ "$ # !!! please never do this on the production system !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] "
#~ "= 48\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"
#~ msgstr ""
#~ "$ # !!! ВНИМАНИЕ: никогда не делайте этого\n"
#~ "  # в условиях промышленной эксплуатации !!!\n"
#~ "$ tarantoolctl enter example\n"
#~ "/bin/tarantoolctl: Found example.lua in /etc/tarantool/instances.available\n"
#~ "/bin/tarantoolctl: Connecting to /var/run/tarantool/example.control\n"
#~ "/bin/tarantoolctl: connected to unix/:/var/run/tarantool/example.control\n"
#~ "unix/:/var/run/tarantool/example.control> require('ffi').cast('char *', 0)[0] "
#~ "= 48\n"
#~ "/bin/tarantoolctl: unix/:/var/run/tarantool/example.control: Remote host "
#~ "closed connection"

#~ msgid ""
#~ ":samp:`coredumpctl list /usr/bin/tarantool` displays the latest crashes of "
#~ "the Tarantool daemon:"
#~ msgstr ""
#~ "Введем :samp:`coredumpctl list /usr/bin/tarantool`, чтобы получить отчет о "
#~ "последних аварийных завершениях Tarantool-демона:"

#~ msgid ":samp:`coredumpctl gdb <pid>` starts :program:`gdb` on the core dump."
#~ msgstr ""
#~ "Далее с помощью команды :samp:`coredumpctl gdb <pid>` запустим отладчик :"
#~ "program:`gdb` и подадим сохраненный дамп памяти ему на вход."

#~ msgid ""
#~ "For additional information, please refer to the documentation provided with "
#~ "your Linux distribution."
#~ msgstr "Дополнительно см. документацию по вашей Linux-системе."

#~ msgid "Precautions"
#~ msgstr "Особые указания"

#~ msgid ""
#~ "Please don't use ``tarantoolctl {start,stop,restart}`` to control instances "
#~ "started by :program:`systemd`. It is still possible to use :program:"
#~ "`tarantoolctl` to start and stop instances from your local directories (e.g. :"
#~ "file:`${HOME}`) without obtaining ``ROOT`` access."
#~ msgstr ""
#~ "Пожалуйста, не используйте ``tarantoolctl {start,stop,restart}`` для "
#~ "управления экземплярами, которые были запущены с помощью :program:`systemd`. "
#~ "Но вы можете использовать :program:`tarantoolctl` для запуска/остановки "
#~ "экземпляров в ваших локальных директориях (например, :file:`${HOME}`), что не "
#~ "требует пользовательских прав уровня ``ROOT``."

#~ msgid ""
#~ ":program:`tarantoolctl` is configured to work properly with :program:"
#~ "`systemd`. Please don't modify system-wide settings of :program:"
#~ "`tarantoolctl`, such as paths, directory permissions and usernames. "
#~ "Otherwise, you have a chance to shoot yourself in the foot."
#~ msgstr ""
#~ "Утилита :program:`tarantoolctl` уже настроена так, чтобы корректно работать "
#~ "с :program:`systemd`. Пожалуйста, не меняйте общесистемные настройки для :"
#~ "program:`tarantoolctl`, такие как пути, настройки прав для директорий и имена "
#~ "пользователей, т.к. это может привести к неожиданным проблемам."

#~ msgid ""
#~ ":program:`systemd` scripts are maintained by the Tarantool Team (http://"
#~ "tarantool.org). Please file tickets directly to the upstream's bug tracker "
#~ "(https://github.com/tarantool/tarantool/issues/) rather than to your Linux "
#~ "distribution."
#~ msgstr ""
#~ "Поддержкой скриптов для :program:`systemd` занимается команда разработки "
#~ "Tarantool'а (http://tarantool.org). Если у вас возникли проблемы при работе "
#~ "Tarantool'а с :program:`systemd`, то мы просим сообщать об этом нашей команде "
#~ "(https://github.com/tarantool/tarantool/issues/), а не разработчикам вашего "
#~ "Linux-дистрибутива."

#~ msgid "About modules/rocks"
#~ msgstr "Про модули/rocks"

#~ msgid ""
#~ "Modules that come from Tarantool developers and community contributors are "
#~ "available at `rocks.tarantool.org <http://rocks.tarantool.org>`_. Some of "
#~ "them -- :ref:`expirationd <expirationd-module>`, :ref:`mysql <dbms_modules-"
#~ "mysql-example>`, :ref:`postgresql <dbms_modules-postgresql-example>`, :ref:"
#~ "`shard <shard-module>` -- are discussed elsewhere in this manual."
#~ msgstr ""
#~ "Модули, созданные командой Tarantool'а и членами сообщества разработчиков, "
#~ "выложены на `rocks.tarantool.org <http://rocks.tarantool.org>`_. Про "
#~ "некоторые из этих модулей — :ref:`expirationd <expirationd-module>`, :ref:"
#~ "`mysql <dbms_modules-mysql-example>`, :ref:`postgresql <dbms_modules-"
#~ "postgresql-example>`, :ref:`shard <shard-module>` -- подробнее говорится в "
#~ "других разделах текущей документации."

#~ msgid ""
#~ "**Step 1:** Install LuaRocks. A general description of installing LuaRocks on "
#~ "a Unix system is given in the `LuaRocks Quick Start Guide <http://luarocks."
#~ "org/#quick-start>`_. For example, on Ubuntu you could say:"
#~ msgstr ""
#~ "**Шаг 1:** Установите LuaRocks. Общее описание того, как установить LuaRocks "
#~ "в Unix-системе, приводится в `кратком руководстве по LuaRocks <http://"
#~ "luarocks.org/#quick-start>`_. Например, установить LuaRocks в Ubuntu можно "
#~ "следующей командой:"

#~ msgid ""
#~ "**Step 2:** Add the Tarantool repository to the list of rocks servers. This "
#~ "is done by putting `rocks.tarantool.org <http://rocks.tarantool.org>`_ in "
#~ "the :file:`.luarocks/config.lua` file:"
#~ msgstr ""
#~ "**Шаг 2:** Добавьте репозиторий Tarantool'а в список rocks-серверов. Для "
#~ "этого добавьте `rocks.tarantool.org <http://rocks.tarantool.org>`_ в файл :"
#~ "file:`.luarocks/config.lua`:"

#~ msgid ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
#~ "config.lua"
#~ msgstr ""
#~ "$ mkdir ~/.luarocks\n"
#~ "$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> ~/.luarocks/"
#~ "config.lua"

#~ msgid "search the repositories with"
#~ msgstr "искать существующие модули в общем репозитории"

#~ msgid "add new modules to the local repository with"
#~ msgstr "добавлять новые модули в свой локальный репозиторий"

#~ msgid ""
#~ "... and that is why examples in this manual often begin with ``require`` "
#~ "requests."
#~ msgstr ""
#~ "(вот почему многие примеры в этой документации начинаются с вызова "
#~ "``require``.)"

#~ msgid "Creating a new Lua module locally"
#~ msgstr "Создание нового модуля на языке Lua"

#~ msgid ""
#~ "As an example, let's create a new Lua file named :file:`mymodule.lua`, "
#~ "containing a named function which will be exported. Then, in Tarantool: load, "
#~ "examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый Lua-файл с именем :file:`mymodule.lua`, в котором "
#~ "опишем экспортируемую функцию с некоторым именем, а затем с помощью "
#~ "Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
#~ "функцию."

#~ msgid "The Lua file should look like this:"
#~ msgstr "Lua-файл в нашем примере будет таким:"

#~ msgid "The requests to load, examine and call look like this:"
#~ msgstr ""
#~ "Для загрузки и просмотра модуля, а также вызова описанной в нем функции, "
#~ "выполним следующие команды:"

#~ msgid ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **mymodule = require('mymodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x405edf20'\n"
#~ "...\n"
#~ "\n"
#~ "tarantool> **mymodule.myfun(os.getenv('USER'))**\n"
#~ "Hello world\n"
#~ "---\n"
#~ "..."

#~ msgid "Creating a new C/C++ module locally"
#~ msgstr "Создание нового модуля на языке C/C++"

#~ msgid ""
#~ "As an example, let's create a new C file named :file:`mycmodule.c`, "
#~ "containing a named function which will be exported. Then, in Tarantool: load, "
#~ "examine, and call."
#~ msgstr ""
#~ "Для примера создадим новый C-файл с именем :file:`mymodule.c`, в котором "
#~ "опишем экспортируемую функцию с некоторым именем, а затем с помощью "
#~ "Tarantool'а загрузим и просмотрим наш новый модуль и вызовем описанную в нем "
#~ "функцию."

#~ msgid "Prerequisite: install ``tarantool-dev`` first."
#~ msgstr ""
#~ "Обратите внимание, что для корректной работы требуется заранее установить "
#~ "модуль ``tarantool-dev``."

#~ msgid ""
#~ "/* mycmodule - a simple Tarantool module */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"
#~ msgstr ""
#~ "/* mycmodule - простейший C-модуль для Tarantool'а */\n"
#~ "#include <lua.h>\n"
#~ "#include <lauxlib.h>\n"
#~ "#include <lualib.h>\n"
#~ "#include <tarantool.h>\n"
#~ "static int\n"
#~ "myfun(lua_State *L)\n"
#~ "{\n"
#~ "    if (lua_gettop(L) < 1)\n"
#~ "        return luaL_error(L, \"Usage: myfun(name)\");\n"
#~ "\n"
#~ "    /* Get first argument */\n"
#~ "    const char *name = lua_tostring(L, 1);\n"
#~ "\n"
#~ "    /* Push one result to Lua stack */\n"
#~ "    lua_pushfstring(L, \"Hello, %s\", name);\n"
#~ "    return 1; /* the function returns one result */\n"
#~ "}\n"
#~ "\n"
#~ "LUA_API int\n"
#~ "luaopen_mycmodule(lua_State *L)\n"
#~ "{\n"
#~ "    static const struct luaL_reg reg[] = {\n"
#~ "        { \"myfun\", myfun },\n"
#~ "        { NULL, NULL }\n"
#~ "    };\n"
#~ "    luaL_register(L, \"mycmodule\", reg);\n"
#~ "    return 1;\n"
#~ "}"

#~ msgid ""
#~ "Use :program:`gcc` to compile the code for a shared library (without a \"lib"
#~ "\" prefix), then use :program:`ls` to examine it:"
#~ msgstr ""
#~ "С помощью :program:`gcc` скомпилируем наш код в виде shared-библиотеки (без "
#~ "префикса \"lib\"), а затем просмотрим ее содержимое с помощью :program:`ls`:"

#~ msgid ""
#~ "$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"
#~ msgstr ""
#~ "$ **gcc mycmodule.c -shared -fPIC -I/usr/include/tarantool -o mycmodule.so**\n"
#~ "$ **ls mycmodule.so -l**\n"
#~ "-rwxr-xr-x 1 roman roman 7272 Jun  3 16:51 mycmodule.so"

#~ msgid ""
#~ "Tarantool's developers recommend using Tarantool's `CMake scripts <https://"
#~ "github.com/tarantool/modulekit>`_ which will handle some of the build steps "
#~ "automatically."
#~ msgstr ""
#~ "Для автоматизации сборки рекомендуется использовать `CMake-скрипты для "
#~ "Tarantool'а <https://github.com/tarantool/modulekit>`_."

#~ msgid ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."
#~ msgstr ""
#~ "tarantool> **myсmodule = require('myсmodule')**\n"
#~ "---\n"
#~ "...\n"
#~ "tarantool> **myсmodule**\n"
#~ "---\n"
#~ "- myfun: 'function: 0x4100ec98'\n"
#~ "...\n"
#~ "tarantool> **mycmodule.myfun(os.getenv('USER'))**\n"
#~ "---\n"
#~ "- Hello, world\n"
#~ "..."

#~ msgid "Creating a mixed Lua/C module locally"
#~ msgstr "Создание нового модуля на смеси языков Lua/C"

#~ msgid "Create a Lua module and name it as you like, say ``myfunmodule``."
#~ msgstr "Создайте новый Lua-модуль и назовите его, например, ``myfunmodule``."

#~ msgid ""
#~ "Create a C module (submodule) and name it ``myfunmodule.internal`` or "
#~ "something like that."
#~ msgstr ""
#~ "Создайте (вложенный) модуль на C и назовите его, например, ``myfunmodule."
#~ "internal``."

#~ msgid ""
#~ "Load the C module from your Lua code using :samp:`require('myfunmodule."
#~ "internal')` and then wrap or use it."
#~ msgstr ""
#~ "Загрузите новый C-модуль из Lua-кода с помощью :samp:`require('myfunmodule."
#~ "internal')`, а затем сделайте для него обертку или вызывайте его функции "
#~ "напрямую."

#~ msgid ""
#~ "For a sample of a mixed Lua/C module, see `\"tarantool/http\" repository at "
#~ "GitHub <https://github.com/tarantool/http>`_."
#~ msgstr ""
#~ "Примеры модулей на смеси языков Lua/C можно посмотреть в `репозитории "
#~ "\"tarantool/http\" на GitHub <https://github.com/tarantool/http>`_."

#~ msgid "Tips for special situations"
#~ msgstr "Примечания для особых случаев"

#~ msgid ""
#~ "Lua caches all loaded modules in the ``package.loaded`` table. To reload a "
#~ "module from disk, set its key to `nil`:"
#~ msgstr ""
#~ "В среде Lua все загруженные модули кешируются в таблице ``package.loaded``. "
#~ "Чтобы перегрузить какой-либо модуль с диска, укажите для его ключа значение "
#~ "`nil`:"

#~ msgid ""
#~ "Use ``package.path`` to search for :file:`.lua` modules, and use ``package."
#~ "cpath`` to search for C binary modules."
#~ msgstr ""
#~ "Для поиска :file:`.lua`-модулей используйте команду ``package.path``, а для "
#~ "поиска бинарных модулей на C используйте команду ``package.cpath``."

#~ msgid ""
#~ "To see the internal state from within a Lua module, use :samp:`state` and "
#~ "create a local variable inside the scope of the file:"
#~ msgstr ""
#~ "Для просмотра внутреннего состояния прямо изнутри Lua-модуля используйте :"
#~ "samp:`state` и соответствующую локальную переменную в рамках модуля:"

#~ msgid ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- use state\n"
#~ "end\n"
#~ "return exports"
#~ msgstr ""
#~ "-- mymodule\n"
#~ "local exports = {}\n"
#~ "local state = {}\n"
#~ "exports.myfun = function()\n"
#~ "    state.x = 42 -- используем state\n"
#~ "end\n"
#~ "return exports"

#~ msgid ""
#~ "If you tried out the :ref:`Starting Tarantool and making your first database "
#~ "<user_guide_getting_started-first_database>` exercise from the last chapter, "
#~ "then your database looks like this:"
#~ msgstr ""
#~ "Если вы уже выполнили тестовое задание из раздела :ref:`Первичный запуск "
#~ "Tarantool'а и создание базы данных <user_guide_getting_started-"
#~ "first_database>` в предыдущей главе, то ваша база данных имеет следующий вид:"

#~ msgid ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| SPACE 'tester'                             |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | TUPLE SET 'tester'                     | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Tuple: [ 1 ]                      |  | |\n"
#~ "| | | Tuple: [ 2, 'Music' ]             |  | |\n"
#~ "| | | Tuple: [ 3, 'length', 93 ]        |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | INDEX 'primary'                        | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Key: 1                            |  | |\n"
#~ "| | | Key: 2                            |  | |\n"
#~ "| | | Key: 3                            |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"
#~ msgstr ""
#~ "+--------------------------------------------+\n"
#~ "|                                            |\n"
#~ "| ПРОСТРАНСТВО 'tester'                      |\n"
#~ "| +----------------------------------------+ |\n"
#~ "| |                                        | |\n"
#~ "| | НАБОР КОРТЕЖЕЙ 'tester'                | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Кортеж: [ 1 ]                     |  | |\n"
#~ "| | | Кортеж: [ 2, 'Music' ]            |  | |\n"
#~ "| | | Кортеж: [ 3, 'length', 93 ]       |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| | ИНДЕКС 'primary'                       | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| | | Ключ: 1                           |  | |\n"
#~ "| | | Ключ: 2                           |  | |\n"
#~ "| | | Ключ: 3                           |  | |\n"
#~ "| | +-----------------------------------+  | |\n"
#~ "| |                                        | |\n"
#~ "| +----------------------------------------+ |\n"
#~ "+--------------------------------------------+"

#~ msgid ""
#~ "When Tarantool is being used to store data, there is always at least one "
#~ "space. There can be many spaces. Each space has a unique name specified by "
#~ "the user. Each space has a unique numeric identifier which can be specified "
#~ "by the user but usually is assigned automatically by Tarantool. Spaces always "
#~ "contain one tuple set and one or more indexes."
#~ msgstr ""
#~ "Когда Tarantool используется для хранения данных, то он создает по меньшей "
#~ "мере одно пространство (space). В общем же случае пространств может быть "
#~ "много. Каждое пространство имеет уникальное имя, заданное пользователем, а "
#~ "также уникальный числовой идентификатор, который тоже может быть задан "
#~ "пользователем, но обычно назначается автоматически самим Tarantool'ом. "
#~ "Пространство всегда содержит один набор кортежей и один или более индексов."

#~ msgid "Tuple set"
#~ msgstr "Набор кортежей"

#~ msgid "A *tuple set* -- 'tester' in the example -- is a group of tuples."
#~ msgstr ""
#~ "*Набор кортежей* — в нашем примере он назван 'tester' — это группа кортежей."

#~ msgid ""
#~ "There is always one tuple set in a space. The identifier of a tuple set is "
#~ "the same as the space name -- 'tester' in the example."
#~ msgstr ""
#~ "Каждое пространство всегда содержит один набор кортежей. Идентификатор набора "
#~ "кортежей совпадает с именем самого пространства, в нашем примере — `tester`."

#~ msgid ""
#~ "A tuple fills the same role as a “row” or a “record”, and the components of a "
#~ "tuple (which we call “fields”) fill the same role as a “row column” or "
#~ "“record field”, except that: the fields of a tuple can be composite "
#~ "structures, such as arrays or maps and don't need to have names. That's why "
#~ "there was no need to pre-define the tuple set when creating the space, and "
#~ "that's why each tuple can have a different number of elements. Tuples are "
#~ "stored as `MsgPack`_ arrays."
#~ msgstr ""
#~ "Кортеж (tuple) выполняет ту же роль, что \"строка\" или \"запись\", а "
#~ "компоненты кортежа (его \"полЯ\") выполняют ту же роль, что \"поле столбца, "
#~ "соответствующее данной строке\" или \"поле в записи\" за тем исключением, что "
#~ "поля кортежа могут быть составными (например, они могут быть массивами или "
#~ "отображениями) и им не нужны имена. Поэтому нет необходимости предварительно "
#~ "определять набор кортежей при создании пространства, а каждый кортеж может "
#~ "иметь различное количество элементов. Кортежи хранятся в виде `MsgPack`_-"
#~ "массивов."

#~ msgid ""
#~ "When Tarantool returns a tuple value, it surrounds strings with single "
#~ "quotes, separates fields with commas, and encloses the tuple inside square "
#~ "brackets. For example: ``[3, 'length', 93]``."
#~ msgstr ""
#~ "Когда Tarantool возвращает значение кортежа, он берет строки в одинарные "
#~ "кавычки, отделяет поля с запятыми и заключает кортеж в квадратные скобки. "
#~ "Например, ``[ 3, 'length', 93 ]``."

#~ msgid ""
#~ "In order for a tuple set to be useful, there must always be at least one "
#~ "index in a space. There can be many indexes. As with spaces, the user can and "
#~ "should specify the index name, and let Tarantool come up with a unique "
#~ "numeric identifier (the \"index id\"). In our example there is one index and "
#~ "its name is “primary”."
#~ msgstr ""
#~ "Чтобы набором кортежей было можно пользоваться, в пространстве необходим по "
#~ "крайней мере один индекс. Вообще же индексов в пространстве может быть много. "
#~ "Как и в случае с пространствами, пользователь может — и должен — указать имя "
#~ "индекса, а Tarantool подставляет уникальный числовой идентификатор "
#~ "(\"идентификатор индекса\"). В нашем примере всего один индекс с именем "
#~ "“primary”."

#~ msgid ""
#~ "An index may be *multi-part*, that is, the user can declare that an index key "
#~ "value is taken from two or more fields in the tuple, in any order. An index "
#~ "may be *unique*, that is, the user can declare that it would be illegal to "
#~ "have the same key value twice. An index may have *one of four types*: HASH "
#~ "which is fast and is best for exact-equality searches with unique keys, TREE "
#~ "which allows partial-key searching and ordered results, BITSET which can be "
#~ "good for searches that contain '=' and multiple ANDed conditions, and RTREE "
#~ "for spatial coordinates. The first index is called the “*primary key*” index "
#~ "and it must be unique; all other indexes are called “secondary” indexes."
#~ msgstr ""
#~ "Индекс может быть *составным*. Значение ключа в таком индексе составляется из "
#~ "значений двух или более полей кортежа, причем они могут браться в любом "
#~ "порядке. Индекс может быть *уникальным*. В этом случае один и тот же ключ не "
#~ "может встречаться в индексе более одного раза. Также индекс может быть одного "
#~ "из следующих *четырех типов*: HASH (он самый быстрый и самый экономный в "
#~ "плане использования памяти, но он должен быть уникальным), TREE (он позволяет "
#~ "делать поиск по части ключа и получать отсортированные результаты), BITSET "
#~ "(он хорош для поиска с '=' и больших количеством AND-условий) или RTREE (для "
#~ "пространственных координат). Первый индекс называется “*первичным*” (primary) "
#~ "и должен быть уникальным. Все остальные индексы называются "
#~ "“вторичными” (secondary)."

#~ msgid "``number`` (unsigned integer or signed integer or floating-point value)"
#~ msgstr ""
#~ "``number`` (беззнаковое целое число, либо знаковое целое число, либо число с "
#~ "плавающей точкой)"

#~ msgid "``scalar`` (boolean or number or string)"
#~ msgstr "``scalar`` (логическое значение, либо число, либо строковое значение)"

#~ msgid ""
#~ "``array`` (a series of numbers for use with :ref:`RTREE indexes <box_index-"
#~ "rtree>`)"
#~ msgstr ""
#~ "``array`` (последовательность чисел для :ref:`RTREE-индексов <box_index-"
#~ "rtree>`)"

#~ msgid "Take our example, which has the request:"
#~ msgstr "В рамках нашего примера рассмотрим следующий запрос:"

#~ msgid ""
#~ "The effect is that, for all tuples in tester, field number 1 must exist and "
#~ "must contain an unsigned integer."
#~ msgstr ""
#~ "В результате у всех кортежей в пространстве `tester` должно быть поле с "
#~ "номером 1, содержащее беззнаковое целое число."

#~ msgid ""
#~ "Space definitions and index definitions are stored permanently in system "
#~ "spaces. It is possible to add, drop, or alter the definitions at runtime, "
#~ "with some restrictions. See syntax details for defining spaces and indexes "
#~ "in :ref:`reference on Tarantool's \"box\" module <index-box_library>`."
#~ msgstr ""
#~ "Определения пространств и индексов хранятся в системных пространствах. Можно "
#~ "(с некоторыми ограничениями) на ходу добавлять, удалять и менять эти "
#~ "определения. Правила синтаксиса в определениях пространств и индексов даны в "
#~ "разделе :ref:`Библиотека \"box\" <index-box_library>`."

#~ msgid ""
#~ "Tarantool can work with numbers, strings, booleans, tables, and userdata."
#~ msgstr ""
#~ "Tarantool работает с числами (numbers), строками (strings), логическими "
#~ "значениями (booleans), таблицами (tables) и пользовательскими типами данных "
#~ "(userdata)."

#~ msgid "General type"
#~ msgstr "Общий тип"

#~ msgid "Specific type"
#~ msgstr "Особый тип"

#~ msgid "What Lua ``type()`` would return"
#~ msgstr "Результат Lua type()"

#~ msgid "\"`table`_\""
#~ msgstr "\"`table`_\""

#~ msgid "\"`Userdata`_\""
#~ msgstr "\"`Userdata`_\""

#~ msgid ""
#~ "For database storage, Tarantool uses MsgPack rules. Storage is variable-"
#~ "length, so the smallest number requires only one byte but the largest number "
#~ "requires nine bytes. When a field has an 'unsigned' index, all values must be "
#~ "unsigned integers between 0 and 18,446,744,073,709,551,615."
#~ msgstr ""
#~ "Для хранения данных в базе Tarantool использует формат MsgPack. Данные при "
#~ "хранении имеют переменную длину, поэтому для самого маленького числа "
#~ "потребуется только один байт, а самое большее число потребует девять байтов. "
#~ "Если поле имеет индекс 'unsigned', то оно может содержать только целые "
#~ "беззнаковые числа со значениями в диапазоне от 0 до "
#~ "18,446,744,073,709,551,615."

#~ msgid ""
#~ "A *string* is a variable-length sequence of bytes, usually represented with "
#~ "alphanumeric characters inside single quotes."
#~ msgstr ""
#~ "Тип *string* (строка) — это последовательность байтов, имеющая переменную "
#~ "длину. Как правило, строки представлены в виде алфавитно-числовых символы, "
#~ "заключенных в одинарные кавычки."

#~ msgid ""
#~ "A *tuple* is returned in YAML format like ``- [120, 'a', 'b', 'c']``. A few "
#~ "functions may return tables with multiple tuples. A scalar may be converted "
#~ "to a tuple with only one field. A Lua table may contain all of a tuple's "
#~ "fields, but not nil."
#~ msgstr ""
#~ "Тип *tuple* возвращается в формате YAML, например ``- [120, 'a', 'b', 'c']``. "
#~ "Некоторые функции могут возвращать таблицы с несколькими кортежами. Скалярная "
#~ "величина может быть конвертирована в кортеж с 1 полем. Lua-таблица может "
#~ "содержать все типы полей, допустимые для кортежей, кроме нулевого типа (nil)."

#~ msgid ""
#~ "Some of the data types may be used in :ref:`indexed fields "
#~ "<details_about_index_field_types>`."
#~ msgstr ""
#~ "Некоторые из этих типов данных подходят для :ref:`индексируемых полей "
#~ "<details_about_index_field_types>`."

#~ msgid "For more tuple examples see :ref:`box.tuple <box_tuple>`."
#~ msgstr ""
#~ "См. также примеры кортежей в разделе про модуль :ref:`box.tuple <box_tuple>`."

#~ msgid ""
#~ "The basic operations are: the five data-change operations (``insert``, "
#~ "``update``, ``upsert``, ``delete``, ``replace``), and the data-retrieval "
#~ "operation (``select``). There are also minor operations like “ping” which can "
#~ "only be used with the binary protocol. Also, there are :ref:`index iterator "
#~ "<box_index-index_pairs>` operations, which can only be used with Lua code. "
#~ "(Index iterators are for traversing indexes one key at a time, taking "
#~ "advantage of features that are specific to an index type, for example "
#~ "evaluating Boolean expressions when traversing BITSET indexes, or going in "
#~ "descending order when traversing TREE indexes.)"
#~ msgstr ""
#~ "Основные операции — это пять операций для изменения данных (INSERT, UPDATE, "
#~ "UPSERT, DELETE, REPLACE) и одна операция для возвращения данных (SELECT). "
#~ "Также в Tarantool'е поддерживаются второстепенные операции типа PING, которые "
#~ "можно использовать только в рамках бинарного протокола. Кроме того, в "
#~ "Tarantool'е есть операции для :ref:`индекс-итераторов <box_index-"
#~ "index_pairs>`, которые можно использовать только в коде на языке Lua. (Индекс-"
#~ "итераторы нужны для обхода индексов от одного ключа к другому и дают "
#~ "возможность пользоваться преимуществами разных типов индексов, например "
#~ "вычислять значение выражений логического типа при обходе BITSET-индексов или "
#~ "двигаться в порядке убывания значений при обходе TREE-индексов.)"

#~ msgid "Six examples of basic operations:"
#~ msgstr "Шесть примеров основных операций:"

#~ msgid ""
#~ "-- Add a new tuple to tuple set tester.\n"
#~ "-- The first field, field[1], will be 999 (type is unsigned).\n"
#~ "-- The second field, field[2], will be 'Taranto' (type is string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Update the tuple, changing field field[2].\n"
#~ "-- The clause \"{999}\", which has the value to look up in\n"
#~ "-- the index of the tuple's primary-key field, is mandatory\n"
#~ "-- because update() requests must always have a clause that\n"
#~ "-- specifies the primary key, which in this case is field[1].\n"
#~ "-- The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment\n"
#~ "-- will happen to field[2] with the new value.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Upsert the tuple, changing field field[2] again.\n"
#~ "-- The syntax of upsert is similar to the syntax of update,\n"
#~ "-- but the return value will be different.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Replace the tuple, adding a new field.\n"
#~ "-- This is also possible with the update() request but\n"
#~ "-- the update() request is usually more complicated.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Retrieve the tuple.\n"
#~ "-- The clause \"{999}\" is still mandatory, although it does not have to\n"
#~ "-- mention the primary key.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Delete the tuple.\n"
#~ "-- Once again the clause to identify the primary-key field is mandatory.\n"
#~ "tarantool> box.space.tester:delete{999}"
#~ msgstr ""
#~ "-- Добавляем новый кортеж в набор кортежей с именем tester.\n"
#~ "-- Первое поле, field[1], будет равно 999 (тип = unsigned).\n"
#~ "-- Второе поле, field[2], будет равно 'Taranto' (тип = string).\n"
#~ "tarantool> box.space.tester:insert{999, 'Taranto'}\n"
#~ "\n"
#~ "-- Обновляем кортеж, меняем значение поля field[2].\n"
#~ "-- Условие \"{999}\", содержащее значение ключа, которое нужно\n"
#~ "-- искать в первичном индексе, построенном по первому полю\n"
#~ "-- кортежа, является обязательным, поскольку запросам update()\n"
#~ "-- всегда требуется условие, определяющее значение первичного\n"
#~ "-- ключа, в данном случае field[1].\n"
#~ "-- Условие \"{{'=', 2, 'Tarantino'}}\" определяет, что полю field[2] нужно \n"
#~ "-- присвоить новое значение.\n"
#~ "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})\n"
#~ "\n"
#~ "-- Выполняем операцию upsert() для кортежа и снова меняем\n"
#~ "-- значение поля field[2].\n"
#~ "-- Синтаксис запроса upsert() аналогичен синтаксису update(),\n"
#~ "-- но возвращаемые значения у этих запросов разные.\n"
#~ "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})\n"
#~ "\n"
#~ "-- Производим замену кортежа с помощью replace(), добавляем новое поле.\n"
#~ "-- Это можно сделать и с помощью запроса update(),\n"
#~ "-- но такой вариант часто оказывается более сложным.\n"
#~ "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}\n"
#~ "\n"
#~ "-- Возвращаем значение кортежа.\n"
#~ "-- Условие \"{999}\" все еще обязательно, хотя оно и не должно\n"
#~ "-- содержать значение первичного ключа.\n"
#~ "tarantool> box.space.tester:select{999}\n"
#~ "\n"
#~ "-- Удаляем кортеж.\n"
#~ "-- Условие, определяющее значение первичного ключа,\n"
#~ "-- снова является обязательным.\n"
#~ "tarantool> box.space.tester:delete{999}"

#~ msgid ""
#~ "If this is happening on a remote client, then the client parses the statement "
#~ "and changes it to a binary-protocol instruction which has already been "
#~ "checked, and which the server can understand without needing to parse "
#~ "everything again. The client ships a packet to the server."
#~ msgstr ""
#~ "Если запрос делается с удаленного клиента, то клиент разбирает введенное "
#~ "выражение, проверяет на корректность и переводит его в формат инструкций "
#~ "бинарного протокола, которые Tarantool-сервер сможет понять без повторного "
#~ "разбора. Затем клиент отправляет всё в виде пакета на сторону сервера."

#~ msgid ""
#~ "The transaction processor thread sends a message to the write-ahead logging "
#~ "(WAL) thread."
#~ msgstr ""
#~ "Поток обработки транзакций посылает сообщение другому потоку, который "
#~ "занимается записью в WAL."

#~ msgid ""
#~ "At this point, a *yield* takes place. To know the significance of that -- and "
#~ "it's quite significant -- you have to know a few facts and a few new words."
#~ msgstr ""
#~ "В этот момент происходит *передача управления* (yield). Чтобы понять важность "
#~ "этого события — а оно действительно важно, — нужно пояснить несколько фактов "
#~ "и ввести ряд новых терминов."

#~ msgid "FACT 1:"
#~ msgstr "ФАКТ #1:"

#~ msgid "FACT 2:"
#~ msgstr "ФАКТ #2:"

#~ msgid "FACT 3:"
#~ msgstr "ФАКТ #3:"

#~ msgid ""
#~ "Yields must happen, otherwise the transaction processor thread would stick "
#~ "permanently on the same fiber. There are :ref:`implicit yields <atomic-"
#~ "the_implicit_yield_rules>`: every data-change operation or network-access "
#~ "causes an implicit yield, and every statement that goes through the tarantool "
#~ "client causes an implicit yield. And there are explicit yields: in a Lua "
#~ "function one can and should add “yield” statements to prevent hogging. This "
#~ "is called *cooperative multitasking*."
#~ msgstr ""
#~ "Без передачи управления не обойтись, т.к. иначе поток обработки транзакций "
#~ "сможет выполнять инструкции только для одного файбера. Передача управления "
#~ "может осуществляться один их двух способов. Первый — это :ref:`неявная "
#~ "передача <atomic-the_implicit_yield_rules>`. Она делается при каждой "
#~ "операции, связанной с изменением данных, при каждом обращении к сетевому "
#~ "соединению, а также при каждом запросе, который передается через Tarantool-"
#~ "клиент. Второй способ передачи управления — это явная передача. Ее можно — и "
#~ "нужно — вызывать внутри Lua-функций с помощью инструкции “yield”, чтобы не "
#~ "допустить захвата процессора одним файбером. Это называется *взаимная "
#~ "многозадачность*."

#~ msgid ""
#~ "Since all data-change operations end with an implicit yield and an implicit "
#~ "commit, and since no data-change operation can change more than one tuple, "
#~ "there is no need for any locking. Consider, for example, a Lua function that "
#~ "does three Tarantool operations:"
#~ msgstr ""
#~ "Поскольку все операции, связанные с изменением данных, заканчиваются неявной "
#~ "передачей управления и неявным коммитом, и поскольку каждая такая операция "
#~ "может затрагивать не более одного кортежа, то не возникает нужды в "
#~ "блокировках. Для примера рассмотрим следующую Lua-функцию, которая "
#~ "осуществляет три операции в Tarantool'е:"

#~ msgid ""
#~ "s:select{999}             -- this does not yield and does not commit\n"
#~ "s:update({...},{{...}})   -- this yields and commits\n"
#~ "s:select{999}             -- this does not yield and does not commit"
#~ msgstr ""
#~ "s:select{999}             -- не происходит ни передачи управления, ни "
#~ "коммита\n"
#~ "s:update({...},{{...}})   -- происходит и передача управления, и коммит\n"
#~ "s:select{999}             -- не происходит ни передачи управления, ни коммита"

#~ msgid ""
#~ "The combination “SELECT plus UPDATE” is an atomic transaction: the function "
#~ "holds a consistent view of the database until the UPDATE ends. For the "
#~ "combination “UPDATE plus SELECT” the view is not consistent, because after "
#~ "the UPDATE the transaction processor thread can switch to another fiber, and "
#~ "delete the tuple that was just updated."
#~ msgstr ""
#~ "Последовательность операций “SELECT + UPDATE” является атомарной транзакцией: "
#~ "функция сохраняет базу данных в согласованном виде, пока не отработает "
#~ "UPDATE. А в случае “UPDATE + SELECT” согласованности нет, поскольку после "
#~ "операции UPDATE поток обработки транзакций может переключится на другой "
#~ "файбер и удалить тот кортеж, что был обновлен в рамках предыдущей операции "
#~ "UPDATE."

#~ msgid ""
#~ "Note re storage engine: vinyl handles yields differently, see :ref:"
#~ "`differences between memtx and vinyl <vinyl_diff>`."
#~ msgstr ""
#~ "Примечание про движок: в движке vinyl передача управления происходит по-"
#~ "другому, см. раздел про :ref:`различия между движками memtx и vinyl "
#~ "<vinyl_diff>`."

#~ msgid "Note re multi-request transactions"
#~ msgstr "Примечание про составные транзакции:"

#~ msgid ""
#~ "Since locks don't exist, and disk writes only involve the write-ahead log, "
#~ "transactions are usually fast. Also the Tarantool server may not be using up "
#~ "all the threads of a powerful multi-core processor, so advanced users may be "
#~ "able to start a second Tarantool server on the same processor without ill "
#~ "effects."
#~ msgstr ""
#~ "Посколько блокировки не используются, а запись на диск производится только "
#~ "при работе с WAL-файлом, то транзакции в Tarantool'е обычно совершаются "
#~ "быстро. Кроме того, если мы имеем дело с мощным многоядерным процессором, то "
#~ "Tarantool-сервер может задействовать для работы не все потоки такого "
#~ "процессора, и продвинутые пользователи могут безболезненно запускать второй "
#~ "Tarantool-сервер на том же процессоре."

#~ msgid ""
#~ "Additional examples of requests can be found in the Tarantool regression test "
#~ "suite (https://github.com/tarantool/tarantool/tree/1.7/test/box). A complete "
#~ "grammar of supported data-manipulation functions will come later in this "
#~ "chapter."
#~ msgstr ""
#~ "См. также примеры с запросами в регрессионных тестах для Tarantool'а (https://"
#~ "github.com/tarantool/tarantool/tree/1.7/test/box). Полное описание грамматики "
#~ "поддерживаемых в Tarantool'е функций для манипулирования данными см. далее в "
#~ "этой главе."

#~ msgid ""
#~ "Since not all Tarantool operations can be expressed with the data-"
#~ "manipulation functions, or with Lua, to gain complete access to data "
#~ "manipulation functionality one must use a :ref:`Perl, PHP, Python or other "
#~ "programming language connector <index-box_connectors>`. The client/server "
#~ "protocol is open and documented. See this :ref:`annotated BNF <box_protocol-"
#~ "iproto_protocol>`."
#~ msgstr ""
#~ "Не все операции в Tarantool'е можно выразить с помощью функций по "
#~ "манипулированию данными или с помощью языка Lua. Чтобы получить доступ ко "
#~ "всем возможностями манипулирования данными, вам понадобится :ref:`коннектор "
#~ "для Perl, PHP, Python или другого языка программирования <index-"
#~ "box_connectors>`. Бинарный клиент-серверный протокол для коннекторов является "
#~ "открытым. Документация по нему доступна в виде аннотированных :ref:`BNF-"
#~ "диаграмм <box_protocol-iproto_protocol>`."

#~ msgid ""
#~ "Tarantool maintains a set of write-ahead log (WAL) files. There is a separate "
#~ "thread -- the WAL writer -- which catches all requests that can change a "
#~ "database, such as ``box.schema.create`` or ``box.space.insert``. Ordinarily "
#~ "the WAL writer writes the request, along with administrative fields and "
#~ "flags, to a WAL file immediately. This ensures data persistence, because, "
#~ "even if an in-memory database is lost when the power goes off, Tarantool "
#~ "recovers it automatically when it starts up again, by reading the WAL files "
#~ "and redoing the requests (this is called the \"recovery process\"). Users can "
#~ "change the timing of the WAL writer, or turn it off, by setting :ref:"
#~ "`wal_mode <cfg_binary_logging_snapshots-wal_mode>`."
#~ msgstr ""
#~ "Tarantool сохраняет данные и информацию об изменениях в нескольких WAL-файлах "
#~ "(write-ahead log). Записью в WAL занимается отдельный поток. Он ловит все "
#~ "запросы, которые могут привести к изменению данных в базе, например ``box."
#~ "schema.create`` или ``box.space.insert``. Как правило, запись о запросе, "
#~ "включая служебные поля и флаги, делается в WAL-файл немедленно. Это "
#~ "обеспечивает сохранность данных, поскольку, даже если данные из памяти "
#~ "утеряны вследствие перебоя в электроснабжении, Tarantool восстановит их "
#~ "автоматически при следующем старте: он загрузит данные из WAL-файлов, а затем "
#~ "применит все записанные в WAL-файлах запросы (это называется \"процесс "
#~ "восстановления\"). Пользователи могут менять частоту записи или вовсе "
#~ "отключать запись в WAL с помощью параметра :ref:`wal_mode "
#~ "<cfg_binary_logging_snapshots-wal_mode>`."

#~ msgid "Data manipulation"
#~ msgstr "Манипулирование данными"

#~ msgid ""
#~ "The basic *data-manipulation* requests are: ``insert``, ``replace``, "
#~ "``update``, ``upsert``, ``delete``, ``select``. All of them are part of the "
#~ "``box`` library. Most of them may return data. Usually both inputs and "
#~ "outputs are Lua tables."
#~ msgstr ""
#~ "Основные запросы для *манипулирования данными* — это ``insert``, ``replace``, "
#~ "``update``, ``upsert``, ``delete``, ``select``. Все они реализованы в "
#~ "библиотеке ``box``. Многие из этих запросов могут возвращать данные. Как "
#~ "правило, и вводимые, и возвращаемые значения являются Lua-таблицами."

#~ msgid ""
#~ "The Lua syntax for data-manipulation functions can vary. Here are examples of "
#~ "the variations with ``select`` requests; the same rules exist for the other "
#~ "data-manipulation functions. Every one of the examples does the same thing: "
#~ "select a tuple set from a space named 'tester' where the primary-key field "
#~ "value equals 1. For the examples there is an assumption that the numeric id "
#~ "of 'tester' is 512, which happens to be the case in our sandbox example only."
#~ msgstr ""
#~ "Lua-синтаксис в данных функциях может различаться. Далее приводятся варианты "
#~ "таких различий на примере SELECT-запросов. Аналогичные правила существуют и "
#~ "для остальных функций. В каждом из приведенных примеров выполняются следующие "
#~ "действия: производится выборка по набору кортежей из пространства с именем "
#~ "'tester', где значение поля, которое соответствует ключу в первичном индексе, "
#~ "равно 1. Также во всех примерах мы подразумеваем, что числовой идентификатор "
#~ "пространства 'tester' равен 512, но это верно только для нашей тестовой базы."

#~ msgid "First, there are five *object reference variations*:"
#~ msgstr "Во-первых, есть пять *способов ссылки на объект*:"

#~ msgid ""
#~ "-- #1 module . submodule . name\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 replace name with a literal in square brackets\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 replace name with a numeric id in square brackets\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 use a variable instead of a literal for the name\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 use a variable for the entire object reference\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"
#~ msgstr ""
#~ "-- #1 имя_модуля . имя_вложенного_модуля . имя_объекта\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2 вместо имени объекта указываем литерал в квадратных скобках\n"
#~ "tarantool> box.space['tester']:select{1}\n"
#~ "-- #3 вместо имени объекта указываем числовой идентификатор в квадратных "
#~ "скобках\n"
#~ "tarantool> box.space[512]:select{1}\n"
#~ "-- #4 вместо литерала, обозначающего имя объекта, указываем переменную\n"
#~ "tarantool> variable = 'tester'\n"
#~ "tarantool> box.space[variable]:select{1}\n"
#~ "-- #5 указываем переменную вместо ссылки на весь объект\n"
#~ "tarantool> s = box.space.tester\n"
#~ "tarantool> s:select{1}"

#~ msgid ""
#~ "Later examples in this manual will usually have the \":samp:`box.space."
#~ "{tester}:`\" form (#1); however, this is a matter of user preference and all "
#~ "the variations exist in the wild."
#~ msgstr ""
#~ "Для примеров в остальной части документации мы будем, как правило, "
#~ "использовать вариант синтаксиса #1, например \":samp:`box.space.{tester}:`\". "
#~ "Но вы можете с тем же успехом пользоваться любым из пяти описанных выше "
#~ "вариантов."

#~ msgid ""
#~ "Later descriptions in this manual will use the syntax \"``space_object:``\" "
#~ "for references to objects which are spaces as in the above examples, and "
#~ "\"``index_object:``\" for references to objects which are indexes (for "
#~ "example :samp:`box.space.{tester}.index.{primary}:`)."
#~ msgstr ""
#~ "Также мы в дальнейшем будем использовать синтаксис типа  \":code:"
#~ "`space_object:`\" для ссылки на пространства (как в приведенных выше "
#~ "примерах) и \":code:`index_object:`\" для ссылки на индексы (например, :samp:"
#~ "`box.space.{tester}.index.{primary}:`)."

#~ msgid "Then, there are seven *parameter variations*:"
#~ msgstr "Во-вторых, есть семь *способов задания параметров*:"

#~ msgid ""
#~ "-- #1\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2\n"
#~ "tarantool> box.space.tester:select({1})\n"
#~ "-- #3\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "-- #4\n"
#~ "tarantool> box.space.tester.select(box.space.tester,1)\n"
#~ "-- #5\n"
#~ "tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
#~ "-- #6\n"
#~ "tarantool> variable = 1\n"
#~ "tarantool> box.space.tester:select{variable}\n"
#~ "-- #7\n"
#~ "tarantool> variable = {1}\n"
#~ "tarantool> box.space.tester:select(variable)"
#~ msgstr ""
#~ "-- #1\n"
#~ "tarantool> box.space.tester:select{1}\n"
#~ "-- #2\n"
#~ "tarantool> box.space.tester:select({1})\n"
#~ "-- #3\n"
#~ "tarantool> box.space.tester:select(1)\n"
#~ "-- #4\n"
#~ "tarantool> box.space.tester.select(box.space.tester,1)\n"
#~ "-- #5\n"
#~ "tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
#~ "-- #6\n"
#~ "tarantool> variable = 1\n"
#~ "tarantool> box.space.tester:select{variable}\n"
#~ "-- #7\n"
#~ "tarantool> variable = {1}\n"
#~ "tarantool> box.space.tester:select(variable)"

#~ msgid ""
#~ "The primary-key value is enclosed in braces, and if it was a multi-part "
#~ "primary key then the value would be multi-part, for example ``...select{1,2,3}"
#~ "``. The braces can be enclosed inside parentheses — ``...select({...})`` — "
#~ "which are optional unless it is necessary to pass something besides the "
#~ "primary-key value, as in example #5. Literal values such as 1 (a scalar "
#~ "value) or {1} (a Lua table value) may be replaced by variable names, as in "
#~ "examples #6 and #7. Although there are special cases where braces can be "
#~ "omitted, they are preferable because they signal \"Lua table\". Examples and "
#~ "descriptions in this manual have the \"{1}\" form; however, this too is a "
#~ "matter of user preference and all the variations exist in the wild."
#~ msgstr ""
#~ "Значение первичного ключа заключается в фигурные скобки. Если же этот "
#~ "первичный ключ является составным, то и значение будет составным, например "
#~ "``...select{1,2,3}``. Фигурные скобки в свою очередь могут заключаться в "
#~ "круглые скобки — например, ``...select({...})``. Это опциональный вариант "
#~ "синтаксиса, и он необходим только в том случае, если нужно передать что-то "
#~ "помимо первичного ключа, как в примере #5. Вместо значений-литералов — "
#~ "например, 1 (скалярное значение) или {1} (Lua-таблица) — можно использовать "
#~ "имена переменных, как в примерах #6 и #7. Хотя в некоторых случаях фигурные "
#~ "скобки можно опускать, мы рекомендуем всегда их использовать. Так вы явно "
#~ "обозначите, что значение имеет тип \"Lua-таблица\". В примерах и описаниях в "
#~ "документации мы везде используем фигурные скобки, например \"{1}\".  Но как и "
#~ "в случае со ссылками на объект, вы можете пользоваться любым допустимым "
#~ "вариантом синтаксиса."

#~ msgid ""
#~ "All the data-manipulation functions operate on tuple sets but, since primary "
#~ "keys are unique, the number of tuples in the tuple set is always 0 or 1. The "
#~ "only exception is ``box.space...select``, which may accept either a primary-"
#~ "key value or a secondary-key value."
#~ msgstr ""
#~ "Все функции для манипулирования данными оперируют наборами кортежей. Однако, "
#~ "поскольку первичные ключи всегда уникальны, количество кортежей в таком "
#~ "наборе всегда равно 0 или 1. Единственным исключением является функция ``box."
#~ "space...select``, которая может брать на вход как первичный, так и вторичный "
#~ "ключ."

#~ msgid "**Complexity factors that may affect data-manipulation functions**"
#~ msgstr ""
#~ "**Факторы, которые могут влиять на быстродействие функций для манипулирования "
#~ "данными из библиотеки box**"

#~ msgid ""
#~ "In the discussion of each data-manipulation function, there will be a note "
#~ "about which complexity factors might affect the function's resource usage."
#~ msgstr ""
#~ "Далее в описании каждой функции для манипулирования данными будет дано "
#~ "примечание, какие из перечисленных выше факторов могут влиять на ее "
#~ "быстродействие."

#~ msgid "An indexed field may be a string rather than a number."
#~ msgstr "Индексируемое поле может быть строкой, а не числом."

#~ msgid ""
#~ "For an ordinary index, the most common data types are 'unsigned' = any non-"
#~ "negative integer, or 'string' = any series of bytes. Numbers are ordered "
#~ "according to their point on the number line -- so 2345 is greater than 500 -- "
#~ "while strings are ordered according to the encoding of the first byte then "
#~ "the encoding of the second byte then the encoding of the third byte and so on "
#~ "-- so '2345' is less than '500'."
#~ msgstr ""
#~ "Обычный индекс, как правило, строится по полям одного из двух типов: 'NUM' = "
#~ "числовой (numeric) = любое неотрицательное целое число, либо 'STR' = строка "
#~ "(string) = любая последовательность байтов. Числа в индексе упорядочены по "
#~ "числовой прямой (например, число 2345 больше, чем число 500), а строки — по "
#~ "коду первого байта, затем по коду второго, третьего и т.д. (и теперь строка "
#~ "'2345' будет меньше, чем строка '500')."

#~ msgid "There may be more than one field."
#~ msgstr "Индекс может строиться по нескольким полям."

#~ msgid ""
#~ "For an ordinary index, the maximum number of parts is 255. The specification "
#~ "of each part consists of a field number and a type."
#~ msgstr ""
#~ "В обычном индексе может быть максимум 255 частей. Каждая часть "
#~ "характеризуется номером поля и его типом."

#~ msgid "The index does not have to be unique."
#~ msgstr "Индекс может быть неуникальным."

#~ msgid "The index does not have to be a tree."
#~ msgstr "Индекс может представлять собой не только дерево."

#~ msgid ""
#~ "The existence of indexes does not affect the syntax of data-change requests, "
#~ "but does cause select requests to have more variety."
#~ msgstr ""
#~ "Наличие индексов никак не влияет на синтаксис запросов на изменение данных. А "
#~ "вот SELECT-запросы, благодаря индексам, становятся более разнообразными."

#~ msgid ""
#~ "Searches on BITSET indexes can be for BITS_ANY_SET, BITS_ALL_SET, "
#~ "BITS_ALL_NOT_SET, EQ, or ALL."
#~ msgstr ""
#~ "При поиске по BITSET-индексам можно использовать операторы BITS_ANY_SET, "
#~ "BITS_ALL_SET, BITS_ALL_NOT_SET, EQ и ALL."

#~ msgid ""
#~ "Searches on RTREE indexes can be for GT, GE, LT, LE, OVERLAPS, or NEIGHBOR."
#~ msgstr ""
#~ "При поиске по RTREE-индексам можно использовать операторы GT, GE, LT, LE, "
#~ "OVERLAPS и NEIGHBOR."

#~ msgid "Another example"
#~ msgstr "Например:"

#~ msgid ""
#~ "The PHP driver is `tarantool-php <https://github.com/tarantool/tarantool-"
#~ "php>`_. It is not supplied as part of the Tarantool repository; it must be "
#~ "installed separately. It can be installed with :program:`git`. It requires "
#~ "other modules which should be installed first. For example, on Ubuntu, the "
#~ "installation could look like this:"
#~ msgstr ""
#~ "Tarantool-коннектор для языка PHP называется `tarantool-php <https://github."
#~ "com/tarantool/tarantool-php>`_. Он устанавливается отдельно от Tarantool'а с "
#~ "помощью :program:`git` и требует предварительной установки еще несколько "
#~ "зависимых модулей. Вот пример установки этого коннектора под Ubuntu:"

#~ msgid ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"
#~ msgstr ""
#~ "$ sudo apt-get install php5-cli\n"
#~ "$ sudo apt-get install php5-dev\n"
#~ "$ sudo apt-get install php-pear\n"
#~ "$ cd ~\n"
#~ "$ git clone https://github.com/tarantool/tarantool-php.git\n"
#~ "$ cd tarantool-php\n"
#~ "$ phpize\n"
#~ "$ ./configure\n"
#~ "$ make\n"
#~ "$ # make install is optional"

#~ msgid ""
#~ "At this point there is a file named :file:`~/tarantool-php/modules/tarantool."
#~ "so`. PHP will only find it if the PHP initialization file :file:`php.ini` "
#~ "contains a line like :samp:`extension=./tarantool.so`, or if PHP is started "
#~ "with the option :samp:`-d extension=~/tarantool-php/modules/tarantool.so`."
#~ msgstr ""
#~ "После отработки всех команд будет создан файл с именем :file:`~/tarantool-php/"
#~ "modules/tarantool.so`. PHP увидит его, только если в файле инициализации :"
#~ "file:`php.ini` есть строка вида :samp:`extension=./tarantool.so`, либо если "
#~ "при запуске PHP вы укажете опцию :samp:`-d extension=~/tarantool-php/modules/"
#~ "tarantool.so`."

#~ msgid "Q: |br| A: |br|"
#~ msgstr "Вопрос: |br| Ответ: |br|"

#~ msgid ""
#~ "Why Tarantool? |br| Tarantool is the latest generation of a family of in-"
#~ "memory data servers developed for web applications. It is the result of "
#~ "practical experience and trials within Mail.Ru since development began in "
#~ "2008."
#~ msgstr ""
#~ "Почему Tarantool? |br| Tarantool — это in-memory сервер баз данных последнего "
#~ "поколения, предназначенный для работы с веб-приложениями. Разработка ведется "
#~ "с учетом многолетнего опыта использования Tarantool'а в стенах Mail.Ru. "
#~ "Первый релиз состоялся в 2008 году."

#~ msgid ""
#~ "What's the key advantage of Tarantool? |br| Tarantool provides a rich "
#~ "database feature set (HASH, TREE, RTREE, BITSET indexes, secondary indexes, "
#~ "composite indexes, transactions, triggers, asynchronous replication) in a "
#~ "flexible environment of a Lua interpreter. |br| These two properties make it "
#~ "possible to be a fast, atomic and reliable in-memory data server which "
#~ "handles non-trivial application-specific logic. The advantage over "
#~ "traditional SQL servers is in performance: low-overhead, lock-free "
#~ "architecture means Tarantool can serve an order of magnitude more requests "
#~ "per second, on comparable hardware. The advantage over NoSQL alternatives is "
#~ "in flexibility: Lua allows flexible processing of data stored in a compact, "
#~ "denormalized format."
#~ msgstr ""
#~ "В чем состоит главное преимущество Tarantool'а? |br| Tarantool предоставляет "
#~ "богатый набор функций по работе с базами данных (HASH, TREE, RTREE, BitSet-"
#~ "индексы, вторичные индексы, составные индексы, транзакции, триггеры, "
#~ "асинхронная репликация), и всё это — в гибкой среде Lua-интерпретатора. |br| "
#~ "Эти два обстоятельства делают Tarantool быстрым и надежным in-memory сервером "
#~ "баз данных с атомарными операциями и сложной логикой на стороне сервера. "
#~ "Преимуществом Tarantool'а по сравнению с традиционными SQL СУБД является его "
#~ "высокая производительность: низкие накладные расходы и безблокировочная "
#~ "архитектура позволяют Tarantool'у обрабатывать на порядок больше запросов в "
#~ "секунду на аналогичном оборудовании. Преимущество же перед другими NoSQL СУБД "
#~ "заключается в большей гибкости Tarantool'а: язык Lua позволяет гибко "
#~ "обрабатывать данные, хранящиеся в компактном, ненормализованном формате."

#~ msgid ""
#~ "What are your development plans? |br| We continuously improve server "
#~ "performance. On the feature front, automatic sharding and synchronous "
#~ "replication, and a subset of SQL are the major goals for 2016-2018. We have "
#~ "an open roadmap to which we encourage anyone to add feature requests."
#~ msgstr ""
#~ "Каковы ваши планы по развитию? |br| Мы постоянно улучшаем производительность "
#~ "серверной части. Наши главные цели на 2016-2018 год — это автоматический "
#~ "шардинг и синхронная репликация, а также частичная поддержка SQL. План работ "
#~ "находится в открытом доступе, и все желающие могут оставлять запросы на "
#~ "добавление функционала."

#~ msgid ""
#~ "How serious is Mail.Ru about Tarantool? |br| Tarantool is an open source "
#~ "project, distributed under a BSD license, so it does not depend on any one "
#~ "sponsor. However, it is an integral part of the Mail.Ru backbone, so it gets "
#~ "a lot of support from Mail.Ru."
#~ msgstr ""
#~ "Насколько серьезны планы Mail.Ru в отношении Tarantool'а? |br| Tarantool — "
#~ "это проект с открытым кодом, распространяемый под лицензией BSD, поэтому он "
#~ "не зависит от внешних спонсоров. В то же время, Tarantool — это часть "
#~ "технологического \"костяка\" Mail.Ru, и поэтому он пользуется сильной "
#~ "поддержкой со стороны Mail.Ru."

#~ msgid ""
#~ "To get started, you can either *download the whole Tarantool package* as "
#~ "described in the first part of :ref:`Chapter 2 \"Getting Started\" "
#~ "<user_guide_getting_started>`, or you can skip the download and *connect to "
#~ "the online Tarantool server* running on the web at http://try.tarantool.org. "
#~ "Either way, as the first tryout, you can follow the introductory example "
#~ "\"Starting Tarantool and making your first database\" from :ref:`the second "
#~ "part of Chapter 2 <user_guide_getting_started-first_database>`. If you want "
#~ "more hands-on experience, proceed to the :ref:`\"Tutorials\" <tutorials>` "
#~ "part after you are through with Chapter 2."
#~ msgstr ""
#~ "Знакомство с Tarantool'ом вы можете начать с того, что скачаете готовый "
#~ "установочный пакет (как описано в начале :ref:`главы 2 \"Начало работы\" "
#~ "<user_guide_getting_started>`) или воспользуетесь нашим онлайн-стендом на "
#~ "http://try.tarantool.org. В любом случае для первого знакомства вы можете "
#~ "выполнить тренировочный пример \"Первичный запуск Tarantool'а и создание базы "
#~ "данных\" из второй части главы 2. После этого вы можете заглянуть в наш :ref:`"
#~ "\"Практикум\" <tutorials>`, где содержится еще больше практических заданий."

#~ msgid ""
#~ "This chapter shows how to download, how to install, and how to start "
#~ "Tarantool for the first time."
#~ msgstr ""
#~ "В этой главе рассказывается, как скачать, установить и начать работать с "
#~ "Tarantool'ом с нуля."

#~ msgid ""
#~ "For production, if possible, you should download a binary (executable) "
#~ "package. This will ensure that you have the same build of the same version "
#~ "that the developers have. That makes analysis easier if later you need to "
#~ "report a problem, and avoids subtle problems that might happen if you used "
#~ "different tools or different parameters when building from source. The "
#~ "section about binaries is \":ref:`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`\"."
#~ msgstr ""
#~ "Для промышленной эксплуатации рекомендуется скачать бинарный (исполняемый) "
#~ "пакет. Тогда вы гарантированно получите сборку той же версии, что и у "
#~ "разработчиков. Это существенно упростит поиск ошибок, если вам в будущем "
#~ "понадобится помощь, а также позволит избежать проблем из-за того, что вы "
#~ "использовали инструменты или параметры отличные от тех, что использовали при "
#~ "сборке сами разработчики. См. раздел “:ref:`user_guide_getting_started-"
#~ "downloading_and_installing_a_binary_package`”."

#~ msgid ""
#~ "For development, you will want to download a source package and make the "
#~ "binary by yourself using a C/C++ compiler and common tools. Although this is "
#~ "a bit harder, it gives more control. And the source packages include "
#~ "additional files, for example the Tarantool test suite. The section about "
#~ "source is \":ref:`Building from source <building_from_source>`\" in :ref:"
#~ "`Contributor's Guide <contrib_guide>`."
#~ msgstr ""
#~ "Для разработческих целей вы можете скачать исходные файлы и собрать бинарный "
#~ "пакет самостоятельно с помощью компилятора C/C++ и обычных инструментов для "
#~ "сборки. Хотя это и более трудный способ получить бинарный пакет, но он дает "
#~ "вам больший контроль над результатом. Также в состав исходных файлов входят "
#~ "дополнительные пакеты, например набор тестов для Tarantool'а. См. раздел \":"
#~ "ref:`Сборка из исходных файлов <building_from_source>`\" в \":ref:"
#~ "`Руководстве участника проекта <contrib_guide>`\"."

#~ msgid ""
#~ "If the installation has already been done, then you should try it out. So "
#~ "we've provided some instructions that you can use to make a temporary "
#~ "“sandbox”. In a few minutes you can start the server and type in some "
#~ "database-manipulation statements. The section about the sandbox is \":ref:"
#~ "`user_guide_getting_started-first_database`\"."
#~ msgstr ""
#~ "После установки вы можете сразу опробовать Tarantool в действии. Ниже вы "
#~ "найдете инструкции по созданию безопасной тестовой среды. Всего за несколько "
#~ "минут вы сможете запустить Tarantool-сервер и задать несколько инструкций по "
#~ "манипулированию данными. См. раздел \":ref:`user_guide_getting_started-"
#~ "first_database`”."

#~ msgid ""
#~ "Binary packages for two Tarantool versions -- for the stable 1.6 and the "
#~ "latest 1.7 -- are provided at http://tarantool.org/download.html. An "
#~ "automatic build system creates, tests and publishes packages for every push "
#~ "into the 1.7 branch."
#~ msgstr ""
#~ "Бинарные пакеты для двух версий Tarantool'а — стабильной 1.6 и самой свежей "
#~ "1.7 — выложены на странице http://tarantool.org/download.html. При каждом "
#~ "изменении исходного кода на GitHub (репозиторий http://github.com/tarantool/"
#~ "tarantool, ветка \"1.7\") происходит сборка, автоматическое тестирование и "
#~ "выкладка бинарных пакетов на вышеуказанную страницу."

#~ msgid "Starting Tarantool and making your first database"
#~ msgstr "Первичный запуск Tarantool'а и создание базы данных"

#~ msgid "Start the server. The server name is tarantool."
#~ msgstr "Запустите Tarantool-сервер. Имя программы — :program:`tarantool`."

#~ msgid ""
#~ "The server starts in interactive mode and outputs a command prompt. To turn "
#~ "on the database, :ref:`configure <box_introspection-box_cfg>` it. This "
#~ "minimal example is sufficient:"
#~ msgstr ""
#~ "Tarantool-сервер запускается в интерактивном режиме и выводит приглашение "
#~ "командной строки. Чтобы создать базу данных, задайте ее настройки с помощью "
#~ "вызова :ref:`box.cfg <box_introspection-box_cfg>`. Вот пример минимальной "
#~ "конфигурации:"

#~ msgid ""
#~ "If all goes well, you will see the server displaying progress as it "
#~ "initializes, something like this:"
#~ msgstr ""
#~ "Если все в порядке, то Tarantool-сервер начнет в прогрессе отображать процесс "
#~ "инициализации, например:"

#~ msgid ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"
#~ msgstr ""
#~ "tarantool> box.cfg{listen = 3301}\n"
#~ "2015-08-07 09:41:41.077 ... version 1.7.0-1216-g73f7154\n"
#~ "2015-08-07 09:41:41.077 ... log level 5\n"
#~ "2015-08-07 09:41:41.078 ... mapping 1073741824 bytes for a shared arena...\n"
#~ "2015-08-07 09:41:41.079 ... initialized\n"
#~ "2015-08-07 09:41:41.081 ... initializing an empty data directory\n"
#~ "2015-08-07 09:41:41.095 ... creating './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.095 ... saving snapshot './00000000000000000000.snap."
#~ "inprogress'\n"
#~ "2015-08-07 09:41:41.127 ... done\n"
#~ "2015-08-07 09:41:41.128 ... primary: bound to 0.0.0.0:3301\n"
#~ "2015-08-07 09:41:41.128 ... ready to accept requests"

#~ msgid ""
#~ "Now that the server is up, you could start up a different shell and connect "
#~ "to its primary port with:"
#~ msgstr ""
#~ "Поскольку Tarantool-сервер уже запущен, вы можете запустить новый терминал и "
#~ "присоединиться к основному порту Tarantool-сервера, введя следующую команду:"

#~ msgid "$ telnet 0 3301"
#~ msgstr "$ telnet 0 3301"

#~ msgid ""
#~ "but for example purposes it is simpler to just leave the server running in "
#~ "\"interactive mode\". On production machines the :ref:`interactive mode "
#~ "<administration-using_tarantool_as_a_client>` is just for administrators, but "
#~ "because it's convenient for learning it will be used for most examples in "
#~ "this manual. Tarantool is waiting for the user to type instructions."
#~ msgstr ""
#~ "но пока что будет лучше оставить Tarantool-сервер работать в интерактивном "
#~ "режиме. На промышленных серверах :ref:`интерактивный режим <administration-"
#~ "using_tarantool_as_a_client>` нужен лишь для администрирования, однако для "
#~ "наглядности большинство примеров в данном руководстве даны именно в "
#~ "интерактивном режиме. Итак, Tarantool ждет от вас ввода инструкций."

#~ msgid "Your terminal screen should now look like this:"
#~ msgstr "Вот что должно отображаться на вашем терминале к этому моменту:"

#~ msgid "Now, to prepare for the example in the next section, try this:"
#~ msgstr ""
#~ "Далее, чтобы подготовиться к тестовому примеру в следующем разделе, введите:"

#~ msgid ""
#~ "In the previous section the first request was with ``box.cfg{listen = 3301}"
#~ "``. The ``listen`` value can be any form of URI (uniform resource "
#~ "identifier); in this case it's just a local port: port 3301. It's possible to "
#~ "send requests to the listen URI via:"
#~ msgstr ""
#~ "В предыдущем разделе ваш первый запрос был :samp:`box.cfg{listen = 3301}`. "
#~ "Значением ``listen`` может быть любой URI (универсальный код ресурса), в "
#~ "данном случае — просто номер локального порта (3301). Вы можете отправлять "
#~ "запросы на URI для прослушивания с помощью:"

#~ msgid ""
#~ "a connector (which will be the subject of the \":ref:`index-box_connectors`\" "
#~ "chapter),"
#~ msgstr "коннектора (см. главу \":ref:`index-box_connectors`\"),"

#~ msgid ""
#~ "You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
#~ "indefinitely, on either Tarantool instance. When the testing is over: To drop "
#~ "the space: ``s:drop()``. To stop tarantoolctl: Ctrl+C or Ctrl+D. To stop "
#~ "tarantool (an alternative): :ref:`os.exit() <os-exit>`. To stop tarantool "
#~ "(from another terminal): ``sudo pkill -f tarantool``. To destroy the test: "
#~ "``rm -r ~/tarantool_sandbox``."
#~ msgstr ""
#~ "Вы можете повторно вводить команды :code:`box.space...:insert{}` и :code:`box."
#~ "space...:select{}` сколько угодно раз, на любом экземпляре Tarantool'а. В "
#~ "конце тестирования воспользуйтесь следующими командами. Чтобы удалить "
#~ "пространство: :code:`s:drop()`. Чтобы остановить  ``tarantoolctl``: Ctrl+C "
#~ "или Ctrl+D. Чтобы остановить Tarantool (альтернативный вариант): :ref:`os."
#~ "exit() <os-exit>`. Чтобы остановить Tarantool (с другого терминала): :code:"
#~ "`sudo pkill -f tarantool`. Чтобы удалить тестовую базу: :code:`rm -r ~/"
#~ "tarantool_sandbox`."
