# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-07-14 13:15+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../doc/1.7/reference/configuration/cfg_basic.rst:1
#: ../doc/1.7/reference/configuration/cfg_basic.rst:29
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:2
#: ../doc/1.7/reference/configuration/cfg_basic.rst:30
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:3
#: ../doc/1.7/reference/configuration/cfg_basic.rst:31
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:4
#: ../doc/1.7/reference/configuration/cfg_basic.rst:32
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:5
#: ../doc/1.7/reference/configuration/cfg_basic.rst:33
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:6
#: ../doc/1.7/reference/configuration/cfg_basic.rst:34
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:7
#: ../doc/1.7/reference/configuration/cfg_basic.rst:35
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:8
#: ../doc/1.7/reference/configuration/cfg_basic.rst:36
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:9
#: ../doc/1.7/reference/configuration/cfg_basic.rst:37
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:10
#: ../doc/1.7/reference/configuration/cfg_basic.rst:38
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:11
#: ../doc/1.7/reference/configuration/cfg_basic.rst:39
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:17
#: ../doc/1.7/reference/configuration/cfg_basic.rst:45
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-log>` and"
" :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:21
#: ../doc/1.7/reference/configuration/cfg_basic.rst:49
#: ../doc/1.7/reference/configuration/cfg_basic.rst:110
#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:15
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:43
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:25
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:53
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:66
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:46
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:74
#: ../doc/1.7/reference/configuration/cfg_logging.rst:115
#: ../doc/1.7/reference/configuration/cfg_logging.rst:143
msgid "Type: boolean"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:22
#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:26
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:54
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:47
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:75
msgid "Default: false"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:23
#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
#: ../doc/1.7/reference/configuration/cfg_basic.rst:113
#: ../doc/1.7/reference/configuration/cfg_basic.rst:124
#: ../doc/1.7/reference/configuration/cfg_basic.rst:149
#: ../doc/1.7/reference/configuration/cfg_basic.rst:152
#: ../doc/1.7/reference/configuration/cfg_basic.rst:163
#: ../doc/1.7/reference/configuration/cfg_basic.rst:177
#: ../doc/1.7/reference/configuration/cfg_basic.rst:188
#: ../doc/1.7/reference/configuration/cfg_basic.rst:191
#: ../doc/1.7/reference/configuration/cfg_basic.rst:216
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:17
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:30
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:45
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:58
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:73
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:101
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:27
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:57
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:85
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:110
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:123
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:138
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:76
#: ../doc/1.7/reference/configuration/cfg_logging.rst:103
#: ../doc/1.7/reference/configuration/cfg_logging.rst:117
#: ../doc/1.7/reference/configuration/cfg_logging.rst:131
#: ../doc/1.7/reference/configuration/cfg_logging.rst:145
#: ../doc/1.7/reference/configuration/cfg_storage.rst:27
#: ../doc/1.7/reference/configuration/cfg_storage.rst:38
#: ../doc/1.7/reference/configuration/cfg_storage.rst:50
#: ../doc/1.7/reference/configuration/cfg_storage.rst:55
#: ../doc/1.7/reference/configuration/cfg_storage.rst:62
#: ../doc/1.7/reference/configuration/cfg_storage.rst:66
#: ../doc/1.7/reference/configuration/cfg_storage.rst:72
#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:82
#: ../doc/1.7/reference/configuration/cfg_storage.rst:90
#: ../doc/1.7/reference/configuration/cfg_storage.rst:93
#: ../doc/1.7/reference/configuration/cfg_storage.rst:100
#: ../doc/1.7/reference/configuration/cfg_storage.rst:104
#: ../doc/1.7/reference/configuration/cfg_storage.rst:110
#: ../doc/1.7/reference/configuration/cfg_storage.rst:116
#: ../doc/1.7/reference/configuration/cfg_storage.rst:121
#: ../doc/1.7/reference/configuration/cfg_storage.rst:127
#: ../doc/1.7/reference/configuration/cfg_storage.rst:132
#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
#: ../doc/1.7/reference/configuration/cfg_storage.rst:144
#: ../doc/1.7/reference/configuration/cfg_storage.rst:149
#: ../doc/1.7/reference/configuration/cfg_storage.rst:155
#: ../doc/1.7/reference/configuration/cfg_storage.rst:166
#: ../doc/1.7/reference/configuration/cfg_storage.rst:177
msgid "Dynamic: no"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:29
#: ../doc/1.7/reference/configuration/cfg_basic.rst:57
msgid ""
"Add the given string to the server's process title (what’s shown in the "
"COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:33
#: ../doc/1.7/reference/configuration/cfg_basic.rst:61
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process"
" thus:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:36
#: ../doc/1.7/reference/configuration/cfg_basic.rst:64
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:41
#: ../doc/1.7/reference/configuration/cfg_basic.rst:69
msgid ""
"But if the configuration parameters include "
"``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:44
#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:49
#: ../doc/1.7/reference/configuration/cfg_basic.rst:77
#: ../doc/1.7/reference/configuration/cfg_basic.rst:83
#: ../doc/1.7/reference/configuration/cfg_basic.rst:94
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_basic.rst:122
#: ../doc/1.7/reference/configuration/cfg_basic.rst:147
#: ../doc/1.7/reference/configuration/cfg_basic.rst:150
#: ../doc/1.7/reference/configuration/cfg_basic.rst:161
#: ../doc/1.7/reference/configuration/cfg_basic.rst:175
#: ../doc/1.7/reference/configuration/cfg_basic.rst:186
#: ../doc/1.7/reference/configuration/cfg_basic.rst:189
#: ../doc/1.7/reference/configuration/cfg_basic.rst:214
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:59
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:87
#: ../doc/1.7/reference/configuration/cfg_logging.rst:101
#: ../doc/1.7/reference/configuration/cfg_logging.rst:129
#: ../doc/1.7/reference/configuration/cfg_replication.rst:31
#: ../doc/1.7/reference/configuration/cfg_replication.rst:59
msgid "Type: string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
#: ../doc/1.7/reference/configuration/cfg_basic.rst:78
#: ../doc/1.7/reference/configuration/cfg_basic.rst:95
#: ../doc/1.7/reference/configuration/cfg_basic.rst:100
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:148
#: ../doc/1.7/reference/configuration/cfg_basic.rst:176
#: ../doc/1.7/reference/configuration/cfg_basic.rst:187
#: ../doc/1.7/reference/configuration/cfg_basic.rst:215
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:44
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:102
#: ../doc/1.7/reference/configuration/cfg_logging.rst:130
#: ../doc/1.7/reference/configuration/cfg_networking.rst:14
#: ../doc/1.7/reference/configuration/cfg_networking.rst:42
#: ../doc/1.7/reference/configuration/cfg_replication.rst:32
#: ../doc/1.7/reference/configuration/cfg_replication.rst:60
msgid "Default: null"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:73
#: ../doc/1.7/reference/configuration/cfg_basic.rst:79
#: ../doc/1.7/reference/configuration/cfg_basic.rst:101
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
#: ../doc/1.7/reference/configuration/cfg_basic.rst:140
#: ../doc/1.7/reference/configuration/cfg_basic.rst:167
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:68
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:96
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:45
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:73
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:97
msgid "Dynamic: yes"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:57
#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be "
"specified** if connections will occur from remote clients that do not use"
" the :ref:`“admin port” <admin-security>`. Connections made with "
":samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" "
"connections."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:64
#: ../doc/1.7/reference/configuration/cfg_basic.rst:92
msgid "A typical value is 3301."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:68
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:71
#: ../doc/1.7/reference/configuration/cfg_basic.rst:99
msgid "Type: integer or string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:79
#: ../doc/1.7/reference/configuration/cfg_basic.rst:107
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to"
" :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:84
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:151
#: ../doc/1.7/reference/configuration/cfg_basic.rst:162
#: ../doc/1.7/reference/configuration/cfg_basic.rst:190
msgid "Default: \".\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:91
#: ../doc/1.7/reference/configuration/cfg_basic.rst:119
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:102
#: ../doc/1.7/reference/configuration/cfg_basic.rst:130
msgid ""
"Say ``box.cfg{read_only=true...}`` to put the server instance in read-"
"only mode. After this, any requests that try to change persistent data "
"will fail with error :errcode:`ER_READONLY`. Read-only mode should be "
"used for master-replica :ref:`replication <replication>`. Read-only mode "
"does not affect data-change requests for spaces defined as "
":ref:`temporary <box_schema-space_create>`. Although read-only mode "
"prevents the server from writing to the :ref:`WAL <internals-wal>`, it "
"does not prevent writing diagnostics with the :ref:`log module <log-"
"module>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:118
#: ../doc/1.7/reference/configuration/cfg_basic.rst:146
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, "
"defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:130
#: ../doc/1.7/reference/configuration/cfg_basic.rst:158
msgid ""
"The vinyl storage engine has a scheduler which does compaction. When "
"vinyl is low on available memory, the compaction scheduler may be unable "
"to keep up with incoming update requests. In that situation, queries may "
"time out after ``vinyl_timeout`` seconds. This should rarely occur, since"
" normally vinyl would throttle inserts when it is running low on "
"compaction bandwidth."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:137
#: ../doc/1.7/reference/configuration/cfg_basic.rst:165
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:43
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:71
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:99
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:93
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:108
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:121
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:136
#: ../doc/1.7/reference/configuration/cfg_logging.rst:127
#: ../doc/1.7/reference/configuration/cfg_logging.rst:155
#: ../doc/1.7/reference/configuration/cfg_networking.rst:13
#: ../doc/1.7/reference/configuration/cfg_networking.rst:41
#: ../doc/1.7/reference/configuration/cfg_storage.rst:25
#: ../doc/1.7/reference/configuration/cfg_storage.rst:53
#: ../doc/1.7/reference/configuration/cfg_storage.rst:60
#: ../doc/1.7/reference/configuration/cfg_storage.rst:88
#: ../doc/1.7/reference/configuration/cfg_storage.rst:125
#: ../doc/1.7/reference/configuration/cfg_storage.rst:153
msgid "Type: float"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_basic.rst:166
msgid "Default: 60"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:145
#: ../doc/1.7/reference/configuration/cfg_basic.rst:173
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:155
#: ../doc/1.7/reference/configuration/cfg_basic.rst:183
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` "
"and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different "
"values, so that write-ahead log files and snapshot files can be stored on"
" different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:169
#: ../doc/1.7/reference/configuration/cfg_basic.rst:197
msgid ""
"A directory where database working files will be stored. The server "
"instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. "
"Can be relative to the current directory. If not specified, defaults to "
"the current directory. Other directory parameters may be relative to "
"``work_dir``, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:175
#: ../doc/1.7/reference/configuration/cfg_basic.rst:203
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:183
#: ../doc/1.7/reference/configuration/cfg_basic.rst:211
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in "
"``/home/user/A/C``, and all other files or subdirectories in "
"``/home/user/A``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:1
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:29
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:2
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:3
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:31
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:4
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:32
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:5
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:33
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:11
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:39
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start) or a write-ahead log file (at server instance start or to relay to"
" a replica), abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:16
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:44
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:56
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:67
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:84
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_logging.rst:116
#: ../doc/1.7/reference/configuration/cfg_logging.rst:144
msgid "Default: true"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid ""
"How many log records to store in a single write-ahead log file. When this"
" limit is reached, Tarantool creates another WAL file named :samp"
":`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based "
"backups."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:28
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:56
#: ../doc/1.7/reference/configuration/cfg_logging.rst:27
#: ../doc/1.7/reference/configuration/cfg_logging.rst:55
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
#: ../doc/1.7/reference/configuration/cfg_networking.rst:58
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:43
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:67
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:95
#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
#: ../doc/1.7/reference/configuration/cfg_storage.rst:48
#: ../doc/1.7/reference/configuration/cfg_storage.rst:64
#: ../doc/1.7/reference/configuration/cfg_storage.rst:70
#: ../doc/1.7/reference/configuration/cfg_storage.rst:76
#: ../doc/1.7/reference/configuration/cfg_storage.rst:80
#: ../doc/1.7/reference/configuration/cfg_storage.rst:91
#: ../doc/1.7/reference/configuration/cfg_storage.rst:98
#: ../doc/1.7/reference/configuration/cfg_storage.rst:102
#: ../doc/1.7/reference/configuration/cfg_storage.rst:108
#: ../doc/1.7/reference/configuration/cfg_storage.rst:114
#: ../doc/1.7/reference/configuration/cfg_storage.rst:119
#: ../doc/1.7/reference/configuration/cfg_storage.rst:130
#: ../doc/1.7/reference/configuration/cfg_storage.rst:136
#: ../doc/1.7/reference/configuration/cfg_storage.rst:142
#: ../doc/1.7/reference/configuration/cfg_storage.rst:147
#: ../doc/1.7/reference/configuration/cfg_storage.rst:164
#: ../doc/1.7/reference/configuration/cfg_storage.rst:175
msgid "Type: integer"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:29
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:57
msgid "Default: 500000"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:36
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes"
" per second it can write to disk. The same can be achieved by splitting "
":ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-"
"memtx_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:45
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:61
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:73
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:89
#: ../doc/1.7/reference/configuration/cfg_logging.rst:29
#: ../doc/1.7/reference/configuration/cfg_logging.rst:57
#: ../doc/1.7/reference/configuration/cfg_logging.rst:129
#: ../doc/1.7/reference/configuration/cfg_logging.rst:157
#: ../doc/1.7/reference/configuration/cfg_networking.rst:15
#: ../doc/1.7/reference/configuration/cfg_networking.rst:32
#: ../doc/1.7/reference/configuration/cfg_networking.rst:43
#: ../doc/1.7/reference/configuration/cfg_networking.rst:60
#: ../doc/1.7/reference/configuration/cfg_replication.rst:33
#: ../doc/1.7/reference/configuration/cfg_replication.rst:61
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:51
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:53
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:54
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:82
msgid ""
"``write``: fibers wait for their data to be written to the write-ahead "
"log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:56
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:84
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each "
":manpage:`write(2)`;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:60
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:88
msgid "Default: \"write\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:67
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:95
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the "
"sake of replication or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:72
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:100
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:68
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:96
msgid "Default: 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:3
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:31
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:5
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:6
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:34
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:7
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:35
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:8
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:36
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:9
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:37
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:10
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:38
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:11
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:39
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:12
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:40
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:13
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:14
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:42
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:15
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:43
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:16
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:44
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:17
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:45
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:23
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:51
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:101
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:129
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:61
msgid ""
"**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter "
"was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:69
msgid ""
"**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:49
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:63
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:77
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:91
msgid ""
"**Deprecated** in favor of :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:52
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:80
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start), abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:74
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:102
msgid ""
"**Deprecated** in favor of :ref:`replication <cfg_replication-"
"replication>`. The parameter was only renamed, while the type, values and"
" semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:111
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:86
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:114
msgid ""
"How much memory Tarantool allocates to actually store tuples, **in "
"gigabytes**. When the limit is reached, INSERT or UPDATE requests begin "
"failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not "
"go beyond the defined limit to allocate tuples, there is additional "
"memory used to store indexes and connection information. Depending on "
"actual configuration and workload, Tarantool can consume up to 20% more "
"than the limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:122
msgid "Default: 1.0"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:103
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:131
msgid ""
"The multiplier for computing the sizes of memory chunks that tuples are "
"stored in. A lower value may result in less wasted memory depending on "
"the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:109
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:137
msgid "Default: 1.1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:116
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:144
msgid ""
"**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:125
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:153
msgid ""
"**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-"
"memtx_min_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:134
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:162
msgid ""
"**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The "
"parameter was only renamed, while the type, values and semantics remained"
" intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:142
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:170
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only "
"renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:151
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:179
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:3
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:31
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:5
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:33
msgid ""
"Hot standby is a feature which provides a simple form of failover without"
" replication."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:8
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:36
msgid ""
"The expectation is that there will be two instances of the server using "
"the same configuration. The first one to start will be the \"primary\" "
"instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:12
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:40
msgid ""
"To initiate the standby instance, start a second instance of the "
"Tarantool server on the same computer with the same :ref:`box.cfg "
"<box_introspection-box_cfg>` configuration settings -- including the same"
" directories and same non-null URIs -- and with the additional parameter "
"``hot_standby = true``. Expect to see a notification ending with the "
"words ``I> Entering hot standby mode``. This is fine. It means that the "
"standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:21
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:49
msgid ""
"The standby instance will initialize and will try to take a lock on "
":ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary "
"instance has made a lock on ``wal_dir``. So the standby instance goes "
"into a loop, reading the write ahead log which the primary instance is "
"writing (so the two instances are always in synch), and trying to take "
"the lock. If the primary instance goes down for any reason, the lock will"
" be released. in this case, the standby instance will succeed in taking "
"the lock, will connect on listen address and will become the primary "
"instance. Expect to see a notification ending with the words ``I> ready "
"to accept requests``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:33
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:61
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:35
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:63
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:37
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:65
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and "
"FreeBSD); on these platforms, it is designed so that the loop repeats "
"every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:41
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:69
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it "
"is designed to work with ``wal_mode = 'write'`` or ``wal_mode = "
"'fsync'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:43
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:71
msgid ""
"for spaces created with :ref:`engine = 'vinyl' <box_schema-"
"space_create>`; it is designed to work for spaces created with ``engine ="
" 'memtx'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:3
#: ../doc/1.7/reference/configuration/cfg_logging.rst:31
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:4
#: ../doc/1.7/reference/configuration/cfg_logging.rst:32
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:5
#: ../doc/1.7/reference/configuration/cfg_logging.rst:33
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:6
#: ../doc/1.7/reference/configuration/cfg_logging.rst:34
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:12
#: ../doc/1.7/reference/configuration/cfg_logging.rst:40
msgid "What level of detail the log will have. There are seven levels:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:14
#: ../doc/1.7/reference/configuration/cfg_logging.rst:42
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:15
#: ../doc/1.7/reference/configuration/cfg_logging.rst:43
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:16
#: ../doc/1.7/reference/configuration/cfg_logging.rst:44
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:17
#: ../doc/1.7/reference/configuration/cfg_logging.rst:45
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:18
#: ../doc/1.7/reference/configuration/cfg_logging.rst:46
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:19
#: ../doc/1.7/reference/configuration/cfg_logging.rst:47
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:20
#: ../doc/1.7/reference/configuration/cfg_logging.rst:48
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:22
#: ../doc/1.7/reference/configuration/cfg_logging.rst:50
msgid ""
"By setting log_level, one can enable logging of all classes below or "
"equal to the given level. Tarantool prints its logs to the standard error"
" stream by default, but this can be changed with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:28
#: ../doc/1.7/reference/configuration/cfg_logging.rst:56
msgid "Default: 5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:31
#: ../doc/1.7/reference/configuration/cfg_logging.rst:59
msgid ""
"Warning: prior to Tarantool 1.7.5 there were only six levels and "
"``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level"
" 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring "
"repetitive events which would cause too much log writing if ``INFO`` were"
" used instead."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:40
#: ../doc/1.7/reference/configuration/cfg_logging.rst:68
msgid ""
"By default, Tarantool sends the log to the standard error stream "
"(``stderr``). If ``log`` is specified, Tarantool sends the log to a file,"
" or to a pipe, or to the system logger."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:44
#: ../doc/1.7/reference/configuration/cfg_logging.rst:56
#: ../doc/1.7/reference/configuration/cfg_logging.rst:70
#: ../doc/1.7/reference/configuration/cfg_logging.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:84
#: ../doc/1.7/reference/configuration/cfg_logging.rst:98
msgid "Example setting:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:46
#: ../doc/1.7/reference/configuration/cfg_logging.rst:74
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file: tarantool.log'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:52
#: ../doc/1.7/reference/configuration/cfg_logging.rst:80
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s "
"default directory. If the ``log`` string has no prefix or has the prefix "
"\"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:58
#: ../doc/1.7/reference/configuration/cfg_logging.rst:86
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:64
#: ../doc/1.7/reference/configuration/cfg_logging.rst:92
msgid ""
"This will start the program ``cronolog`` when the server starts, and will"
" send all log messages to the standard input (``stdin``) of cronolog. If "
"the ``log`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline "
"<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:100
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:80
#: ../doc/1.7/reference/configuration/cfg_logging.rst:108
msgid ""
"If the ``log`` string has the prefix \"syslog:\", then the string is "
"interpreted as a message for the `syslogd <http://www.rfc-"
"base.org/txt/rfc-5424.txt>`_ program which normally is running in the "
"background of any Unix-like platform. One can optionally specify an "
"``identity``, a ``facility``, or both. The ``identity`` is an arbitrary "
"string, default value = ``tarantool``, which will be placed at the "
"beginning of all messages. The facility is an abbreviation for the name "
"of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ "
"facilities, default value = ``user``, which tell syslogd where the "
"message should go."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:91
#: ../doc/1.7/reference/configuration/cfg_logging.rst:119
msgid ""
"Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, "
"kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, "
"local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:95
#: ../doc/1.7/reference/configuration/cfg_logging.rst:123
msgid ""
"The ``facility`` setting is currently ignored but will be used in the "
"future."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:97
#: ../doc/1.7/reference/configuration/cfg_logging.rst:125
msgid ""
"When logging to a file, Tarantool reopens the log on SIGHUP. When log is "
"a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>`"
" variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:109
#: ../doc/1.7/reference/configuration/cfg_logging.rst:137
msgid ""
"If ``log_nonblock`` equals true, Tarantool does not block on the log file"
" descriptor when it’s not ready for write, and drops the message instead."
" If :ref:`log_level <cfg_logging-log_level>` is high, and a lot of "
"messages go to the log file, setting ``log_nonblock`` to true may improve"
" logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:123
#: ../doc/1.7/reference/configuration/cfg_logging.rst:151
msgid ""
"If processing a request takes longer than the given value (in seconds), "
"warn about it in the log. Has effect only if :ref:`log_level "
"<cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:128
#: ../doc/1.7/reference/configuration/cfg_logging.rst:156
msgid "Default: 0.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:135
#: ../doc/1.7/reference/configuration/cfg_logging.rst:163
msgid "Logging example"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:137
#: ../doc/1.7/reference/configuration/cfg_logging.rst:165
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when "
"the server instance is writing to a log and signals are used when "
"archiving it."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:140
#: ../doc/1.7/reference/configuration/cfg_logging.rst:168
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:142
#: ../doc/1.7/reference/configuration/cfg_logging.rst:170
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the "
"logging will go to `Log_file`, then put a message \"Log Line #1\" in the "
"log file:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:145
#: ../doc/1.7/reference/configuration/cfg_logging.rst:173
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:151
#: ../doc/1.7/reference/configuration/cfg_logging.rst:179
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. "
"The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:185
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1033
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:159
#: ../doc/1.7/reference/configuration/cfg_logging.rst:187
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:161
#: ../doc/1.7/reference/configuration/cfg_logging.rst:189
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:165
#: ../doc/1.7/reference/configuration/cfg_logging.rst:193
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool "
"instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:198
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1046
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:172
#: ../doc/1.7/reference/configuration/cfg_logging.rst:200
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the "
"Tarantool instance. The result of this is: Tarantool will open `Log_file`"
" again, and the next log message will go to `Log_file`. (The same effect "
"could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:208
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1056
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:182
#: ../doc/1.7/reference/configuration/cfg_logging.rst:210
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:184
#: ../doc/1.7/reference/configuration/cfg_logging.rst:212
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:188
#: ../doc/1.7/reference/configuration/cfg_logging.rst:216
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the "
"example is done:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:222
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1070
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:197
#: ../doc/1.7/reference/configuration/cfg_logging.rst:225
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:230 ../internal after
#: doc/1.7/reference/configuration/cfg_logging.rst:1078 padding
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:1
#: ../doc/1.7/reference/configuration/cfg_networking.rst:29
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:2
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
msgid ":ref:`readahead <cfg_networking-readahead>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:8
#: ../doc/1.7/reference/configuration/cfg_networking.rst:36
msgid ""
"The instance will sleep for io_collect_interval seconds between "
"iterations of the event loop. Can be used to reduce CPU load in "
"deployments in which the number of client connections is large, but "
"requests are not so frequent (for example, each connection issues just a "
"handful of requests per second)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:21
#: ../doc/1.7/reference/configuration/cfg_networking.rst:49
msgid ""
"The size of the read-ahead buffer associated with a client connection. "
"The larger the buffer, the more memory an active connection consumes and "
"the more requests can be read from the operating system buffer in a "
"single system call. The rule of thumb is to make sure the buffer can "
"contain at least a few dozen requests. Therefore, if a typical tuple in a"
" request is large, e.g. a few kilobytes or even megabytes, the read-ahead"
" buffer size should be increased. If batched request processing is not "
"used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:31
#: ../doc/1.7/reference/configuration/cfg_networking.rst:59
msgid "Default: 16320"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:1
#: ../doc/1.7/reference/configuration/cfg_replication.rst:29
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:7
#: ../doc/1.7/reference/configuration/cfg_replication.rst:35
msgid ""
"If ``replication`` is not an empty string, the instance is considered to "
"be a Tarantool :ref:`replica <replication>`. The replica will try to "
"connect to the master specified in ``replication`` with a :ref:`URI "
"<index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:12
#: ../doc/1.7/reference/configuration/cfg_replication.rst:40
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:14
#: ../doc/1.7/reference/configuration/cfg_replication.rst:42
msgid ""
"If there is more than one replication source in a replica set, specify an"
" array of URIs, for example: (replace 'uri' and 'uri2' in this example "
"with valid URIs):"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:17
#: ../doc/1.7/reference/configuration/cfg_replication.rst:45
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:19
#: ../doc/1.7/reference/configuration/cfg_replication.rst:47
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. "
"Thus it is possible to use the same ``replication`` specification on "
"multiple servers."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:24
#: ../doc/1.7/reference/configuration/cfg_replication.rst:52
msgid ""
"The default user name is ‘guest’. A replica does not accept data-change "
"requests on the :ref:`listen <cfg_basic-listen>` port. The "
"``replication`` parameter is dynamic, that is, to enter master mode, "
"simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:29
#: ../doc/1.7/reference/configuration/cfg_replication.rst:57
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:1
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:29
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:2
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:30
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:4
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:32
msgid ""
"The checkpoint daemon is a fiber which is constantly running. At "
"intervals, it may make new snapshot (.snap) files and then may delete old"
" snapshot files. If the checkpoint daemon deletes an old snapshot file, "
"then it will also delete any write-ahead log (.xlog) files which are "
"older than the snapshot file and which contain information that is "
"present in the snapshot file. It will also delete obsolete vinyl .run "
"files."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:11
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:39
msgid ""
"Exceptions: the checkpoint daemon will not delete a file if a backup is "
"ongoing and the file has not been backed up (see :ref:`\"Hot backup\" "
"<admin-backups-hot_backup_vinyl_memtx>`), or if replication is ongoing "
"and the file has not been relayed to a replica (see :ref:`\"Replication "
"architecture\" <replication-architecture>`), or if a replica is "
"connecting."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:18
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:46
msgid ""
"The :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` configuration settings determine how long the "
"intervals are, and how many snapshots should exist before deletions "
"occur."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:27
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:55
msgid ""
"The interval between actions by the checkpoint daemon, in seconds. If "
"``checkpoint_interval`` is set to a value greater than zero, and there is"
" activity which causes change to a database, then the checkpoint daemon "
"will call :ref:`box.snapshot <box-snapshot>` every "
"``checkpoint_interval`` seconds, creating a new snapshot file each time. "
"If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is "
"disabled."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:34
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:62
#: ../doc/1.7/reference/reference_lua/box_error.rst:66
#: ../doc/1.7/reference/reference_rock/dbms.rst:110
#: ../doc/1.7/reference/reference_rock/dbms.rst:463
msgid "For example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:36
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:64
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:40
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:68
msgid ""
"will cause the checkpoint daemon to create a new database snapshot once "
"per minute, if there is activity."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:44
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:72
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:51
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:79
msgid ""
"The maximum number of snapshots that may exist on the ``memtx_dir`` "
"directory before the checkpoint daemon will delete old snapshots. If "
"``checkpoint_count`` equals zero, then the checkpoint daemon does not "
"delete old snapshots. For example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:56
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:84
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:63
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:91
msgid ""
"will cause the checkpoint daemon to create a new snapshot each hour until"
" it has created ten snapshots. After that, it will delete the oldest "
"snapshot (and any associated write-ahead-log files) after creating a new "
"one."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:1
#: ../doc/1.7/reference/configuration/cfg_storage.rst:29
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:2
#: ../doc/1.7/reference/configuration/cfg_storage.rst:30
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:3
#: ../doc/1.7/reference/configuration/cfg_storage.rst:31
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:4
#: ../doc/1.7/reference/configuration/cfg_storage.rst:32
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:5
#: ../doc/1.7/reference/configuration/cfg_storage.rst:33
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:6
#: ../doc/1.7/reference/configuration/cfg_storage.rst:34
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:7
#: ../doc/1.7/reference/configuration/cfg_storage.rst:35
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:8
#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:9
#: ../doc/1.7/reference/configuration/cfg_storage.rst:37
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:10
#: ../doc/1.7/reference/configuration/cfg_storage.rst:38
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:11
#: ../doc/1.7/reference/configuration/cfg_storage.rst:39
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:12
#: ../doc/1.7/reference/configuration/cfg_storage.rst:40
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:18
#: ../doc/1.7/reference/configuration/cfg_storage.rst:46
msgid ""
"How much memory Tarantool allocates to actually store tuples, in bytes. "
"When the limit is reached, INSERT or UPDATE requests begin failing with "
"error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the"
" defined limit to allocate tuples, there is additional memory used to "
"store indexes and connection information. Depending on actual "
"configuration and workload, Tarantool can consume up to 20% more than the"
" limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:26
#: ../doc/1.7/reference/configuration/cfg_storage.rst:54
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:33
#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
msgid ""
"Size of the largest allocation unit, in bytes. It can be increased if it "
"is necessary to store large tuples."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:37
#: ../doc/1.7/reference/configuration/cfg_storage.rst:65
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:44
#: ../doc/1.7/reference/configuration/cfg_storage.rst:72
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if "
"most of the tuples are very small. The value must be between 8 and "
"1048280 inclusive."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:49
#: ../doc/1.7/reference/configuration/cfg_storage.rst:77
msgid "Default: 16"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:56
#: ../doc/1.7/reference/configuration/cfg_storage.rst:84
msgid ""
"Bloom filter false positive rate -- the suitable probability of the bloom"
" filter to give a wrong result. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
#: ../doc/1.7/reference/configuration/cfg_storage.rst:89
msgid "Default = 0.05"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:68
#: ../doc/1.7/reference/configuration/cfg_storage.rst:96
msgid "The maximal cache size for vinyl, in bytes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:71
#: ../doc/1.7/reference/configuration/cfg_storage.rst:81
#: ../doc/1.7/reference/configuration/cfg_storage.rst:99
#: ../doc/1.7/reference/configuration/cfg_storage.rst:109
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:106
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:88
#: ../doc/1.7/reference/configuration/cfg_storage.rst:116
msgid ""
"Page size, in bytes. Page is a R/W unit for vinyl disk operations. This "
"can be overridden by a :ref:`create_index <box_space-create_index>` "
"option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:92
#: ../doc/1.7/reference/configuration/cfg_storage.rst:120
msgid "Default = 8 * 1024"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:99
#: ../doc/1.7/reference/configuration/cfg_storage.rst:127
msgid ""
"The maximal range size for vinyl, in bytes. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:103
#: ../doc/1.7/reference/configuration/cfg_storage.rst:131
msgid "Default = 1024 * 1024 * 1024"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:110
#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
msgid ""
"The maximal number of runs per level in vinyl LSM tree. If this number is"
" exceeded, a new level is created. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:115
#: ../doc/1.7/reference/configuration/cfg_storage.rst:143
#: ../doc/1.7/reference/configuration/cfg_storage.rst:148
#: ../doc/1.7/reference/configuration/cfg_storage.rst:176
msgid "Default = 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:122
#: ../doc/1.7/reference/configuration/cfg_storage.rst:150
msgid ""
"Ratio between the sizes of different levels in the LSM tree. This can be "
"overridden by a :ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:126
#: ../doc/1.7/reference/configuration/cfg_storage.rst:154
msgid "Default = 3.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:133
#: ../doc/1.7/reference/configuration/cfg_storage.rst:161
msgid ""
"The maximum number of read threads that vinyl can use for some concurrent"
" operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:137
#: ../doc/1.7/reference/configuration/cfg_storage.rst:165
msgid "Default = 1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:144
#: ../doc/1.7/reference/configuration/cfg_storage.rst:172
msgid ""
"The maximum number of write threads that vinyl can use for some "
"concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:33
msgid "Configuration reference"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:35
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an :ref:`initialization file <index-"
"init_label>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:38
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:43
msgid ""
"$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:51
msgid "Command options"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:55
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:61
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:63
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:70
msgid "In this example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:72
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking "
"programming framework."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:75
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` "
"is incremented for each new milestone and indicates possible incompatible"
" changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there "
"may be a commit number and commit SHA1 to indicate how much this "
"particular build has diverged from the last release."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:83
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:88
msgid ""
"Tarantool uses `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to "
"produce its version id, and this id can be used at any time to check out "
"the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:98
msgid "URI"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:100
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to "
"the `generic syntax for a URI schema "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may "
"contain (in order) a user name for login, a password, a host name or host"
" IP address, and a port number. Only the port number is always mandatory."
" The password is mandatory if the user name is specified, unless the user"
" name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or "
"``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or "
"'[::]' is assumed, meaning respectively any IPv4 address or any IPv6 "
"address, on the local machine. If username:password is omitted, then "
"'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:119
msgid "URI fragment"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:119
#: ../doc/1.7/reference/reference_lua/digest.rst:224
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:154
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:262
#: ../doc/1.7/reference/reference_lua/log.rst:72
#: ../doc/1.7/reference/reference_lua/msgpack.rst:68
#: ../doc/1.7/reference/reference_lua/net_box.rst:331
#: ../doc/1.7/reference/reference_lua/tap.rst:206
#: ../doc/1.7/reference/reference_lua/uuid.rst:138
#: ../doc/1.7/reference/reference_lua/yaml.rst:64
#: ../doc/1.7/reference/reference_rock/dbms.rst:277
#: ../doc/1.7/reference/reference_rock/dbms.rst:619
msgid "Example"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:121
msgid "port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:121
msgid "3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:123
msgid "host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:123
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:125
msgid "username:password@host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:125
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:128
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply "
"\"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:132
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:138
msgid "Initialization file"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:140
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-"
"initialization-file`, then Tarantool begins by invoking the Lua program "
"in the file, which by convention may have the name \"``script.lua``\". "
"The Lua program may get further arguments from the command line or may "
"use operating-system functions, such as ``getenv()``. The Lua program "
"almost always begins by invoking ``box.cfg()``, if the database server "
"will be used or if ports need to be opened. For example, suppose "
"``script.lua`` contains the lines"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:148
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:159
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and "
"suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``."
" Then the screen might look like this:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:163
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:177
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-"
"start>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:193
msgid "Configuration parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:195
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:197
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:199
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since "
"some of the parameters (such as directory addresses) are semi-permanent, "
"it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is "
"the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:204
msgid ""
"Most configuration parameters are for allocating resources, opening "
"ports, and specifying database behavior. All parameters are optional. A "
"few parameters are dynamic, that is, they can be changed at runtime by "
"calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:209
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To "
"see a particular parameter, for example the listen address, say "
"``box.cfg.listen``."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:212
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for "
"networking, and for logging."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:217
msgid "Basic parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:223
msgid "Configuring the storage"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:231
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:237
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:245
msgid "Hot standby"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:251
msgid "Replication"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:257
msgid "Networking"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:263
msgid "Logging"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:269
msgid "Deprecated parameters"
msgstr ""

#: ../doc/1.7/reference/index.rst:33
msgid "Reference"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:33
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:35
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with "
"``select()`` requests. The same rules exist for the other data-"
"manipulation functions."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:39
msgid ""
"Every one of the examples does the same thing: select a tuple set from a "
"space named 'tester' where the primary-key field value equals 1. For "
"these examples, we assume that the numeric id of 'tester' is 512, which "
"happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:46
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:48
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:58
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" "
"form (#1). However, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:62
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" "
"for references to objects which are spaces, and \"``index_object:``\" for"
" references to objects which are indexes (for example "
":samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:69
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:71
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:90
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its "
"only argument is a Lua table, and we use it sometimes in our examples. "
"This is why ``select{1}`` is equivalent to ``select({1})``. Literal "
"values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may "
"be replaced by variable names, as in examples #6 and #7. Although there "
"are special cases where braces can be omitted, they are preferable "
"because they signal \"Lua table\". Examples and descriptions in this "
"manual have the ``{1}`` form. However, this too is a matter of user "
"preference and all the variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:33
msgid "Module `box`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:35
msgid ""
"As well as executing Lua chunks or defining their own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its"
" submodules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:38
msgid ""
"The contents of the ``box`` module can be inspected at runtime with "
"``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:61
msgid ""
"Every submodule contains one or more Lua functions. A few submodules "
"contain members as well as functions. The functions allow data definition"
" (create alter drop), data manipulation (insert delete update upsert "
"select replace), and introspection (inspecting contents of spaces, "
"accessing server configuration)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:31
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:35
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in ``error()`` function is that "
"when the error reaches the client, its error code is preserved. In "
"contrast, a Lua error would always be presented to the client as "
":errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:42
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst
#: ../doc/1.7/reference/reference_lua/box_once.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/osmodule.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "Parameters"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:50
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:57
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_ in "
"the source tree. Lua constants which correspond to those Tarantool errors"
" are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:63
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:64
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:68
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst
msgid "except"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:74
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:76
#: ../doc/1.7/reference/reference_lua/box_error.rst:114
#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:72
#: ../doc/1.7/reference/reference_lua/clock.rst:54
#: ../doc/1.7/reference/reference_lua/clock.rst:77
#: ../doc/1.7/reference/reference_lua/clock.rst:96
#: ../doc/1.7/reference/reference_lua/clock.rst:115
#: ../doc/1.7/reference/reference_lua/clock.rst:135
#: ../doc/1.7/reference/reference_lua/console.rst:73
#: ../doc/1.7/reference/reference_lua/console.rst:104
#: ../doc/1.7/reference/reference_lua/console.rst:129
#: ../doc/1.7/reference/reference_lua/console.rst:168
#: ../doc/1.7/reference/reference_lua/crypto.rst:67
#: ../doc/1.7/reference/reference_lua/crypto.rst:96
#: ../doc/1.7/reference/reference_lua/csv.rst:77
#: ../doc/1.7/reference/reference_lua/csv.rst:159
#: ../doc/1.7/reference/reference_lua/csv.rst:204
#: ../doc/1.7/reference/reference_lua/errno.rst:69
#: ../doc/1.7/reference/reference_lua/fiber.rst:93
#: ../doc/1.7/reference/reference_lua/fiber.rst:117
#: ../doc/1.7/reference/reference_lua/fiber.rst:137
#: ../doc/1.7/reference/reference_lua/fiber.rst:157
#: ../doc/1.7/reference/reference_lua/fiber.rst:171
#: ../doc/1.7/reference/reference_lua/fiber.rst:188
#: ../doc/1.7/reference/reference_lua/fiber.rst:207
#: ../doc/1.7/reference/reference_lua/fiber.rst:234
#: ../doc/1.7/reference/reference_lua/fiber.rst:251
#: ../doc/1.7/reference/reference_lua/fiber.rst:271
#: ../doc/1.7/reference/reference_lua/fiber.rst:292
#: ../doc/1.7/reference/reference_lua/fiber.rst:317
#: ../doc/1.7/reference/reference_lua/fiber.rst:337
#: ../doc/1.7/reference/reference_lua/fiber.rst:362
#: ../doc/1.7/reference/reference_lua/fiber.rst:382
#: ../doc/1.7/reference/reference_lua/fiber.rst:427
#: ../doc/1.7/reference/reference_lua/fiber.rst:446
#: ../doc/1.7/reference/reference_lua/fio.rst:64
#: ../doc/1.7/reference/reference_lua/fio.rst:84
#: ../doc/1.7/reference/reference_lua/fio.rst:102
#: ../doc/1.7/reference/reference_lua/fio.rst:126
#: ../doc/1.7/reference/reference_lua/fio.rst:159
#: ../doc/1.7/reference/reference_lua/fio.rst:197
#: ../doc/1.7/reference/reference_lua/fio.rst:218
#: ../doc/1.7/reference/reference_lua/fio.rst:233
#: ../doc/1.7/reference/reference_lua/fio.rst:246
#: ../doc/1.7/reference/reference_lua/fio.rst:270
#: ../doc/1.7/reference/reference_lua/fio.rst:293
#: ../doc/1.7/reference/reference_lua/fio.rst:312
#: ../doc/1.7/reference/reference_lua/fio.rst:335
#: ../doc/1.7/reference/reference_lua/fio.rst:351
#: ../doc/1.7/reference/reference_lua/fio.rst:386
#: ../doc/1.7/reference/reference_lua/fio.rst:408
#: ../doc/1.7/reference/reference_lua/fio.rst:431
#: ../doc/1.7/reference/reference_lua/fio.rst:461
#: ../doc/1.7/reference/reference_lua/fio.rst:479
#: ../doc/1.7/reference/reference_lua/fio.rst:502
#: ../doc/1.7/reference/reference_lua/fio.rst:520
#: ../doc/1.7/reference/reference_lua/fio.rst:552
#: ../doc/1.7/reference/reference_lua/fio.rst:572
#: ../doc/1.7/reference/reference_lua/http.rst:52
#: ../doc/1.7/reference/reference_lua/http.rst:144
#: ../doc/1.7/reference/reference_lua/iconv.rst:60
#: ../doc/1.7/reference/reference_lua/iconv.rst:79
#: ../doc/1.7/reference/reference_lua/jit.rst:43
#: ../doc/1.7/reference/reference_lua/jit.rst:58
#: ../doc/1.7/reference/reference_lua/jit.rst:71
#: ../doc/1.7/reference/reference_lua/jit.rst:85
#: ../doc/1.7/reference/reference_lua/jit.rst:106
#: ../doc/1.7/reference/reference_lua/json.rst:51
#: ../doc/1.7/reference/reference_lua/json.rst:89
#: ../doc/1.7/reference/reference_lua/json.rst:116
#: ../doc/1.7/reference/reference_lua/net_box.rst:150
#: ../doc/1.7/reference/reference_lua/net_box.rst:167
#: ../doc/1.7/reference/reference_lua/net_box.rst:181
#: ../doc/1.7/reference/reference_lua/net_box.rst:194
#: ../doc/1.7/reference/reference_lua/net_box.rst:209
#: ../doc/1.7/reference/reference_lua/net_box.rst:231
#: ../doc/1.7/reference/reference_lua/net_box.rst:289
#: ../doc/1.7/reference/reference_lua/net_box.rst:305
#: ../doc/1.7/reference/reference_lua/net_box.rst:316
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:80
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:96
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:110
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:123
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:139
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:197
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:213
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:224
#: ../doc/1.7/reference/reference_lua/osmodule.rst:58
#: ../doc/1.7/reference/reference_lua/osmodule.rst:81
#: ../doc/1.7/reference/reference_lua/osmodule.rst:100
#: ../doc/1.7/reference/reference_lua/osmodule.rst:117
#: ../doc/1.7/reference/reference_lua/osmodule.rst:135
#: ../doc/1.7/reference/reference_lua/osmodule.rst:150
#: ../doc/1.7/reference/reference_lua/osmodule.rst:163
#: ../doc/1.7/reference/reference_lua/osmodule.rst:178
#: ../doc/1.7/reference/reference_lua/osmodule.rst:193
#: ../doc/1.7/reference/reference_lua/osmodule.rst:208
#: ../doc/1.7/reference/reference_lua/osmodule.rst:223
#: ../doc/1.7/reference/reference_lua/osmodule.rst:239
#: ../doc/1.7/reference/reference_lua/osmodule.rst:254
#: ../doc/1.7/reference/reference_lua/other.rst:45
#: ../doc/1.7/reference/reference_lua/other.rst:83
#: ../doc/1.7/reference/reference_lua/pickle.rst:92
#: ../doc/1.7/reference/reference_lua/pickle.rst:137
#: ../doc/1.7/reference/reference_lua/socket.rst:141
#: ../doc/1.7/reference/reference_lua/socket.rst:159
#: ../doc/1.7/reference/reference_lua/socket.rst:176
#: ../doc/1.7/reference/reference_lua/socket.rst:248
#: ../doc/1.7/reference/reference_lua/socket.rst:404
#: ../doc/1.7/reference/reference_lua/strict.rst:46
#: ../doc/1.7/reference/reference_lua/tap.rst:97
#: ../doc/1.7/reference/reference_lua/tap.rst:139
#: ../doc/1.7/reference/reference_lua/tarantool.rst:46
#: ../doc/1.7/reference/reference_lua/uri.rst:55
#: ../doc/1.7/reference/reference_lua/uri.rst:78
#: ../doc/1.7/reference/reference_lua/xlog.rst:54
#: ../doc/1.7/reference/reference_rock/dbms.rst:216
#: ../doc/1.7/reference/reference_rock/dbms.rst:240
#: ../doc/1.7/reference/reference_rock/dbms.rst:264
#: ../doc/1.7/reference/reference_rock/dbms.rst:559
#: ../doc/1.7/reference/reference_rock/dbms.rst:583
#: ../doc/1.7/reference/reference_rock/dbms.rst:606
msgid "**Example:**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:78
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:97
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:107
msgid "rtype: table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:111
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:116
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:33
msgid "Function `box.once`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:37
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:42
msgid ""
"See an example of using ``box.once()`` while :ref:`bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:45
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, "
"you can re-execute the failed ``box.once()`` block without stopping the "
"database. The solution is to delete the ``once`` object from the system "
"space :ref:`_schema <box_space-schema>`. Say "
"``box.space._schema:select{}``, find your ``once`` object there and "
"delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:52
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:72
msgid "a value that will be checked"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:73
msgid "a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:74
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:33
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:37
msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, tuples which were allocated before the snapshot has started are not"
" freed until the snapshot has finished. To preserve consistency of the "
"primary key, used to iterate over tuples, a copy-on-write technique is "
"employed. If the master process changes part of a primary key, the "
"corresponding process page is split, and the snapshot process obtains an "
"old copy of the page. In effect, the snapshot process uses multi-version "
"concurrency control in order to avoid copying changes which are "
"superseded while it is running."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:49
msgid ""
"Since a snapshot is written sequentially, one can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:55
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:63
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and writes this view to the snapshot file from a separate "
"thread."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:68
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:74
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:89
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:95
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:33
msgid "Module `clock`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:35
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:47
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:51
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:52
#: ../doc/1.7/reference/reference_lua/clock.rst:75
#: ../doc/1.7/reference/reference_lua/clock.rst:94
#: ../doc/1.7/reference/reference_lua/clock.rst:113
msgid "number or number64"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:56
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:62
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function"
" `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:68
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:74
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:79
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:88
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to"
" use with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:93
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:98
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:107
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to "
"use with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:112
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:117
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:125
msgid ""
"The time that a function takes within a processor. This function uses "
"``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it "
"is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:129
msgid "function or function reference"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:130
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:132
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever"
" the function returns."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:137
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:33
msgid "Module `console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:35
msgid ""
"The console module allows one Tarantool instance to access another "
"Tarantool instance, and allows one Tarantool instance to start listening "
"on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:45
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from"
" '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:49
msgid ""
"The console.connect function allows one Tarantool instance, in "
"interactive mode, to access another Tarantool instance. Subsequent "
"requests will appear to be handled locally, but in reality the requests "
"are being sent to the remote instance and the local instance is acting as"
" a client. Once connection is successful, the prompt will change and "
"subsequent requests are sent to, and executed on, the remote instance. "
"Results are displayed on the local instance. To return to local mode, "
"enter ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:57
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the "
"connection might look something like: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:61
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote instance is done with user name = 'guest'. The remote"
" instance could allow for this by granting at least one privilege: "
"``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:67
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:68
#: ../doc/1.7/reference/reference_lua/fiber.rst:315
#: ../doc/1.7/reference/reference_lua/fiber.rst:358
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:252
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:258
#: ../doc/1.7/reference/reference_lua/log.rst:62
#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
#: ../doc/1.7/reference/reference_lua/tap.rst:65
#: ../doc/1.7/reference/reference_lua/tap.rst:76
#: ../doc/1.7/reference/reference_lua/tap.rst:83
#: ../doc/1.7/reference/reference_lua/tap.rst:137
msgid "nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:70
msgid ""
"Possible errors: the connection will fail if the target Tarantool "
"instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:75
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:89
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in ``box.cfg{listen=...}``. The alternative way of listening is"
" via the URI specified in ``console.listen(...)``. This alternative way "
"is called \"administrative\" or simply :ref:`\"admin port\" <admin-"
"security>`. The listening is usually over a local host with a Unix domain"
" socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:96
msgid "the URI of the local instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:98
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, "
"so it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, "
"for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:106
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:127
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:131
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the Tarantool instance with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:136
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:145
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using Tarantool as a client or the user is using Tarantool via "
"``console.connect()``, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is "
"`true`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:154
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:156
msgid ""
"The default end-of-request marker is a newline (line feed). Custom "
"markers are not necessary because Tarantool can tell when a multi-line "
"request has not ended (for example, if it sees that a function "
"declaration does not have an end keyword). Nonetheless for special needs,"
" or for entering multi-line requests in older Tarantool versions, you can"
" change the end-of-request marker. As a result, newline alone is not "
"treated as end of request."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:164
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:166
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:170
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"    statement_1 = 'a'\n"
"    statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:33
msgid "Module `crypto`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:37
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's crypto module "
"supports ten types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` module. The functions "
"in crypto are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:49
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:52
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:53
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:54
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:55
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:58
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:60
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:61
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:62
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:63
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:65
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:69
msgid ""
"crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:80
msgid ""
"Pass or return a digest derived from the string. The twelve choices of "
"algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:83
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:84
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:85
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:86
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:87
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:88
msgid "ripemd160 -"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:89
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:90
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:91
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:92
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:93
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:94
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:98
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:105
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:107
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions.."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:113
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:137
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:139
msgid ""
"The following functions are equivalent. For example, the ``digest`` "
"function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:142
msgid ""
"crypto.cipher.aes256.cbc.encrypt('string', 'key') == "
"digest.aes256cbc.encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:31
msgid "Module `csv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:35
msgid ""
"The csv module handles records formatted according to Comma-Separated-"
"Values (CSV) rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:38
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:40
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:42
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:43
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:44
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:45
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:46
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:52
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:54
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to"
" designate end-of-field"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:56
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte "
"character to designate encloser of string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:58
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to "
"read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:60
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to "
"skip at the start (usually for a header)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:67
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:71
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:73
#: ../doc/1.7/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:75
#: ../doc/1.7/reference/reference_lua/fiber.rst:205
#: ../doc/1.7/reference/reference_lua/fio.rst:144
#: ../doc/1.7/reference/reference_lua/fio.rst:214
#: ../doc/1.7/reference/reference_lua/fio.rst:518
#: ../doc/1.7/reference/reference_lua/http.rst:106
#: ../doc/1.7/reference/reference_lua/json.rst:87
#: ../doc/1.7/reference/reference_lua/pickle.rst:135
#: ../doc/1.7/reference/reference_lua/socket.rst:174
#: ../doc/1.7/reference/reference_lua/socket.rst:548
#: ../doc/1.7/reference/reference_lua/socket.rst:560
#: ../doc/1.7/reference/reference_lua/yaml.rst:54
msgid "table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:79
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:82
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:94
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:97
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:106
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:114
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and "
"example respectively:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:118
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:145
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:151
#: ../doc/1.7/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:163
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:177
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:193
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time. Use of an iterator is strongly recommended if the amount of data "
"is large (ten or more megabytes)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:206
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:211
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:33
msgid "Module `digest`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:37
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"digest module supports several types of cryptographic hash functions "
"(AES_, MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function"
" (CRC32_), two functions for base64_, and two non-cryptographic hash "
"functions (guava_, murmur_). Some of the digest functionality is also "
"present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:45
msgid "The functions in digest are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:50
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:54
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:58
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:62
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:66
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:70
msgid ""
"Returns 160-bit binary string = digest made with SHA-0.|br| Not "
"recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:75
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:79
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:83
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:87
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:91
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:95
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:99
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:103
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:107
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:111
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:115
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:119
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:123
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:127
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:131
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:133
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ "
"polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to "
"be compatible with other checksum functions in other programming "
"languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:138
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:145
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:147
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:154
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:160
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:167
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:169
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:174
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:184
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:189
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:196
msgid "Incremental methods in the digest module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:198
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:204
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:226
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:230
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:256
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:259
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:33
msgid "Database error codes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:35
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:46
msgid "**List of error codes**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:52
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:52
msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has "
"been reached."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:62
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:62
msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:66
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:66
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:69
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:69
msgid "The specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:83
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:83
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:86
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:86
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:92
msgid "Handling errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:94
msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:97
msgid "Invoke with pcall."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:112
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:115
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:117
msgid ""
"To make a new error and pass it on, the box.error module provides "
":ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:120
msgid ""
"To find the last error, the box.error module provides "
":ref:`box.error.last() <box_error-last>`. (There is also a way to find "
"the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:125
msgid "Log."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:127
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:129
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:133
msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:137
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:151
msgid ""
"After a function call that might fail, like fio.open() above, it is "
"common to see syntax like ``if not f then ...`` or ``if f == nil then "
"...``, which check for common failures. But if there had been a syntax "
"error, for example fio.opex instead of fio.open, then there would have "
"been a Lua error and f would not have been changed. If checking for such "
"an obvious error had been a concern, the programmer would probably have "
"used pcall()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:161
msgid ""
"All functions in Tarantool modules should work this way, unless the "
"manual explicitly says otherwise."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:33
msgid "Module `errno`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:37
msgid "The ``errno`` module provides:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:39
msgid "a function :ref:`strerror() <errno-strerror>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:40
msgid "an operator :ref:`errno() <errno-errno>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:41
msgid ""
"a `metatable <https://www.lua.org/pil/13.html>`_ with constant error "
"names."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:43
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return "
"operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:51
msgid ""
"Return an error number for the last operating-system-related function, or"
" 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:54
msgid "integer"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:60
msgid ""
"Return a string, given an error number. The string will contain the text "
"of the conventional error message for the current operating system. If "
"``code`` is not supplied, the error message will be for the last "
"operating-system-related function, or 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:65
msgid "number of an operating-system error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:67
#: ../doc/1.7/reference/reference_lua/fiber.rst:186
#: ../doc/1.7/reference/reference_lua/fiber.rst:290
#: ../doc/1.7/reference/reference_lua/fiber.rst:335
#: ../doc/1.7/reference/reference_lua/fio.rst:62
#: ../doc/1.7/reference/reference_lua/fio.rst:82
#: ../doc/1.7/reference/reference_lua/fio.rst:100
#: ../doc/1.7/reference/reference_lua/json.rst:49
#: ../doc/1.7/reference/reference_lua/msgpack.rst:46
#: ../doc/1.7/reference/reference_lua/pickle.rst:88
#: ../doc/1.7/reference/reference_lua/socket.rst:285
#: ../doc/1.7/reference/reference_lua/socket.rst:316
#: ../doc/1.7/reference/reference_lua/socket.rst:332
#: ../doc/1.7/reference/reference_lua/uri.rst:76
#: ../doc/1.7/reference/reference_lua/yaml.rst:46
msgid "string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:71
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-"
"open>` which causes error 2 (``errno.ENOENT``). The display includes the "
"error number, the associated error string, and the error name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:75
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:100
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:103
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:33
msgid "Module `fiber`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:35
msgid "The ``fiber`` module allows for creating, running and managing *fibers*."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:37
msgid ""
"A fiber is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*. A fiber has three "
"possible states: **running**, **suspended** or **dead**. When a fiber is "
"created with :ref:`fiber.create() <fiber-create>`, it is running. When a "
"fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is "
"suspended. When a fiber ends (because the fiber function ends), it is "
"dead."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:45
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:49
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:60
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:67
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:72
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:85
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:87
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:88
msgid "what will be passed to function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:90
msgid "created fiber object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Rtype"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:91
#: ../doc/1.7/reference/reference_lua/fiber.rst:115
#: ../doc/1.7/reference/reference_lua/fiber.rst:135
#: ../doc/1.7/reference/reference_lua/fio.rst:382
#: ../doc/1.7/reference/reference_lua/http.rst:50
#: ../doc/1.7/reference/reference_lua/iconv.rst:56
#: ../doc/1.7/reference/reference_lua/net_box.rst:148
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:78
#: ../doc/1.7/reference/reference_lua/socket.rst:139
#: ../doc/1.7/reference/reference_lua/socket.rst:157
#: ../doc/1.7/reference/reference_lua/socket.rst:347
#: ../doc/1.7/reference/reference_lua/socket.rst:373
#: ../doc/1.7/reference/reference_lua/tap.rst:51
msgid "userdata"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:95
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:114
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:119
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:132
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:134
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:139
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:152
msgid ""
"Yield control to the transaction processor thread and sleep for the "
"specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:155
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:159
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:169
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:173
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:183
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:185
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:190
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:201
msgid "Return information about all fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:203
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:209
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:227
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:231
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:232
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:236
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:248
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:253
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:266
#: ../doc/1.7/reference/reference_lua/fiber.rst:287
#: ../doc/1.7/reference/reference_lua/fiber.rst:311
#: ../doc/1.7/reference/reference_lua/fiber.rst:331
#: ../doc/1.7/reference/reference_lua/fiber.rst:355
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create"
" <fiber-create>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:268
msgid "id of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:269
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:119
#: ../doc/1.7/reference/reference_lua/fio.rst:124
#: ../doc/1.7/reference/reference_lua/fio.rst:498
#: ../doc/1.7/reference/reference_lua/socket.rst:265
#: ../doc/1.7/reference/reference_lua/socket.rst:388
msgid "number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:273
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:289
msgid "name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:294
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:305
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:313
msgid "the new name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:319
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:329
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:334
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:339
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:350
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:id() <fiber_object-id>` will cause "
"``error: the fiber is dead``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:360
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:364
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program send\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:375
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The storage is garbage-collected when "
":samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:384
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: "
"fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:415
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:421
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:425
#: ../doc/1.7/reference/reference_lua/fiber.rst:444
msgid "num"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:429
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:441
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:448
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:458
msgid "Example Of Fiber Use"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:460
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each "
"iteration of the loop adds 1 to a global variable named gvar, then goes "
"to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() "
"<fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:465
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:478
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:481
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:489
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:491
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:497
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:502
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:509
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:514
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:31
msgid "Submodule `fiber-ipc`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:33
msgid ""
"The ``fiber-ipc`` submodule allows sending and receiving messages between"
" different processes and has a synchronization mechanism for fibers, "
"similar to \"Condition Variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
" The words \"different processes\" in this context mean different "
"connections, different sessions, or different fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:40
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section. Call the other"
" ``fiber-ipc`` routines, via channel, to send messages, receive messages,"
" or check ipc status. Message exchange is synchronous. The channel is "
"garbage collected when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:47
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called cond for examples in this section. Call ``cond:wait()`` to make a"
" fiber wait for a signal via a condition variable. Call ``cond:signal()``"
" to send a signal to wake up a single fiber that has executed "
"``cond:wait()``. Call ``cond:broadcast()`` to send a signal to all fibers"
" that have executed ``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:60
msgid "Channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:64
msgid "Create a new communication channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:66
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:70
msgid "new channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:71
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:77
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:80
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:81
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:82
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:86
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:112
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:128
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:136
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:144
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:150
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:245
#: ../doc/1.7/reference/reference_lua/fio.rst:195
#: ../doc/1.7/reference/reference_lua/fio.rst:291
#: ../doc/1.7/reference/reference_lua/fio.rst:333
#: ../doc/1.7/reference/reference_lua/fio.rst:349
#: ../doc/1.7/reference/reference_lua/fio.rst:406
#: ../doc/1.7/reference/reference_lua/fio.rst:477
#: ../doc/1.7/reference/reference_lua/net_box.rst:165
#: ../doc/1.7/reference/reference_lua/net_box.rst:179
#: ../doc/1.7/reference/reference_lua/net_box.rst:192
#: ../doc/1.7/reference/reference_lua/net_box.rst:207
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:94
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:108
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:121
#: ../doc/1.7/reference/reference_lua/socket.rst:246
#: ../doc/1.7/reference/reference_lua/socket.rst:425
#: ../doc/1.7/reference/reference_lua/socket.rst:436
#: ../doc/1.7/reference/reference_lua/tap.rst:95
#: ../doc/1.7/reference/reference_lua/tap.rst:127
#: ../doc/1.7/reference/reference_lua/tap.rst:158
#: ../doc/1.7/reference/reference_lua/tap.rst:169
#: ../doc/1.7/reference/reference_lua/tap.rst:186
#: ../doc/1.7/reference/reference_lua/tap.rst:194
msgid "boolean"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:90
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:96
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:99
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:100
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:105
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:109
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:111
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:116
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:118
msgid "the number of messages."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:123
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:125
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:132
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:135
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:140
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:143
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:148
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:156
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:160
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:224
msgid "Condition variables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:228
msgid "Create a new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:230
msgid "new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:231
msgid "Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:237
msgid ""
"Make the current fiber go to sleep, waiting until until another fiber "
"invokes the ``signal()`` or ``broadcast()`` method on the cond object. "
"The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:241
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:242
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:249
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:256
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:264
msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:268
msgid "On terminal #1, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:270
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:277
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:280
msgid "On terminal #2, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:282
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:287
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:290
msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:33
msgid "Module `fio`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:37
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:41
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:43
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:44
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:45
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for "
"example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:54
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:58
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:60
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:61
#: ../doc/1.7/reference/reference_lua/fio.rst:78
#: ../doc/1.7/reference/reference_lua/fio.rst:97
msgid "path name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:66
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:75
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:79
msgid "suffix"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:81
msgid "file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:86
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:95
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:99
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:104
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:115
msgid "Common file manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:119
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type \"man 2 umask\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:122
msgid "mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:123
msgid "previous mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:128
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:138
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\""
" or \"man 2 stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:141
msgid "path name of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:142
msgid ""
"fields which describe the file's block size, creation time, size, and "
"other attributes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:146
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include "
"methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:149
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:150
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:151
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:152
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:153
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:154
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:155
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:157
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:161
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:187
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2"
" rmdir\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:190
msgid "path of directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:191
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:194
#: ../doc/1.7/reference/reference_lua/fio.rst:290
#: ../doc/1.7/reference/reference_lua/fio.rst:332
#: ../doc/1.7/reference/reference_lua/fio.rst:348
#: ../doc/1.7/reference/reference_lua/fio.rst:476
#: ../doc/1.7/reference/reference_lua/fio.rst:550
msgid "true if success, false if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:199
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:208
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:212
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:213
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:216
#: ../doc/1.7/reference/reference_lua/fio.rst:384
#: ../doc/1.7/reference/reference_lua/fio.rst:500
#: ../doc/1.7/reference/reference_lua/socket.rst:375
msgid "Possible errors: nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:220
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:231
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:235
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:244
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:248
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:260
msgid ""
"Functions to create and delete links. For details type \"man readlink\", "
"\"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:263
msgid "existing file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:264
msgid "linked name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:266
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if "
"success, false if failure. ``fio.readlink`` returns the link value if "
"success, nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:272
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:285
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:287
msgid "original name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:288
msgid "new name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:295
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:305
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:308
msgid "new user uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:309
msgid "new group uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:310
msgid "new permissions"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:314
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:327
msgid ""
"Reduce file size to a specified value. For details type \"man 2 "
"truncate\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:337
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:346
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:353
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:369
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:372
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:376
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREAT` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:381
msgid "file handle (later - fh)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:388
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:402
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 "
"close\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:404
#: ../doc/1.7/reference/reference_lua/fio.rst:424
#: ../doc/1.7/reference/reference_lua/fio.rst:455
#: ../doc/1.7/reference/reference_lua/fio.rst:475
#: ../doc/1.7/reference/reference_lua/fio.rst:493
#: ../doc/1.7/reference/reference_lua/fio.rst:516
#: ../doc/1.7/reference/reference_lua/fio.rst:549
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:405
msgid "true if success, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:410
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:420
msgid ""
"Perform read/write random-access operation on a file, without affecting "
"the current seek position of the file. For details type \"man 2 pread\" "
"or \"man 2 pwrite\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:425
#: ../doc/1.7/reference/reference_lua/fio.rst:456
msgid "number of bytes to read"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:426
#: ../doc/1.7/reference/reference_lua/fio.rst:457
msgid "value to write"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:427
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:428
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:433
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:445
msgid ""
"Perform non-random-access read or write on a file. For details type \"man"
" 2 read\" or \"man 2 write\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:450
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:458
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:463
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:472
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:481
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:490
msgid ""
"Shift position in the file to the specified position. For details type "
"\"man 2 seek\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:494
msgid "position to seek to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:495
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:497
msgid "the new position if success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:504
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:513
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type \"man 2 "
"stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:517
msgid "details about the file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:522
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:545
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type \"man 2 fsync\" or"
" \"man 2 fdatasync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:554
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:565
msgid "FIO constants"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:569
msgid ""
"Table with constants which are the same as POSIX flag values on the "
"target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:574
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:33
msgid "Module `fun`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:35
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the "
"module are \"sequence processors\" such as ``map``, ``filter``, "
"``reduce``, ``zip`` -- they take a user-written function as an argument "
"and run it against every element in a sequence, which can be faster or "
"more convenient than a user-written loop. Inside the module are "
"\"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they "
"return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or "
"Erlang."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:45
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual ``require`` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
"``require`` request. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:51
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:33
msgid "Module `http`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:37
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides"
" the functionality of an HTTP client with support for HTTPS and "
"keepalive. It uses routines in the `libcurl "
"<https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:47
msgid "the maximum number of entries in the connection cache."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:49
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:54
msgid ""
"tarantool> http_client = require('http.client').new({5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:64
msgid ""
"If ``http_client`` is an HTTP client instance, ``http_client:request()`` "
"will perform an HTTP request and, if there is a successful connection, "
"will return a table with connection information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:68
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:69
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:70
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:71
msgid ""
"table of connection options, with any of these components:   * "
"``timeout`` - number of seconds to wait for a curl API read request    "
"before timing out  * ``ca_path`` - path to a directory holding one or "
"more certificates to    verify the peer with  * ``ca_file`` - path to an "
"SSL certificate file to verify the peer with  * ``headers`` - table of "
"HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the "
"operating system    will wait while the connection is idle before sending"
" keepalive    probes. See also    `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``keepalive_interval`` - the interval, in seconds, that the operating    "
"system will wait between sending keepalive probes. See also    "
"`CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``low_speed_time`` - set the \"low speed time\" -- the time that the    "
"transfer speed should be below the \"low speed limit\" for the library"
"    to consider it too slow and abort. See also    "
"`CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` - set the \"low speed limit\" -- the average    "
"transfer speed in bytes per second that the transfer should be below    "
"during \"low speed time\" seconds for the library to consider it to be"
"    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:71
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:74
msgid ""
"``timeout`` - number of seconds to wait for a curl API read request "
"before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:76
msgid ""
"``ca_path`` - path to a directory holding one or more certificates to "
"verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:78
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:79
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:80
msgid ""
"``keepalive_idle`` - delay, in seconds, that the operating system will "
"wait while the connection is idle before sending keepalive probes. See "
"also `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:84
msgid ""
"``keepalive_interval`` - the interval, in seconds, that the operating "
"system will wait between sending keepalive probes. See also "
"`CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:87
msgid ""
"``low_speed_time`` - set the \"low speed time\" -- the time that the "
"transfer speed should be below the \"low speed limit\" for the library to"
" consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:91
msgid ""
"``low_speed_limit`` - set the \"low speed limit\" -- the average transfer"
" speed in bytes per second that the transfer should be below during \"low"
" speed time\" seconds for the library to consider it to be too slow and "
"abort. See also `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:96
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:98
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:100
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:101
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:102
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:103
msgid "``body`` - response body"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:104
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:108
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:110
msgid ""
"``http_client:get(url, options)`` - shortcut for "
"``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:112
msgid ""
"``http_client:post (url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:114
msgid ""
"``http_client:put(url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:116
msgid ""
"``http_client:patch(url, body, options)`` - shortcut for "
"``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:118
msgid ""
"``http_client:options(url, options)`` - shortcut for "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:120
msgid ""
"``http_client:head(url, options)`` - shortcut for "
"``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:122
msgid ""
"``http_client:delete(url, options)`` - shortcut for "
"``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:124
msgid ""
"``http_client:trace(url, options)`` - shortcut for "
"``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:126
msgid ""
"``http_client:connect:(url, options)`` - shortcut for "
"``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:131
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:133
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:134
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:135
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:136
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:137
msgid ""
"``http_200_responses`` - total number of requests which have returned "
"code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:139
msgid ""
"``http_other_responses`` - total number of requests which have not "
"returned code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:141
msgid ""
"``failed_requests`` - total number of requests which have failed "
"including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:146
msgid ""
"Connect to an HTTP server, look at the size of the response for a 'GET' "
"request, and look at the statistics for the session."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:149
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:33
msgid "Module `iconv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:37
msgid ""
"The ``iconv`` module provides a way to convert a string with one encoding"
" to a string with another encoding, for example from ASCII to UTF-8. It "
"is based on the POSIX iconv routines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:41
msgid ""
"An exact list of the available encodings may depend on environment. "
"Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, "
"and about 100 others. For a complete list, type ``iconv --list`` on a "
"terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:50
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:52
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:53
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:55
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:58
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:62
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:70
msgid "Convert."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:72
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:74
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:76
msgid ""
"If anything in input-string cannot be converted, there will be an error "
"message and the result string will be unchanged."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:81
msgid ""
"We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER "
"DE) is hexadecimal 0414 according to the character database of Unicode_. "
"Therefore that is what it will look like in UTF-16. We know that "
"Tarantool typically uses the UTF-8 character set. So make a from-UTF-8"
"-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks"
" like in the UTF-8 source, and use string.hex('Д'-after-conversion) to "
"show what it looks like in the UTF-16 target. Since the result is 0414, "
"we see that iconv conversion works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:90
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:33
msgid "Built-in modules reference"
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:35
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:39
msgid ""
"Some functions in these modules are analogs to functions from `standard "
"Lua libraries <http://www.lua.org/manual/>`_. For better results, we "
"recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:43
msgid "List of Lua modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:31
msgid "Module `jit`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:35
msgid ""
"The ``jit`` module has functions for tracing the LuaJIT Just-In-Time "
"compiler's progress, showing the byte-code or assembler output that the "
"compiler produces, and in general providing information about what LuaJIT"
" does with Lua code."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:41
msgid "Prints the byte code of a function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:45
msgid ""
"function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:52
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:56
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:60
msgid ""
"-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:65
msgid "For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:69
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:73
msgid ""
"-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:78
msgid "For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:83
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:87
msgid ""
"-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:98
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:104
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:108
msgid ""
"-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:119
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:33
msgid "Module `json`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:35
msgid ""
"The json module provides JSON manipulation routines. It is based on the "
"`Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON "
"please read `the official documentation`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:45
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:47
#: ../doc/1.7/reference/reference_lua/msgpack.rst:44
#: ../doc/1.7/reference/reference_lua/yaml.rst:44
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:48
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:53
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:83
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:85
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:86
#: ../doc/1.7/reference/reference_lua/yaml.rst:53
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:91
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:113
#: ../doc/1.7/reference/reference_lua/msgpack.rst:63
#: ../doc/1.7/reference/reference_lua/yaml.rst:60
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:118
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:140
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:142
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:143
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:145
#: ../doc/1.7/reference/reference_lua/yaml.rst:97
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:148
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:172
msgid "Configuration settings"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:174
msgid ""
"There are configuration settings which affect the way that Tarantool "
"encodes invalid numbers or types. They are all boolean ``true``/``false``"
" values"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:177
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:178
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:180
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use null for all "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:182
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:184
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a "
"number\") and 1/0 (which is \"infinity\") as special values rather than "
"nulls or errors:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:187
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:195
msgid "The result of the json.encode request will look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:197
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:204
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack "
"<msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:33
msgid "Module `log`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:37
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic "
"messages may be either system-generated by the server's internal code, or"
" user-generated with the :samp:`log.{log_level}` function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:48
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-log>`,"
" given log_level_function_name = ``error`` or ``warn`` or ``info`` or "
"``verbose`` or ``debug``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:52
#, python-format
msgid ""
"The actual output will be a line containing the current timestamp, a "
"module name, 'E' or 'W' or 'I' or 'V' or 'D' or 'R' depending on "
"``log_level_function_name``, and ``message``. Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`. Messages may contain C-style format specifiers "
"%d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if x is "
"a number and y is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:74
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:83
msgid "$ less tarantool.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:90
msgid ""
"2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:94
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:96
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:33
msgid "Module `msgpack`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:35
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them,"
" or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:42
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:45
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:50
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:52
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:54
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:55
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:57
msgid "lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:70
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:95
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:97
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:98
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:100
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:104
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:124
msgid "**Result:**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:129
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:132
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:137
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:139
msgid "and the second encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:144
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:146
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:154
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:160
msgid "{}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:160
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:163
msgid "'a'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:163
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:165
msgid "false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:165
msgid "'false' = c2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:167
msgid "true"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:167
msgid "'true' = c3"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:169
msgid "127"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:169
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "65535"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "4294967295"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
msgid "'nil' = c0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "msgpack.NULL"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "same as nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid "[0] = 5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:182
msgid "[0] = nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:182
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "1.5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:188
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in"
" the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:33
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:33
msgid "Module `net.box`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:35
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is connecting to MySQL or MariaDB or "
"PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The "
"other variant, which is discussed in this section, is connecting to "
"Tarantool server instances via a network using the built-in ``net.box`` "
"module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:41
msgid "You can call the following methods:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:43
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:45
msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:47
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on a"
" remote box,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:49
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:51
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example, when"
" it's necessary to prioritize requests or to use different authentication"
" IDs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:60
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:68
msgid "On this diagram:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:70
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:72
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:74
msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:78
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:88
msgid ""
"The names ``connect()`` and ``new()`` are synonymous with the only "
"difference that ``connect()`` is the preferred name, while ``new()`` is "
"retained for backward compatibility."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:92
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:98
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any"
" request can yield, and database state may have changed by the time it "
"regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:110
msgid "Possible options:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:112
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 secs)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:118
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores "
"transient failures. The wait completes once the connection is established"
" or is closed explicitly."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:121
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any "
"time the connection is broken or if a connection attempt fails. This "
"makes transient network failures become transparent to the application. "
"Reconnect happens automatically in the background, so queries/requests "
"that suffered due to connectivity loss are transparently retried. The "
"number of retries is unlimited, connection attempts are done over the "
"specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a "
"connection is explicitly closed (or garbage-collected), reconnects stop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:130
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:139
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:145
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:75
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:146
msgid ""
"possible options are `wait_connected`, `reconnect_after`, `call_16` and "
"`console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:147
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:77
msgid "conn object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:152
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:162
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:91
msgid "Execute a PING command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:164
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:93
msgid "true on success, false on error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:169
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:98
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:175
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:104
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:177
#: ../doc/1.7/reference/reference_lua/net_box.rst:205
msgid "in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:178
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:107
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:183
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:112
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:189
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:118
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:191
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:120
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:196
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:125
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:202
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:204
msgid "target states"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:206
msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:211
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:224
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:132
msgid "Close a connection."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:226
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:134
msgid ""
"Connection objects are garbage collected just like any other objects in "
"Lua, so an explicit destruction is not mandatory. However, since close() "
"is a system call, it is good programming practice to close a connection "
"explicitly when it is no longer needed, to avoid lengthy stalls of the "
"garbage collector."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:233
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:141
msgid "conn:close()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:239
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:147
msgid ""
":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:244
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:253
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:161
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:258
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:166
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:263
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:171
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:268
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:176
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:273
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:181
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:278
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:186
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:285
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:193
msgid ""
"``conn:call('func', '1', '2', '3')`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:291
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:199
msgid "conn:call('function5')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:299
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:307
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:215
msgid "conn:eval('return 5+5')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:313
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:221
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:318
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:226
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:322
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:230
msgid ""
"All remote calls support execution timeouts. Using a wrapper object makes"
" the remote connection API compatible with the local one, removing the "
"need for a separate ``timeout`` argument, which the local version would "
"ignore. Once a request is sent, it cannot be revoked from the remote "
"server even if a timeout expires: the timeout expiration only aborts the "
"wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:333
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:335
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:337
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:338
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:340
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:342
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:347
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:353
msgid "And here starts the example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:355
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:35
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS "
"modules <dbms_modules>` reference. In this section the subject is the "
"built-in variant, ``net.box``. This is for connecting to tarantool "
"servers via a network."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:41
msgid ""
"Call ``require('net.box')`` to get a ``net.box`` object, which will be "
"called ``net_box`` for examples in this section. Call ``net_box.new()`` "
"to connect and get a connection object, which will be called ``conn`` for"
" examples in this section. Call the other ``net.box()`` routines, passing"
" ``conn:``, to execute requests on the remote box. Call :ref:`conn:close "
"<socket-close>` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:47
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example when "
"it's necessary to prioritize requests or to use different authentication "
"ids."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:60
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It is re-established automatically after a "
"disconnect. The returned ``conn`` object supports methods for making "
"remote requests, such as select, update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:65
msgid ""
"For the local tarantool server there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-"
"the_implicit_yield_rules>` any request can yield, and database state may "
"have changed by the time it regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:76
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:82
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:152
msgid ""
"due to :ref:`the implicit yield rules <atomic-the_implicit_yield_rules>` "
"a local :samp:`box.space.{space-name}:select`:code:`{...}` does not "
"yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` "
"call does yield, so global variables or database tuples data may change "
"when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:207
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-privileges>` is required; if the "
"user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:239
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:241
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. Assume that the database is nearly empty. Assume that the tarantool "
"server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:246
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:33
msgid "Module `os`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:37
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, "
":ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most "
"of these functions are described in the Lua manual Chapter 22 `The "
"Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:54
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:56
msgid "what to execute."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:60
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:76
msgid "Rename a file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:78
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:79
msgid "changed name of file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:83
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:96
msgid "Get environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:98
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:102
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:113
msgid "Remove file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:115
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:119
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:130
msgid "Return a formatted date."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:132
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:137
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:148
msgid ""
"Exit the program. If this is done on a server instance, then the instance"
" stops."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:152
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:161
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:165
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:176
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:180
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:191
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:195
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:206
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:210
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:221
msgid "Set an environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:225
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:236
msgid ""
"Change the locale. If new-locale-string is not specified, return the "
"current locale."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:241
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:252
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:256
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:31
msgid "Miscellaneous"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:37
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can"
" be expressed in decimal, binary (for example 0b1010), or hexadecimal "
"(for example -0xffff). The result can be used in arithmetic, and the "
"arithmetic will be 64-bit integer arithmetic rather than floating-point "
"arithmetic. (Operations on an unconverted Lua number use floating-point "
"arithmetic.) The ``tonumber64()`` function is added by Tarantool; the "
"name is global."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:47
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:70
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:74
msgid "Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:75
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:78
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:80
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:85
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:31
msgid "Module `pickle`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:37
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:43
msgid "**Format specifiers**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:48
msgid "b, B"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:48
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:51
msgid "s, S"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:51
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:55
msgid "i, I"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:55
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:59
msgid "l, L"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:59
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:63
msgid "n"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:63
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:67
msgid "N"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:67
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:70
msgid "q, Q"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:70
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:74
msgid "f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:74
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:77
msgid "d"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:77
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid "a, A"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in "
"the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:84
msgid "string containing format specifiers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:85
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:86
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:90
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:94
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:128
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:134
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:139
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:33
msgid "Module `socket`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:35
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:41
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:52
msgid "**Socket functions**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid "Purposes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid "Names"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:59
msgid "setup"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:59
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:61
#: ../doc/1.7/reference/reference_lua/socket.rst:63
#: ../doc/1.7/reference/reference_lua/socket.rst:65
#: ../doc/1.7/reference/reference_lua/socket.rst:67
#: ../doc/1.7/reference/reference_lua/socket.rst:71
#: ../doc/1.7/reference/reference_lua/socket.rst:73
#: ../doc/1.7/reference/reference_lua/socket.rst:77
#: ../doc/1.7/reference/reference_lua/socket.rst:79
#: ../doc/1.7/reference/reference_lua/socket.rst:83
#: ../doc/1.7/reference/reference_lua/socket.rst:85
#: ../doc/1.7/reference/reference_lua/socket.rst:89
#: ../doc/1.7/reference/reference_lua/socket.rst:93
#: ../doc/1.7/reference/reference_lua/socket.rst:97
#: ../doc/1.7/reference/reference_lua/socket.rst:101
#: ../doc/1.7/reference/reference_lua/socket.rst:103
#: ../doc/1.7/reference/reference_lua/socket.rst:105
#: ../doc/1.7/reference/reference_lua/socket.rst:109
#: ../doc/1.7/reference/reference_lua/socket.rst:111
#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid "\"\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:61
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:63
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:67
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:69
msgid "sending"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:69
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:73
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid "receiving"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:79
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid "flag setting"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid "client/server"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:89
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:91
msgid "teardown"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:93
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:95
msgid "error checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:95
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:97
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid "information"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:101
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:103
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:107
msgid "state checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:107
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:109
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:117
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:126
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:135
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:138
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:143
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:151
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:153
msgid "URL or IP address"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:154
msgid "port number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:155
msgid "timeout"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:156
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:161
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:169
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:173
#: ../doc/1.7/reference/reference_lua/socket.rst:547
#: ../doc/1.7/reference/reference_lua/socket.rst:559
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:178
msgid ""
"``socket.getaddrinfo('tarantool.org', 'http')`` will return variable "
"information such as"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:181
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:200
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:204
msgid "host name or IP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:205
msgid "host port, may be 0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:206
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:208
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:211
msgid ""
"The handler-function parameter may be a function name (for example "
"``function_55``), a function declaration (for example ``function () "
"print('!') end``), or a table including handler = function (for example "
"``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:216
msgid "Example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:218
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:226
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:243
msgid "Parameters:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:233
msgid "Either:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:232
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:234
msgid "port - a number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:236
#: ../doc/1.7/reference/reference_lua/socket.rst:243
msgid "Or:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:236
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:237
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:239
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:241
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:245
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:250
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:261
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:264
#: ../doc/1.7/reference/reference_lua/socket.rst:387
msgid "the number of bytes sent."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:267
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:273
msgid ""
"Write as much as possible data to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:280
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:284
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:287
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:300
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:305
#: ../doc/1.7/reference/reference_lua/socket.rst:327
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:307
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:309
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:312
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:322
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:330
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:338
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:346
msgid "a socket object on success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:349
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:355
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:357
msgid ""
"On Linux the listen ``backlog`` backlog may be from "
"/proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:361
msgid "true for success, false for error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:362
msgid "boolean."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:368
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:372
msgid "new socket if success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:381
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:390
#: ../doc/1.7/reference/reference_lua/socket.rst:402
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:396
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:399
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:400
msgid "string, table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:406
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:410
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:420
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:422
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:424
#: ../doc/1.7/reference/reference_lua/tap.rst:94
#: ../doc/1.7/reference/reference_lua/tap.rst:126
#: ../doc/1.7/reference/reference_lua/tap.rst:157
#: ../doc/1.7/reference/reference_lua/tap.rst:168
#: ../doc/1.7/reference/reference_lua/tap.rst:185
#: ../doc/1.7/reference/reference_lua/tap.rst:193
msgid "true or false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:431
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when its userdata is garbage collected by "
"Lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:434
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:443
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:446
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:448
msgid "number, string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:454
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:458
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:459
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:460
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:461
msgid "SO_DEBUG"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:462
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:463
msgid "SO_ERROR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:464
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:465
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:466
msgid "SO_MARK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:467
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:468
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:469
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:470
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:471
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:472
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:473
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:474
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:475
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:476
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:477
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:478
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:479
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:480
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:481
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:482
msgid "SO_TYPE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:484
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:490
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:496
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:501
msgid "new active and timeout values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:507
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:508
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:509
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:511
msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:518
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:520
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:526
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:528
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:534
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:536
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:542
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:554
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:566
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:569
msgid "file descriptor"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:570
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:571
msgid "number of seconds to wait"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:573
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:576
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:580
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:584
msgid "Examples"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:588
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:590
msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:596
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:627
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:629
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:635
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:672
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:674
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:679
msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:682
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:684
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:699
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:706
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:711
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:714
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:718
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:33
msgid "Module `strict`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:37
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or"
" off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:42
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:48
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:31
msgid "Module `tap`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:33
msgid ""
"The tap module streamlines the testing of other modules. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:43
msgid "Initialize."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:45
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:49
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:50
msgid "taptest"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:53
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:62
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:69
msgid ""
"Checks the number of tests performed. This check should only be done "
"after all planned tests are complete, so ordinarily ``taptest:check()`` "
"will only appear at the end of a script."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:73
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not "
"equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:80
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:82
msgid "the message to be displayed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:87
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:91
msgid "an expression which is true or false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:92
#: ../doc/1.7/reference/reference_lua/tap.rst:124
#: ../doc/1.7/reference/reference_lua/tap.rst:135
#: ../doc/1.7/reference/reference_lua/tap.rst:156
#: ../doc/1.7/reference/reference_lua/tap.rst:166
#: ../doc/1.7/reference/reference_lua/tap.rst:183
#: ../doc/1.7/reference/reference_lua/tap.rst:198
msgid "name of test"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:99
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:121
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:131
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:141
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:151
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:154
#: ../doc/1.7/reference/reference_lua/tap.rst:164
#: ../doc/1.7/reference/reference_lua/tap.rst:196
msgid "actual result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:155
#: ../doc/1.7/reference/reference_lua/tap.rst:165
#: ../doc/1.7/reference/reference_lua/tap.rst:197
msgid "expected result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:162
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:179
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:190
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:208
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:212
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:226
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:228
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:31
msgid "Module `tarantool`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:35
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:41
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info() <box_introspection-box_info>` but use of the tarantool "
"module is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:48
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:31
msgid "Module `uri`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:33
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard "
"<https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like "
"this: |br| [scheme:]scheme-specific-part[#fragment] |br| A common type, a"
" hierarchical URI, looks like this: |br| "
"[scheme:][//authority][path][?query][#fragment] |br| For example the "
"string `'https://tarantool.org/x.html#y'` has three components: https is "
"the scheme, tarantool.org/x.html is the path, and y is the fragment. "
"Tarantool's URI module provides routines which convert URI strings into "
"their components, or turn components into URI strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:51
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
msgid "returns"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:52
msgid ""
"URI-components-table. Possible components are fragment, host, login, "
"password, path, query, scheme, service."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:53
msgid "Table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:57
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:74
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:75
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:80
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:31
msgid "Module `uuid`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:33
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:39
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:41
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:42
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:43
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:45
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:47
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:48
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:49
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:50
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:52
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:54
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:60
msgid "A nil object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:66
#: ../doc/1.7/reference/reference_lua/uuid.rst:73
#: ../doc/1.7/reference/reference_lua/uuid.rst:80
msgid "a UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:67
#: ../doc/1.7/reference/reference_lua/uuid.rst:89
#: ../doc/1.7/reference/reference_lua/uuid.rst:97
msgid "cdata"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:74
msgid "16-byte string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:81
msgid "36-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:87
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:88
#: ../doc/1.7/reference/reference_lua/uuid.rst:96
msgid "converted UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:95
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:105
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:107
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:108
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:109
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:110
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:112
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:114
#: ../doc/1.7/reference/reference_lua/uuid.rst:121
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:115
msgid "16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:122
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:128
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:133
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:134
msgid "bool"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:140
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:33
msgid "Module `xlog`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:35
msgid ""
"The xlog module contains one function: ``pairs()``. It can be used to "
"read Tarantool's snapshot files or write-ahead-log (WAL) files. A "
"description of the file format is in section :ref:`Data persistence and "
"the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:46
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:48
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:49
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:51
msgid ""
"Possible errors: File does not contain properly formatted snapshot or "
"write-ahead-log information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:56
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in "
"the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting "
"started\" exercises <getting_started>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:60
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure "
"can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:63
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:72
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:74
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:33
msgid "Module `yaml`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:35
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:42
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:45
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:50
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:52
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:66
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:89
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:92
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:93
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:94
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:95
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:100
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:136
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:33
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:35
msgid ""
"The discussion here in the reference is about incorporating and using two"
" modules that have already been created: the \"SQL DBMS rocks\" for MySQL"
" and PostgreSQL."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:39
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: "
"another DBMS, and Tarantool. The module which connects Tarantool to "
"another DBMS may be called a \"connector\". Within the module there is a "
"shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:44
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for "
"Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:47
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL"
" statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a "
"\"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be "
"useful even if that was all Tarantool could do. But of course Tarantool "
"is also a DBMS, so the module also is useful for any operations, such as "
"database copying and accelerating, which work best when the application "
"can work on both SQL and Tarantool inside the same Lua routine. The "
"methods for connect/select/insert/etc. are similar to the ones in the "
":ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:58
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very "
"similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL "
"Example\" -- contain some redundancy."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:66
msgid "MySQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:68
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C "
"connector is used. The package that matters most is the MySQL client "
"developer package, typically named something like libmysqlclient-dev. The"
" file that matters most from this package is libmysqlclient.so or a "
"similar name. One can use ``find`` or ``whereis`` to see what directories"
" these files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:75
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server instance. After that, "
"one can pass any MySQL statement to the server instance and receive "
"results, including multiple result sets."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:81
#: ../doc/1.7/reference/reference_rock/dbms.rst:434
msgid "Installation"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:83
#: ../doc/1.7/reference/reference_rock/dbms.rst:436
msgid ""
"Check the instructions for `downloading and installing a binary package "
"<http://tarantool.org/download.html>`_ that apply for the environment "
"where Tarantool was installed. In addition to installing ``tarantool``, "
"install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:89
#: ../doc/1.7/reference/reference_rock/dbms.rst:442
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:93
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:97
#: ../doc/1.7/reference/reference_rock/dbms.rst:450
msgid "With LuaRocks"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:99
#: ../doc/1.7/reference/reference_rock/dbms.rst:452
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:106
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:118
#: ../doc/1.7/reference/reference_rock/dbms.rst:471
msgid "With GitHub"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:120
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there,"
" saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:122
msgid ""
"git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:129
#: ../doc/1.7/reference/reference_rock/dbms.rst:482
msgid ""
"At this point it is a good idea to check that the installation produced a"
" file named ``driver.so``, and to check that this file is on a directory "
"that is searched by the ``require`` request."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:135
#: ../doc/1.7/reference/reference_rock/dbms.rst:488
msgid "Connecting"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:137
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will "
"assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:140
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:144
#: ../doc/1.7/reference/reference_rock/dbms.rst:497
msgid "Now, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:149
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:151
#: ../doc/1.7/reference/reference_rock/dbms.rst:504
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:153
#: ../doc/1.7/reference/reference_rock/dbms.rst:506
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:154
#: ../doc/1.7/reference/reference_rock/dbms.rst:507
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:155
#: ../doc/1.7/reference/reference_rock/dbms.rst:508
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system "
"user name"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:156
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:157
#: ../doc/1.7/reference/reference_rock/dbms.rst:510
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:158
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:160
msgid ""
"The option names, except for `raise`, are similar to the names that "
"MySQL's mysql client uses, for details see the MySQL manual at "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option "
"should be set to :codenormal:`true` if errors should be raised when "
"encountered. To connect with a Unix socket rather than with TCP, specify "
"``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:167
#: ../doc/1.7/reference/reference_rock/dbms.rst:514
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:169
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:185
#: ../doc/1.7/reference/reference_rock/dbms.rst:526
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:187
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:203
#: ../doc/1.7/reference/reference_rock/dbms.rst:545
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:207
#: ../doc/1.7/reference/reference_rock/dbms.rst:549
msgid "How to ping"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:209
#: ../doc/1.7/reference/reference_rock/dbms.rst:551
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:214
#: ../doc/1.7/reference/reference_rock/dbms.rst:556
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:218
#: ../doc/1.7/reference/reference_rock/dbms.rst:561
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:227
#: ../doc/1.7/reference/reference_rock/dbms.rst:570
msgid "Executing a statement"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:229
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:234
#: ../doc/1.7/reference/reference_rock/dbms.rst:577
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:236
#: ../doc/1.7/reference/reference_rock/dbms.rst:579
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks "
"(\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:242
msgid ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:255
#: ../doc/1.7/reference/reference_rock/dbms.rst:597
msgid "Closing connection"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:257
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:262
#: ../doc/1.7/reference/reference_rock/dbms.rst:604
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:266
#: ../doc/1.7/reference/reference_rock/dbms.rst:608
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:272
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:279
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of MySQL "
"had been installed on ~/mysql-5.5. The mysqld server instance is already "
"running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:283
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:364
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool "
"doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:367
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:375
msgid ""
"Create a Lua function that will connect to the MySQL server instance, "
"(using some factory default values for the port and user and password), "
"retrieve one row, and display the row. For explanations of the statement "
"types used here, read the Lua tutorial earlier in the Tarantool user "
"manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:380
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:404
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that "
"was inserted into the MySQL database. And now it's been selected with the"
" Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:411
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:413
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been "
"installed. More recent versions should also work. The package that "
"matters most is the PostgreSQL developer package, typically named "
"something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:418
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:422
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL "
"files are present and must explicitly state where they are when building "
"the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to "
"see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:428
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server instance. "
"After that, one can pass any PostgreSQL statement to the server instance "
"and receive results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:446
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to "
"install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:459
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:473
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:475
msgid ""
"git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:490
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume "
"that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:493
msgid "pg = require('pg')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:502
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:509
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, "
"default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:512
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:516
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:528
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:572
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:585
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:599
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:614
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:621
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of "
"PostgreSQL had been installed on /usr. The PostgreSQL server instance is "
"already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:625
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master"
"\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears "
"here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:699
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:702
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:710
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve"
" one row, and display the row. For explanations of the statement types "
"used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:715
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:740
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row "
"that was inserted into the PostgreSQL database. And now it's been "
"selected with the Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:33
msgid "Module `expirationd`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:35
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, "
"let us look at expirationd, which Tarantool supplies on GitHub_ with an "
"Artistic license. The expirationd.lua program is lengthy (about 500 "
"lines), so here we will only highlight the matters that will be enhanced "
"by studying the full source later."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:40
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:48
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being"
" done with a :doc:`fiber<../reference_lua/fiber>`. The program is making "
"a fiber and turning control over to it so it runs occasionally, goes to "
"sleep, then comes back for more."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:53
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:62
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index "
"of the space that is being scanned\", and within it, if the tuple is "
"\"expired\" (for example, if the tuple has a timestamp field which is "
"less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:67
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:78
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` "
"which does a \"delete\" of a tuple from its original space. First the fun"
" :ref:`fun <fun-module>` module is used, specifically fun.map_. "
"Remembering that :codenormal:`index[0]` is always the space's primary "
"key, and "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is "
"always the field number for key part :codeitalic:`N`, fun.map() is "
"creating a table from the primary-key values of the tuple. The result of "
"fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:88
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:93
msgid ""
"At this point, if the above explanation is worthwhile, it's clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other "
"fibers can operate at the same time, and - whenever it finds a tuple that"
" has expired - deletes it from this space. Now the "
"\"``expirationd_run_task()``\" function can be used in a test which "
"creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:102
msgid ""
"For those who like to see things run, here are the exact steps to get "
"expirationd through the test."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:105
msgid ""
"Get ``expirationd.lua``. There are standard ways - it is after all part "
"of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_"
"  - but for this purpose just copy the contents of expirationd.lua_ to a "
"default directory."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:108
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:109
msgid "Execute these requests:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:111
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:134
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should "
"already be familiar."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:139
msgid ""
"The function which will be supplied to expirationd is "
":codenormal:`is_tuple_expired`, which is saying \"if the second field of "
"the tuple is less than the :ref:`current time <fiber-time>`  , then "
"return true, otherwise return false\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:144
msgid ""
"The key for getting the rock rolling is ``expd = "
"require('expirationd')``. The \"``require``\" function is what reads in "
"the program; it will appear in many later examples in this manual, when "
"it's necessary to get a module that's not part of the Tarantool kernel. "
"After the Lua variable expd has been assigned the value of the "
"expirationd module, it's possible to invoke the module's ``run_task()`` "
"function."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:151
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has "
"had time to do its iterations through the spaces, ``expd.task_stats()`` "
"will print out a report showing how many tuples have expired -- "
"\"expired_count: 0\". After sleeping for two more seconds, "
"``expd.task_stats()`` will print out a report showing how many tuples "
"have expired -- \"expired_count: 1\". This shows that the "
"is_tuple_expired() function eventually returned \"true\" for one of the "
"tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:161
msgid ""
"Of course, expirationd can be customized to do different things by "
"passing different parameters, which will be evident after looking in more"
" detail at the source code."
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:31
msgid "Rocks reference"
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:33
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:33
msgid "Module `shard`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:37
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple "
"nodes, with a Tarantool database server instance on each node. With this "
"arrangement, each instance is handling only a subset of the total data, "
"so larger loads can be handled by simply adding more computers to a "
"network."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:42
msgid ""
"The Tarantool shard module has facilities for creating shards, as well as"
" analogues for the data-manipulation functions of the box library "
"(select, insert, replace, update, delete)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:46
msgid "First some terminology:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:49
msgid "**Consistent Hash**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:51
msgid ""
"The shard module distributes according to a hash algorithm, that is, it "
"applies a hash function to a tuple's primary-key value in order to decide"
" which shard the tuple belongs to. The hash function is `consistent`_ so "
"that changing the number of servers will not affect results for many "
"keys. The specific hash function that the shard module uses is "
":ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:57
msgid "**Instance**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:59
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes "
"called a \"server instance\". Usually each shard is associated with one "
"instance, or, if both sharding and replicating are going on, each shard "
"is associated with one replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:63
msgid "**Queue**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:65
msgid ""
"A temporary list of recent update requests. Sometimes called "
"\"batching\". Since updates to a sharded database can be slow, it may "
"speed up throughput to send requests to a queue rather than wait for the "
"update to finish on every node. The shard module has functions for adding"
" requests to the queue, which it will process without further "
"intervention. Queuing is optional."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:71
msgid "**Redundancy**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:73
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:74
msgid "**Replica**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:76
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:77
msgid "**Replica set**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:79
msgid ""
"Often a single shard is associated with a single instance; however, often"
" the shard is replicated. When a shard is replicated, the multiple "
"instances (\"replicas\"), which handle the shard's replicated data, are a"
" \"replica set\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:83
msgid "**Replicated data**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:85
msgid ""
"A complete copy of the data. The shard module handles both sharding and "
"replication. One shard can contain one or more replicated data copies. "
"When a write occurs, the write is attempted on every replicated data copy"
" in turn. The shard module does not use the built-in replication feature."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:89
msgid "**Shard**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:91
msgid ""
"A subset of the tuples in the database partitioned according to the value"
" returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:95
msgid "**Zone**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:97
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is "
"a single computer with a single Tarantool-server instance. A shard's "
"replicated data copies should be in different zones."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:102
msgid ""
"The shard package is distributed separately from the main tarantool "
"package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:105
msgid "sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:109
msgid ""
"Or, download from github tarantool/shard and tarantool/connpool and use "
"the Lua files as described in the README. Then, before using the module, "
"say ``shard = require('shard')``"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:113
msgid "The most important function is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:118
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:120
msgid ""
"This must be called for every shard. The shard-configuration is a table "
"with these fields:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:123
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:124
msgid "login (the user name which applies for accessing via the shard module)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:125
msgid "password (the password for the login)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:126
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:127
msgid ""
"binary (a port number that this host is listening on, on the current "
"host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:130
msgid ""
"Possible Errors: Redundancy should not be greater than the number of "
"servers; the servers must be alive; two replicated data copies of the "
"same shard should not be in the same zone."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:136
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:138
msgid ""
"The number of replicated data copies per shard (redundancy) is 3. The "
"number of instances is 3. The shard module will conclude that there is "
"only one shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:142
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:163
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:165
msgid ""
"This describes three shards. Each shard has two replicated data copies. "
"Since the number of servers is 7, and the number of replicated data "
"copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of"
" the servers will not be used. This is not necessarily an error, because "
"perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:170
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:196
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:203
msgid ""
"Every data-access function in the box module has an analogue in the shard"
" module, so (for example) to insert in table T in a sharded database one "
"simply says ``shard.T:insert{...}`` instead of "
"``box.space.T:insert{...}``. A ``shard.T:select{}`` request without a "
"primary key will search all shards."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:211
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:218
msgid ""
"Every queued data-access function has an analogue in the shard module. "
"The user must add an operation_id. The details of queued data-access "
"functions, and of maintenance-related functions, are on `the shard "
"section of github`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:224
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:226
msgid ""
"There is only one shard, and that shard contains only one replicated data"
" copy. So this isn't illustrating the features of either replication or "
"sharding, it's only illustrating what the syntax is, and what the "
"messages look like, that anyone could duplicate in a minute or two with "
"the magic of cut-and-paste."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:231
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:257
msgid ""
"If one cuts and pastes the above, then the result, showing only the "
"requests and responses for shard.init and shard.tester, should look "
"approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:261
msgid ""
"tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:290
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:292
msgid ""
"There are two shards, and each shard contains one replicated data copy. "
"This requires two nodes. In real life the two nodes would be two "
"computers, but for this illustration the requirement is merely: start two"
" shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:297
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:299
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:327
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:329
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:357
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It "
"will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:361
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:363
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:370
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by "
"Terminal #2, via the shard module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:373
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:31
msgid "Module `tdb`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:33
msgid ""
"The Tarantool Debugger (abbreviation = tdb) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining"
" variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding "
"hints."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:39
msgid ""
"It is not supplied as part of the Tarantool repository; it must be "
"installed separately. Here is the usual way:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:42
msgid ""
"git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:49
msgid ""
"To initiate tdb within a Lua program and set a breakpoint, edit the "
"program to include these lines:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:52
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:57
msgid ""
"To start the debugging session, execute the Lua program. Execution will "
"stop at the breakpoint, and it will be possible to enter debugging "
"commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:62
msgid "Debugger Commands"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:66
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:65
msgid ""
"Backtrace -- show the stack (in red), with program/function names and "
"line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:69
msgid ":codebold:`c`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:69
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:76
msgid ":codebold:`e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:72
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This "
"is particularly useful for displaying the values of the program's "
"variables. Other debugger commands will not work until one exits "
"evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:79
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:79
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:83
msgid ":codebold:`f`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:82
msgid ""
"Display the fiber id, the program name, and the percentage of memory "
"used, as a table."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:86
msgid ":codebold:`n`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:86
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid ":codebold:`h`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:96
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:95
msgid ""
"Display names and values of variables, for example the control variables "
"of a Lua \"for\" statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:99
msgid ":codebold:`q`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:99
msgid "Quit immediately."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:103
msgid "Example Session"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:105
msgid ""
"Put the following program in a default directory and call it "
"\"example.lua\":"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:107
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:115
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:120
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:122
#: ../doc/1.7/reference/reference_rock/tdb.rst:147
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:127
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:134
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and "
"the current line -- line 3 of example.lua -- is the default color. Now "
"enter six debugger commands:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:138
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:152
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:169
msgid "Another debugger example can be found here_."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:33
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:35
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool instances. It "
"is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:38
msgid "The command format is:"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:40
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:42
msgid "where:"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:44
msgid ""
"COMMAND is one of the following: start, stop, logrotate, status, enter, "
"restart, eval, check, connect, cat, play."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:47
msgid "NAME is the name of an :ref:`instance file <admin-instance_file>`."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:49
msgid "FILE is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:51
msgid "URI is the URI of some Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:53
msgid "OPTIONS are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:55
msgid "See also:"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:57
msgid "Detailed reference upon ``man tarantoolctl`` or ``tarantoolctl --help``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:58
msgid "Usage examples in :ref:`Server administration <admin>` section."
msgstr ""

