# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the Tarantool package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Tarantool 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-07-14 13:24+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"

#: ../doc/1.7/book/admin/backups.rst:33
msgid "Backups"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:35
msgid ""
"Tarantool storage architecture is append-only: files are only appended "
"to, and are never overwritten. Old files are removed by garbage "
"collection after a checkpoint. You can configure the amount of past "
"checkpoints preserved by garbage collection by configuring Tarantool's "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`. Backups can be "
"taken at any time, with minimal overhead on database performance."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:46
msgid "Hot backup (memtx)"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:48
msgid "This is a special case when there are only in-memory tables."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:50
msgid ""
"The last snapshot file is a backup of the entire database; and the WAL "
"files that are made after the last snapshot are incremental backups. "
"Therefore taking a backup is a matter of copying the snapshot and WAL "
"files."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:54
msgid ""
"Use ``tar`` to make a (possibly compressed) copy of the latest .snap and "
".xlog files on the :ref:`memtx_dir <cfg_basic-memtx_dir>` and "
":ref:`wal_dir <cfg_basic-wal_dir>` directories."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:58
msgid "If there is a security policy, encrypt the .tar file."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:60
msgid "Copy the .tar file to a safe place."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:62
msgid ""
"Later, restoring the database is a matter of taking the .tar file and "
"putting its contents back in the memtx_dir and wal_dir directories."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:69
msgid "Hot backup (vinyl/memtx)"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:71
msgid ""
"Vinyl stores its files in :ref:`vinyl_dir <cfg_basic-vinyl_dir>`, and "
"creates a folder for each database space. Dump and compaction processes "
"are append-only and create new files. Old files are garbage collected "
"after each checkpoint."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:75
msgid "To take a mixed backup:"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:77
msgid ""
"Issue ``box.backup.begin()`` on the administrative console. This will "
"suspend garbage collection till the next ``box.backup.end()`` and will "
"return a list of files to backup."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:81
msgid ""
"Copy the files from the list to a safe location. This will include memtx "
"snapshot files, vinyl run and index files, at a state consistent with the"
" last checkpoint."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:85
msgid "Resume garbage collection with ``box.backup.end()``."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:91
msgid "Continuous remote backup (memtx)"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:93
msgid ""
"The :ref:`replication <replication>` feature is useful for backup as well"
" as for load balancing."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:96
msgid ""
"Therefore taking a backup is a matter of ensuring that any given replica "
"is up to date, and doing a cold backup on it. Since all the other "
"replicas continue to operate, this is not a cold backup from the end "
"user’s point of view. This could be done on a regular basis, with a "
"``cron`` job or with a Tarantool fiber."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:105
msgid "Continuous backup (memtx)"
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:107
msgid ""
"The logged changes done since the last cold backup must be secured, while"
" the system is running."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:110
msgid ""
"For this purpose, you need a file copy utility that will do the copying "
"remotely and continuously, copying only the parts of a write ahead log "
"file that are changing. One such utility is `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_."
msgstr ""

#: ../doc/1.7/book/admin/backups.rst:115
msgid ""
"Alternatively, you need an ordinary file copy utility, but there should "
"be frequent production of new snapshot files or new WAL files as changes "
"occur, so that only the new files need to be copied."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:33
msgid "Bug reports"
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:35
msgid ""
"If you found a bug in Tarantool, you’re doing us a favor by taking the "
"time to tell us about it."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:38
msgid ""
"Please create an issue at Tarantool repository at GitHub. We encourage "
"you to include the following information:"
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:41
msgid ""
"Steps needed to reproduce the bug, and an explanation why this differs "
"from the expected behavior according to our manual. Please provide "
"specific unique information. For example, instead of \"I can’t get "
"certain information\", say \"box.space.x:delete() didn’t report what was "
"deleted\"."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:46
msgid ""
"Your operating system name and version, the Tarantool name and version, "
"and any unusual details about your machine and its configuration."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:49
msgid ""
"Related files like a :ref:`stack trace <admin-stack_traces>` or a "
"Tarantool :ref:`log file <admin-logs>`."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:52
msgid ""
"If this is a feature request or if it affects a special category of "
"users, be sure to mention that."
msgstr ""

#: ../doc/1.7/book/admin/bug_reports.rst:55
msgid ""
"Usually within one or two workdays a Tarantool team member will write an "
"acknowledgment, or some questions, or suggestions for a workaround."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:33
msgid "Daemon supervision"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:39
msgid "Server signals"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:41
msgid "Tarantool processes these signals during the main thread event loop:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:49
msgid "Signal"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:49
#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
#: ../doc/1.7/book/box/data_model.rst:631
msgid "Effect"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:51
msgid "SIGHUP"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:51
msgid ""
"May cause log file rotation. See the :ref:`example <cfg_logging-"
"logging_example>` in reference on Tarantool logging parameters."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:55
msgid "SIGUSR1"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:55
msgid "May cause a database checkpoint. See :ref:`box.snapshot <box-snapshot>`."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
msgid "SIGTERM"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:58
msgid "May cause graceful shutdown (information will be saved first)."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:61
msgid "SIGINT (also known as keyboard interrupt)"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:61
msgid "May cause graceful shutdown."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
msgid "SIGKILL"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:65
msgid "Causes an immediate shutdown."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:68
msgid ""
"Other signals will result in behavior defined by the operating system. "
"Signals other than SIGKILL may be ignored, especially if Tarantool is "
"executing a long-running procedure which prevents return to the main "
"thread event loop."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:76
msgid "Automatic instance restart"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:78
msgid ""
"On ``systemd``-enabled platforms, ``systemd`` automatically restarts all "
"Tarantool instances in case of failure. To demonstrate it, let’s try to "
"destroy an instance:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:82
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5885 (tarantool)\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> os.exit(-1)\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:93
msgid "Now let’s make sure that ``systemd`` has restarted the instance:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:95
msgid ""
"$ systemctl status tarantool@my_app|grep PID\n"
"Main PID: 5914 (tarantool)"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:100
msgid "Finally, let’s check the boot logs:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:102
msgid ""
"$ journalctl -u tarantool@my_app -n 8\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:09:45 MSK. --\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Unit entered failed state.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Failed with result 'exit-code'.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: "
"tarantool@my_app.service: Service hold-off time over, scheduling restart."
"\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:09:45 localhost.localdomain tarantoolctl[5910]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:09:45 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:119
msgid "Core dumps"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:121
msgid ""
"Tarantool makes a core dump if it receives any of the following signals: "
"SIGSEGV, SIGFPE, SIGABRT or SIGQUIT. This is automatic if Tarantool "
"crashes."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:124
msgid ""
"On ``systemd``-enabled platforms, ``coredumpctl`` automatically saves "
"core dumps and stack traces in case of a crash. Here is a general \"how "
"to\" for how to enable core dumps on a Unix system:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:128
msgid ""
"Ensure session limits are configured to enable core dumps, i.e. say "
"``ulimit -c unlimited``. Check  \"man 5 core\" for other reasons why a "
"core dump may not be produced."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:132
msgid ""
"Set a directory for writing core dumps to, and make sure that the "
"directory is writable. On Linux, the directory path is set in a kernel "
"parameter configurable via ``/proc/sys/kernel/core_pattern``."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:136
msgid ""
"Make sure that core dumps include stack trace information. If you use a "
"binary Tarantool distribution, this is automatic. If you build Tarantool "
"from source, you will not get detailed information if you pass "
"``-DCMAKE_BUILD_TYPE=Release`` to CMake."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:141
msgid ""
"To simulate a crash, you can execute an illegal command against a "
"Tarantool instance:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:144
msgid ""
"$ # !!! please never do this on a production system !!!\n"
"$ tarantoolctl enter my_app\n"
"unix/:/var/run/tarantool/my_app.control> require('ffi').cast('char *', "
"0)[0] = 48\n"
"/bin/tarantoolctl: unix/:/var/run/tarantool/my_app.control: Remote host "
"closed connection"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:151
msgid ""
"Alternatively, if you know the process ID of the instance (here we refer "
"to it as $PID), you can abort a Tarantool instance by running ``gdb`` "
"debugger:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:154
msgid "$ gdb -batch -ex \"generate-core-file\" -p $PID"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:158
msgid "or manually sending a SIGABRT signal:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:160
msgid "$ kill -SIGABRT $PID"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:166
msgid "To find out the process id of the instance ($PID), you can:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:168
msgid ""
"look it up in the instance's :ref:`box.info.pid <box_introspection-"
"box_info>`,"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:170
msgid "find it with ``ps -A | grep tarantool``, or"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:172
msgid "say ``systemctl status tarantool@my_app|grep PID``."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:174
msgid ""
"On a ``systemd-enabled`` system, to see the latest crashes of the "
"Tarantool daemon, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:177
msgid ""
"$ coredumpctl list /usr/bin/tarantool\n"
"MTIME                            PID   UID   GID SIG PRESENT EXE\n"
"Sat 2016-01-23 15:21:24 MSK   20681  1000  1000   6   /usr/bin/tarantool\n"
"Sat 2016-01-23 15:51:56 MSK   21035   995   992   6   /usr/bin/tarantool"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:184
msgid "To save a core dump into a file, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:186
msgid "$ coredumpctl -o filename.core info <pid>"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:194
msgid "Stack traces"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:196
msgid ""
"Since Tarantool stores tuples in memory, core files may be large. For "
"investigation, you normally don't need the whole file, but only a \"stack"
" trace\" or \"backtrace\"."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:200
msgid "To save a stack trace into a file, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:202
msgid ""
"$ gdb -se \"tarantool\" -ex \"bt full\" -ex \"thread apply all bt\" "
"--batch -c core> /tmp/tarantool_trace.txt"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:206
#: ../doc/1.7/book/admin/instance_config.rst:140
#: ../doc/1.7/book/replication/repl_bootstrap.rst:67
#: ../doc/1.7/reference/tarantoolctl.rst:42
msgid "where:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:208
msgid "\"tarantool\" is the path to the Tarantool executable,"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:209
msgid "\"core\" is the path to the core file, and"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:210
msgid ""
"\"/tmp/tarantool_trace.txt\" is a sample path to a file for saving the "
"stack trace."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:214
msgid ""
"Occasionally, you may find that the trace file contains output without "
"debug symbols – the lines will contain ”??” instead of names. If this "
"happens, check the instructions on these Tarantool wiki pages: `How to "
"debug core dump of stripped tarantool "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-dump-of-"
"stripped-tarantool>`_ and `How to debug core from different OS "
"<https://github.com/tarantool/tarantool/wiki/How-to-debug-core-from-"
"different-OS>`_."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:221
msgid "To see the stack trace and other useful information in console, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:223
msgid ""
"$ coredumpctl info 21035\n"
"          PID: 21035 (tarantool)\n"
"          UID: 995 (tarantool)\n"
"          GID: 992 (tarantool)\n"
"       Signal: 6 (ABRT)\n"
"    Timestamp: Sat 2016-01-23 15:51:42 MSK (4h 36min ago)\n"
" Command Line: tarantool my_app.lua <running>\n"
"   Executable: /usr/bin/tarantool\n"
"Control Group: /system.slice/system-"
"tarantool.slice/tarantool@my_app.service\n"
"         Unit: tarantool@my_app.service\n"
"        Slice: system-tarantool.slice\n"
"      Boot ID: 7c686e2ef4dc4e3ea59122757e3067e2\n"
"   Machine ID: a4a878729c654c7093dc6693f6a8e5ee\n"
"     Hostname: localhost.localdomain\n"
"      Message: Process 21035 (tarantool) of user 995 dumped core.\n"
"\n"
"               Stack trace of thread 21035:\n"
"               #0  0x00007f84993aa618 raise (libc.so.6)\n"
"               #1  0x00007f84993ac21a abort (libc.so.6)\n"
"               #2  0x0000560d0a9e9233 _ZL12sig_fatal_cbi (tarantool)\n"
"               #3  0x00007f849a211220 __restore_rt (libpthread.so.0)\n"
"               #4  0x0000560d0aaa5d9d lj_cconv_ct_ct (tarantool)\n"
"               #5  0x0000560d0aaa687f lj_cconv_ct_tv (tarantool)\n"
"               #6  0x0000560d0aaabe33 lj_cf_ffi_meta___newindex "
"(tarantool)\n"
"               #7  0x0000560d0aaae2f7 lj_BC_FUNCC (tarantool)\n"
"               #8  0x0000560d0aa9aabd lua_pcall (tarantool)\n"
"               #9  0x0000560d0aa71400 lbox_call (tarantool)\n"
"               #10 0x0000560d0aa6ce36 lua_fiber_run_f (tarantool)\n"
"               #11 0x0000560d0a9e8d0c "
"_ZL16fiber_cxx_invokePFiP13__va_list_tagES0_ (tarantool)\n"
"               #12 0x0000560d0aa7b255 fiber_loop (tarantool)\n"
"               #13 0x0000560d0ab38ed1 coro_init (tarantool)\n"
"               ..."
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:262
msgid "Debugger"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:264
msgid "To start ``gdb`` debugger on the core dump, say:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:266
msgid "$ coredumpctl gdb <pid>"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:270
msgid ""
"It is highly recommended to install ``tarantool-debuginfo`` package to "
"improve ``gdb`` experience, for example:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:273
msgid "$ dnf debuginfo-install tarantool"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:277
msgid ""
"``gdb`` also provides information about the debuginfo packages you need "
"to install:"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:280
msgid ""
"$ # gdb -p <pid>\n"
"...\n"
"Missing separate debuginfos, use: dnf debuginfo-install\n"
"glibc-2.22.90-26.fc24.x86_64 krb5-libs-1.14-12.fc24.x86_64\n"
"libgcc-5.3.1-3.fc24.x86_64 libgomp-5.3.1-3.fc24.x86_64\n"
"libselinux-2.4-6.fc24.x86_64 libstdc++-5.3.1-3.fc24.x86_64\n"
"libyaml-0.1.6-7.fc23.x86_64 ncurses-libs-6.0-1.20150810.fc24.x86_64\n"
"openssl-libs-1.0.2e-3.fc24.x86_64"
msgstr ""

#: ../doc/1.7/book/admin/daemon_supervision.rst:291
msgid ""
"Symbolic names are present in stack traces even if you don’t have "
"``tarantool-debuginfo`` package installed."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:33
msgid "Disaster recovery"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:35
msgid ""
"The minimal fault-tolerant Tarantool configuration would be a replication"
" cluster that includes a master and a replica, or two masters."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:38
msgid ""
"The basic recommendation is to configure all Tarantool instances in a "
"cluster to create :ref:`snapshot files <index-box_persistence>` at a "
"regular basis."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:41
msgid "Here follow action plans for typical crash scenarios."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:47
msgid "Master-replica"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:49
msgid "Configuration: One master and one replica."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:51
msgid "Problem: The master has crashed."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:53
#: ../doc/1.7/book/admin/disaster_recovery.rst:120
msgid "Your actions:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:55
msgid ""
"Ensure the master is stopped for good. For example, log in to the master "
"machine and use ``systemctl stop tarantool@<instance_name>``."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:58
msgid ""
"Switch the replica to master mode by setting :ref:`box.cfg.read_only "
"<cfg_basic-read_only>` parameter to *false* and let the load be handled "
"by the replica (effective master)."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:62
msgid ""
"Set up a replacement for the crashed master on a spare host, with "
":ref:`replication <cfg_replication-replication>` parameter set to replica"
" (effective master), so it begins to catch up with the new master’s "
"state. The new instance should have :ref:`box.cfg.read_only <cfg_basic-"
"read_only>` parameter set to *true*."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:68
msgid ""
"You lose the few transactions in the master :ref:`write ahead log file "
"<index-box_persistence>`, which it may have not transferred to the "
"replica before crash. If you were able to salvage the master .xlog file, "
"you may be able to recover these. In order to do it:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:73
msgid ""
"Find out the position of the crashed master, as reflected on the new "
"master."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:75
msgid "Find out instance UUID from the crashed master xlog:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:77
msgid ""
"$ head -5 *.xlog | grep Instance\n"
"Instance: ed607cad-8b6d-48d8-ba0b-dae371b79155"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:82
msgid "On the new master, use the UUID to find the position:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:84
msgid ""
"tarantool>box.info.vclock[box.space._cluster.index.uuid:select{'ed607cad-"
"8b6d-48d8-ba0b-dae371b79155'}[1][1]]\n"
"---\n"
"- 23425\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:91
msgid ""
"Play the records from the crashed .xlog to the new master, starting from "
"the new master position:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:94
msgid ""
"Issue this request locally at the new master's machine to find out "
"instance ID of the new master:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:97
#: ../doc/1.7/book/replication/repl_architecture.rst:111
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '88580b5c-4474-43ab-bd2b-2409a9af80d2']\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:104
msgid "Play the records to the new master:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:106
msgid ""
"$ tarantoolctl <new_master_uri> <xlog_file> play --from-lsn 23425 "
"--replica 1"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:114
msgid "Master-master"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:116
msgid "Configuration: Two masters."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:118
msgid "Problem: Master#1 has crashed."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:122
msgid "Let the load be handled by master#2 (effective master) alone."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:124
msgid ""
"2. Follow the same steps as in the :ref:`master-replica <admin-"
"disaster_recovery-master_replica>` recovery scenario to create a new "
"master and salvage lost data."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:132
msgid "Data loss"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:134
msgid "Configuration: Master-master or master-replica."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:136
msgid ""
"Problem: Data was deleted at one master and this data loss was propagated"
" to the other node (master or replica)."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:139
msgid ""
"The following steps are applicable only to data in memtx storage engine. "
"Your actions:"
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:142
msgid ""
"Put all nodes in :ref:`read-only mode <cfg_basic-read_only>` and disable "
"checkpointing with ``box.backup.begin()``. Disabling the checkpointing is"
" necessary to prevent automatic garbage collection of older checkpoints."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:146
msgid ""
"Get the latest valid .snap file and use ``tarantoolctl cat`` command to "
"calculate at which lsn the data loss occurred."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:149
msgid ""
"Start a new instance (instance#1) and use ``tarantoolctl play`` command "
"to play to it the contents of .snap/.xlog files up to the calculated lsn."
msgstr ""

#: ../doc/1.7/book/admin/disaster_recovery.rst:152
msgid "Bootstrap a new replica from the recovered master (instance#1)."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:33
msgid "Server administration"
msgstr ""

#: ../doc/1.7/book/admin/index.rst:35
msgid "Tarantool is designed to have multiple running instances on the same host."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:37
msgid ""
"Here we show how to administer Tarantool instances using any of the "
"following utilities:"
msgstr ""

#: ../doc/1.7/book/admin/index.rst:40
msgid "``systemd`` native utilities, or"
msgstr ""

#: ../doc/1.7/book/admin/index.rst:41
msgid ""
":ref:`tarantoolctl <tarantoolctl>`, a utility shipped and installed as "
"part of Tarantool distribution."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:46
msgid "Unlike the rest of this manual, here we use system-wide paths."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:47
msgid "Console examples here are for Fedora."
msgstr ""

#: ../doc/1.7/book/admin/index.rst:49 ../doc/1.7/book/replication/index.rst:39
msgid "This chapter includes the following sections:"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:33
msgid "Instance configuration"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:35
msgid "For each Tarantool instance, you need two files:"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:37
msgid ""
"[Optional] An :ref:`application file <app_server-launching_app>` with "
"instance-specific logic. Put this file into the ``/usr/share/tarantool/``"
" directory."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:41
msgid ""
"For example, ``/usr/share/tarantool/my_app.lua`` (here we implement it as"
" a :ref:`Lua module <app_server-modules>` that bootstraps the database "
"and exports ``start()`` function for API calls):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:45
msgid ""
"local function start()\n"
"    box.schema.space.create(\"somedata\")\n"
"    box.space.somedata:create_index(\"primary\")\n"
"    <...>\n"
"end\n"
"\n"
"return {\n"
"  start = start;\n"
"}"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:57
msgid ""
"An :ref:`instance file <admin-instance_file>` with instance-specific "
"initialization logic and parameters. Put this file, or a symlink to it, "
"into the ``/etc/tarantool/instances.enabled`` directory."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:61
msgid ""
"For example, ``/etc/tarantool/instances.enabled/my_app.lua`` (here we "
"load ``my_app.lua`` module and make a call to ``start()`` function from "
"that module):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:65
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"box.cfg {\n"
"    listen = 3301;\n"
"}\n"
"\n"
"-- load my_app module and call start() function\n"
"-- with some app options controlled by sysadmins\n"
"local m = require('my_app').start({...})"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:81
msgid "Instance file"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:83
msgid ""
"After this short introduction, you may wonder what an instance file is, "
"what it is for, and how ``tarantoolctl`` uses it. After all, Tarantool is"
" an application server, so why not start the application stored in "
"``/usr/share/tarantool`` directly?"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:88
msgid ""
"A typical Tarantool application is not a script, but a daemon running in "
"background mode and processing requests, usually sent to it over a TCP/IP"
" socket. This daemon needs to be started automatically when the operating"
" system starts, and managed with the operating system standard tools for "
"service management -- such as ``systemd`` or ``init.d``. To serve this "
"very purpose, we created **instance files**."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:95
msgid ""
"You can have more than one instance file. For example, a single "
"application in ``/usr/share/tarantool`` can run in multiple instances, "
"each of them having its own instance file. Or you can have multiple "
"applications in ``/usr/share/tarantool`` -- again, each of them having "
"its own instance file."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:100
msgid ""
"An instance file is typically created by a system administrator. An "
"application file is often provided by a developer, in a Lua rock or an "
"rpm/deb package."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:103
msgid ""
"An instance file is designed to not differ in any way from a Lua "
"application. It must, however, configure the database, i.e. contain a "
"call to :ref:`box.cfg{} <box_introspection-box_cfg>` somewhere in it, "
"because it’s the only way to turn a Tarantool script into a background "
"process, and ``tarantoolctl`` is a tool to manage background processes. "
"Other than that, an instance file may contain arbitrary Lua code, and, in"
" theory, even include the entire application business logic in it. We, "
"however, do not recommend this, since it clutters the instance file and "
"leads to unnecessary copy-paste when you need to run multiple instances "
"of an application."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:117
msgid "`tarantoolctl` configuration file"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:119
msgid ""
"While instance files contain instance configuration, ``tarantoolctl`` "
"configuration file contains the configuration that ``tarantoolctl`` uses "
"to override instance configuration. In other words, it contains system-"
"wide configuration defaults."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:124
msgid ""
"Most of the parameters are similar to those used by :ref:`box.cfg{} "
"<box_introspection-box_cfg>`. Here are the default settings (installed to"
" ``/etc/default/tarantool`` as part of Tarantool distribution):"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:128
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/var/run/tarantool\",\n"
"    wal_dir   = \"/var/lib/tarantool\",\n"
"    memtx_dir = \"/var/lib/tarantool\",\n"
"    vinyl_dir = \"/var/lib/tarantool\",\n"
"    log       = \"/var/log/tarantool\",\n"
"    username  = \"tarantool\",\n"
"}\n"
"instance_dir = \"/etc/tarantool/instances.enabled\""
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``pid_file``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for the pid file and control-socket file; ``tarantoolctl`` will"
" add “/instance_name” to the directory name."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``wal_dir``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for write-ahead .xlog files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``memtx_dir``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for snapshot .snap files; ``tarantoolctl`` will add "
"\"/instance_name\" to the directory name."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``vinyl_dir``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"Directory for vinyl files; ``tarantoolctl`` will add \"/instance_name\" "
"to the directory name."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``log``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The place where the application log will go; ``tarantoolctl`` will add "
"\"/instance_name.log\" to the name."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``username``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The user that runs the Tarantool instance. This is the operating-system "
"user name rather than the Tarantool-client user name. Tarantool will "
"change its effective user to this user after becoming a daemon."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid "``instance_dir``"
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst
msgid ""
"The directory where all instance files for this host are stored. Put "
"instance files in this directory, or create symbolic links."
msgstr ""

#: ../doc/1.7/book/admin/instance_config.rst:171
msgid ""
"As a full-featured example, you can take `example.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/extra/dist/example.lua>`_"
" script that ships with Tarantool and defines all configuration options."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:33
msgid "Logs"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:35
msgid ""
"Tarantool logs important events to a file, e.g. "
"``/var/log/tarantool/my_app.log``. To build the log file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends “.log” extension."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:39
msgid "Let’s write something to the log file:"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:41
msgid ""
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> require('log').info(\"Hello for "
"the manual readers\")\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:49
msgid "Then check the logs:"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:51
msgid ""
"$ tail /var/log/tarantool/my_app.log\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> version "
"1.7.3-382-g68ef3f6a9\n"
"2017-04-04 15:54:04.977 [29255] main/101/tarantoolctl C> log level 5\n"
"2017-04-04 15:54:04.978 [29255] main/101/tarantoolctl I> mapping "
"134217728 bytes for tuple arena...\n"
"2017-04-04 15:54:04.985 [29255] iproto/101/main I> binary: bound to "
"[::1]:3301\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovery start\n"
"2017-04-04 15:54:04.986 [29255] main/101/tarantoolctl I> recovering from "
"`/var/lib/tarantool/my_app/00000000000000000000.snap'\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> ready to accept "
"requests\n"
"2017-04-04 15:54:04.988 [29255] main/101/tarantoolctl I> set "
"'checkpoint_interval' configuration option to 3600\n"
"2017-04-04 15:54:04.988 [29255] main/101/my_app I> Run console at "
"unix/:/var/run/tarantool/my_app.control\n"
"2017-04-04 15:54:04.989 [29255] main/106/console/unix/:/var/ I> started\n"
"2017-04-04 15:54:04.989 [29255] main C> entering the event loop\n"
"2017-04-04 15:54:47.147 [29255] main/107/console/unix/: I> Hello for the "
"manual readers"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:67
msgid ""
"When logging to a file, the system administrator must ensure logs are "
"rotated timely and do not take up all the available disk space. With "
"``tarantoolctl``, log rotation is pre-configured to use ``logrotate`` "
"program, which you must have installed."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:72
msgid ""
"File ``/etc/logrotate.d/tarantool`` is part of the standard Tarantool "
"distribution, and you can modify it to change the default behavior. This "
"is what this file is usually like:"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:76
#, python-format
msgid ""
"/var/log/tarantool/*.log {\n"
"    daily\n"
"    size 512k\n"
"    missingok\n"
"    rotate 10\n"
"    compress\n"
"    delaycompress\n"
"    create 0640 tarantool adm\n"
"    postrotate\n"
"        /usr/bin/tarantoolctl logrotate `basename ${1%%.*}`\n"
"    endscript\n"
"}"
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:91
msgid ""
"If you use a different log rotation program, you can invoke "
"``tarantoolctl logrotate`` command to request instances to reopen their "
"log files after they were moved by the program of your choice."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:97
msgid ""
"Tarantool can write its logs to a log file, ``syslog`` or a program "
"specified in the configuration file (see :ref:`log <cfg_logging-log>` "
"parameter)."
msgstr ""

#: ../doc/1.7/book/admin/logs.rst:100
msgid ""
"By default, logs are written to a file as defined in ``tarantoolctl`` "
"defaults. ``tarantoolctl`` automatically detects if an instance is using "
"``syslog`` or an external program for logging, and does not override the "
"log destination in this case. In such configurations, log rotation is "
"usually handled by the external program used for logging. So, "
"``tarantoolctl logrotate`` command works only if logging-into-file is "
"enabled in the instance file."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:33
msgid "Notes for operating systems"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:39
msgid "Mac OS"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:41
msgid ""
"On Mac OS, you can administer Tarantool instances only with "
"``tarantoolctl``. No native system tools are supported."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:48
msgid "FreeBSD"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:50
msgid ""
"To make ``tarantoolctl`` work along with ``init.d`` utilities on FreeBSD,"
" use paths other than those suggested in :ref:`Instance configuration "
"<admin-instance_config>`. Instead of ``/usr/share/tarantool/`` directory,"
" use ``/usr/local/etc/tarantool/`` and create the following "
"subdirectories:"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:56
msgid "``default`` for ``tarantoolctl`` defaults (see example below),"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:57
msgid "``instances.available`` for all available instance files, and"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:58
msgid "``instances.enabled`` for instance files to be auto-started by sysvinit."
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:60
msgid "Here is an example of ``tarantoolctl`` defaults on FreeBSD:"
msgstr ""

#: ../doc/1.7/book/admin/os_notes.rst:62
msgid ""
"default_cfg = {\n"
"    pid_file   = \"/var/run/tarantool\", -- "
"/var/run/tarantool/${INSTANCE}.pid\n"
"    wal_dir    = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}/"
"\n"
"    snap_dir   = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    vinyl_dir = \"/var/db/tarantool\", -- /var/db/tarantool/${INSTANCE}\n"
"    logger     = \"/var/log/tarantool\", -- "
"/var/log/tarantool/${INSTANCE}.log\n"
"    username   = \"tarantool\",\n"
"}\n"
"\n"
"-- instances.available - all available instances\n"
"-- instances.enabled - instances to autostart by sysvinit\n"
"instance_dir = \"/usr/local/etc/tarantool/instances.available\""
msgstr ""

#: ../doc/1.7/book/admin/security.rst:33
msgid "Security"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:35
msgid "Tarantool allows for two types of connections:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:37
msgid ""
"With :ref:`console.listen() <console-listen>` function from ``console`` "
"module, you can set up a port which can be used to open an administrative"
" console to the server. This is for administrators to connect to a "
"running instance and make requests. ``tarantoolctl`` invokes "
"``console.listen()`` to create a control socket for each started "
"instance."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:43
msgid ""
"With :ref:`box.cfg{listen=...} <cfg_basic-listen>` parameter from ``box``"
" module, you can set up a binary port for connections which read and "
"write to the database or invoke stored procedures."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:47
msgid "When you connect to an admin console:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:49
msgid "The client-server protocol is plain text."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:50
msgid "No password is necessary."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:51
msgid "The user is automatically 'admin'."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:52
msgid "Each command is fed directly to the built-in Lua interpreter."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:54
msgid ""
"Therefore you must set up ports for the admin console very cautiously. If"
" it is a TCP port, it should only be opened for a specific IP. Ideally, "
"it should not be a TCP port at all, it should be a Unix domain socket, so"
" that access to the server machine is required. Thus a typical port setup"
" for admin console is:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:59
msgid "console.listen('/var/lib/tarantool/socket_name.sock')"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:63
msgid "and a typical connection :ref:`URI <index-uri>` is:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:65
msgid "/var/lib/tarantool/socket_name.sock"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:69
msgid ""
"if the listener has the privilege to write on ``/var/lib/tarantool`` and "
"the connector has the privilege to read on ``/var/lib/tarantool``. "
"Alternatively, to connect to an admin console of an instance started with"
" ``tarantoolctl``, use :ref:`tarantoolctl enter <admin-"
"executing_code_on_an_instance>`."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:74
msgid ""
"To find out whether a TCP port is a port for admin console, use "
"``telnet``. For example:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:77
msgid ""
"$ telnet 0 3303\n"
"Trying 0.0.0.0...\n"
"Connected to 0.\n"
"Escape character is '^]'.\n"
"Tarantool 1.7.3 (Lua console)\n"
"type 'help' for interactive help"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:86
msgid ""
"In this example, the response does not include the word \"binary\" and "
"does include the words \"Lua console\". Therefore it is clear that this "
"is a successful connection to a port for admin console, and you can now "
"enter admin requests on this terminal."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:91
msgid "When you connect to a binary port:"
msgstr ""

#: ../doc/1.7/book/admin/security.rst:93
msgid ""
"The client-server protocol is :ref:`binary <box_protocol-"
"iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:94
msgid "The user is automatically ':ref:`guest <authentication-users>`'."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:95
msgid "To change the user, it’s necessary to authenticate."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:97
msgid ""
"For ease of use, ``tarantoolctl connect`` command automatically detects "
"the type of connection during handshake and uses :ref:`EVAL "
"<box_protocol-eval>` binary protocol command when it’s necessary to "
"execute Lua commands over a binary connection. To execute EVAL, the "
"authenticated user must have global \"EXECUTE\" privilege."
msgstr ""

#: ../doc/1.7/book/admin/security.rst:103
msgid ""
"Therefore, when ``ssh`` access to the machine is not available, creating "
"a Tarantool user with global \"EXECUTE\" privilege and non-empty password"
" can be used to provide a system administrator **remote** access to an "
"instance."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:33
msgid "Server introspection"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:39
msgid "Using Tarantool as a client"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:41
msgid "Tarantool enters the interactive mode if:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:43
msgid ""
"you start Tarantool without an :ref:`instance file <admin-"
"instance_file>`, or"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:46
msgid "the instance file contains :ref:`console.start() <console-start>`."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:48
msgid ""
"Tarantool displays a prompt (e.g. \"tarantool>\") and you can enter "
"requests. When used this way, Tarantool can be a client for a remote "
"server. See basic examples in :ref:`Getting started <getting_started>`."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:52
msgid ""
"The interactive mode is used by ``tarantoolctl`` to implement \"enter\" "
"and \"connect\" commands."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:59
msgid "Executing code on an instance"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:61
msgid ""
"You can attach to an instance's admin console and execute some Lua code "
"using ``tarantoolctl``:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:64
msgid ""
"$ # for local instances:\n"
"$ tarantoolctl enter my_app\n"
"/bin/tarantoolctl: Found my_app.lua in /etc/tarantool/instances.available"
"\n"
"/bin/tarantoolctl: Connecting to /var/run/tarantool/my_app.control\n"
"/bin/tarantoolctl: connected to unix/:/var/run/tarantool/my_app.control\n"
"unix/:/var/run/tarantool/my_app.control> 1 + 1\n"
"---\n"
"- 2\n"
"...\n"
"unix/:/var/run/tarantool/my_app.control>\n"
"\n"
"$ # for local and remote instances:\n"
"$ tarantoolctl connect username:password@127.0.0.1:3306"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:80
msgid ""
"You can also use ``tarantoolctl`` to execute Lua code on an instance "
"without attaching to its admin console. For example:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:83
msgid ""
"# executing commands directly from the command line\n"
"$ <command> | tarantoolctl eval my_app\n"
"<...>\n"
"$ # - OR -\n"
"# executing commands from a script file\n"
"$ tarantoolctl eval my_app script.lua\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:95
msgid ""
"Alternatively, you can use the :ref:`console <console-module>` module or "
"the :ref:`net.box <net_box-module>` module from a Tarantool server. Also,"
" you can write your client programs with any of the :ref:`connectors "
"<index-box_connectors>`. However, most of the examples in this manual "
"illustrate usage with either ``tarantoolctl connect`` or :ref:`using the "
"Tarantool server as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:106
msgid "Health checks"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:108
msgid "To check the instance status, say:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:110
msgid ""
"$ tarantoolctl status my_app\n"
"my_app is running (pid: /var/run/tarantool/my_app.pid)\n"
"$ # - OR -\n"
"$ systemctl status tarantool@my_app\n"
"tarantool@my_app.service - Tarantool Database Server\n"
"Loaded: loaded (/etc/systemd/system/tarantool@.service; disabled; vendor "
"preset: disabled)\n"
"Active: active (running)\n"
"Docs: man:tarantool(1)\n"
"Process: 5346 ExecStart=/usr/bin/tarantoolctl start %I (code=exited, "
"status=0/SUCCESS)\n"
"Main PID: 5350 (tarantool)\n"
"Tasks: 11 (limit: 512)\n"
"CGroup: /system.slice/system-tarantool.slice/tarantool@my_app.service\n"
"+ 5350 tarantool my_app.lua <running>"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:126
msgid "To check the boot log, on systems with ``systemd``, say:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:128
msgid ""
"$ journalctl -u tarantool@my_app -n 5\n"
"-- Logs begin at Fri 2016-01-08 12:21:53 MSK, end at Thu 2016-01-21 "
"21:17:47 MSK. --\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Stopped Tarantool "
"Database Server.\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Starting Tarantool "
"Database Server...\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Found my_app.lua in "
"/etc/tarantool/instances.available\n"
"Jan 21 21:17:47 localhost.localdomain tarantoolctl[5969]: "
"/usr/bin/tarantoolctl: Starting instance...\n"
"Jan 21 21:17:47 localhost.localdomain systemd[1]: Started Tarantool "
"Database Server"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:138
msgid ""
"For more details, use the reports provided by functions in the following "
"submodules:"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:140
msgid ""
":ref:`box.cfg <box_introspection-box_cfg>` submodule (check and specify "
"all configuration parameters for the Tarantool server)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:143
msgid ""
":ref:`box.slab <box_introspection-box_slab>` submodule (monitor the total"
" use and fragmentation of memory allocated for storing data in Tarantool)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:146
msgid ""
":ref:`box.info <box_introspection-box_info>` submodule (introspect "
"Tarantool server variables, primarily those related to replication)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:149
msgid ""
":ref:`box.stat <box_introspection-box_stat>` submodule (introspect "
"Tarantool request and network statistics)"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:152
msgid ""
"You can also try `tarantool/prometheus "
"<https://github.com/tarantool/prometheus>`_, a Lua module that makes it "
"easy to collect metrics (e.g. memory usage or number of requests) from "
"Tarantool applications and databases and expose them via the Prometheus "
"protocol."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:157
#: ../doc/1.7/book/box/authentication.rst:246
#: ../doc/1.7/book/box/box_schema.rst:111
#: ../doc/1.7/book/box/box_session.rst:105
#: ../doc/1.7/book/box/box_session.rst:134
#: ../doc/1.7/book/box/box_session.rst:178
#: ../doc/1.7/book/box/box_session.rst:282 ../doc/1.7/book/box/triggers.rst:100
msgid "**Example**"
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:159
msgid ""
"A very popular administrator request is :ref:`box.slab.info() "
"<box_slab_info>`, which displays detailed memory usage statistics for a "
"Tarantool instance."
msgstr ""

#: ../doc/1.7/book/admin/server_introspection.rst:162
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:33
msgid "Starting/stopping an instance"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:35
msgid ""
"While a Lua application is executed by Tarantool, an instance file is "
"executed by ``tarantoolctl`` which is a Tarantool script."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:38
msgid "Here is what ``tarantoolctl`` does when you issue the command:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:40
msgid "$ tarantoolctl start <instance_name>"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:44
msgid ""
"Read and parse the command line arguments. The last argument, in our "
"case, contains an instance name."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:47
msgid ""
"Read and parse its own configuration file. This file contains "
"``tarantoolctl`` defaults, like the path to the directory where instances"
" should be searched for."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:51
msgid ""
"The default ``tarantoolctl`` configuration file is installed in "
"``/etc/default/tarantool``. This file is used when ``tarantoolctl`` is "
"invoked by root. When invoked by a local user, ``tarantoolctl`` first "
"looks for its defaults file in the current directory "
"(``$PWD/.tarantoolctl``), and then in the current user’s home directory "
"(``$HOME/.config/tarantool/tarantool``). If not found, ``tarantoolctl`` "
"falls back to :ref:`built-in defaults <admin-tarantoolctl_config_file>`."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:59
msgid ""
"Look up the instance file in the instance directory, e.g. "
"``/etc/tarantool/instances.enabled``. To build the instance file path, "
"``tarantoolctl`` takes the instance name, prepends the instance directory"
" and appends \".lua\" extension to the instance file."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:64
msgid ""
"Override :ref:`box.cfg{} <box_introspection-box_cfg>` function to pre-"
"process its parameters and ensure that instance paths are pointing to the"
" paths defined in the ``tarantoolctl`` configuration file. For example, "
"if the configuration file specifies that instance work directory must be "
"in ``/var/tarantool``, then the new implementation of ``box.cfg{}`` "
"ensures that :ref:`work_dir <cfg_basic-work_dir>` parameter in "
"``box.cfg{}`` is set to ``/var/tarantool/<instance_name>``, regardless of"
" what the path is set to in the instance file itself."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:73
msgid ""
"Create a so-called \"instance control file\". This is a Unix socket with "
"Lua console attached to it. This file is used later by ``tarantoolctl`` "
"to query the instance state, send commands to the instance and so on."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:77
msgid "Finally, use Lua ``dofile`` command to execute the instance file."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:79
msgid ""
"If you start an instance using ``systemd`` tools, like this (the instance"
" name is ``my_app``):"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:82
msgid ""
"$ systemctl start tarantool@my_app\n"
"$ ps axuf|grep exampl[e]\n"
"taranto+  5350  1.3  0.3 1448872 7736 ?        Ssl  20:05   0:28 "
"tarantool my_app.lua <running>"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:88
msgid ""
"... this actually calls ``tarantoolctl`` like in case of ``tarantoolctl "
"start my_app``."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:91
msgid ""
"To check the instance file for syntax errors prior to starting ``my_app``"
" instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:94
msgid "$ tarantoolctl check my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:98
msgid "To enable ``my_app`` instance for auto-load during system startup, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:100
msgid "$ systemctl enable tarantool@my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:104
msgid "To stop a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:106
msgid ""
"$ tarantoolctl stop my_app\n"
"$ # - OR -\n"
"$ systemctl stop tarantool@my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:112
msgid "To restart (i.e. stop and start) a running ``my_app`` instance, say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:114
msgid ""
"$ tarantoolctl restart my_app\n"
"$ # - OR -\n"
"$ systemctl restart tarantool@my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:124
msgid "Running Tarantool locally"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:126
msgid ""
"Sometimes you may need to run a Tarantool instance locally, e.g. for test"
" purposes. Let's configure a local instance, then start and monitor it "
"with ``tarantoolctl``."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:130
msgid "First, we create a sandbox directory on the user's path:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:132
msgid "$ mkdir ~/tarantool_test"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:136
msgid ""
"... and set default ``tarantoolctl`` configuration in "
"``$HOME/.config/tarantool/tarantool``. Let the file contents be:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:139
msgid ""
"default_cfg = {\n"
"    pid_file  = \"/home/user/tarantool_test/my_app.pid\",\n"
"    wal_dir   = \"/home/user/tarantool_test\",\n"
"    snap_dir  = \"/home/user/tarantool_test\",\n"
"    vinyl_dir = \"/home/user/tarantool_test\",\n"
"    log       = \"/home/user/tarantool_test/log\",\n"
"}\n"
"instance_dir = \"/home/user/tarantool_test\""
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:152
msgid "Specify a full path to the user's home directory instead of \"~/\"."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:154
msgid ""
"Omit ``username`` parameter. ``tarantoolctl`` normally doesn't have "
"permissions to switch current user when invoked by a local user. The "
"instance will be running under 'admin'."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:158
msgid ""
"Next, we create the instance file ``~/tarantool_test/my_app.lua``. Let "
"the file contents be:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:161
msgid ""
"box.cfg{listen = 3301}\n"
"box.schema.user.passwd('Gx5!')\n"
"box.schema.user.grant('guest','read,write,execute','universe')\n"
"fiber = require('fiber')\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary',{})\n"
"i = 0\n"
"while 0 == 0 do\n"
"    fiber.sleep(5)\n"
"    i = i + 1\n"
"    print('insert ' .. i)\n"
"    box.space.tester:insert{i, 'my_app tuple'}\n"
"end"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:177
msgid ""
"Let’s verify our instance file by starting it without ``tarantoolctl`` "
"first:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:179
msgid ""
"$ cd ~/tarantool_test\n"
"$ tarantool my_app.lua\n"
"2017-04-06 10:42:15.762 [54085] main/101/my_app.lua C> version "
"1.7.3-489-gd86e36d5b\n"
"2017-04-06 10:42:15.763 [54085] main/101/my_app.lua C> log level 5\n"
"2017-04-06 10:42:15.764 [54085] main/101/my_app.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-04-06 10:42:15.774 [54085] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-04-06 10:42:15.774 [54085] main/101/my_app.lua I> initializing an "
"empty data directory\n"
"2017-04-06 10:42:15.789 [54085] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-04-06 10:42:15.790 [54085] snapshot/101/main I> done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> vinyl checkpoint "
"done\n"
"2017-04-06 10:42:15.791 [54085] main/101/my_app.lua I> ready to accept "
"requests\n"
"insert 1\n"
"insert 2\n"
"insert 3\n"
"<...>"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:197
msgid "Now we tell ``tarantoolctl`` to start the Tarantool instance:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:199
msgid "$ tarantoolctl start my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:203
msgid "Expect to see messages indicating that the instance has started. Then:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:205
msgid "$ ls -l ~/tarantool_test/my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:209
msgid "Expect to see the .snap file and the .xlog file. Then:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:211
msgid "$ less ~/tarantool_test/log/my_app.log"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:215
msgid ""
"Expect to see the contents of ``my_app``‘s log, including error messages,"
" if any. Then:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:218
msgid ""
"$ tarantoolctl enter my_app\n"
"tarantool> box.cfg{}\n"
"tarantool> console = require('console')\n"
"tarantool> console.connect('localhost:3301')\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:226
msgid "Expect to see several tuples that ``my_app`` has created."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:228
msgid ""
"Stop now. A polite way to stop ``my_app`` is with ``tarantoolctl``, thus "
"we say:"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:230
msgid "$ tarantoolctl stop my_app"
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:234
msgid "Finally, we make a cleanup."
msgstr ""

#: ../doc/1.7/book/admin/start_stop_instance.rst:236
msgid "$ rm -R tarantool_test"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:33
msgid "Upgrades"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:39
msgid "Upgrading a Tarantool database"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:41
msgid ""
"If you created a database with an older Tarantool version and have now "
"installed a newer version, make the request ``box.schema.upgrade()``. "
"This updates Tarantool system spaces to match the currently installed "
"version of Tarantool."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:45
msgid ""
"For example, here is what happens when you run ``box.schema.upgrade()`` "
"with a database created with Tarantool version 1.6.4 to version 1.7.2 "
"(only a small part of the output is shown):"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:49
msgid ""
"tarantool> box.schema.upgrade()\n"
"alter index primary on _space set options to {\"unique\":true}, parts to "
"[[0,\"unsigned\"]]\n"
"alter space _schema set options to {}\n"
"create view _vindex...\n"
"grant read access to 'public' role for _vindex view\n"
"set schema version to 1.7.0\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:64
msgid "Upgrading a Tarantool instance"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:66
msgid ""
"Tarantool is backward compatible between two adjacent versions. For "
"example, you should have no or little trouble when upgrading from "
"Tarantool 1.6 to 1.7, or from Tarantool 1.7 to 1.8. Meanwhile Tarantool "
"1.8 may have incompatible changes when migrating from Tarantool 1.6. to "
"1.8 directly."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:73
msgid "How to upgrade from Tarantool 1.6 to 1.7"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:75
msgid ""
"This procedure is for upgrading a standalone Tarantool instance in "
"production from 1.6.x to 1.7.x. Notice that this will **always imply a "
"downtime**. To upgrade **without downtime**, you need several Tarantool "
"servers running in a replication cluster (see :ref:`below <admin-"
"upgrades_replication_cluster>`)."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:80
msgid ""
"Tarantool 1.7 has an incompatible .snap and .xlog file format: 1.6 files "
"are supported during upgrade, but you won’t be able to return to 1.6 "
"after running under 1.7 for a while. It also renames a few configuration "
"parameters, but old parameters are supported. The full list of breaking "
"changes is available in `release notes for Tarantool 1.7 "
"<https://github.com/tarantool/tarantool/releases>`_."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:86
msgid ""
"Check with application developers whether application files need to be "
"updated due to incompatible changes (see `1.7 release notes "
"<https://github.com/tarantool/tarantool/releases>`_). If yes, back up the"
" old application files."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:91
msgid "Stop the Tarantool server."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:93
msgid ""
"Make a copy of all data (see an appropriate hot backup procedure in "
":ref:`Backups <admin-backups>`) and the package from which the current "
"(old) version was installed (for rollback purposes)."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:97
msgid ""
"Update the Tarantool server. See installation instructions at Tarantool "
"`download page <http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:100
msgid ""
"Update the Tarantool database. Make the request ``box.schema.upgrade()``."
" This will create new system spaces, update data type names (e.g. num -> "
"unsigned, str -> string) and options in Tarantool system spaces."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:104
msgid "Update application files, if needed."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:106
msgid ""
"Launch the updated Tarantool server using ``tarantoolctl`` or "
"``systemctl``."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:112
msgid "Upgrading Tarantool in a replication cluster"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:114
msgid ""
"Tarantool 1.7 can work as a replica for Tarantool 1.6 and vice versa. "
"Replicas perform capability negotiation on handshake, and new 1.7 "
"replication features are not used with 1.6 replicas. This allows "
"upgrading clustered configurations."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:118
msgid ""
"This procedure allows for a rolling upgrade **without downtime** and "
"works for any cluster configuration: master-master or master-replica."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:121
msgid ""
"Upgrade Tarantool at all replicas (or at any master in a master-master "
"cluster). See details in :ref:`Upgrading a Tarantool instance <admin-"
"upgrades_instance>`."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:125
msgid "Verify installation on the replicas:"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:127
msgid "Start Tarantool."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:129
msgid "Attach to the master and start working as before."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:131
msgid ""
"The master runs the old Tarantool version, which is always compatible "
"with the next major version."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:134
msgid "Upgrade the master. The procedure is similar to upgrading a replica."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:136
msgid "Verify master installation:"
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:138
msgid "Start Tarantool with replica configuration to catch up."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:140
msgid "Switch to master mode."
msgstr ""

#: ../doc/1.7/book/admin/upgrades.rst:142
msgid ""
"Upgrade the database on any master node in the cluster. Make the request "
"``box.schema.upgrade()``. This updates Tarantool system spaces to match "
"the currently installed version of Tarantool. Changes are propagated to "
"other nodes via the regular replication mechanism."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:33
msgid "Contributing a module"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:35
msgid ""
"We have already discussed :ref:`how to create a simple module in Lua for "
"local usage <app_server-modules>`. Now let's discuss how to create a more"
" advanced Tarantool module and then get it published on `Tarantool rocks "
"page <http://tarantool.org/rocks.html>`_ and included in `official "
"Tarantool images <http://github.com/tarantool/docker>`_ for Docker."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:42
msgid ""
"To help our contributors, we have created `modulekit "
"<http://github.com/tarantool/modulekit>`_, a set of templates for "
"creating Tarantool modules in Lua and C."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:48
msgid ""
"As a prerequisite for using ``modulekit``, install ``tarantool-dev`` "
"package first. For example, in Ubuntu say:"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:51
msgid "$ sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:59
msgid "Contributing a module in Lua"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:61
msgid ""
"See `README in \"luakit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/luakit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:69
msgid "Contributing a module in C"
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:71
msgid ""
"In some cases, you may want to create a Tarantool module in C rather than"
" in Lua. For example, to work with specific hardware or low-level system "
"interfaces."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:74
msgid ""
"See `README in \"ckit\" branch of tarantool/modulekit repository "
"<http://github.com/tarantool/modulekit/blob/ckit/README.md>`_ for "
"detailed instructions and examples."
msgstr ""

#: ../doc/1.7/book/app_server/contributing_module.rst:80
msgid ""
"You can also create modules with C++, provided that the code does not "
"throw exceptions."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:33
msgid "Cookbook recipes"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:35
msgid ""
"Here are contributions of Lua programs for some frequent or tricky "
"situations."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:37
msgid ""
"You can execute any of these programs by copying the code into a ``.lua``"
" file, and then entering :samp:`chmod +x ./{program-name}.lua` and :samp"
":`./{program-name}.lua` on the terminal."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:41
msgid "The first line is a \"hashbang\":"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:43
msgid "#!/usr/bin/env tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:47
msgid ""
"This runs  Tarantool Lua application server, which should be on the "
"execution path."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:50
msgid "Use freely."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:56
msgid "hello_world.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:58
msgid "The standard example of a simple program."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:60
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"print('Hello, World!')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:70
msgid "console_start.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:72
msgid ""
"Use :ref:`box.once() <box-once>` to initialize a database (creating "
"spaces) if this is the first time the server has been run. Then use "
":ref:`console.start() <console-start>` to start interactive mode."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:76
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- Configure database\n"
"box.cfg {\n"
"    listen = 3313\n"
"}\n"
"\n"
"box.once(\"bootstrap\", function()\n"
"    box.schema.space.create('tweedledum')\n"
"    box.space.tweedledum:create_index('primary',\n"
"        { type = 'TREE', parts = {1, 'unsigned'}})\n"
"end)\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:97
msgid "fio_read.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:99
msgid "Use the :ref:`fio module <fio-module>` to open, read, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:101
#: ../doc/1.7/reference/reference_lua/errcodes.rst:137
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_RDONLY' })\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"local data = f:read(4096)\n"
"f:close()\n"
"print(data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:119
msgid "fio_write.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:121
msgid "Use the :ref:`fio module <fio-module>` to open, write, and close a file."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:123
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fio = require('fio')\n"
"local errno = require('errno')\n"
"local f = fio.open('/tmp/xxxx.txt', {'O_CREAT', 'O_WRONLY', 'O_APPEND'},\n"
"    tonumber('0666', 8))\n"
"if not f then\n"
"    error(\"Failed to open file: \"..errno.strerror())\n"
"end\n"
"f:write(\"Hello\\n\");\n"
"f:close()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:141
msgid "ffi_printf.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:143
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C built-in function: printf(). (For help understanding ffi, see the `FFI "
"tutorial <http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:146
#, python-format
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    int printf(const char *format, ...);\n"
"]]\n"
"\n"
"ffi.C.printf(\"Hello, %s\\n\", os.getenv(\"USER\"));"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:161
msgid "ffi_gettimeofday.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:163
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C function: gettimeofday(). This delivers time with millisecond "
"precision, unlike the time function in Tarantool's :ref:`clock module "
"<clock-module>`."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:167
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef[[\n"
"    typedef long time_t;\n"
"    typedef struct timeval {\n"
"    time_t tv_sec;\n"
"    time_t tv_usec;\n"
"} timeval;\n"
"    int gettimeofday(struct timeval *t, void *tzp);\n"
"]]\n"
"\n"
"local timeval_buf = ffi.new(\"timeval\")\n"
"local now = function()\n"
"    ffi.C.gettimeofday(timeval_buf, nil)\n"
"    return tonumber(timeval_buf.tv_sec * 1000 + (timeval_buf.tv_usec / "
"1000))\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:191
msgid "ffi_zlib.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:193
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to call a "
"C library function. (For help understanding ffi, see the `FFI tutorial "
"<http://luajit.org/ext_ffi_tutorial.html>`_.)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:196
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"    unsigned long compressBound(unsigned long sourceLen);\n"
"    int compress2(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen, int level);\n"
"    int uncompress(uint8_t *dest, unsigned long *destLen,\n"
"    const uint8_t *source, unsigned long sourceLen);\n"
"]]\n"
"local zlib = ffi.load(ffi.os == \"Windows\" and \"zlib1\" or \"z\")\n"
"\n"
"-- Lua wrapper for compress2()\n"
"local function compress(txt)\n"
"    local n = zlib.compressBound(#txt)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.compress2(buf, buflen, txt, #txt, 9)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Lua wrapper for uncompress\n"
"local function uncompress(comp, n)\n"
"    local buf = ffi.new(\"uint8_t[?]\", n)\n"
"    local buflen = ffi.new(\"unsigned long[1]\", n)\n"
"    local res = zlib.uncompress(buf, buflen, comp, #comp)\n"
"    assert(res == 0)\n"
"    return ffi.string(buf, buflen[0])\n"
"end\n"
"\n"
"-- Simple test code.\n"
"local txt = string.rep(\"abcd\", 1000)\n"
"print(\"Uncompressed size: \", #txt)\n"
"local c = compress(txt)\n"
"print(\"Compressed size: \", #c)\n"
"local txt2 = uncompress(c, #txt)\n"
"assert(txt2 == txt)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:241
msgid "ffi_meta.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:243
msgid ""
"Use the `LuaJIT ffi library <http://luajit.org/ext_ffi.html>`_ to access "
"a C object via a metamethod (a method which is defined with a metatable)."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:247
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local ffi = require(\"ffi\")\n"
"ffi.cdef[[\n"
"typedef struct { double x, y; } point_t;\n"
"]]\n"
"\n"
"local point\n"
"local mt = {\n"
"  __add = function(a, b) return point(a.x+b.x, a.y+b.y) end,\n"
"  __len = function(a) return math.sqrt(a.x*a.x + a.y*a.y) end,\n"
"  __index = {\n"
"    area = function(a) return a.x*a.x + a.y*a.y end,\n"
"  },\n"
"}\n"
"point = ffi.metatype(\"point_t\", mt)\n"
"\n"
"local a = point(3, 4)\n"
"print(a.x, a.y)  --> 3  4\n"
"print(#a)        --> 5\n"
"print(a:area())  --> 25\n"
"local b = a + point(0.5, 8)\n"
"print(#b)        --> 12.5"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:277
msgid "print_arrays.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:279
msgid ""
"Create Lua tables, and print them. Notice that for the 'array' table the "
"iterator function is ipairs(), while for the 'map' table the iterator "
"function is pairs(). (`ipairs()` is faster than `pairs()`, but pairs() is"
" recommended for map-like tables or mixed tables.) The display will look "
"like: \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana | k3 v3 | k1 v1 | k2"
" v2\"."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:287
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"for k, v in ipairs(array) do print(k, v) end\n"
"\n"
"map = { k1 = 'v1', k2 = 'v2', k3 = 'v3' }\n"
"for k, v in pairs(map) do print(k, v) end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:301
msgid "count_array.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:303
msgid ""
"Use the '#' operator to get the number of items in an array-like Lua "
"table. This operation has O(log(N)) complexity."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:306
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"array = { 1, 2, 3}\n"
"print(#array)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:317
msgid "count_array_with_nils.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:319
msgid ""
"Missing elements in arrays, which Lua treats a \"nil\"s, cause the simple"
" \"#\" operator to deliver improper results. The \"print(#t)\" "
"instruction will print \"4\"; the \"print(counter)\" instruction will "
"print \"3\"; the \"print(max)\" instruction will print \"10\". Other "
"table functions, such as table.sort(), will also misbehave when \"nils\" "
"are present."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:327
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local t = {}\n"
"t[1] = 1\n"
"t[4] = 4\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:347
msgid "count_array_with_nulls.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:349
msgid ""
"Use explicit ``NULL`` values to avoid the problems caused by Lua's nil =="
" missing value behavior. Although :code:`json.NULL == nil` is "
":code:`true`, all the print instructions in this program will print the "
"correct value: 10."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:354
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local json = require('json')\n"
"local t = {}\n"
"t[1] = 1; t[2] = json.NULL; t[3]= json.NULL;\n"
"t[4] = 4; t[5] = json.NULL; t[6]= json.NULL;\n"
"t[6] = 4; t[7] = json.NULL; t[8]= json.NULL;\n"
"t[9] = json.NULL\n"
"t[10] = 10\n"
"print(#t)\n"
"local counter = 0\n"
"for k,v in pairs(t) do counter = counter + 1 end\n"
"print(counter)\n"
"local max = 0\n"
"for k,v in pairs(t) do if k > max then max = k end end\n"
"print(max)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:377
msgid "count_map.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:379
msgid "Get the number of elements in a map-like table."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:381
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local map = { a = 10, b = 15, c = 20 }\n"
"local size = 0\n"
"for _ in pairs(map) do size = size + 1; end\n"
"print(size)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:394
msgid "swap.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:396
msgid ""
"Use a Lua peculiarity to swap two variables without needing a third "
"variable."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:398
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local x = 1\n"
"local y = 2\n"
"x, y = y, x\n"
"print(x, y)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:411
msgid "class.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:413
msgid ""
"Create a class, create a metatable for the class, create an instance of "
"the class. Another illustration is at `http://lua-"
"users.org/wiki/LuaClassesWithMetatable <http://lua-"
"users.org/wiki/LuaClassesWithMetatable>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:417
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"-- define class objects\n"
"local myclass_somemethod = function(self)\n"
"    print('test 1', self.data)\n"
"end\n"
"\n"
"local myclass_someothermethod = function(self)\n"
"    print('test 2', self.data)\n"
"end\n"
"\n"
"local myclass_tostring = function(self)\n"
"    return 'MyClass <'..self.data..'>'\n"
"end\n"
"\n"
"local myclass_mt = {\n"
"    __tostring = myclass_tostring;\n"
"    __index = {\n"
"        somemethod = myclass_somemethod;\n"
"        someothermethod = myclass_someothermethod;\n"
"    }\n"
"}\n"
"\n"
"-- create a new object of myclass\n"
"local object = setmetatable({ data = 'data'}, myclass_mt)\n"
"print(object:somemethod())\n"
"print(object.data)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:451
msgid "garbage.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:453
msgid ""
"Force Lua `garbage collection "
"<https://www.lua.org/manual/5.1/manual.html#2.10>`_ with the "
"`collectgarbage function <https://www.lua.org/manual/5.1/manual.html#pdf-"
"collectgarbage>`_."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:456
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"collectgarbage('collect')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:466
msgid "fiber_producer_and_consumer.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:468
msgid ""
"Start one fiber for producer and one fiber for consumer. Use "
":ref:`fiber.channel() <fiber_ipc-channel>` to exchange data and "
"synchronize. One can tweak the channel size (:code:`ch_size` in the "
"program code) to control the number of simultaneous tasks waiting for "
"processing."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:473
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local fiber = require('fiber')\n"
"local function consumer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = ch:get()\n"
"        if data == nil then\n"
"            break\n"
"        end\n"
"        print('consumed', i, data)\n"
"        fiber.sleep(math.random()) -- simulate some work\n"
"    end\n"
"end\n"
"\n"
"local function producer_loop(ch, i)\n"
"    -- initialize consumer synchronously or raise an error()\n"
"    fiber.sleep(0) -- allow fiber.create() to continue\n"
"    while true do\n"
"        local data = math.random()\n"
"        ch:put(data)\n"
"        print('produced', i, data)\n"
"    end\n"
"end\n"
"\n"
"local function start()\n"
"    local consumer_n = 5\n"
"    local producer_n = 3\n"
"\n"
"    -- Create a channel\n"
"    local ch_size = math.max(consumer_n, producer_n)\n"
"    local ch = fiber.channel(ch_size)\n"
"\n"
"    -- Start consumers\n"
"    for i=1, consumer_n,1 do\n"
"        fiber.create(consumer_loop, ch, i)\n"
"    end\n"
"\n"
"    -- Start producers\n"
"    for i=1, producer_n,1 do\n"
"        fiber.create(producer_loop, ch, i)\n"
"    end\n"
"end\n"
"\n"
"start()\n"
"print('started')"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:527
msgid "socket_tcpconnect.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:529
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to connect to a "
"remote host via TCP. Display the connection details and the result of a "
"GET request."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:533
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').tcp_connect('google.com', 80)\n"
"print(s:peer().host)\n"
"print(s:peer().family)\n"
"print(s:peer().type)\n"
"print(s:peer().protocol)\n"
"print(s:peer().port)\n"
"print(s:write(\"GET / HTTP/1.0\\r\\n\\r\\n\"))\n"
"print(s:read('\\r\\n'))\n"
"print(s:read('\\r\\n'))"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:551
msgid "socket_tcp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:553
msgid ""
"Use :ref:`socket.tcp_connect() <socket-tcp_connect>` to set up a simple "
"TCP server, by creating a function that handles requests and echos them, "
"and passing the function to :ref:`socket.tcp_server() <socket-"
"tcp_server>`. This program has been used to test with 100,000 clients, "
"with each client getting a separate fiber."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:561
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(s, peer)\n"
"    s:write(\"Welcome to test server, \" .. peer.host ..\"\\n\")\n"
"    while true do\n"
"        local line = s:read('\\n')\n"
"        if line == nil then\n"
"            break -- error or eof\n"
"        end\n"
"        if not s:write(\"pong: \"..line) then\n"
"            break -- error or eof\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local server, addr = require('socket').tcp_server('localhost', 3311, "
"handler)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:584
msgid "getaddrinfo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:586
msgid ""
"Use :ref:`socket.getaddrinfo() <socket-getaddrinfo>` to perform non-"
"blocking DNS resolution, getting both the AF_INET6 and AF_INET "
"information for 'google.com'. This technique is not always necessary for "
"tcp connections because :ref:`socket.tcp_connect() <socket-tcp_connect>` "
"performs `socket.getaddrinfo` under the hood, before trying to connect to"
" the first available address."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:594
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local s = require('socket').getaddrinfo('google.com', 'http', { type = "
"'SOCK_STREAM' })\n"
"print('host=',s[1].host)\n"
"print('family=',s[1].family)\n"
"print('type=',s[1].type)\n"
"print('protocol=',s[1].protocol)\n"
"print('port=',s[1].port)\n"
"print('host=',s[2].host)\n"
"print('family=',s[2].family)\n"
"print('type=',s[2].type)\n"
"print('protocol=',s[2].protocol)\n"
"print('port=',s[2].port)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:614
msgid "socket_udp_echo.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:616
msgid ""
"Tarantool does not currently have a `udp_server` function, therefore "
"socket_udp_echo.lua is more complicated than socket_tcp_echo.lua. It can "
"be implemented with sockets and fibers."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:621
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local socket = require('socket')\n"
"local errno = require('errno')\n"
"local fiber = require('fiber')\n"
"\n"
"local function udp_server_loop(s, handler)\n"
"    fiber.name(\"udp_server\")\n"
"    while true do\n"
"        -- try to read a datagram first\n"
"        local msg, peer = s:recvfrom()\n"
"        if msg == \"\" then\n"
"            -- socket was closed via s:close()\n"
"            break\n"
"        elseif msg ~= nil then\n"
"            -- got a new datagram\n"
"            handler(s, peer, msg)\n"
"        else\n"
"            if s:errno() == errno.EAGAIN or s:errno() == errno.EINTR then"
"\n"
"                -- socket is not ready\n"
"                s:readable() -- yield, epoll will wake us when new data "
"arrives\n"
"            else\n"
"                -- socket error\n"
"                local msg = s:error()\n"
"                s:close() -- save resources and don't wait GC\n"
"                error(\"Socket error: \" .. msg)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function udp_server(host, port, handler)\n"
"    local s = socket('AF_INET', 'SOCK_DGRAM', 0)\n"
"    if not s then\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"    if not s:bind(host, port) then\n"
"        local e = s:errno() -- save errno\n"
"        s:close()\n"
"        errno(e) -- restore errno\n"
"        return nil -- check errno:strerror()\n"
"    end\n"
"\n"
"    fiber.create(udp_server_loop, s, handler) -- start a new background "
"fiber\n"
"    return s\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:670
msgid ""
"A function for a client that connects to this server could look something"
" like this ..."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:673
msgid ""
"local function handler(s, peer, msg)\n"
"    -- You don't have to wait until socket is ready to send UDP\n"
"    -- s:writable()\n"
"    s:sendto(peer.host, peer.port, \"Pong: \" .. msg)\n"
"end\n"
"\n"
"local server = udp_server('127.0.0.1', 3548, handler)\n"
"if not server then\n"
"    error('Failed to bind: ' .. errno.strerror())\n"
"end\n"
"\n"
"print('Started')\n"
"\n"
"require('console').start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:694
msgid "http_get.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:696
msgid "Use the :ref:`http module <http-module>` to get data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:699
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local r = "
"http_client.get('http://api.openweathermap.org/data/2.5/weather?q=Oakland,us')"
"\n"
"if r.status ~= 200 then\n"
"    print('Failed to get weather forecast ', r.reason)\n"
"    return\n"
"end\n"
"local data = json.decode(r.body)\n"
"print('Oakland wind speed: ', data.wind.speed)"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:717
msgid "http_send.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:719
msgid "Use the :ref:`http module <http-module>` to send data via HTTP."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:722
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local http_client = require('http.client')\n"
"local json = require('json')\n"
"local data = json.encode({ Key = 'Value'})\n"
"local headers = { Token = 'xxxx', ['X-Secret-Value'] = 42 }\n"
"local r = http_client.post('http://localhost:8081', data, { headers = "
"headers})\n"
"if r.status == 200 then\n"
"    print 'Success'\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:739
msgid "http_server.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:741
msgid ""
"Use the `http`_ `rock`_ (which must first be installed) to turn Tarantool"
" into a web server."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:744
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"    return self:render{ json = { ['Your-IP-Is'] = self.peer.host } }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- listen *:8080\n"
"server:route({ path = '/' }, handler)\n"
"server:start()\n"
"-- connect to localhost:8080 and see json"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:761
msgid "http_generate_html.lua"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:763
msgid ""
"Use the `http`_ `rock` (which must first be installed) to generate HTML "
"pages from templates. The `http`_ `rock`_ has a fairly simple template "
"engine which allows execution of regular Lua code inside text blocks "
"(like PHP). Therefore there is no need to learn new languages in order to"
" write templates."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:769
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local function handler(self)\n"
"local fruits = { 'Apple', 'Orange', 'Grapefruit', 'Banana'}\n"
"    return self:render{ fruits = fruits }\n"
"end\n"
"\n"
"local server = require('http.server').new(nil, 8080) -- nil means '*'\n"
"server:route({ path = '/', file = 'index.html.lua' }, handler)\n"
"server:start()"
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:782
msgid ""
"An \"HTML\" file for this server, including Lua, could look like this (it"
" would produce \"1 Apple | 2 Orange | 3 Grapefruit | 4 Banana\")."
msgstr ""

#: ../doc/1.7/book/app_server/cookbook.rst:785
#, python-format
msgid ""
"<html>\n"
"<body>\n"
"    <table border=\"1\">\n"
"        % for i,v in pairs(fruits) do\n"
"        <tr>\n"
"            <td><%= i %></td>\n"
"            <td><%= v %></td>\n"
"        </tr>\n"
"        % end\n"
"    </table>\n"
"</body>\n"
"</html>"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:33
msgid "Creating an application"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:35
msgid ""
"Further we walk you through key programming practices that will give you "
"a good start in writing Lua applications for Tarantool. For an adventure,"
" this is a story of implementing... a real microservice based on "
"Tarantool! We implement a backend for a simplified version of `Pokémon Go"
" <https://en.wikipedia.org/wiki/Pokémon_Go>`_, a location-based augmented"
" reality game released in mid-2016. In this game, players use a mobile "
"device's GPS capability to locate, capture, battle and train virtual "
"monsters called \"pokémon\", who appear on the screen as if they were in "
"the same real-world location as the player."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:45
msgid ""
"To stay within the walk-through format, let's narrow the original "
"gameplay as follows. We have a map with pokémon spawn locations. Next, we"
" have multiple players who can send catch-a-pokémon requests to the "
"server (which runs our Tarantool microservice). The server replies "
"whether the pokémon is caught or not, increases the player's pokémon "
"counter if yes, and triggers the respawn-a-pokémon method that spawns a "
"new pokémon at the same location in a while."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:53
msgid ""
"We leave client-side applications outside the scope of this story. Yet we"
" promise a mini-demo in the end to simulate real users and give us some "
"fun. :-)"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:59
msgid "First, what would be the best way to deliver our microservice?"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:65
msgid "Modules, rocks and applications"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:67
msgid ""
"To make our game logic available to other developers and Lua "
"applications, let's put it into a Lua module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:70
msgid ""
"A **module** (called \"rock\" in Lua) is an optional library which "
"enhances Tarantool functionality. So, we can install our logic as a "
"module in Tarantool and use it from any Tarantool application or module. "
"Like applications, modules in Tarantool can be written in Lua (rocks), C "
"or C++."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:75
msgid "Modules are good for two things:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:77
msgid "easier **code management** (reuse, packaging, versioning), and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:78
msgid "hot **code reload** without restarting the Tarantool instance."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:80
msgid ""
"Technically, a module is a file with source code that exports its "
"functions in an API. For example, here is a Lua module named "
"``mymodule.lua`` that exports one function named ``myfun``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:84
msgid ""
"local exports = {}\n"
"exports.myfun = function(input_string)\n"
"   print('Hello', input_string)\n"
"end\n"
"return exports"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:92
msgid ""
"To launch the function ``myfun()`` -- from another module, from a Lua "
"application, or from Tarantool itself, -- we need to save this module as "
"a file, then load this module with the ``require()`` directive and call "
"the exported function."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:96
msgid ""
"For example, here's a Lua application that uses ``myfun()`` function from"
" ``mymodule.lua`` module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:99
msgid ""
"-- loading the module\n"
"local mymodule = require('mymodule')\n"
"\n"
"-- calling myfun() from within test() function\n"
"local test = function()\n"
"  mymodule.myfun()\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:109
msgid ""
"A thing to remember here is that the ``require()`` directive takes load "
"paths to Lua modules from the ``package.path`` variable. This is a "
"semicolon-separated string, where a question mark is used to interpolate "
"the module name. By default, this variable contains system-wide Lua paths"
" and the working directory. But if we put our modules inside a specific "
"folder (e.g. ``scripts/``), we need to add this folder to "
"``package.path`` before any calls to ``require()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:116
msgid "package.path = 'scripts/?.lua;' .. package.path"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:120
msgid ""
"For our microservice, a simple and convenient solution would be to put "
"all methods in a Lua module (say ``pokemon.lua``) and to write a Lua "
"application (say ``game.lua``) that initializes the gaming environment "
"and starts the game loop."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:128
msgid ""
"Now let's get down to implementation details. In our game, we need three "
"entities:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:130
msgid ""
"**map**, which is an array of pokémons with coordinates of respawn "
"locations; in this version of the game, let a location be a rectangle "
"identified with two points, upper-left and lower-right;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:133
msgid ""
"**player**, which has an ID, a name, and coordinates of the player's "
"location point;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:135
msgid ""
"**pokémon**, which has the same fields as the player, plus a status "
"(active/inactive, that is present on the map or not) and a catch "
"probability (well, let's give our pokémons a chance to escape :-) )"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:139
msgid ""
"We'll store these entities as tuples in Tarantool spaces. But to deliver "
"our backend application as a microservice, the good practice would be to "
"send/receive our data in the universal JSON format, thus using Tarantool "
"as a document storage."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:147
msgid "Avro schemas"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:149
msgid ""
"To store JSON data as tuples, we will apply a savvy practice which "
"reduces data footprint and ensures all stored documents are valid. We "
"will use Tarantool module `avro-schema <https://github.com/tarantool"
"/avro-schema>`_ which checks the schema of a JSON document and converts "
"it to a Tarantool tuple. The tuple will contain only field values, and "
"thus take a lot less space than the original document. In avro-schema "
"terms, converting JSON documents to tuples is \"flattening\", and "
"restoring the original documents is \"unflattening\". The usage is quite "
"straightforward:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:158
msgid ""
"For each entity, we need to define a schema in `Apache Avro schema "
"<https://en.wikipedia.org/wiki/Apache_Avro>`_ syntax, where we list the "
"entity's fields with their names and :ref:`Lua types <index-box_data-"
"types>`."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:162
msgid ""
"At initialization, we call ``avro-schema.create()`` that creates objects "
"in memory for all schema entities, and ``compile()`` that generates "
"flatten/unflatten methods for each entity."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:165
msgid ""
"Further on, we just call flatten/unflatten methods for a respective "
"entity on receiving/sending the entity's data."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:168
msgid ""
"Here's what our schema definitions for the player and pokémon entities "
"look like:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:170
msgid ""
"local schema = {\n"
"    player = {\n"
"        type=\"record\",\n"
"        name=\"player_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"player_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    },\n"
"    pokemon = {\n"
"        type=\"record\",\n"
"        name=\"pokemon_schema\",\n"
"        fields={\n"
"            {name=\"id\", type=\"long\"},\n"
"            {name=\"status\", type=\"string\"},\n"
"            {name=\"name\", type=\"string\"},\n"
"            {name=\"chance\", type=\"double\"},\n"
"            {\n"
"                name=\"location\",\n"
"                type= {\n"
"                    type=\"record\",\n"
"                    name=\"pokemon_location\",\n"
"                    fields={\n"
"                        {name=\"x\", type=\"double\"},\n"
"                        {name=\"y\", type=\"double\"}\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:215
msgid "And here's how we create and compile our entities at initialization:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:217
msgid ""
"-- load avro-schema module with require()\n"
"local avro = require('avro_schema')\n"
"\n"
"-- create models\n"
"local ok_m, pokemon = avro.create(schema.pokemon)\n"
"local ok_p, player = avro.create(schema.player)\n"
"if ok_m and ok_p then\n"
"    -- compile models\n"
"    local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"    local ok_cp, compiled_player = avro.compile(player)\n"
"    if ok_cm and ok_cp then\n"
"        -- start the game\n"
"        <...>\n"
"    else\n"
"        log.error('Schema compilation failed')\n"
"    end\n"
"else\n"
"    log.info('Schema creation failed')\n"
"end\n"
"return false"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:240
msgid ""
"As for the map entity, it would be an overkill to introduce a schema for "
"it, because we have only one map in the game, it has very few fields, and"
" -- which is most important -- we use the map only inside our logic, "
"never exposing it to external users."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:248
msgid ""
"Next, we need methods to implement the game logic. To simulate object-"
"oriented programming in our Lua code, let's store all Lua functions and "
"shared variables in a single local variable (let's name it as ``game``). "
"This will allow us to address functions or variables from within our "
"module as ``self.func_name`` or ``self.var_name``. Like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:254
msgid ""
"local game = {\n"
"    -- a local variable\n"
"    num_players = 0,\n"
"\n"
"    -- a method that prints a local variable\n"
"    hello = function(self)\n"
"      print('Hello! Your player number is ' .. self.num_players .. '.')\n"
"    end,\n"
"\n"
"    -- a method that calls another method and returns a local variable\n"
"    sign_in = function(self)\n"
"      self.num_players = self.num_players + 1\n"
"      self:hello()\n"
"      return self.num_players\n"
"    end\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:273
msgid ""
"In OOP terms, we can now regard local variables inside ``game`` as object"
" fields, and local functions as object methods."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:278
msgid ""
"In this manual, Lua examples use **local** variables. Use **global** "
"variables with caution, since the module’s users may be unaware of them."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:281
msgid ""
"To enable/disable the use of undeclared global variables in your Lua "
"code, use Tarantool's :ref:`strict <strict-module>` module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:284
msgid "So, our game module will have the following methods:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:286
msgid ""
"``catch()`` to calculate whether the pokémon was caught (besides the "
"coordinates of both the player and pokémon, this method will apply a "
"probability factor, so not every pokémon within the player's reach will "
"be caught);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:290
msgid ""
"``respawn()`` to add missing pokémons to the map, say, every 60 seconds "
"(we assume that a frightened pokémon runs away, so we remove a pokémon "
"from the map on any catch attempt and add it back to the map in a while);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:293
msgid ""
"``notify()`` to log information about caught pokémons (like \"Player 1 "
"caught pokémon A\");"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:295
msgid ""
"``start()`` to initialize the game (it will create database spaces, "
"create and compile avro schemas, and launch ``respawn()``)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:298
msgid ""
"Besides, it would be convenient to have methods for working with "
"Tarantool storage. For example:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:301
msgid "``add_pokemon()`` to add a pokémon to the database, and"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:302
msgid "``map()`` to populate the map with all pokémons stored in Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:304
msgid ""
"We'll need these two methods primarily when initializing our game, but we"
" can also call them later, for example to test our code."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:311
msgid "Bootstrapping a database"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:313
msgid ""
"Let's discuss game initialization. In ``start()`` method, we need to "
"populate Tarantool spaces with pokémon data. Why not keep all game data "
"in memory? Why use a database? The answer is: :ref:`persistence <index-"
"box_persistence>`. Without a database, we risk losing data on power "
"outage, for example. But if we store our data in an in-memory database, "
"Tarantool takes care to persist it on disk whenever it's changed. This "
"gives us one more benefit: quick startup in case of failure. Tarantool "
"has a :ref:`smart algorithm <internals-recovery_process>` that quickly "
"loads all data from disk into memory on startup, so the warm-up takes "
"little time."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:323
msgid ""
"We'll be using functions from Tarantool built-in :ref:`box <box-module>` "
"module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:325
msgid ""
"``box.schema.create_space('pokemons')`` to create a space named "
"``pokemon`` for storing information about pokémons (we don't create a "
"similar space for players, because we intend to only send/receive player "
"information via API calls, so we needn't store it);"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:329
msgid ""
"``box.space.pokemons:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})`` to create a primary HASH index by pokémon ID;"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:331
msgid ""
"``box.space.pokemons:create_index('status', {type = 'tree', parts = {2, "
"'str'}})`` to create a secondary TREE index by pokémon status."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:334
msgid ""
"Notice the ``parts =`` argument in the index specification. The pokémon "
"ID is the first field in a Tarantool tuple since it’s the first member of"
" the respective Avro type. So does the pokémon status. The actual JSON "
"document may have ID or status fields at any position of the JSON map."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:339
msgid "The implementation of ``start()`` method looks like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:341
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"        box.schema.create_space('pokemons')\n"
"        box.space.pokemons:create_index(\n"
"            \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"        )\n"
"        box.space.pokemons:create_index(\n"
"            \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"        )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            <...>\n"
"        else\n"
"            log.error('Schema compilation failed')\n"
"        end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:379
msgid "GIS"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:381
msgid ""
"Now let's discuss ``catch()``, which is the main method in our gaming "
"logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:383
msgid ""
"Here we receive the player's coordinates and the target pokémon's ID "
"number, and we need to answer whether the player has actually caught the "
"pokémon or not (remember that each pokémon has a chance to escape)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:387
msgid ""
"First thing, we validate the received player data against its :ref:`Avro "
"schema <app_server-avro_schemas>`. And we check whether such a pokémon "
"exists in our database and is displayed on the map (the pokémon must have"
" the active status):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:392
msgid ""
"catch = function(self, pokemon_id, player)\n"
"    -- check player data\n"
"    local ok, tuple = self.player_model.flatten(player)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    -- get pokemon data\n"
"    local p_tuple = box.space.pokemons:get(pokemon_id)\n"
"    if p_tuple == nil then\n"
"        return false\n"
"    end\n"
"    local ok, pokemon = self.pokemon_model.unflatten(p_tuple)\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    if pokemon.status ~= self.state.ACTIVE then\n"
"        return false\n"
"    end\n"
"    -- more catch logic to follow\n"
"    <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:416
msgid "Next, we calculate the answer: caught or not."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:418
msgid ""
"To work with geographical coordinates, we use Tarantool `gis "
"<https://github.com/tarantool/gis>`_ module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:421
msgid ""
"To keep things simple, we don't load any specific map, assuming that we "
"deal with a world map. And we do not validate incoming coordinates, "
"assuming again that all received locations are within the planet Earth."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:425
msgid "We use two geo-specific variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:427
msgid ""
"``wgs84``, which stands for the latest revision of the World Geodetic "
"System standard, `WGS84 "
"<https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84>`_. Basically,"
" it comprises a standard coordinate system for the Earth and represents "
"the Earth as an ellipsoid."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:431
msgid ""
"``nationalmap``, which stands for the `US National Atlas Equal Area "
"<https://epsg.io/2163>`_. This is a projected coordinates system based on"
" WGS84. It gives us a zero base for location projection and allows "
"positioning our players and pokémons in meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:436
msgid ""
"Both these systems are listed in the EPSG Geodetic Parameter Registry, "
"where each system has a unique number. In our code, we assign these "
"listing numbers to respective variables:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:440
msgid ""
"wgs84 = 4326,\n"
"nationalmap = 2163,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:445
msgid ""
"For our game logic, we need one more variable, ``catch_distance``, which "
"defines how close a player must get to a pokémon before trying to catch "
"it. Let's set the distance to 100 meters."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:449
msgid "catch_distance = 100,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:453
msgid ""
"Now we're ready to calculate the answer. We need to project the current "
"location of both player (``p_pos``) and pokémon (``m_pos``) on the map, "
"check whether the player is close enough to the pokémon (using "
"``catch_distance``), and calculate whether the player has caught the "
"pokémon (here we generate some random value and let the pokémon escape if"
" the random value happens to be less than 100 minus pokémon's chance "
"value):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:460
msgid ""
"-- project locations\n"
"local m_pos = gis.Point(\n"
"    {pokemon.location.x, pokemon.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"local p_pos = gis.Point(\n"
"    {player.location.x, player.location.y}, self.wgs84\n"
"):transform(self.nationalmap)\n"
"\n"
"-- check catch distance condition\n"
"if p_pos:distance(m_pos) > self.catch_distance then\n"
"    return false\n"
"end\n"
"-- try to catch pokemon\n"
"local caught = math.random(100) >= 100 - pokemon.chance\n"
"if caught then\n"
"    -- update and notify on success\n"
"    box.space.pokemons:update(\n"
"        pokemon_id, {{'=', self.STATUS, self.state.CAUGHT}}\n"
"    )\n"
"    self:notify(player, pokemon)\n"
"end\n"
"return caught"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:489
msgid "Index iterators"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:491
msgid ""
"By our gameplay, all caught pokémons are returned back to the map. We do "
"this for all pokémons on the map every 60 seconds using ``respawn()`` "
"method. We iterate through pokémons by status using Tarantool index "
"iterator function :ref:`index:pairs <box_index-index_pairs>` and reset "
"the statuses of all \"caught\" pokémons back to \"active\" using "
"``box.space.pokemons:update()``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:497
msgid ""
"respawn = function(self)\n"
"    fiber.name('Respawn fiber')\n"
"    for _, tuple in box.space.pokemons.index.status:pairs(\n"
"           self.state.CAUGHT) do\n"
"        box.space.pokemons:update(\n"
"            tuple[self.ID],\n"
"            {{'=', self.STATUS, self.state.ACTIVE}}\n"
"        )\n"
"    end\n"
" end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:510
msgid "For readability, we introduce named fields:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:512
msgid "ID = 1, STATUS = 2,"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:515
msgid "The complete implementation of ``start()`` now looks like this:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:517
msgid ""
"-- create game object\n"
"start = function(self)\n"
"    -- create spaces and indexes\n"
"    box.once('init', function()\n"
"       box.schema.create_space('pokemons')\n"
"       box.space.pokemons:create_index(\n"
"           \"primary\", {type = 'hash', parts = {1, 'unsigned'}}\n"
"       )\n"
"       box.space.pokemons:create_index(\n"
"           \"status\", {type = \"tree\", parts = {2, 'str'}}\n"
"       )\n"
"    end)\n"
"\n"
"    -- create models\n"
"    local ok_m, pokemon = avro.create(schema.pokemon)\n"
"    local ok_p, player = avro.create(schema.player)\n"
"    if ok_m and ok_p then\n"
"        -- compile models\n"
"        local ok_cm, compiled_pokemon = avro.compile(pokemon)\n"
"        local ok_cp, compiled_player = avro.compile(player)\n"
"        if ok_cm and ok_cp then\n"
"            -- start the game\n"
"            self.pokemon_model = compiled_pokemon\n"
"            self.player_model = compiled_player\n"
"            self.respawn()\n"
"            log.info('Started')\n"
"            return true\n"
"         else\n"
"            log.error('Schema compilation failed')\n"
"         end\n"
"    else\n"
"        log.info('Schema creation failed')\n"
"    end\n"
"    return false\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:557
msgid "Fibers"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:559
msgid ""
"But wait! If we launch it as shown above -- ``self.respawn()`` -- the "
"function will be executed only once, just like all the other methods. But"
" we need to execute ``respawn()`` every 60 seconds. Creating a "
":ref:`fiber <fiber-module>` is the Tarantool way of making application "
"logic work in the background at all times."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:565
msgid ""
"A **fiber** is a lightweight **thread**. The key difference is that "
"threads use preemptive multitasking, while fibers use cooperative "
"multitasking. This gives fibers the following two advantages over "
"threads:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:569
msgid ""
"Better controllability. Threads often depend on the kernel's thread "
"scheduler to preempt a busy thread and resume another thread, so "
"preemption may occur unpredictably. Fibers yield themselves to run "
"another fiber while executing, so yields are controlled by application "
"logic."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:573
msgid ""
"Higher performance. Threads require more resources to preempt as they "
"need to address the system kernel. Fibers are lighter and faster as they "
"don't need to address the kernel to yield."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:577
msgid ""
"Yet fibers have some limitations as compared with threads, the main "
"limitation being no multi-core mode. All fibers in an application belong "
"to a single thread, so they all use the same CPU core as the parent "
"thread. Meanwhile, this limitation is not really serious for Tarantool "
"applications, because a typical bottleneck for Tarantool is the HDD, not "
"the CPU."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:583
msgid ""
"A fiber has all the features of a Lua `coroutine "
"<http://www.lua.org/pil/contents.html#9>`_ and all programming concepts "
"that apply for Lua coroutines will apply for fibers as well. However, "
"Tarantool has made some enhancements for fibers and has used fibers "
"internally. So, although use of coroutines is possible and supported, use"
" of fibers is recommended."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:590
msgid ""
"Well, performance or controllability are of little importance in our "
"case. We'll launch ``respawn()`` in a fiber to make it work in the "
"background all the time. To do so, we'll need to amend ``respawn()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:594
msgid ""
"respawn = function(self)\n"
"    -- let's give our fiber a name;\n"
"    -- this will produce neat output in fiber.info()\n"
"    fiber.name('Respawn fiber')\n"
"    while true do\n"
"        for _, tuple in box.space.pokemons.index.status:pairs(\n"
"                self.state.CAUGHT) do\n"
"            box.space.pokemons:update(\n"
"                tuple[self.ID],\n"
"                {{'=', self.STATUS, self.state.ACTIVE}}\n"
"            )\n"
"        end\n"
"        fiber.sleep(self.respawn_time)\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:612
msgid "and call it as a fiber in ``start()``:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:614
msgid ""
"start = function(self)\n"
"    -- create spaces and indexes\n"
"        <...>\n"
"    -- create models\n"
"        <...>\n"
"    -- compile models\n"
"        <...>\n"
"    -- start the game\n"
"       self.pokemon_model = compiled_pokemon\n"
"       self.player_model = compiled_player\n"
"       fiber.create(self.respawn, self)\n"
"       log.info('Started')\n"
"    -- errors if schema creation or compilation fails\n"
"       <...>\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:634
#: ../doc/1.7/reference/configuration/index.rst:263
msgid "Logging"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:636
msgid ""
"One more helpful function that we used in ``start()`` was ``log.infо()`` "
"from Tarantool :ref:`log <log-module>` module. We also need this function"
" in ``notify()`` to add a record to the log file on every successful "
"catch:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:640
#, python-format
msgid ""
"-- event notification\n"
"notify = function(self, player, pokemon)\n"
"    log.info(\"Player '%s' caught '%s'\", player.name, pokemon.name)\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:647
msgid ""
"We use default Tarantool :ref:`log settings <cfg_logging>`, so we'll see "
"the log output in console when we launch our application in script mode."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:653
msgid ""
"Great! We've discussed all programming practices used in our Lua module "
"(see `pokemon.lua "
"<https://github.com/Sulverus/pokemon/blob/master/src/pokemon.lua>`_)."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:656
msgid ""
"Now let's prepare the test environment. As planned, we write a Lua "
"application (see `game.lua "
"<https://github.com/Sulverus/pokemon/blob/master/game.lua>`_) to "
"initialize Tarantool's database module, initialize our game, call the "
"game loop and simulate a couple of player requests."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:661
msgid ""
"To launch our microservice, we put both ``pokemon.lua`` module and "
"``game.lua`` application in the current directory, install all external "
"modules, and launch the Tarantool instance running our ``game.lua`` "
"application (this example is for Ubuntu):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:666
msgid ""
"$ ls\n"
"game.lua  pokemon.lua\n"
"$ sudo apt-get install tarantool-gis\n"
"$ sudo apt-get install tarantool-avro-schema\n"
"$ tarantool game.lua"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:674
msgid ""
"Tarantool starts and initializes the database. Then Tarantool executes "
"the demo logic from ``game.lua``: adds a pokémon named Pikachu (its "
"chance to be caught is very high, 99.1), displays the current map (it "
"contains one active pokémon, Pikachu) and processes catch requests from "
"two players. Player1 is located just near the lonely Pikachu pokémon and "
"Player2 is located far away from it. As expected, the catch results in "
"this output are \"true\" for Player1 and \"false\" for Player2. Finally, "
"Tarantool displays the current map which is empty, because Pikachu is "
"caught and temporarily inactive:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:683
msgid ""
"$ tarantool game.lua\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> version "
"1.7.3-43-gf5fa1e1\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua C> log level 5\n"
"2017-01-09 20:19:24.605 [6282] main/101/game.lua I> mapping 1073741824 "
"bytes for tuple arena...\n"
"2017-01-09 20:19:24.609 [6282] main/101/game.lua I> initializing an empty"
" data directory\n"
"2017-01-09 20:19:24.634 [6282] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"2017-01-09 20:19:24.635 [6282] snapshot/101/main I> done\n"
"2017-01-09 20:19:24.641 [6282] main/101/game.lua I> ready to accept "
"requests\n"
"2017-01-09 20:19:24.786 [6282] main/101/game.lua I> Started\n"
"---\n"
"- {'id': 1, 'status': 'active', 'location': {'y': 2, 'x': 1}, 'name': "
"'Pikachu', 'chance': 99.1}\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main/101/game.lua I> Player 'Player1' "
"caught 'Pikachu'\n"
"true\n"
"false\n"
"--- []\n"
"...\n"
"\n"
"2017-01-09 20:19:24.789 [6282] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:708
msgid "nginx"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:710
msgid ""
"In the real life, this microservice would work over HTTP. Let's add "
"`nginx <https://nginx.org/en/>`_ web server to our environment and make a"
" similar demo. But how do we make Tarantool methods callable via REST "
"API? We use nginx with `Tarantool nginx upstream "
"<https://github.com/tarantool/nginx_upstream_module>`_ module and create "
"one more Lua script (`app.lua "
"<https://github.com/Sulverus/pokemon/blob/master/src/app.lua>`_) that "
"exports three of our game methods -- ``add_pokemon()``, ``map()`` and "
"``catch()`` -- as REST endpoints of the nginx upstream module:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:719
msgid ""
"local game = require('pokemon')\n"
"box.cfg{listen=3301}\n"
"game:start()\n"
"\n"
"-- add, map and catch functions exposed to REST API\n"
"function add(request, pokemon)\n"
"    return {\n"
"        result=game:add_pokemon(pokemon)\n"
"    }\n"
"end\n"
"\n"
"function map(request)\n"
"    return {\n"
"        map=game:map()\n"
"    }\n"
"end\n"
"\n"
"function catch(request, pid, player)\n"
"    local id = tonumber(pid)\n"
"    if id == nil then\n"
"        return {result=false}\n"
"    end\n"
"    return {\n"
"        result=game:catch(id, player)\n"
"    }\n"
"end"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:748
msgid ""
"An easy way to configure and launch nginx would be to create a Docker "
"container based on a `Docker image <https://hub.docker.com/r/tarantool"
"/tarantool-nginx/>`_ with nginx and the upstream module already installed"
" (see `http/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/http/Dockerfile>`_). We "
"take a standard `nginx.conf "
"<https://github.com/Sulverus/pokemon/blob/master/http/nginx.conf>`_, "
"where we define an upstream with our Tarantool backend running (this is "
"another Docker container, see details below):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:757
msgid ""
"upstream tnt {\n"
"      server pserver:3301 max_fails=1 fail_timeout=60s;\n"
"      keepalive 250000;\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:764
msgid ""
"and add some Tarantool-specific parameters (see descriptions in the "
"upstream module's `README "
"<https://github.com/tarantool/nginx_upstream_module#directives>`_ file):"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:768
msgid ""
"server {\n"
"  server_name tnt_test;\n"
"\n"
"  listen 80 default deferred reuseport so_keepalive=on backlog=65535;\n"
"\n"
"  location = / {\n"
"      root /usr/local/nginx/html;\n"
"  }\n"
"\n"
"  location /api {\n"
"    # answers check infinity timeout\n"
"    tnt_read_timeout 60m;\n"
"    if ( $request_method = GET ) {\n"
"       tnt_method \"map\";\n"
"    }\n"
"    tnt_http_rest_methods get;\n"
"    tnt_http_methods all;\n"
"    tnt_multireturn_skip_count 2;\n"
"    tnt_pure_result on;\n"
"    tnt_pass_http_request on parse_args;\n"
"    tnt_pass tnt;\n"
"  }\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:794
msgid ""
"Likewise, we put Tarantool server and all our game logic in a second "
"Docker container based on the `official Tarantool 1.7 image "
"<https://github.com/tarantool/docker>`_ (see `src/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/src/Dockerfile>`_) and "
"set the container's default command to ``tarantool app.lua``. This is the"
" backend."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:803
msgid "Non-blocking IO"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:805
msgid ""
"To test the REST API, we create a new script (`client.lua "
"<https://github.com/Sulverus/pokemon/blob/master/client/client.lua>`_), "
"which is similar to our ``game.lua`` application, but makes HTTP POST and"
" GET requests rather than calling Lua functions:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:810
#, python-format
msgid ""
"local http = require('curl').http()\n"
"local json = require('json')\n"
"local URI = os.getenv('SERVER_URI')\n"
"local fiber = require('fiber')\n"
"\n"
"local player1 = {\n"
"    name=\"Player1\",\n"
"    id=1,\n"
"    location = {\n"
"        x=1.0001,\n"
"        y=2.0003\n"
"    }\n"
"}\n"
"local player2 = {\n"
"    name=\"Player2\",\n"
"    id=2,\n"
"    location = {\n"
"        x=30.123,\n"
"        y=40.456\n"
"    }\n"
"}\n"
"\n"
"local pokemon = {\n"
"    name=\"Pikachu\",\n"
"    chance=99.1,\n"
"    id=1,\n"
"    status=\"active\",\n"
"    location = {\n"
"        x=1,\n"
"        y=2\n"
"    }\n"
"}\n"
"\n"
"function request(method, body, id)\n"
"    local resp = http:request(\n"
"        method, URI, body\n"
"    )\n"
"    if id ~= nil then\n"
"        print(string.format('Player %d result: %s',\n"
"            id, resp.body))\n"
"    else\n"
"        print(resp.body)\n"
"    end\n"
"end\n"
"\n"
"local players = {}\n"
"function catch(player)\n"
"    fiber.sleep(math.random(5))\n"
"    print('Catch pokemon by player ' .. tostring(player.id))\n"
"    request(\n"
"        'POST', '{\"method\": \"catch\",\n"
"        \"params\": [1, '..json.encode(player)..']}',\n"
"        tostring(player.id)\n"
"    )\n"
"    table.insert(players, player.id)\n"
"end\n"
"\n"
"print('Create pokemon')\n"
"request('POST', '{\"method\": \"add\",\n"
"    \"params\": ['..json.encode(pokemon)..']}')\n"
"request('GET', '')\n"
"\n"
"fiber.create(catch, player1)\n"
"fiber.create(catch, player2)\n"
"\n"
"-- wait for players\n"
"while #players ~= 2 do\n"
"    fiber.sleep(0.001)\n"
"end\n"
"\n"
"request('GET', '')\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:885
msgid ""
"When you run this script, you’ll notice that both players have equal "
"chances to make the first attempt at catching the pokémon. In a classical"
" Lua script, a networked call blocks the script until it’s finished, so "
"the first catch attempt can only be done by the player who entered the "
"game first. In Tarantool, both players play concurrently, since all "
"modules are integrated with Tarantool :ref:`cooperative multitasking "
"<atomic-cooperative_multitasking>` and use non-blocking I/O."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:893
msgid ""
"Indeed, when Player1 makes its first REST call, the script doesn’t block."
" The fiber running ``catch()`` function on behalf of Player1 issues a "
"non-blocking call to the operating system and yields control to the next "
"fiber, which happens to be the fiber of Player2. Player2’s fiber does the"
" same. When the network response is received, Player1's fiber is "
"activated by Tarantool cooperative scheduler, and resumes its work. All "
"Tarantool :ref:`modules <built_in_modules>` use non-blocking I/O and are "
"integrated with Tarantool cooperative scheduler. For module developers, "
"Tarantool provides an :ref:`API <index-c_api_reference>`."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:902
msgid ""
"For our HTTP test, we create a third container based on the `official "
"Tarantool 1.7 image <https://github.com/tarantool/docker>`_ (see "
"`client/Dockerfile "
"<https://github.com/Sulverus/pokemon/blob/master/client/Dockerfile>`_) "
"and set the container's default command to ``tarantool client.lua``."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:910
msgid ""
"To run this test locally, download our `pokemon "
"<https://github.com/Sulverus/pokemon>`_ project from GitHub and say:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:913
msgid ""
"$ docker-compose build\n"
"$ docker-compose up"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:918
msgid ""
"Docker Compose builds and runs all the three containers: ``pserver`` "
"(Tarantool backend), ``phttp`` (nginx) and ``pclient`` (demo client). You"
" can see log messages from all these containers in the console, pclient "
"saying that it made an HTTP request to create a pokémon, made two catch "
"requests, requested the map (empty since the pokémon is caught and "
"temporarily inactive) and exited:"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:924
msgid ""
"pclient_1  | Create pokemon\n"
"<...>\n"
"pclient_1  | {\"result\":true}\n"
"pclient_1  | "
"{\"map\":[{\"id\":1,\"status\":\"active\",\"location\":{\"y\":2,\"x\":1},\"name\":\"Pikachu\",\"chance\":99.100000}]}"
"\n"
"pclient_1  | Catch pokemon by player 2\n"
"pclient_1  | Catch pokemon by player 1\n"
"pclient_1  | Player 1 result: {\"result\":true}\n"
"pclient_1  | Player 2 result: {\"result\":false}\n"
"pclient_1  | {\"map\":[]}\n"
"pokemon_pclient_1 exited with code 0"
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:937
msgid ""
"Congratulations! Here's the end point of our walk-through. As further "
"reading, see more about :ref:`installing <app_server-installing_module>` "
"and :ref:`contributing <app_server-contributing_module>` a module."
msgstr ""

#: ../doc/1.7/book/app_server/creating_app.rst:941
msgid ""
"See also reference on :ref:`Tarantool modules <built_in_modules>` and "
":ref:`C API <index-c_api_reference>`, and don't miss our :ref:`Lua "
"cookbook recipes <cookbook>`."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:33
msgid "Application server"
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:35
msgid ""
"In this chapter, we introduce the basics of working with Tarantool as a "
"Lua application server."
msgstr ""

#: ../doc/1.7/book/app_server/index.rst:38 ../doc/1.7/book/box/index.rst:38
#: ../doc/1.7/book/getting_started/index.rst:38
msgid "This chapter contains the following sections:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:33
msgid "Installing a module"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:35
msgid ""
"Modules in Lua and C that come from Tarantool developers and community "
"contributors are available in the following locations:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:38
msgid "Tarantool LuaRocks repository, and"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:39
msgid "Tarantool deb/rpm repositories."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:43
msgid ""
"As a current limitation, neither of these locations is available for Mac "
"OS users."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:50
msgid "Installing a module from LuaRocks"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:52
msgid ""
"See `README in tarantool/rocks repository "
"<https://github.com/tarantool/rocks#installing-a-module-from-luarocks>`_ "
"for detailed instructions."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:60
msgid "Installing a module from deb/rpm"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:62
msgid "Follow these steps:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:64
msgid ""
"Install Tarantool as recommended on the `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:67
msgid ""
"Install the module you need. Look up the module's name on `Tarantool "
"rocks page <http://tarantool.org/rocks.html>`_ and put the prefix "
"\"tarantool-\" before the module name to avoid ambiguity:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:71
msgid ""
"# for Ubuntu/Debian:\n"
"$ sudo apt-get install tarantool-<module-name>\n"
"\n"
"# for RHEL/CentOS/Amazon:\n"
"$ sudo yum install tarantool-<module-name>"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:79
msgid ""
"For example, to install the module `shard "
"<http://github.com/tarantool/shard>`_ on Ubuntu, say:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:82
msgid "$ sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:86
msgid "Once these steps are complete, you can:"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:88
msgid "load any module with"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:90
msgid "tarantool> local-name = require('module-name')"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:94
msgid ""
"search locally for installed modules using ``package.path`` (Lua) or "
"``package.cpath`` (C):"
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:97
msgid ""
"tarantool> package.path\n"
"---\n"
"- ./?.lua;./?/init.lua; "
"/usr/local/share/tarantool/?.lua;/usr/local/share/\n"
"tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/ini"
"\n"
"t.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/"
"\n"
"usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua;\n"
"...\n"
"\n"
"tarantool> package.cpath\n"
"---\n"
"- ./?.so;/usr/local/lib/x86_64-linux-"
"gnu/tarantool/?.so;/usr/lib/x86_64-li\n"
"nux-"
"gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/local/lib/x86_64\n"
"-linux-gnu/lua/5.1/?.so;/usr/lib/x86_64-linux-"
"gnu/lua/5.1/?.so;/usr/local/\n"
"lib/lua/5.1/?.so;\n"
"..."
msgstr ""

#: ../doc/1.7/book/app_server/installing_module.rst:117
msgid ""
"Question-marks stand for the module name that was specified earlier when "
"saying ``require('module-name')``."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:33
msgid "Launching an application"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:35
msgid ""
"Using Tarantool as an application server, you can write your own "
"applications. Tarantool’s native language for writing applications is "
"`Lua <http://www.lua.org/about.html>`_, so a typical application would be"
" a file that contains your Lua script. But you can also write "
"applications in C or C++."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:43
msgid ""
"If you're new to Lua, we recommend going over the interactive Tarantool "
"tutorial before proceeding with this chapter. To launch the tutorial, say"
" ``tutorial()`` in Tarantool console:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:47
msgid ""
"tarantool> tutorial()\n"
"---\n"
"- |\n"
" Tutorial -- Screen #1 -- Hello, Moon\n"
" ====================================\n"
"\n"
" Welcome to the Tarantool tutorial.\n"
" It will introduce you to Tarantool’s Lua application server\n"
" and database server, which is what’s running what you’re seeing.\n"
" This is INTERACTIVE -- you’re expected to enter requests\n"
" based on the suggestions or examples in the screen’s text.\n"
" <...>"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:62
msgid ""
"Let's create and launch our first Lua application for Tarantool. Here's a"
" simplest Lua application, the good old \"Hello, world!\":"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:65
msgid ""
"#!/usr/bin/env tarantool\n"
"print('Hello, world!')"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:70
msgid "We save it in a file (let it be ``myapp.lua`` in the current directory)."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:72
msgid "Now let's discuss how we can launch our application with Tarantool."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:78
msgid "Launching in Docker"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:80
msgid ""
"If we run Tarantool in a :ref:`Docker container <getting_started-"
"using_docker>`, the following command will start Tarantool without any "
"application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:83
msgid ""
"# create a temporary container and run it in interactive mode\n"
"$ docker run --rm -t -i tarantool/tarantool"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:88
msgid "To run Tarantool with our application, we can say:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:90
msgid ""
"# create a temporary container and\n"
"# launch Tarantool with our application\n"
"$ docker run --rm -t -i \\\n"
"             -v `pwd`/myapp.lua:/opt/tarantool/myapp.lua \\\n"
"             -v /data/dir/on/host:/var/lib/tarantool \\\n"
"             tarantool/tarantool tarantool /opt/tarantool/myapp.lua"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:99
msgid "Here two resources on the host get mounted in the container:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:101
msgid "our application file (``\\`pwd\\`/myapp.lua``) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:102
msgid "Tarantool data directory (``/data/dir/on/host``)."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:104
msgid ""
"By convention, the directory for Tarantool application code inside a "
"container is ``/opt/tarantool``, and the directory for data is "
"``/var/lib/tarantool``."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:111
msgid "Launching a binary program"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:113
msgid ""
"If we run Tarantool from a :ref:`binary package <getting_started-"
"using_binary>` or from a :ref:`source build <building_from_source>`, we "
"can launch our application:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:117
msgid "in the script mode,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:118
msgid "as a server application, or"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:119
msgid "as a daemon service."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:121
msgid "The simplest way is to pass the filename to Tarantool at start:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:129
msgid "Tarantool starts, executes our script in the **script mode** and exits."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:131
msgid ""
"Now let’s turn this script into a **server application**. We use "
":ref:`box.cfg <box_introspection-box_cfg>` from Tarantool’s built-in Lua "
"module to:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:135
msgid ""
"launch the database (a database has a persistent on-disk state, which "
"needs to be restored after we start an application) and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:137
msgid "configure Tarantool as a server that accepts requests over a TCP port."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:139
msgid ""
"We also add some simple database logic, using :ref:`space.create() "
"<box_schema-space_create>` and :ref:`create_index() <box_space-"
"create_index>` to create a space with a primary index. We use the "
"function :ref:`box.once() <box-once>` to make sure that our logic will be"
" executed only once when the database is initialized for the first time, "
"so we don't try to create an existing space or index on each invocation "
"of the script:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:160
msgid "Now we launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:179
msgid ""
"This time, Tarantool executes our script and keeps working as a server, "
"accepting TCP requests on port 3301. We can see Tarantool in the current "
"session’s process list:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:189
msgid ""
"But the Tarantool instance will stop if we close the current terminal "
"window. To detach Tarantool and our application from the terminal window,"
" we can launch it in the **daemon mode**. To do so, we add some "
"parameters to ``box.cfg{}``:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:193
msgid ""
":ref:`background <cfg_basic-background>` = ``true`` that actually tells "
"Tarantool to work as a daemon service,"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:195
msgid ""
":ref:`log <cfg_logging-log>` = ``'dir-name'`` that tells the Tarantool "
"daemon where to store its log file (other log settings are available in "
"Tarantool :ref:`log <log-module>` module), and"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:198
msgid ""
":ref:`pid_file <cfg_basic-pid_file>` = ``'file-name'`` that tells the "
"Tarantool daemon where to store its pid file."
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:201
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:34
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:62
#: ../doc/1.7/reference/reference_lua/box_error.rst:66
#: ../doc/1.7/reference/reference_rock/dbms.rst:110
#: ../doc/1.7/reference/reference_rock/dbms.rst:463
msgid "For example:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:203
msgid ""
"box.cfg {\n"
"   listen = 3301\n"
"   background = true,\n"
"   log = '1.log',\n"
"   pid_file = '1.pid'\n"
"}"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:212
msgid "We launch our application in the same manner as before:"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:220
msgid ""
"Tarantool executes our script, gets detached from the current shell "
"session (you won't see it with ``ps | grep \"tarantool\"``) and continues"
" working in the background as a daemon attached to the global session "
"(with SID = 0):"
msgstr ""

#: ../doc/1.7/book/app_server/launching_app.rst:230
msgid ""
"Now that we have discussed how to create and launch a Lua application for"
" Tarantool, let's dive deeper into programming practices."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:33
msgid "Transaction control"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:35
msgid ""
"Transactions in Tarantool occur in **fibers** on a single **thread**. "
"That is why Tarantool has a guarantee of execution atomicity. That "
"requires emphasis."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:43
msgid "Threads, fibers and yields"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:45
msgid ""
"How does Tarantool process a basic operation? As an example, let's take "
"this query:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:47
msgid "tarantool> box.space.tester:update({3}, {{'=', 2, 'size'}, {'=', 3, 0}})"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:51
msgid "This is equivalent to an SQL statement like:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:53
msgid ""
"UPDATE tester SET \"field[2]\" = 'size', \"field[3]\" = 0 WHERE "
"\"field[[1]\" = 3"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:57
msgid "This query will be processed with three operating system **threads**:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:59
msgid ""
"If we issue the query on a remote client, then the **network thread** on "
"the server side receives the query, parses the statement and changes it "
"to a server executable message which has already been checked, and which "
"the server instance can understand without parsing everything again."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:64
msgid ""
"The network thread ships this message to the instance's **\"transaction "
"processor\" thread** using a lock-free message bus. Lua programs execute "
"directly in the transaction processor thread, and do not require parsing "
"and preparation."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:69
msgid ""
"The instance's transaction processor thread uses the primary-key index on"
" field[1] to find the location of the tuple. It determines that the tuple"
" can be updated (not much can go wrong when you're merely changing an "
"unindexed field value to something shorter)."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:74
msgid ""
"The transaction processor thread sends a message to the **write-ahead "
"logging (WAL) thread** to commit the transaction. When done, the WAL "
"thread replies with a COMMIT or ROLLBACK result, which is returned to the"
" client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:79
msgid ""
"Notice that there is only one transaction processor thread in Tarantool. "
"Some people are used to the idea that there can be multiple threads "
"operating on the database, with (say) thread #1 reading row #x, while "
"thread #2 writes row #y. With Tarantool, no such thing ever happens. Only"
" the transaction processor thread can access the database, and there is "
"only one transaction processor thread for each Tarantool instance."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:86
msgid ""
"Like any other Tarantool thread, the transaction processor thread can "
"handle many **fibers**. A fiber is a set of computer instructions that "
"may contain \"**yield**\" signals. The transaction processor thread will "
"execute all computer instructions until a yield, then switch to execute "
"the instructions of a different fiber. Thus (say) the thread reads row #x"
" for the sake of fiber #1, then writes row #y for the sake of fiber #2."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:93
msgid ""
"Yields must happen, otherwise the transaction processor thread would "
"stick permanently on the same fiber. There are two types of yields:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:96
msgid ""
":ref:`implicit yields <atomic-implicit-yields>`: every data-change "
"operation or network-access causes an implicit yield, and every statement"
" that goes through the Tarantool client causes an implicit yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:100
msgid ""
"explicit yields: in a Lua function, you can (and should) add “yield” "
"statements to prevent hogging. This is called **cooperative "
"multitasking**."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:107
msgid "Cooperative multitasking"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:109
msgid ""
"Cooperative multitasking means: unless a running fiber deliberately "
"yields control, it is not preempted by some other fiber. But a running "
"fiber will deliberately yield when it encounters a “yield point”: a "
"transaction commit, an operating system call, or an explicit ``yield()`` "
"request. Any system call which can block will be performed "
"asynchronously, and any running fiber which must wait for a system call "
"will be preempted, so that another ready-to-run fiber takes its place and"
" becomes the new running fiber."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:117
msgid ""
"This model makes all programmatic locks unnecessary: cooperative "
"multitasking ensures that there will be no concurrency around a resource,"
" no race conditions, and no memory consistency issues."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:121
msgid ""
"When requests are small, for example simple UPDATE or INSERT or DELETE or"
" SELECT, fiber scheduling is fair: it takes only a little time to process"
" the request, schedule a disk write, and yield to a fiber serving the "
"next client."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:125
msgid ""
"However, a function might perform complex computations or might be "
"written in such a way that yields do not occur for a long time. This can "
"lead to unfair scheduling, when a single client throttles the rest of the"
" system, or to apparent stalls in request processing. Avoiding this "
"situation is the responsibility of the function’s author."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:135
msgid "Transactions"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:137
msgid ""
"In the absence of transactions, any function that contains yield points "
"may see changes in the database state caused by fibers that preempt. "
"Multi-statement transactions exist to provide isolation: each transaction"
" sees a consistent database state and commits all its changes atomically."
" At commit time, a yield happens and all transaction changes are written "
"to the write ahead log in a single batch."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:144
msgid ""
"To implement isolation, Tarantool uses a simple optimistic scheduler: the"
" first transaction to commit wins. If a concurrent active transaction has"
" read a value modified by a committed transaction, it is aborted."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:148
msgid ""
"The cooperative scheduler ensures that, in absence of yields, a multi-"
"statement transaction is not preempted and hence is never aborted. "
"Therefore, understanding yields is essential to writing abort-free code."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:154
msgid "You can’t mix storage engines in a transaction today."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:160
msgid "Implicit yields"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:162
msgid ""
"The only explicit yield requests in Tarantool are :ref:`fiber.sleep() "
"<fiber-sleep>` and :ref:`fiber.yield() <fiber-yield>`, but many other "
"requests \"imply\" yields because Tarantool is designed to avoid "
"blocking."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:166
msgid "Database operations usually do not yield, but it depends on the engine:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:168
msgid "In memtx, reads or writes do not require I/O and do not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:170
msgid ""
"In vinyl, not all data is in memory, and SELECT often incurs a disc I/O, "
"and therefore yields, while a write may stall waiting for memory to free "
"up, thus also causing a yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:174
msgid ""
"In the \"autocommit\" mode, all data change operations are followed by an"
" automatic commit, which yields. So does an explicit commit of a multi-"
"statement transaction, :ref:`box.commit() <box-commit>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:178
msgid ""
"Many functions in modules :ref:`fio <fio-section>`, :ref:`net_box "
"<net_box-module>`, :ref:`console <console-module>` and :ref:`socket "
"<socket-module>` (the \"os\" and \"network\" requests) yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:182
#: ../doc/1.7/book/box/authentication.rst:180
#: ../doc/1.7/book/box/box_session.rst:209
msgid "**Example #1**"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:184
msgid ""
"*Engine = memtx* |br| ``select() insert()`` has one yield, at the end of "
"insertion, caused by implicit commit; ``select()`` has nothing to write "
"to the WAL and so does not yield."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:188
msgid ""
"*Engine = vinyl* |br| ``select() insert()`` has between one and three "
"yields, since ``select()`` may yield if the data is not in cache, "
"``insert()`` may yield waiting for available memory, and there is an "
"implicit yield at commit."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:193
msgid ""
"The sequence ``begin() insert() insert() commit()`` yields only at commit"
" if the engine is memtx, and can yield up to 3 times if the engine is "
"vinyl."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:196
#: ../doc/1.7/book/box/authentication.rst:188
#: ../doc/1.7/book/box/box_session.rst:218
msgid "**Example #2**"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:198
msgid ""
"Assume that in space ‘tester’ there are tuples in which the third field "
"represents a positive dollar amount. Let's start a transaction, withdraw "
"from tuple#1, deposit in tuple#2, and end the transaction, making its "
"effects permanent."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:203
msgid ""
"tarantool> function txn_example(from, to, amount_of_money)\n"
"         >   box.begin()\n"
"         >   box.space.tester:update(from, {{'-', 3, amount_of_money}})\n"
"         >   box.space.tester:update(to,   {{'+', 3, amount_of_money}})\n"
"         >   box.commit()\n"
"         >   return \"ok\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> txn_example({999}, {1000}, 1.00)\n"
"---\n"
"- \"ok\"\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:219
msgid ""
"If :ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>` = ‘none’, then"
" implicit yielding at commit time does not take place, because there are "
"no writes to the WAL."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:223
msgid ""
"If a task is interactive -- sending requests to the server and receiving "
"responses -- then it involves network IO, and therefore there is an "
"implicit yield, even if the request that is sent to the server is not "
"itself an implicit yield request. Therefore, the sequence:"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:231
msgid ""
"select\n"
"select\n"
"select"
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:235
msgid ""
"causes blocking (in memtx), if it is inside a function or Lua program "
"being executed on the server instance, but causes yielding (in both memtx"
" and vinyl) if it is done as a series of transmissions from a client, "
"including a client which operates via telnet, via one of the connectors, "
"or via the MySQL and PostgreSQL rocks, or via the interactive mode when "
":ref:`using Tarantool as a client <admin-using_tarantool_as_a_client>`."
msgstr ""

#: ../doc/1.7/book/box/atomic.rst:242
msgid ""
"After a fiber has yielded and then has regained control, it immediately "
"issues :ref:`testcancel <fiber-testcancel>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:33
msgid "Access control"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:35
msgid ""
"Understanding security details is primarily an issue for administrators. "
"Meanwhile, ordinary users should at least skim this section to get an "
"idea of how Tarantool makes it possible for administrators to prevent "
"unauthorized access to the database and to certain functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:40
msgid "In a nutshell:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:42
msgid ""
"There is a method to guarantee with password checks that users really are"
" who they say they are (“authentication”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:45
msgid ""
"There is a :ref:`_user <box_space-user>` system space, where usernames "
"and password-hashes are stored."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:48
msgid ""
"There are functions for saying that certain users are allowed to do "
"certain things (“privileges”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:51
msgid ""
"There is a :ref:`_priv <box_space-priv>` system space, where privileges "
"are stored. Whenever a user tries to do an operation, there is a check "
"whether the user has the privilege to do the operation (“access "
"control”)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:55
msgid "Further on, we explain all of this in more detail."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:61
msgid "Users"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:63
msgid ""
"There is a **current user** for any program working with Tarantool, local"
" or remote. If a remote connection is using a :ref:`binary port <admin-"
"security>`, the current user, by default, is '**guest**'. If the "
"connection is using an :ref:`admin-console port <admin-security>`, the "
"current user is '**admin**'. When executing a :ref:`Lua initialization "
"script <index-init_label>`, the current user is also ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:72
msgid ""
"The current user name can be found with :ref:`box.session.user() "
"<box_session-user>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:74
msgid "The current user can be changed:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:76
msgid ""
"For a binary port connection -- with AUTH protocol command, supported by "
"most clients;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:79
msgid ""
"For an admin-console connection and in a Lua initialization script -- "
"with :ref:`box.session.su <box_session-su>`;"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:82
msgid ""
"For a stored function invoked with CALL command over a binary port -- "
"with :ref:`SETUID <box_schema-func_create>` property enabled for the "
"function, which makes Tarantool temporarily replace the current user with"
" the function’s creator, with all creator's privileges, during function "
"execution."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:91
msgid "Passwords"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:93
msgid ""
"Each user may have a **password**. The password is any alphanumeric "
"string."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:95
#, python-format
msgid ""
"Tarantool passwords are stored in the :ref:`_user <box_space-user>` "
"system space with a `cryptographic hash function "
"<https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ so that, if"
" the password is ‘x’, the stored hash-password is a long string like "
"‘lL3OvhkIPOKh+Vn9Avlkx69M/Ck=‘. When a client connects to a Tarantool "
"instance, the instance sends a random `salt value "
"<https://en.wikipedia.org/wiki/Salt_%28cryptography%29>`_ which the "
"client must mix with the hashed-password before sending to the instance. "
"Thus the original value ‘x’ is never stored anywhere except in the user’s"
" head, and the hashed value is never passed down a network wire except "
"when mixed with a random salt."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:109
msgid ""
"For more details of the password hashing algorithm (e.g. for the purpose "
"of writing a new client application), read the `scramble.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/scramble.h>`_ header"
" file."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:114
msgid ""
"This system prevents malicious onlookers from finding passwords by "
"snooping in the log files or snooping on the wire. It is the same system "
"that `MySQL introduced several years ago "
"<http://dev.mysql.com/doc/refman/5.7/en/password-hashing.html>`_, which "
"has proved adequate for medium-security installations. Nevertheless, "
"administrators should warn users that no system is foolproof against "
"determined long-term attacks, so passwords should be guarded and changed "
"occasionally. Administrators should also advise users to choose long "
"unobvious passwords, but it is ultimately up to the users to choose or "
"change their own passwords."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:124
msgid ""
"There are two functions for managing passwords in Tarantool: "
":ref:`box.schema.user.password() <box_schema-user_password>` for changing"
" a user's password and :ref:`box.schema.user.passwd() <box_schema-"
"user_passwd>` for getting a hash-password."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:133
msgid "Owners and privileges"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:135
msgid ""
"In Tarantool, all objects are organized into a hierarchy of ownership. "
"Ordinarily the **owner** of every object is its creator. The creator of "
"the initial database state (we call it ‘universe’) --  including the "
"database itself, the system spaces, the users -- is ‘admin’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:140
msgid ""
"An object's owner can share some rights on the object by **granting "
"privileges** to other users. The following privileges are implemented:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:143
msgid "Read an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:144
msgid "Write, i.e. modify contents of an object,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:145
msgid ""
"Execute, i.e. use an object (if the privilege makes sense for the object;"
" for example, spaces can not be \"executed\", but functions can)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:150
msgid ""
"Currently, \"drop\" and \"grant\" privileges can not be granted to other "
"users. This possibility will be added in future versions of Tarantool."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:153
msgid ""
"This is how the privilege system works under the hood. To be able to "
"create objects, a user needs to have write access to Tarantool's system "
"spaces. The 'admin' user, who is at the top of the hierarchy and who is "
"the ultimate source of privileges, shares write access to a system space "
"(e.g. :ref:`_space <box_space-space>`) with some users. Now the users can"
" insert data into the system space (e.g. creating new spaces) and "
"themselves become creators/definers of new objects. For the objects they "
"created, the users can in turn share privileges with other users."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:162
msgid ""
"This is why only an object's owner can drop the object, but not other "
"ordinary users. Meanwhile, 'admin' can drop any object or delete any "
"other user, because 'admin' is the creator and ultimate owner of them "
"all."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:166
msgid ""
"The syntax of all :ref:`grant() <box_schema-user_grant>`/:ref:`revoke() "
"<box_schema-user_revoke>` commands in Tarantool follows this basic idea."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:170
msgid "Their first argument is \"who gets\" or \"who is revoked\" a grant."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:172
msgid ""
"Their second argument is the type of privilege granted, or a list of "
"privileges."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:174
msgid "Their third argument is the object type on which the privilege is granted."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:176
msgid ""
"Their fourth and optional argument is the object name (‘universe' has no "
"name, because there is only one ‘universe’, but you need to specify names"
" for functions/users/spaces/etc)."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:182
msgid ""
"Here we disable all privileges and run Tarantool in the ‘no-privilege’ "
"mode."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:184
msgid "box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:190
msgid ""
"Here we create a Lua function that will be executed under the user id of "
"its creator, even if called by another user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:193
msgid ""
"First, we create two spaces ('u' and 'i') and grant a no-password user "
"('internal') full access to them. Then we define a function "
"('read_and_modify') and the no-password user becomes this function's "
"creator. Finally, we grant another user ('public_user') access to execute"
" Lua functions created by the no-password user."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:198
msgid ""
"box.schema.space.create('u')\n"
"box.schema.space.create('i')\n"
"box.schema.space.u:create_index('pk')\n"
"box.schema.space.i:create_index('pk')\n"
"\n"
"box.schema.user.create(‘internal’)\n"
"\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'u')\n"
"box.schema.user.grant('internal', 'read,write', 'space', 'i')\n"
"\n"
"function read_and_modify(key)\n"
"  local u = box.space.u\n"
"  local i = box.space.i\n"
"  local fiber = require('fiber')\n"
"  local t = u:get{key}\n"
"  if t ~= nil\n"
"        u:put{key, box.session.uid()}\n"
"        i:put{key, fiber.time()}\n"
"  end\n"
"end\n"
"\n"
"box.session.su('internal')\n"
"box.schema.func.create('read_and_modify', {setuid= true})\n"
"box.session.su('admin')\n"
"box.schema.user.create('public_user', {password = 'secret'})\n"
"box.schema.user.grant('public_user', 'execute', 'function', "
"'read_and_modify')"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:231
msgid "Roles"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:233
msgid ""
"A **role** is a container for privileges which can be granted to regular "
"users. Instead of granting or revoking individual privileges, you can put"
" all the privileges in a role and then grant or revoke the role."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:237
msgid ""
"Role information is stored in the :ref:`_user <box_space-user>` space, "
"but the third field in the tuple -- the type field -- is ‘role’ rather "
"than ‘user’."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:240
msgid ""
"An important feature in role management is that roles can be **nested**. "
"For example, role R1 can be granted a privilege \"role R2\", so users "
"with the role R1 will subsequently get all privileges from both roles R1 "
"and R2. In other words, a user gets all the privileges that are granted "
"to a user’s roles, directly or indirectly."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:248
msgid ""
"-- This example will work for a user with many privileges, such as "
"'admin'\n"
"-- Create space T with a primary index\n"
"box.schema.space.create('T')\n"
"box.space.T:create_index('primary', {})\n"
"-- Create user U1 so that later we can change the current user to U1\n"
"box.schema.user.create('U1')\n"
"-- Create two roles, R1 and R2\n"
"box.schema.role.create('R1')\n"
"box.schema.role.create('R2')\n"
"-- Grant role R2 to role R1 and role R1 to user U1 (order doesn't matter)"
"\n"
"box.schema.role.grant('R1', 'execute', 'role', 'R2')\n"
"box.schema.user.grant('U1', 'execute', 'role', 'R1')\n"
"-- Grant read/write privileges for space T to role R2\n"
"-- (but not to role R1 and not to user U1)\n"
"box.schema.role.grant('R2', 'read,write', 'space', 'T')\n"
"-- Change the current user to user U1\n"
"box.session.su('U1')\n"
"-- An insertion to space T will now succeed because, due to nested roles,"
"\n"
"-- user U1 has write privilege on space T\n"
"box.space.T:insert{1}"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:271
msgid ""
"For details about Tarantool functions related to role management, see "
"reference on :ref:`box.schema <box_schema>` submodule."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:278
msgid "Sessions and security"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:280
msgid "A **session** is the state of a connection to Tarantool. It contains:"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:282
msgid "an integer id identifying the connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:283
msgid ""
"the :ref:`current user <authentication-users>` associated with the "
"connection,"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:284
msgid "text description of the connected peer, and"
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:285
msgid "session local state, such as Lua variables and functions."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:287
msgid ""
"In Tarantool, a single session can execute multiple concurrent "
"transactions. Each transaction is identified by a unique integer id, "
"which can be queried at start of the transaction using "
":ref:`box.session.sync() <box_session-sync>`."
msgstr ""

#: ../doc/1.7/book/box/authentication.rst:293
msgid ""
"To track all connects and disconnects, you can use :ref:`connection and "
"authentication triggers <triggers>`."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:33
#: ../doc/1.7/book/box/box_introspection.rst:33
msgid "Submodule `box.cfg`"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:37
#: ../doc/1.7/book/box/box_introspection.rst:37
msgid ""
"The ``box.cfg`` submodule is for administrators to specify all the server"
" configuration parameters (see \"Configuration reference\" for :ref:`a "
"complete description of all configuration parameters <box_cfg_params>`). "
"Use ``box.cfg`` without braces to get read-only access to those "
"parameters."
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:42 ../doc/1.7/book/box/box_index.rst:61
#: ../doc/1.7/book/box/box_index.rst:461 ../doc/1.7/book/box/box_index.rst:597
#: ../doc/1.7/book/box/box_index.rst:625 ../doc/1.7/book/box/box_index.rst:653
#: ../doc/1.7/book/box/box_index.rst:685 ../doc/1.7/book/box/box_index.rst:709
#: ../doc/1.7/book/box/box_index.rst:785 ../doc/1.7/book/box/box_index.rst:808
#: ../doc/1.7/book/box/box_index.rst:828 ../doc/1.7/book/box/box_info.rst:122
#: ../doc/1.7/book/box/box_introspection.rst:42
#: ../doc/1.7/book/box/box_introspection.rst:106
#: ../doc/1.7/book/box/box_introspection.rst:168
#: ../doc/1.7/book/box/box_schema.rst:204
#: ../doc/1.7/book/box/box_schema.rst:241
#: ../doc/1.7/book/box/box_schema.rst:274
#: ../doc/1.7/book/box/box_schema.rst:311
#: ../doc/1.7/book/box/box_schema.rst:333
#: ../doc/1.7/book/box/box_schema.rst:355
#: ../doc/1.7/book/box/box_schema.rst:378
#: ../doc/1.7/book/box/box_schema.rst:397
#: ../doc/1.7/book/box/box_schema.rst:412
#: ../doc/1.7/book/box/box_schema.rst:442
#: ../doc/1.7/book/box/box_schema.rst:472
#: ../doc/1.7/book/box/box_schema.rst:489
#: ../doc/1.7/book/box/box_schema.rst:526
#: ../doc/1.7/book/box/box_schema.rst:547
#: ../doc/1.7/book/box/box_schema.rst:562 ../doc/1.7/book/box/box_slab.rst:55
#: ../doc/1.7/book/box/box_slab.rst:114 ../doc/1.7/book/box/box_slab.rst:156
#: ../doc/1.7/book/box/box_space.rst:171 ../doc/1.7/book/box/box_space.rst:193
#: ../doc/1.7/book/box/box_space.rst:219 ../doc/1.7/book/box/box_space.rst:416
#: ../doc/1.7/book/box/box_space.rst:449 ../doc/1.7/book/box/box_space.rst:480
#: ../doc/1.7/book/box/box_space.rst:503 ../doc/1.7/book/box/box_space.rst:521
#: ../doc/1.7/book/box/box_space.rst:624 ../doc/1.7/book/box/box_space.rst:667
#: ../doc/1.7/book/box/box_space.rst:703 ../doc/1.7/book/box/box_space.rst:721
#: ../doc/1.7/book/box/box_space.rst:758 ../doc/1.7/book/box/box_space.rst:830
#: ../doc/1.7/book/box/box_space.rst:907 ../doc/1.7/book/box/box_space.rst:1012
#: ../doc/1.7/book/box/box_space.rst:1048
#: ../doc/1.7/book/box/box_space.rst:1067
#: ../doc/1.7/book/box/box_space.rst:1084
#: ../doc/1.7/book/box/box_space.rst:1134
#: ../doc/1.7/book/box/box_space.rst:1250
#: ../doc/1.7/book/box/box_space.rst:1470 ../doc/1.7/book/box/box_tuple.rst:62
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:239
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:277
#: ../doc/1.7/dev_guide/reference_capi/coio.rst:68
#: ../doc/1.7/dev_guide/reference_capi/say.rst:77
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:163
#: ../doc/1.7/reference/reference_lua/box_error.rst:76
#: ../doc/1.7/reference/reference_lua/box_error.rst:114
#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:72
#: ../doc/1.7/reference/reference_lua/clock.rst:54
#: ../doc/1.7/reference/reference_lua/clock.rst:77
#: ../doc/1.7/reference/reference_lua/clock.rst:96
#: ../doc/1.7/reference/reference_lua/clock.rst:115
#: ../doc/1.7/reference/reference_lua/clock.rst:135
#: ../doc/1.7/reference/reference_lua/console.rst:73
#: ../doc/1.7/reference/reference_lua/console.rst:104
#: ../doc/1.7/reference/reference_lua/console.rst:129
#: ../doc/1.7/reference/reference_lua/console.rst:168
#: ../doc/1.7/reference/reference_lua/crypto.rst:67
#: ../doc/1.7/reference/reference_lua/crypto.rst:96
#: ../doc/1.7/reference/reference_lua/csv.rst:77
#: ../doc/1.7/reference/reference_lua/csv.rst:159
#: ../doc/1.7/reference/reference_lua/csv.rst:204
#: ../doc/1.7/reference/reference_lua/errno.rst:69
#: ../doc/1.7/reference/reference_lua/fiber.rst:93
#: ../doc/1.7/reference/reference_lua/fiber.rst:117
#: ../doc/1.7/reference/reference_lua/fiber.rst:137
#: ../doc/1.7/reference/reference_lua/fiber.rst:157
#: ../doc/1.7/reference/reference_lua/fiber.rst:171
#: ../doc/1.7/reference/reference_lua/fiber.rst:188
#: ../doc/1.7/reference/reference_lua/fiber.rst:207
#: ../doc/1.7/reference/reference_lua/fiber.rst:234
#: ../doc/1.7/reference/reference_lua/fiber.rst:251
#: ../doc/1.7/reference/reference_lua/fiber.rst:271
#: ../doc/1.7/reference/reference_lua/fiber.rst:292
#: ../doc/1.7/reference/reference_lua/fiber.rst:317
#: ../doc/1.7/reference/reference_lua/fiber.rst:337
#: ../doc/1.7/reference/reference_lua/fiber.rst:362
#: ../doc/1.7/reference/reference_lua/fiber.rst:382
#: ../doc/1.7/reference/reference_lua/fiber.rst:427
#: ../doc/1.7/reference/reference_lua/fiber.rst:446
#: ../doc/1.7/reference/reference_lua/fio.rst:64
#: ../doc/1.7/reference/reference_lua/fio.rst:84
#: ../doc/1.7/reference/reference_lua/fio.rst:102
#: ../doc/1.7/reference/reference_lua/fio.rst:126
#: ../doc/1.7/reference/reference_lua/fio.rst:159
#: ../doc/1.7/reference/reference_lua/fio.rst:197
#: ../doc/1.7/reference/reference_lua/fio.rst:218
#: ../doc/1.7/reference/reference_lua/fio.rst:233
#: ../doc/1.7/reference/reference_lua/fio.rst:246
#: ../doc/1.7/reference/reference_lua/fio.rst:270
#: ../doc/1.7/reference/reference_lua/fio.rst:293
#: ../doc/1.7/reference/reference_lua/fio.rst:312
#: ../doc/1.7/reference/reference_lua/fio.rst:335
#: ../doc/1.7/reference/reference_lua/fio.rst:351
#: ../doc/1.7/reference/reference_lua/fio.rst:386
#: ../doc/1.7/reference/reference_lua/fio.rst:408
#: ../doc/1.7/reference/reference_lua/fio.rst:431
#: ../doc/1.7/reference/reference_lua/fio.rst:461
#: ../doc/1.7/reference/reference_lua/fio.rst:479
#: ../doc/1.7/reference/reference_lua/fio.rst:502
#: ../doc/1.7/reference/reference_lua/fio.rst:520
#: ../doc/1.7/reference/reference_lua/fio.rst:552
#: ../doc/1.7/reference/reference_lua/fio.rst:572
#: ../doc/1.7/reference/reference_lua/http.rst:52
#: ../doc/1.7/reference/reference_lua/http.rst:144
#: ../doc/1.7/reference/reference_lua/iconv.rst:60
#: ../doc/1.7/reference/reference_lua/iconv.rst:79
#: ../doc/1.7/reference/reference_lua/jit.rst:43
#: ../doc/1.7/reference/reference_lua/jit.rst:58
#: ../doc/1.7/reference/reference_lua/jit.rst:71
#: ../doc/1.7/reference/reference_lua/jit.rst:85
#: ../doc/1.7/reference/reference_lua/jit.rst:106
#: ../doc/1.7/reference/reference_lua/json.rst:51
#: ../doc/1.7/reference/reference_lua/json.rst:89
#: ../doc/1.7/reference/reference_lua/json.rst:116
#: ../doc/1.7/reference/reference_lua/net_box.rst:150
#: ../doc/1.7/reference/reference_lua/net_box.rst:167
#: ../doc/1.7/reference/reference_lua/net_box.rst:181
#: ../doc/1.7/reference/reference_lua/net_box.rst:194
#: ../doc/1.7/reference/reference_lua/net_box.rst:209
#: ../doc/1.7/reference/reference_lua/net_box.rst:231
#: ../doc/1.7/reference/reference_lua/net_box.rst:289
#: ../doc/1.7/reference/reference_lua/net_box.rst:305
#: ../doc/1.7/reference/reference_lua/net_box.rst:316
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:80
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:96
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:110
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:123
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:139
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:197
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:213
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:224
#: ../doc/1.7/reference/reference_lua/osmodule.rst:58
#: ../doc/1.7/reference/reference_lua/osmodule.rst:81
#: ../doc/1.7/reference/reference_lua/osmodule.rst:100
#: ../doc/1.7/reference/reference_lua/osmodule.rst:117
#: ../doc/1.7/reference/reference_lua/osmodule.rst:135
#: ../doc/1.7/reference/reference_lua/osmodule.rst:150
#: ../doc/1.7/reference/reference_lua/osmodule.rst:163
#: ../doc/1.7/reference/reference_lua/osmodule.rst:178
#: ../doc/1.7/reference/reference_lua/osmodule.rst:193
#: ../doc/1.7/reference/reference_lua/osmodule.rst:208
#: ../doc/1.7/reference/reference_lua/osmodule.rst:223
#: ../doc/1.7/reference/reference_lua/osmodule.rst:239
#: ../doc/1.7/reference/reference_lua/osmodule.rst:254
#: ../doc/1.7/reference/reference_lua/other.rst:45
#: ../doc/1.7/reference/reference_lua/other.rst:83
#: ../doc/1.7/reference/reference_lua/pickle.rst:92
#: ../doc/1.7/reference/reference_lua/pickle.rst:137
#: ../doc/1.7/reference/reference_lua/socket.rst:141
#: ../doc/1.7/reference/reference_lua/socket.rst:159
#: ../doc/1.7/reference/reference_lua/socket.rst:176
#: ../doc/1.7/reference/reference_lua/socket.rst:248
#: ../doc/1.7/reference/reference_lua/socket.rst:404
#: ../doc/1.7/reference/reference_lua/strict.rst:46
#: ../doc/1.7/reference/reference_lua/tap.rst:97
#: ../doc/1.7/reference/reference_lua/tap.rst:139
#: ../doc/1.7/reference/reference_lua/tarantool.rst:46
#: ../doc/1.7/reference/reference_lua/uri.rst:55
#: ../doc/1.7/reference/reference_lua/uri.rst:78
#: ../doc/1.7/reference/reference_lua/xlog.rst:54
#: ../doc/1.7/reference/reference_rock/dbms.rst:216
#: ../doc/1.7/reference/reference_rock/dbms.rst:240
#: ../doc/1.7/reference/reference_rock/dbms.rst:264
#: ../doc/1.7/reference/reference_rock/dbms.rst:559
#: ../doc/1.7/reference/reference_rock/dbms.rst:583
#: ../doc/1.7/reference/reference_rock/dbms.rst:606
msgid "**Example:**"
msgstr ""

#: ../doc/1.7/book/box/box_cfg.rst:44
#: ../doc/1.7/book/box/box_introspection.rst:44
msgid ""
"tarantool> box.cfg\n"
"---\n"
"- checkpoint_count: 2\n"
"  too_long_threshold: 0.5\n"
"  slab_alloc_factor: 1.1\n"
"  memtx_max_tuple_size: 1048576\n"
"  background: false\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:33
msgid "Submodule `box.index`"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:35
msgid ""
"The ``box.index`` submodule provides read-only access for index "
"definitions and index keys. Indexes are contained in :samp:`box.space"
".{space-name}.index` array within each space object. They provide an API "
"for ordered iteration over tuples. This API is a direct binding to "
"corresponding methods of index objects of type ``box.index`` in the "
"storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:47
msgid "True if the index is unique, false if the index is not unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_introspection.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_slab.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "rtype"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:49 ../doc/1.7/book/box/box_schema.rst:65
#: ../doc/1.7/book/box/box_schema.rst:83 ../doc/1.7/book/box/box_space.rst:264
#: ../doc/1.7/book/box/box_space.rst:266 ../doc/1.7/book/box/data_model.rst:183
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:86
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:112
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:128
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:136
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:144
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:150
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:245
#: ../doc/1.7/reference/reference_lua/fio.rst:195
#: ../doc/1.7/reference/reference_lua/fio.rst:291
#: ../doc/1.7/reference/reference_lua/fio.rst:333
#: ../doc/1.7/reference/reference_lua/fio.rst:349
#: ../doc/1.7/reference/reference_lua/fio.rst:406
#: ../doc/1.7/reference/reference_lua/fio.rst:477
#: ../doc/1.7/reference/reference_lua/net_box.rst:165
#: ../doc/1.7/reference/reference_lua/net_box.rst:179
#: ../doc/1.7/reference/reference_lua/net_box.rst:192
#: ../doc/1.7/reference/reference_lua/net_box.rst:207
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:94
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:108
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:121
#: ../doc/1.7/reference/reference_lua/socket.rst:246
#: ../doc/1.7/reference/reference_lua/socket.rst:425
#: ../doc/1.7/reference/reference_lua/socket.rst:436
#: ../doc/1.7/reference/reference_lua/tap.rst:95
#: ../doc/1.7/reference/reference_lua/tap.rst:127
#: ../doc/1.7/reference/reference_lua/tap.rst:158
#: ../doc/1.7/reference/reference_lua/tap.rst:169
#: ../doc/1.7/reference/reference_lua/tap.rst:186
#: ../doc/1.7/reference/reference_lua/tap.rst:194
msgid "boolean"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:53
msgid "Index type, 'TREE' or 'HASH' or 'BITSET' or 'RTREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:57
msgid "An array describing index key fields."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:59 ../doc/1.7/book/box/box_info.rst:120
#: ../doc/1.7/book/box/box_introspection.rst:104
#: ../doc/1.7/book/box/box_schema.rst:97 ../doc/1.7/book/box/box_slab.rst:53
#: ../doc/1.7/book/box/box_slab.rst:112 ../doc/1.7/book/box/box_slab.rst:154
#: ../doc/1.7/book/box/box_space.rst:1082
#: ../doc/1.7/reference/reference_lua/csv.rst:75
#: ../doc/1.7/reference/reference_lua/fiber.rst:205
#: ../doc/1.7/reference/reference_lua/fio.rst:144
#: ../doc/1.7/reference/reference_lua/fio.rst:214
#: ../doc/1.7/reference/reference_lua/fio.rst:518
#: ../doc/1.7/reference/reference_lua/http.rst:106
#: ../doc/1.7/reference/reference_lua/json.rst:87
#: ../doc/1.7/reference/reference_lua/pickle.rst:135
#: ../doc/1.7/reference/reference_lua/socket.rst:174
#: ../doc/1.7/reference/reference_lua/socket.rst:548
#: ../doc/1.7/reference/reference_lua/socket.rst:560
#: ../doc/1.7/reference/reference_lua/yaml.rst:54
msgid "table"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:63
msgid ""
"tarantool> box.space.tester.index.primary\n"
"---\n"
"- unique: true\n"
"  parts:\n"
"  - type: unsigned\n"
"    fieldno: 1\n"
"  id: 0\n"
"  space_id: 513\n"
"  name: primary\n"
"  type: TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:81
msgid ""
"Search for a tuple or a set of tuples via the given index, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:84
msgid ""
"The :samp:`{key}` parameter specifies what must match within the index. "
"The :samp:`{iterator}` parameter specifies the rule for matching and "
"ordering. Different index types support different iterators. For example,"
" a TREE index maintains a strict order of keys and can return all tuples "
"in ascending or descending order, starting from the specified key. Other "
"index types, however, do not support ordering."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:91
msgid ""
"To understand consistency of tuples returned by an iterator, it's "
"essential to know the principles of the Tarantool transaction processing "
"subsystem. An iterator in Tarantool does not own a consistent read view. "
"Instead, each procedure is granted exclusive access to all tuples and "
"spaces until there is a \"context switch\": which may happen due to "
":ref:`the implicit yield rules <atomic-implicit-yields>`, or by an "
"explicit call to :ref:`fiber.yield <fiber-yield>`. When the execution "
"flow returns to the yielded procedure, the data set could have changed "
"significantly. Iteration, resumed after a yield point, does not preserve "
"the read view, but continues with the new content of the database. The "
"tutorial :ref:`Indexed pattern search <c_lua_tutorial-"
"indexed_pattern_search>` shows one way that iterators and yields can be "
"used together."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_space.rst
#: ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/say.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
#: ../doc/1.7/reference/reference_lua/box_error.rst
#: ../doc/1.7/reference/reference_lua/box_once.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/errno.rst
#: ../doc/1.7/reference/reference_lua/fiber.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/osmodule.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "Parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:105 ../doc/1.7/book/box/box_index.rst:450
#: ../doc/1.7/book/box/box_index.rst:585 ../doc/1.7/book/box/box_index.rst:612
#: ../doc/1.7/book/box/box_index.rst:640 ../doc/1.7/book/box/box_index.rst:671
#: ../doc/1.7/book/box/box_index.rst:701 ../doc/1.7/book/box/box_index.rst:730
#: ../doc/1.7/book/box/box_index.rst:751 ../doc/1.7/book/box/box_index.rst:769
#: ../doc/1.7/book/box/box_index.rst:800 ../doc/1.7/book/box/box_index.rst:820
#: ../doc/1.7/book/box/box_index.rst:842
msgid "an :ref:`object reference <app_server-object_reference>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:107 ../doc/1.7/book/box/box_space.rst:606
msgid "value to be matched against the index key, which may be multi-part"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:109
msgid "as defined in tables below. The default iterator type is 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_info.rst
#: ../doc/1.7/book/box/box_introspection.rst ../doc/1.7/book/box/box_schema.rst
#: ../doc/1.7/book/box/box_session.rst ../doc/1.7/book/box/box_slab.rst
#: ../doc/1.7/book/box/box_space.rst ../doc/1.7/book/box/box_tuple.rst
#: ../doc/1.7/dev_guide/documentation_guidelines.rst
#: ../doc/1.7/reference/reference_lua/clock.rst
#: ../doc/1.7/reference/reference_lua/console.rst
#: ../doc/1.7/reference/reference_lua/csv.rst
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst
#: ../doc/1.7/reference/reference_lua/fio.rst
#: ../doc/1.7/reference/reference_lua/http.rst
#: ../doc/1.7/reference/reference_lua/iconv.rst
#: ../doc/1.7/reference/reference_lua/json.rst
#: ../doc/1.7/reference/reference_lua/log.rst
#: ../doc/1.7/reference/reference_lua/msgpack.rst
#: ../doc/1.7/reference/reference_lua/net_box.rst
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst
#: ../doc/1.7/reference/reference_lua/other.rst
#: ../doc/1.7/reference/reference_lua/pickle.rst
#: ../doc/1.7/reference/reference_lua/socket.rst
#: ../doc/1.7/reference/reference_lua/tap.rst
#: ../doc/1.7/reference/reference_lua/uuid.rst
#: ../doc/1.7/reference/reference_lua/yaml.rst
msgid "return"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:113 ../doc/1.7/book/box/box_space.rst:611
msgid ""
"`iterator <https://www.lua.org/pil/7.1.html>`_ which can be used in a "
"for/end loop or with `totable() "
"<https://rtsisyk.github.io/luafun/reducing.html#fun.totable>`_"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:117
msgid ""
"**Possible errors:** No such space; wrong type; Selected iteration type "
"is not supported for the index type; or key is not supported for the "
"iteration type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:121
msgid "**Complexity factors:** Index size, Index type; Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:124
msgid ""
"A search-key-value can be a number (for example ``1234``), a string (for "
"example ``'abcd'``), or a table of numbers and strings (for example "
"``{1234, 'abcd'}``). Each part of a key will be compared to each part of "
"an index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:129
msgid "**Iterator types for TREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
#: ../doc/1.7/book/box/box_space.rst:1384
msgid "Type"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
msgid "Arguments"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:138 ../doc/1.7/book/box/box_index.rst:238
#: ../doc/1.7/book/box/box_index.rst:272 ../doc/1.7/book/box/box_index.rst:308
#: ../doc/1.7/book/box/box_space.rst:1384
msgid "Description"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140 ../doc/1.7/book/box/box_index.rst:245
#: ../doc/1.7/book/box/box_index.rst:278 ../doc/1.7/book/box/box_index.rst:313
msgid "box.index.EQ or 'EQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140 ../doc/1.7/book/box/box_index.rst:146
#: ../doc/1.7/book/box/box_index.rst:151 ../doc/1.7/book/box/box_index.rst:158
#: ../doc/1.7/book/box/box_index.rst:165 ../doc/1.7/book/box/box_index.rst:169
#: ../doc/1.7/book/box/box_index.rst:175 ../doc/1.7/book/box/box_index.rst:245
#: ../doc/1.7/book/box/box_index.rst:251 ../doc/1.7/book/box/box_index.rst:313
#: ../doc/1.7/book/box/box_index.rst:321 ../doc/1.7/book/box/box_index.rst:326
#: ../doc/1.7/book/box/box_index.rst:331 ../doc/1.7/book/box/box_index.rst:336
#: ../doc/1.7/book/box/box_index.rst:346
msgid "search value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:140
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. Tuples are returned in ascending order by "
"index key. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146
msgid "box.index.REQ or 'REQ'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:146
msgid ""
"Matching is the same as for ``box.index.EQ``. Tuples are returned in "
"descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:151 ../doc/1.7/book/box/box_index.rst:251
#: ../doc/1.7/book/box/box_index.rst:321
msgid "box.index.GT or 'GT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:151
msgid ""
"The comparison operator is '>' (greater than). If an index key is greater"
" than a search value, it matches. Tuples are returned in ascending order "
"by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:158 ../doc/1.7/book/box/box_index.rst:326
msgid "box.index.GE or 'GE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:158
msgid ""
"The comparison operator is '>=' (greater than or equal to). If an index "
"key is greater than or equal to a search value, it matches. Tuples are "
"returned in ascending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:165 ../doc/1.7/book/box/box_index.rst:274
#: ../doc/1.7/book/box/box_index.rst:310
msgid "box.index.ALL or 'ALL'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:165
msgid "Same as box.index.GE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:169 ../doc/1.7/book/box/box_index.rst:331
msgid "box.index.LT or 'LT'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:169
msgid ""
"The comparison operator is '<' (less than). If an index key is less than "
"a search value, it matches. Tuples are returned in descending order by "
"index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:175 ../doc/1.7/book/box/box_index.rst:336
msgid "box.index.LE or 'LE'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:175
msgid ""
"The comparison operator is '<=' (less than or equal to). If an index key "
"is less than or equal to a search value, it matches. Tuples are returned "
"in descending order by index key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:184
msgid ""
"Informally, we can state that searches with TREE indexes are generally "
"what users will find is intuitive, provided that there are no nils and no"
" missing parts. Formally, the logic is as follows. A search key has zero "
"or more parts, for example {}, {1,2,3},{1,nil,3}. An index key has one or"
" more parts, for example {1}, {1,2,3},{1,2,3}. An search key may contain "
"nil (but not msgpack.NULL, which is the wrong type). An index key may not"
" contain nil or msgpack.NULL, although a later version of Tarantool will "
"have different rules --  the behavior of searches with nil is subject to "
"change. Possible iterators are LT, LE, EQ, REQ, GE, GT. A search key is "
"said to \"match\" an index key if the following statements, which are "
"pseudocode for the comparison operation, return TRUE."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:231
msgid "**Iterator types for HASH indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240
msgid "box.index.ALL"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240 ../doc/1.7/book/box/box_index.rst:274
#: ../doc/1.7/book/box/box_index.rst:310
msgid "none"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:240
msgid ""
"All index keys match. Tuples are returned in ascending order by hash of "
"index key, which will appear to be random."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:245
msgid ""
"The comparison operator is '==' (equal to). If an index key is equal to a"
" search value, it matches. The number of returned tuples will be 0 or 1. "
"This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:251
msgid ""
"The comparison operator is '>' (greater than). If a hash of an index key "
"is greater than a hash of a search value, it matches. Tuples are returned"
" in ascending order by hash of index key, which will appear to be random."
" Provided that the space is not being updated, one can retrieve all the "
"tuples in a space, N tuples at a time, by using {iterator='GT', limit=N} "
"in each search, and using the last returned value from the previous "
"result as the start search value for the next search."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:265
msgid "**Iterator types for BITSET indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:274
msgid "All index keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:278 ../doc/1.7/book/box/box_index.rst:283
#: ../doc/1.7/book/box/box_index.rst:288 ../doc/1.7/book/box/box_index.rst:293
msgid "bitset value"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:278
msgid ""
"If an index key is equal to a bitset value, it matches. Tuples are "
"returned in their order within the space. This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:283
msgid "box.index.BITS_ALL_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:283
msgid ""
"If all of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:288
msgid "box.index.BITS_ANY_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:288
msgid ""
"If any of the bits which are 1 in the bitset value are 1 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:293
msgid "box.index.BITS_ALL_NOT_SET"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:293
msgid ""
"If all of the bits which are 1 in the bitset value are 0 in the index "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:301
msgid "**Iterator types for RTREE indexes**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:310
msgid "All keys match. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:313
msgid ""
"If all points of the rectangle-or-box defined by the search value are the"
" same as the rectangle-or-box defined by the index key, it matches. "
"Tuples are returned in their order within the space. \"Rectangle-or-box\""
" means \"rectangle-or-box as explained in section about :ref:`RTREE "
"<box_index-rtree>`\". This is the default."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:321
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:326
msgid ""
"If all points of the rectangle-or-box defined by the search value are "
"within, or at the side of, the rectangle-or-box defined by the index key,"
" it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:331
msgid ""
"If all points of the rectangle-or-box defined by the index key are within"
" the rectangle-or-box defined by the search key, it matches. Tuples are "
"returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:336
msgid ""
"If all points of the rectangle-or-box defined by the index key are "
"within, or at the side of, the rectangle-or-box defined by the search "
"key, it matches. Tuples are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid "box.index.OVERLAPS or 'OVERLAPS'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid "search values"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:341
msgid ""
"If some points of the rectangle-or-box defined by the search value are "
"within the rectangle-or-box defined by the index key, it matches. Tuples "
"are returned in their order within the space."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:346
msgid "box.index.NEIGHBOR or 'NEIGHBOR'"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:346
msgid ""
"If some points of the rectangle-or-box defined by the defined by the key "
"are within, or at the side of, defined by the index key, it matches. "
"Tuples are returned in order: nearest neighbor first."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:352
msgid "**First Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:354
msgid "Default 'TREE' Index and ``pairs()`` function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:356
msgid ""
"tarantool> s = box.schema.space.create('space17')\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {\n"
"         >   parts = {1, 'string', 2, 'string'}\n"
"         > })\n"
"---\n"
"...\n"
"tarantool> s:insert{'C', 'C'}\n"
"---\n"
"- ['C', 'C']\n"
"...\n"
"tarantool> s:insert{'B', 'A'}\n"
"---\n"
"- ['B', 'A']\n"
"...\n"
"tarantool> s:insert{'C', '!'}\n"
"---\n"
"- ['C', '!']\n"
"...\n"
"tarantool> s:insert{'A', 'C'}\n"
"---\n"
"- ['A', 'C']\n"
"...\n"
"tarantool> function example()\n"
"         >   for _, tuple in\n"
"         >     s.index.primary:pairs(nil, {\n"
"         >         iterator = box.index.ALL}) do\n"
"         >       print(tuple)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> example()\n"
"['A', 'C']\n"
"['B', 'A']\n"
"['C', '!']\n"
"['C', 'C']\n"
"---\n"
"...\n"
"tarantool> s:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:402
msgid "**Second Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:404
msgid ""
"This Lua code finds all the tuples whose primary key values begin with "
"'XY'. The assumptions include that there is a one-part primary-key TREE "
"index on the first field, which must be a string. The iterator loop "
"ensures that the search will return tuples where the first value is "
"greater than or equal to 'XY'. The conditional statement within the loop "
"ensures that the looping will stop when the first two letters are not "
"'XY'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:412
msgid ""
"for _, tuple in\n"
"box.space.t.index.primary:pairs(\"XY\",{iterator = \"GE\"}) do\n"
"  if (string.sub(tuple[1], 1, 2) ~= \"XY\") then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:420
msgid "**Third Example of index pairs():**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:422
msgid ""
"This Lua code finds all the tuples whose primary key values are greater "
"than or equal to 1000, and less than or equal to 1999 (this type of "
"request is sometimes called a \"range search\" or a \"between search\"). "
"The assumptions include that there is a one-part primary-key TREE index "
"on the first field, which must be a number. The iterator loop ensures "
"that the search will return tuples where the first value is greater than "
"or equal to 1000. The conditional statement within the loop ensures that "
"the looping will stop when the first value is greater than 1999."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:432
msgid ""
"for _, tuple in\n"
"box.space.t2.index.primary:pairs(1000,{iterator = \"GE\"}) do\n"
"  if (tuple[1] > 1999) then break end\n"
"  print(tuple)\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:444
msgid ""
"This is an alternative to :ref:`box.space...select() <box_space-select>` "
"which goes via a particular index and can make use of additional "
"parameters that specify the iterator type, and the limit (that is, the "
"maximum number of tuples to return) and the offset (that is, which tuple "
"to start with in the list)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:452 ../doc/1.7/book/box/box_index.rst:587
#: ../doc/1.7/book/box/box_index.rst:614 ../doc/1.7/book/box/box_index.rst:642
#: ../doc/1.7/book/box/box_index.rst:703 ../doc/1.7/book/box/box_index.rst:732
#: ../doc/1.7/book/box/box_index.rst:753
msgid "values to be matched against the index key"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:453
msgid "none, any or all of next parameters"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:454
msgid "type of iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:455
msgid "maximum number of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:456
msgid "start tuple number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:458
msgid "the tuple or tuples that match the field values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:459 ../doc/1.7/book/box/box_space.rst:752
msgid "array of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:463
msgid ""
"-- Create a space named tester.\n"
"tarantool> sp = box.schema.space.create('tester')\n"
"-- Create a unique index 'primary'\n"
"-- which won't be needed for this example.\n"
"tarantool> sp:create_index('primary', {parts = {1, 'unsigned' }})\n"
"-- Create a non-unique index 'secondary'\n"
"-- with an index on the second field.\n"
"tarantool> sp:create_index('secondary', {\n"
"         >   type = 'tree',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'string'}\n"
"         > })\n"
"-- Insert three tuples, values in field[2]\n"
"-- equal to 'X', 'Y', and 'Z'.\n"
"tarantool> sp:insert{1, 'X', 'Row with field[2]=X'}\n"
"tarantool> sp:insert{2, 'Y', 'Row with field[2]=Y'}\n"
"tarantool> sp:insert{3, 'Z', 'Row with field[2]=Z'}\n"
"-- Select all tuples where the secondary index\n"
"-- keys are greater than 'X'.`\n"
"tarantool> sp.index.secondary:select({'X'}, {\n"
"         >   iterator = 'GT',\n"
"         >   limit = 1000\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:489
msgid "The result will be a table of tuple and will look like this:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:491
msgid ""
"---\n"
"- - [2, 'Y', 'Row with field[2]=Y']\n"
"  - [3, 'Z', 'Row with field[2]=Z']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:500
msgid ""
":samp:`index.{index-name}` is optional. If it is omitted, then the "
"assumed index is the first (primary-key) index. Therefore, for the "
"example above, ``box.space.tester:select({1}, {iterator = 'GT'})`` would "
"have returned the same two rows, via the 'primary' index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:507
msgid ""
":samp:`iterator = {iterator-type}` is optional. If it is omitted, then "
"``iterator = 'EQ'`` is assumed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:512
msgid ""
":samp:`{field-value} [, {field-value ...}]` is optional. If it is "
"omitted, then every key in the index is considered to be a match, "
"regardless of iterator type. Therefore, for the example above, "
"``box.space.tester:select{}`` will select every tuple in the tester space"
" via the first (primary-key) index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:522
msgid ""
":samp:`box.space.{space-name}.index.{index-name}:select(...)[1]``. can be"
" replaced by :samp:`box.space.{space-name}.index.{index-name}:get(...)`. "
"That is, ``get`` can be used as a convenient shorthand to get the first "
"tuple in the tuple set that would be returned by ``select``. However, if "
"there is more than one tuple in the tuple set, then ``get`` returns an "
"error."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:530
msgid "**Example with BITSET index:**"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:532
msgid ""
"The following script shows creation and search with a BITSET index. "
"Notice: BITSET cannot be unique, so first a primary-key index is created."
" Notice: bit values are entered as hexadecimal literals for easier "
"reading."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:536
msgid ""
"tarantool> s = box.schema.space.create('space_with_bitset')\n"
"tarantool> s:create_index('primary_index', {\n"
"         >   parts = {1, 'string'},\n"
"         >   unique = true,\n"
"         >   type = 'TREE'\n"
"         > })\n"
"tarantool> s:create_index('bitset_index', {\n"
"         >   parts = {2, 'unsigned'},\n"
"         >   unique = false,\n"
"         >   type = 'BITSET'\n"
"         > })\n"
"tarantool> s:insert{'Tuple with bit value = 01', 0x01}\n"
"tarantool> s:insert{'Tuple with bit value = 10', 0x02}\n"
"tarantool> s:insert{'Tuple with bit value = 11', 0x03}\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.EQ\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ANY_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 10', 2]\n"
"  - ['Tuple with bit value = 11', 3]\n"
"...\n"
"tarantool> s.index.bitset_index:select(0x02, {\n"
"         >   iterator = box.index.BITS_ALL_NOT_SET\n"
"         > })\n"
"---\n"
"- - ['Tuple with bit value = 01', 1]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:583
msgid ""
"Search for a tuple via the given index, as described :ref:`earlier "
"<box_index-note>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:589
msgid "the tuple whose index-key fields are equal to the passed key values."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:590 ../doc/1.7/book/box/box_index.rst:619
#: ../doc/1.7/book/box/box_index.rst:647 ../doc/1.7/book/box/box_index.rst:676
#: ../doc/1.7/book/box/box_index.rst:741 ../doc/1.7/book/box/box_index.rst:756
#: ../doc/1.7/book/box/box_space.rst:164 ../doc/1.7/book/box/box_space.rst:407
#: ../doc/1.7/book/box/box_space.rst:467 ../doc/1.7/book/box/box_space.rst:498
#: ../doc/1.7/book/box/box_space.rst:694 ../doc/1.7/book/box/box_space.rst:888
#: ../doc/1.7/book/box/box_tuple.rst:56 ../doc/1.7/book/box/box_tuple.rst:200
#: ../doc/1.7/book/box/box_tuple.rst:201 ../doc/1.7/book/box/box_tuple.rst:320
msgid "tuple"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:592
msgid ""
"**Possible errors:** No such index; wrong type; more than one tuple "
"matches."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:594
msgid ""
"**Complexity factors:** Index size, Index type. See also "
":ref:`space_object:get() <box_space-get>`."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:599
msgid ""
"tarantool> box.space.tester.index.primary:get(2)\n"
"---\n"
"- [2, 'Music']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:610
msgid "Find the minimum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:616
msgid ""
"the tuple for the first key in the index. If optional ``key-value`` is "
"supplied, returns the first key which is greater than or equal to ``key-"
"value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:621 ../doc/1.7/book/box/box_index.rst:649
msgid "**Possible errors:** index is not of type 'TREE'."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:623 ../doc/1.7/book/box/box_index.rst:651
#: ../doc/1.7/book/box/box_index.rst:678 ../doc/1.7/book/box/box_space.rst:617
#: ../doc/1.7/book/box/box_space.rst:756
msgid "**Complexity factors:** Index size, Index type."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:627
msgid ""
"tarantool> box.space.tester.index.primary:min()\n"
"---\n"
"- ['Alpha!', 55, 'This is the first tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:638
msgid "Find the maximum value in the specified index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:644
msgid ""
"the tuple for the last key in the index. If optional ``key-value`` is "
"supplied, returns the last key which is less than or equal to ``key-"
"value``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:655
msgid ""
"tarantool> box.space.tester.index.primary:max()\n"
"---\n"
"- ['Gamma!', 55, 'This is the third tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:666
msgid ""
"Find a random value in the specified index. This method is useful when "
"it's important to get insight into data distribution in an index without "
"having to iterate over the entire data set."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:673
msgid "an arbitrary non-negative integer"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:675
msgid "the tuple for the random key in the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst ../doc/1.7/book/box/box_space.rst
msgid "Note re storage engine:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``random()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:687
msgid ""
"tarantool> box.space.tester.index.secondary:random(1)\n"
"---\n"
"- ['Beta!', 66, 'This is the second tuple!']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:698
msgid ""
"Iterate over an index, counting the number of tuples which match the key-"
"value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:704 ../doc/1.7/book/box/box_space.rst:215
msgid "comparison method"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:706
msgid "the number of matching index keys."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:707 ../doc/1.7/book/box/box_index.rst:846
#: ../doc/1.7/book/box/box_schema.rst:73 ../doc/1.7/book/box/box_schema.rst:77
#: ../doc/1.7/book/box/box_session.rst:46
#: ../doc/1.7/book/box/box_session.rst:51
#: ../doc/1.7/book/box/box_session.rst:77 ../doc/1.7/book/box/box_space.rst:262
#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:279
#: ../doc/1.7/book/box/box_space.rst:281 ../doc/1.7/book/box/box_space.rst:283
#: ../doc/1.7/book/box/box_space.rst:285 ../doc/1.7/book/box/box_space.rst:287
#: ../doc/1.7/book/box/box_tuple.rst:88 ../doc/1.7/book/box/box_tuple.rst:113
#: ../doc/1.7/book/box/box_tuple.rst:162
#: ../doc/1.7/reference/reference_lua/fiber.rst:269
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:119
#: ../doc/1.7/reference/reference_lua/fio.rst:124
#: ../doc/1.7/reference/reference_lua/fio.rst:498
#: ../doc/1.7/reference/reference_lua/socket.rst:265
#: ../doc/1.7/reference/reference_lua/socket.rst:388
msgid "number"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:711
msgid ""
"tarantool> box.space.tester.index.primary:count(999)\n"
"---\n"
"- 0\n"
"...\n"
"tarantool> box.space.tester.index.primary:count('Alpha!', { iterator = "
"'LE' })\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:724 ../doc/1.7/book/box/box_space.rst:846
#: ../doc/1.7/book/box/box_tuple.rst:301
msgid "Update a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:726
msgid ""
"Same as :ref:`box.space...update() <box_space-update>`, but key is "
"searched in this index instead of primary key. This index ought to be "
"unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:733 ../doc/1.7/book/box/box_space.rst:880
#: ../doc/1.7/book/box/box_space.rst:997
msgid "operation type represented in string"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:734 ../doc/1.7/book/box/box_space.rst:881
#: ../doc/1.7/book/box/box_space.rst:998 ../doc/1.7/book/box/box_tuple.rst:313
msgid ""
"what field the operation will apply to. The field number can be negative,"
" meaning the position from the end of tuple. (#tuple + negative field "
"number + 1)"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:738 ../doc/1.7/book/box/box_space.rst:885
#: ../doc/1.7/book/box/box_space.rst:1002 ../doc/1.7/book/box/box_tuple.rst:317
msgid "what value will be applied"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:740 ../doc/1.7/book/box/box_space.rst:887
msgid "the updated tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:745
msgid "Delete a tuple identified by a key."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:747
msgid ""
"Same as :ref:`box.space...delete() <box_space-delete>`, but key is "
"searched in this index instead of in the primary-key index. This index "
"ought to be unique."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:755
msgid "the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl will return `nil`, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:767
msgid "Alter an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:771
msgid ""
"options list, same as the options list for :ref:`create_index <box_space-"
"create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:774 ../doc/1.7/book/box/box_index.rst:824
#: ../doc/1.7/book/box/box_schema.rst:162
#: ../doc/1.7/book/box/box_schema.rst:376
#: ../doc/1.7/book/box/box_schema.rst:524 ../doc/1.7/book/box/box_space.rst:442
#: ../doc/1.7/book/box/box_space.rst:663 ../doc/1.7/book/box/box_space.rst:719
#: ../doc/1.7/book/box/box_space.rst:821 ../doc/1.7/book/box/data_model.rst:181
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:273
#: ../doc/1.7/reference/reference_lua/console.rst:68
#: ../doc/1.7/reference/reference_lua/fiber.rst:315
#: ../doc/1.7/reference/reference_lua/fiber.rst:358
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:252
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:258
#: ../doc/1.7/reference/reference_lua/log.rst:62
#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
#: ../doc/1.7/reference/reference_lua/tap.rst:65
#: ../doc/1.7/reference/reference_lua/tap.rst:76
#: ../doc/1.7/reference/reference_lua/tap.rst:83
#: ../doc/1.7/reference/reference_lua/tap.rst:137
msgid "nil"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:776
msgid ""
"**Possible errors:** Index does not exist, or the first index cannot be "
"changed to {unique = false}, or the alter function is only applicable for"
" the memtx storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst
msgid "vinyl does not support ``alter()``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:787
msgid ""
"tarantool> box.space.space55.index.primary:alter({type = 'HASH'})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:797
msgid ""
"Drop an index. Dropping a primary-key index has a side effect: all tuples"
" are deleted."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:803
msgid "nil."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:805
msgid ""
"**Possible errors:** Index does not exist, or a primary-key index cannot "
"be dropped while a secondary-key index exists."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:810
msgid ""
"tarantool> box.space.space55.index.primary:drop()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:818
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:268
msgid "Rename an index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:822
msgid "new name for index"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:826
msgid "**Possible errors:** index_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:830
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:279
msgid ""
"tarantool> box.space.space55.index.primary:rename('secondary')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:836 ../doc/1.7/book/box/box_space.rst:819
msgid "**Complexity factors:** Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:840
msgid "Return the total number of bytes taken by the index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:845 ../doc/1.7/book/box/box_tuple.rst:112
msgid "number of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:850
msgid "Example showing use of the box functions"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:852
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. The example function will:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:856
msgid "select a tuple whose key value is 1000;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:857
msgid "return an error if the tuple already exists and already has 3 fields;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:860
msgid "Insert or replace the tuple with:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:859
msgid "field[1] = 1000"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:860
msgid "field[2] = a uuid"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:861
msgid "field[3] = number of seconds since 1970-01-01;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:862
msgid "Get field[3] from what was replaced;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:863
msgid "Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:864
msgid "Return the formatted value."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:866
msgid ""
"The function uses Tarantool box functions :ref:`box.space...select "
"<box_space-select>`, :ref:`box.space...replace <box_space-replace>`, "
":ref:`fiber.time <fiber-time>`, :ref:`uuid.str <uuid-str>`. The function "
"uses Lua functions `os.date()`_ and `string.sub()`_."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:875
#, python-format
msgid ""
"function example()\n"
"  local a, b, c, table_of_selected_tuples, d\n"
"  local replaced_tuple, time_field\n"
"  local formatted_time_field\n"
"  local fiber = require('fiber')\n"
"  table_of_selected_tuples = box.space.tester:select{1000}\n"
"  if table_of_selected_tuples ~= nil then\n"
"    if table_of_selected_tuples[1] ~= nil then\n"
"      if #table_of_selected_tuples[1] == 3 then\n"
"        box.error({code=1, reason='This tuple already has 3 fields'})\n"
"      end\n"
"    end\n"
"  end\n"
"  replaced_tuple = box.space.tester:replace\n"
"    {1000,  require('uuid').str(), tostring(fiber.time())}\n"
"  time_field = tonumber(replaced_tuple[3])\n"
"  formatted_time_field = os.date(\"%Y-%m-%d %H:%M:%S\", time_field)\n"
"  c = time_field % 1\n"
"  d = string.sub(c, 3, 6)\n"
"  formatted_time_field = formatted_time_field .. '.' .. d\n"
"  return formatted_time_field\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:900 ../doc/1.7/book/box/box_tuple.rst:369
msgid "... And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:902
msgid ""
"tarantool> box.space.tester:delete(1000)\n"
"---\n"
"- [1000, '264ee2da03634f24972be76c43808254', '1391037015.6809']\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- 2014-01-29 16:11:51.1582\n"
"...\n"
"tarantool> example(1000)\n"
"---\n"
"- error: 'This tuple already has 3 fields'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:919
msgid "Example showing a user-defined iterator"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:921
msgid ""
"Here is an example that shows how to build one's own iterator. The "
"``paged_iter`` function is an \"iterator function\", which will only be "
"understood by programmers who have read the Lua manual section `Iterators"
" and Closures <https://www.lua.org/pil/7.1.html>`_. It does paginated "
"retrievals, that is, it returns 10 tuples at a time from a table named "
"\"t\", whose primary key was defined with "
"``create_index('primary',{parts={1,'string'}})``."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:928
msgid ""
"function paged_iter(search_key, tuples_per_page)\n"
"  local iterator_string = \"GE\"\n"
"  return function ()\n"
"  local page = box.space.t.index[0]:select(search_key,\n"
"    {iterator = iterator_string, limit=tuples_per_page})\n"
"  if #page == 0 then return nil end\n"
"  search_key = page[#page][1]\n"
"  iterator_string = \"GT\"\n"
"  return page\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:942
msgid ""
"Programmers who use ``paged_iter`` do not need to know why it works, they"
" only need to know that, if they call it within a loop, they will get 10 "
"tuples at a time until there are no more tuples. In this example the "
"tuples are merely printed, a page at a time. But it should be simple to "
"change the functionality, for example by yielding after each retrieval, "
"or by breaking when the tuples fail to match some additional criteria."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:949
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i = 1, #page, 1 do\n"
"    print(page[i])\n"
"  end\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:962
msgid "Submodule `box.index` with index type = RTREE for spatial searches"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:964
msgid ""
"The :ref:`box.index <box_index>` submodule may be used for spatial "
"searches if the index type is RTREE. There are operations for searching "
"*rectangles* (geometric objects with 4 corners and 4 sides) and *boxes* "
"(geometric objects with more than 4 corners and more than 4 sides, "
"sometimes called hyperrectangles). This manual uses the term *rectangle-"
"or-box* for the whole class of objects that includes both rectangles and "
"boxes. Only rectangles will be illustrated."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:972
msgid ""
"Rectangles are described according to their X-axis (horizontal axis) and "
"Y-axis (vertical axis) coordinates in a grid of arbitrary size. Here is a"
" picture of four rectangles on a grid with 11 horizontal points and 11 "
"vertical points:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:978
msgid ""
"           X AXIS\n"
"           1   2   3   4   5   6   7   8   9   10  11\n"
"        1\n"
"        2  #-------+                                           "
"<-Rectangle#1\n"
"Y AXIS  3  |       |\n"
"        4  +-------#\n"
"        5          #-----------------------+                   "
"<-Rectangle#2\n"
"        6          |                       |\n"
"        7          |   #---+               |                   "
"<-Rectangle#3\n"
"        8          |   |   |               |\n"
"        9          |   +---#               |\n"
"        10         +-----------------------#\n"
"        11                                     #               "
"<-Rectangle#4"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:992
msgid ""
"The rectangles are defined according to this scheme: {X-axis coordinate "
"of top left, Y-axis coordinate of top left, X-axis coordinate of bottom "
"right, Y-axis coordinate of bottom right} -- or more succinctly: "
"{x1,y1,x2,y2}. So in the picture ... Rectangle#1 starts at position 1 on "
"the X axis and position 2 on the Y axis, and ends at position 3 on the X "
"axis and position 4 on the Y axis, so its coordinates are {1,2,3,4}. "
"Rectangle#2's coordinates are {3,5,9,10}. Rectangle#3's coordinates are "
"{4,7,5,9}. And finally Rectangle#4's coordinates are {10,11,10,11}. "
"Rectangle#4 is actually a \"point\" since it has zero width and zero "
"height, so it could have been described with only two digits: {10,11}."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1002
msgid ""
"Some relationships between the rectangles are: \"Rectangle#1's nearest "
"neighbor is Rectangle#2\", and \"Rectangle#3 is entirely inside "
"Rectangle#2\"."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1005
msgid "Now let us create a space and add an RTREE index."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1007
msgid ""
"tarantool> s = box.schema.space.create('rectangles')\n"
"tarantool> i = s:create_index('primary', {\n"
"         >   type = 'HASH',\n"
"         >   parts = {1, 'unsigned'}\n"
"         > })\n"
"tarantool> r = s:create_index('rtree', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1020
msgid ""
"Field#1 doesn't matter, we just make it because we need a primary-key "
"index. (RTREE indexes cannot be unique and therefore cannot be primary-"
"key indexes.) The second field must be an \"array\", which means its "
"values must represent {x,y} points or {x1,y1,x2,y2} rectangles. Now let "
"us populate the table by inserting two tuples, containing the coordinates"
" of Rectangle#2 and Rectangle#4."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1026
msgid ""
"tarantool> s:insert{1, {3, 5, 9, 10}}\n"
"tarantool> s:insert{2, {10, 11}}"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1031
msgid ""
"And now, following the description of `RTREE iterator types`_, we can "
"search the rectangles with these requests:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1036
msgid ""
"tarantool> r:select({10, 11, 10, 11}, {iterator = 'EQ'})\n"
"---\n"
"- - [2, [10, 11]]\n"
"...\n"
"tarantool> r:select({4, 7, 5, 9}, {iterator = 'GT'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"...\n"
"tarantool> r:select({1, 2, 3, 4}, {iterator = 'NEIGHBOR'})\n"
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"  - [2, [10, 11]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1052
msgid ""
"Request#1 returns 1 tuple because the point {10,11} is the same as the "
"rectangle {10,11,10,11} (\"Rectangle#4\" in the picture). Request#2 "
"returns 1 tuple because the rectangle {4,7,5,9}, which was "
"\"Rectangle#3\" in the picture, is entirely within{3,5,9,10} which was "
"Rectangle#2. Request#3 returns 2 tuples, because the NEIGHBOR iterator "
"always returns all tuples, and the first returned tuple will be "
"{3,5,9,10} (\"Rectangle#2\" in the picture) because it is the closest "
"neighbor of {1,2,3,4} (\"Rectangle#1\" in the picture)."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1060
msgid ""
"Now let us create a space and index for cuboids, which are rectangle-or-"
"boxes that have 6 corners and 6 sides."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1063
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   dimension = 3,\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1074
msgid ""
"The additional option here is ``dimension=3``. The default dimension is "
"2, which is why it didn't need to be specified for the examples of "
"rectangle. The maximum dimension is 20. Now for insertions and selections"
" there will usually be 6 coordinates. For example:"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1079
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2, 1, 2}, {iterator = box.index.GT})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1084
msgid ""
"Now let us create a space and index for Manhattan-style spatial objects, "
"which are rectangle-or-boxes that have a different way to calculate "
"neighbors."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1087
msgid ""
"tarantool> s = box.schema.space.create('R')\n"
"tarantool> i = s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> r = s:create_index('S', {\n"
"         >   type = 'RTREE',\n"
"         >   unique = false,\n"
"         >   distance = 'manhattan',\n"
"         >   parts = {2, 'ARRAY'}\n"
"         > })"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1098
msgid ""
"The additional option here is ``distance='manhattan'``. The default "
"distance calculator is 'euclid', which is the straightforward as-the-"
"crow-flies method. The optional distance calculator is 'manhattan', which"
" can be a more appropriate method if one is following the lines of a grid"
" rather than traveling in a straight line."
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1104
msgid ""
"tarantool> s:insert{1, {0, 3, 0, 3}}\n"
"tarantool> r:select({1, 2, 1, 2}, {iterator = box.index.NEIGHBOR})"
msgstr ""

#: ../doc/1.7/book/box/box_index.rst:1110
msgid ""
"More examples of spatial searching are online in the file `R tree index "
"quick start and usage`_."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:33
#: ../doc/1.7/book/box/box_introspection.rst:60
msgid "Submodule `box.info`"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:37
#: ../doc/1.7/book/box/box_introspection.rst:64
msgid ""
"The ``box.info`` submodule provides access to information about server "
"instance variables."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:40
msgid ""
"**version** is the Tarantool version. This value is also shown by "
":ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:42
msgid "**id** corresponds to **replication.id** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:43
msgid ""
"**ro** is ``true`` if the instance is in \"read-only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in ``box.cfg{}``)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:45
msgid "**vclock** corresponds to **replication.downstream.vclock** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:46
msgid ""
"**uptime** is the number of seconds since the instance started. This "
"value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:48
msgid "**lsn** corresponds to **replication.lsn** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:49
msgid "**vinyl** returns runtime statistics for vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:50
msgid ""
"**cluster.uuid** is the UUID of the replica set. Every instance in a "
"replica set will have the same ``cluster.uuid`` value. This value is also"
" stored in :ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:54
msgid ""
"**pid** is the process ID. This value is also shown by :ref:`tarantool "
"<tarantool-build>` module and by the Linux command ``ps -A``."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:57
msgid "**status** corresponds to **replication.upstream.status** (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:58
msgid ""
"**signature** is the sum of all **lsn** values from the vector clocks "
"(**vclock**) of all instances in the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:60
msgid "**uuid** corresponds to **replication.uuid**  (see below)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:64
msgid ""
"**replication** part contains statistics for all instances in the replica"
" set in regard to the current instance (see an example in the section "
":ref:`\"Monitoring a replica set\" <replication-monitoring>`):"
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:68
msgid ""
"**replication.id** is a short numeric identifier of the instance within "
"the replica set."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:70
msgid ""
"**replication.uuid** is a globally unique identifier of the instance. "
"This value is also stored in :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:73
msgid ""
"**replication.lsn** is the :ref:`log sequence number <replication-"
"mechanism>` (LSN) for the latest entry in the instance's :ref:`write "
"ahead log <index-box_persistence>` (WAL)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:76
msgid ""
"**replication.upstream** contains statistics for the replication data "
"uploaded by the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:78
msgid "**replication.upstream.status** is the replication status of the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:80
msgid ""
"``auth`` means that the instance is getting authenticated to connect to a"
" replication source."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:82
msgid ""
"``connecting`` means that the instance is trying to connect to the "
"replications source(s) listed in its :ref:`replication <cfg_replication-"
"replication>` parameter."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:85
msgid ""
"``disconnected`` means that the instance is not connected to the replica "
"set (due to network problems, not replication errors)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:87
msgid ""
"``follow`` means that the instance's role is \"replica\" (read-only) and "
"replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:89
msgid ""
"``running`` means the instance's role is \"master\" (non read-only) and "
"replication is in progress."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:91
msgid ""
"``stopped`` means that replication was stopped due to a replication error"
" (e.g. duplicate key)."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:94
msgid ""
"**replication.upstream.idle** is the time (in seconds) since the instance"
" received the last event from a master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:96
msgid ""
"**replication.upstream.lag** is the time difference between the local "
"time at the instance, recorded when the event was received, and the local"
" time at another master recorded when the event was written to the write "
"ahead log on that master."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:101
msgid ""
"Since ``lag`` calculation uses operating system clock from two different "
"machines, don’t be surprised if it’s negative: a time drift may lead to "
"the remote master clock being consistently behind the local instance's "
"clock."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:105
msgid "For multi-master configurations, this is the maximal lag."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:107
msgid ""
"**replication.downstream** contains statistics for the replication data "
"requested and downloaded from the instance."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:109
msgid ""
"**replication.downstream.vclock** is the instance's :ref:`vector clock "
"<internals-vector>`, which contains a pair '**id**, **lsn**'."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:114
#: ../doc/1.7/book/box/box_introspection.rst:98
msgid ""
"Since ``box.info`` contents are dynamic, it's not possible to iterate "
"over keys with the Lua ``pairs()`` function. For this purpose, "
"``box.info()`` builds and returns a Lua table with all keys and values "
"provided in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:119
#: ../doc/1.7/book/box/box_introspection.rst:103
msgid "keys and values in the submodule."
msgstr ""

#: ../doc/1.7/book/box/box_info.rst:124
msgid ""
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 1\n"
"  ro: false\n"
"  vclock: {1: 8}\n"
"  uptime: 7280\n"
"  lsn: 8\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: f7c0c1c6-f9d8-4df7-82ff-d4bd00610a6c\n"
"  pid: 16162\n"
"  status: running\n"
"  signature: 8\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"      lsn: 8\n"
"    2:\n"
"      id: 2\n"
"      uuid: bd949e5d-7ff9-413e-b4f2-c9b0149fdda6\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7256.7571430206\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"    3:\n"
"      id: 3\n"
"      uuid: c5cb61d5-fa48-460d-abd7-3f13709d07a7\n"
"      lsn: 0\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 7255.7510120869\n"
"        lag: 0\n"
"      downstream:\n"
"        vclock: {1: 8}\n"
"  uuid: 1899631e-6369-40a1-81c9-7d170e909276\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:66
msgid "**server.lsn** Log Sequence Number for the latest entry in the WAL."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:67
msgid ""
"**server.ro**  True if the instance is in \"read_only\" mode (same as "
":ref:`read_only <cfg_basic-read_only>` in box.cfg)."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:69
msgid ""
"**server.uuid** The unique identifier of this instance, as stored in the "
"database. This value is also in the :ref:`box.space._cluster <box_space-"
"cluster>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:72
msgid "**server.id** The number of this server's instance within a replica set."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:73
msgid ""
"**version** Tarantool version. This value is also shown by "
":ref:`tarantool --version <index-tarantool_version>`."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:75
msgid ""
"**status** Usually this is 'running', but it can be 'loading', 'orphan', "
"or 'hot_standby'."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:76
msgid "**vclock** Same as replication.vclock."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:77
msgid ""
"**pid** Process ID. This value is also shown by the :ref:`tarantool "
"<tarantool-build>` module. This value is also shown by the Linux \"ps "
"-A\" command."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:80
msgid ""
"**cluster.uuid** UUID of the replica set. Every instance in a replica set"
" will have the same cluster.uuid value. This value is also in the "
":ref:`box.space._schema <box_space-schema>` system space."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:82
msgid "**vinyl()** Returns runtime statistics for the vinyl storage engine."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:83
msgid ""
"**replication.lag** Number of seconds that the replica is behind the "
"master."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:84
msgid ""
"**replication.status** Usually this is 'follow', but it can be 'off', "
"'stopped', 'connecting', 'auth', or 'disconnected'."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:86
msgid "**replication.idle** Number of seconds that the instancehas been idle."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:87
msgid ""
"**replication.vclock** See the :ref:`discussion of \"vector clock\" "
"<internals-vector>` in the Internals section."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:88
msgid ""
"**replication.uuid** The unique identifier of a master to which this "
"instance is connected."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:89
msgid ""
"**replication.uptime** Number of seconds since the instance started. This"
" value can also be retrieved with :ref:`tarantool.uptime() <tarantool-"
"build>`."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:92
msgid ""
"The replication fields are blank unless the instance is a :ref:`replica "
"<index-box_replication>`. The replication fields are in an array if the "
"instance is a replica for more than one master."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:108
msgid ""
"tarantool> box.info()\n"
"---\n"
"- server:\n"
"    lsn: 158\n"
"    ro: false\n"
"    uuid: a2684219-b2b1-4334-88ab-50b0722283fd\n"
"    id: 1\n"
"  version: 1.7.2-435-g6ba8500\n"
"  pid: 12932\n"
"  status: running\n"
"  vclock:\n"
"  - 158\n"
"  replication:\n"
"    status: off\n"
"  uptime: 908\n"
"...\n"
"tarantool> box.info.pid\n"
"---\n"
"- 12932\n"
"...\n"
"tarantool> box.info.status\n"
"---\n"
"- running\n"
"...\n"
"tarantool> box.info.uptime\n"
"---\n"
"- 1065\n"
"...\n"
"tarantool> box.info.version\n"
"---\n"
"- 1.7.2-435-g6ba8500\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:147
#: ../doc/1.7/book/box/box_slab.rst:33
msgid "Submodule `box.slab`"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:151
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store tuples. This can "
"be used to monitor the total memory use and memory fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:155
msgid ""
"The display of slabs is broken down by the slab size -- 64-byte, "
"136-byte, and so on. The example omits the slabs which are empty. The "
"example display is saying that: * there are 16 items stored in the "
"64-byte slab (and 16*64=102 so bytes_used = 1024); * there is 1 item "
"stored in the 136-byte slab (and 136*1=136 so bytes_used = 136); * the "
"``arena_used`` value is the total of all the bytes_used values (1024+136 "
"= 1160); * the ``arena_size`` value is the ``arena_used`` value plus the "
"total of all the"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:162
msgid "bytes_free values (1160+4193200+4194088 = 8388448)."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:164
#, python-format
msgid ""
"The ``arena_size`` and ``arena_used`` values are the amount of the % of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` that is already "
"distributed to the slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:170
msgid ""
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 4194304\n"
"...\n"
"tarantool> box.slab.info().arena_size\n"
"---\n"
"- 104857600\n"
"...\n"
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16248\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15736\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"    <...>\n"
"...\n"
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 15736\n"
"  mem_used: 560\n"
"  item_count: 14\n"
"  item_size: 40\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:210
#: ../doc/1.7/book/box/box_stat.rst:33
msgid "Submodule `box.stat`"
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:212
#: ../doc/1.7/book/box/box_stat.rst:35
msgid ""
"The ``box.stat`` submodule provides access to request and network "
"statistics. Show the average number of requests per second, and the total"
" number of requests since startup, broken down by request type and "
"network events statistics."
msgstr ""

#: ../doc/1.7/book/box/box_introspection.rst:216
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: []\n"
"- []\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:33
msgid "Submodule `box.schema`"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:37
msgid ""
"The ``box.schema`` submodule has data-definition functions for spaces, "
"users, roles, and function tuples."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:44
msgid "Create a space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:46
msgid ""
"name of space, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:48
msgid "see \"Options for box.schema.space.create\" chart, below"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:50
msgid "space object"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:51
#: ../doc/1.7/dev_guide/documentation_guidelines.rst:237
#: ../doc/1.7/reference/reference_lua/fiber.rst:91
#: ../doc/1.7/reference/reference_lua/fiber.rst:115
#: ../doc/1.7/reference/reference_lua/fiber.rst:135
#: ../doc/1.7/reference/reference_lua/fio.rst:382
#: ../doc/1.7/reference/reference_lua/http.rst:50
#: ../doc/1.7/reference/reference_lua/iconv.rst:56
#: ../doc/1.7/reference/reference_lua/net_box.rst:148
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:78
#: ../doc/1.7/reference/reference_lua/socket.rst:139
#: ../doc/1.7/reference/reference_lua/socket.rst:157
#: ../doc/1.7/reference/reference_lua/socket.rst:347
#: ../doc/1.7/reference/reference_lua/socket.rst:373
#: ../doc/1.7/reference/reference_lua/tap.rst:51
msgid "userdata"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:55
msgid "**Options for box.schema.space.create**"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:52
#: ../doc/1.7/book/box/box_space.rst:256 ../doc/1.7/book/box/box_space.rst:1384
msgid "Name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:63 ../doc/1.7/book/box/box_space.rst:256
msgid "Default"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65
msgid "temporary"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65
msgid ""
"space contents are temporary: changes are not stored in the :ref:`write-"
"ahead log <internals-wal>` and there is no :ref:`replication "
"<replication>`. Note re storage engine: vinyl does not support temporary "
"spaces."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:65 ../doc/1.7/book/box/box_schema.rst:83
#: ../doc/1.7/reference/reference_lua/msgpack.rst:165
msgid "false"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73 ../doc/1.7/book/box/box_space.rst:262
msgid "id"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73
msgid ""
"unique identifier: users can refer to spaces with the id instead of the "
"name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:73
msgid "last space's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid "field_count"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid ""
"fixed count of fields: for example if field_count=5, it is illegal to "
"insert a tuple with fewer than or more than 5 fields"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:77
msgid "0 i.e. not fixed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83 ../doc/1.7/book/box/box_space.rst:266
msgid "if_not_exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:83
msgid ""
"create space only if a space with the same name does not exist already, "
"otherwise do nothing but do not cause an error"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "engine"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "storage engine: 'memtx' or 'vinyl'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89 ../doc/1.7/book/box/box_schema.rst:92
#: ../doc/1.7/book/box/box_schema.rst:309
#: ../doc/1.7/book/box/box_session.rst:66
#: ../doc/1.7/book/box/box_session.rst:85
#: ../doc/1.7/book/box/data_model.rst:185
#: ../doc/1.7/reference/reference_lua/errno.rst:67
#: ../doc/1.7/reference/reference_lua/fiber.rst:186
#: ../doc/1.7/reference/reference_lua/fiber.rst:290
#: ../doc/1.7/reference/reference_lua/fiber.rst:335
#: ../doc/1.7/reference/reference_lua/fio.rst:62
#: ../doc/1.7/reference/reference_lua/fio.rst:82
#: ../doc/1.7/reference/reference_lua/fio.rst:100
#: ../doc/1.7/reference/reference_lua/json.rst:49
#: ../doc/1.7/reference/reference_lua/msgpack.rst:46
#: ../doc/1.7/reference/reference_lua/pickle.rst:88
#: ../doc/1.7/reference/reference_lua/socket.rst:285
#: ../doc/1.7/reference/reference_lua/socket.rst:316
#: ../doc/1.7/reference/reference_lua/socket.rst:332
#: ../doc/1.7/reference/reference_lua/uri.rst:76
#: ../doc/1.7/reference/reference_lua/yaml.rst:46
msgid "string"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:89
msgid "'memtx'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92 ../doc/1.7/book/box/box_space.rst:1386
#: ../doc/1.7/book/box/box_space.rst:1389
msgid "user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92
msgid ""
"name of the user who is considered to be the space's :ref:`owner "
"<authentication-owners_privileges>` for authorization purposes"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:92
msgid "current user's name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid "format"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid ""
"field names and types: For an illustration with the ``format`` option, "
"see the :ref:`box.space._space <box_space-space>` example."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:97
msgid "(blank)"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:104
msgid ""
"There are three :ref:`syntax variations <app_server-object_reference>` "
"for object references targeting space objects, for example "
":samp:`box.schema.space.drop({space-id})` will drop a space. However, the"
" common approach is to use functions attached to the space objects, for "
"example :ref:`space_object:drop() <box_space-drop>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:113
msgid ""
"tarantool> s = box.schema.space.create('space55')\n"
"---\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   id = 555,\n"
"         >   temporary = false\n"
"         > })\n"
"---\n"
"- error: Space 'space55' already exists\n"
"...\n"
"tarantool> s = box.schema.space.create('space55', {\n"
"         >   if_not_exists = true\n"
"         > })\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:131
msgid ""
"After a space is created, usually the next step is to :ref:`create an "
"index <box_space-create_index>` for it, and then it is available for "
"insert, select, and all the other :ref:`box.space <box_space>` functions."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:139
msgid ""
"Create a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users<authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:144
#: ../doc/1.7/book/box/box_schema.rst:235
#: ../doc/1.7/book/box/box_schema.rst:506
msgid "The possible options are:"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:146
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already exists,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:149
msgid ""
"``password`` (default = '') - string; the ``password`` = *password* "
"specification is good because in a :ref:`URI <index-uri>` (Uniform "
"Resource Identifier) it is usually illegal to include a user-name without"
" a password."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:156
#: ../doc/1.7/book/box/box_space.rst:1468
msgid "The maximum number of users is 32."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:158
msgid ""
"name of user, which should not be a number and should not contain special"
" characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:160
msgid "``if_not_exists``, ``password``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:164
#: ../doc/1.7/book/box/box_schema.rst:185
msgid "**Examples:**"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:166
msgid ""
"box.schema.user.create('Lena')\n"
"box.schema.user.create('Lena', {password = 'X'})\n"
"box.schema.user.create('Lena', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:176
msgid ""
"Drop a user. For explanation of how Tarantool maintains user data, see "
"section :ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:181
#: ../doc/1.7/book/box/box_schema.rst:201
#: ../doc/1.7/book/box/box_schema.rst:219
#: ../doc/1.7/book/box/box_schema.rst:260
msgid "the name of the user"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:182
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the user does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:187
msgid ""
"box.schema.user.drop('Lena')\n"
"box.schema.user.drop('Lena',{if_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:196
msgid ""
"Return ``true`` if a user exists; return ``false`` if a user does not "
"exist. For explanation of how Tarantool maintains user data, see section "
":ref:`Users <authentication-users>` and reference on :ref:`_user "
"<box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:202
#: ../doc/1.7/book/box/box_schema.rst:410
#: ../doc/1.7/book/box/box_schema.rst:560
#: ../doc/1.7/reference/reference_lua/uuid.rst:134
msgid "bool"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:206
msgid "box.schema.user.exists('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:216
msgid ""
"Grant :ref:`privileges <authentication-owners_privileges>` to a user or "
"to another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:220
msgid "'read' or 'write' or 'execute' or a combination,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:221
msgid "'space' or 'function'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:222
msgid "name of object to grant permissions to"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:223
msgid "name of role to grant to user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:224
msgid "``grantor``, ``if_not_exists``"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:226
msgid ""
"If :samp:`'function','{object-name}'` is specified, then a _func tuple "
"with that object-name must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:229
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'. In this case, object name"
" is omitted."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:232
#: ../doc/1.7/book/box/box_schema.rst:271
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` (see section :ref:`Roles <authentication-roles>`)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:237
msgid ""
"``grantor`` = *grantor_name_or_id* -- string or number, for custom "
"grantor,"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:238
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the user already has the "
"privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:243
msgid ""
"box.schema.user.grant('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.grant('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.grant('Lena', 'read,write', 'universe')\n"
"box.schema.user.grant('Lena', 'Accountant')\n"
"box.schema.user.grant('Lena', 'read,write,execute', 'universe')\n"
"box.schema.user.grant('X', 'read', 'universe', nil, {if_not_exists=true}))"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:257
msgid ""
"Revoke :ref:`privileges <authentication-owners_privileges>` from a user "
"or from another role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:261
#: ../doc/1.7/book/box/box_schema.rst:427
#: ../doc/1.7/book/box/box_schema.rst:459
msgid "'read' or 'write' or 'execute' or a combination"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:262
#: ../doc/1.7/book/box/box_schema.rst:428
#: ../doc/1.7/book/box/box_schema.rst:460
msgid "'space' or 'function'"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:263
#: ../doc/1.7/book/box/box_schema.rst:429
#: ../doc/1.7/book/box/box_schema.rst:461
msgid "the name of a function or space"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:265
msgid ""
"The user must exist, and the object must exist, but it is not an error if"
" the user does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:268
#: ../doc/1.7/book/box/box_schema.rst:436
#: ../doc/1.7/book/box/box_schema.rst:466
msgid ""
"**Variation:** instead of ``object-type, object-name`` say 'universe' "
"which means 'all object-types and all objects'."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:276
msgid ""
"box.schema.user.revoke('Lena', 'read', 'space', 'tester')\n"
"box.schema.user.revoke('Lena', 'execute', 'function', 'f')\n"
"box.schema.user.revoke('Lena', 'read,write', 'universe')\n"
"box.schema.user.revoke('Lena', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:287
msgid ""
"Return a hash of a user's password. For explanation of how Tarantool "
"maintains passwords, see section :ref:`Passwords <authentication-"
"passwords>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:293
msgid ""
"If a non-'guest' user has no password, it’s **impossible** to connect to "
"Tarantool using this user. The user is regarded as “internal” only, not "
"usable from a remote connection. Such users can be useful if they have "
"defined some procedures with the :ref:`SETUID <box_schema-func_create>` "
"option, on which privileges are granted to externally-connectable users. "
"This way, external users cannot create/drop objects, they can only invoke"
" procedures."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:300
msgid ""
"For the 'guest' user, it’s impossible to set a password: that would be "
"misleading, since 'guest' is the default user on a newly-established "
"connection over a :ref:`binary port <admin-security>`, and Tarantool does"
" not require a password to establish a binary connection. It is, however,"
" possible to change the current user to ‘guest’ by providing the AUTH "
"packet with no password at all or an empty password. This feature is "
"useful for connection pools, which want to reuse a connection for a "
"different user without re-establishing it."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:308
msgid "password to be hashed"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:313
msgid "box.schema.user.password('ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:321
msgid ""
"Associate a password with the user who is currently logged in, or with "
"another user."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:324
msgid ""
"Users who wish to change their own passwords should use "
"``box.schema.user.passwd(password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:327
msgid ""
"Administrators who wish to change passwords of other users should use "
"``box.schema.user.passwd(user-name, password)`` syntax."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:330
msgid "user-name"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:331
msgid "password"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:335
msgid ""
"box.schema.user.passwd('ЛЕНА')\n"
"box.schema.user.passwd('Lena', 'ЛЕНА')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:344
msgid ""
"Return a description of a user's privileges. For explanation of how "
"Tarantool maintains user data, see section :ref:`Users <authentication-"
"users>` and reference on :ref:`_user <box_space-user>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:349
msgid ""
"the name of the user. This is optional; if it is not supplied, then the "
"information will be for the user who is currently logged in."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:357
msgid ""
"box.schema.user.info()\n"
"box.schema.user.info('Lena')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:366
msgid ""
"Create a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:370
msgid ""
"name of role, which should not be a number and should not contain special"
" characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:372
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already exists"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:380
msgid ""
"box.schema.role.create('Accountant')\n"
"box.schema.role.create('Accountant', {if_not_exists = false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:389
msgid ""
"Drop a role. For explanation of how Tarantool maintains role data, see "
"section :ref:`Roles <authentication-roles>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:393
#: ../doc/1.7/book/box/box_schema.rst:409
#: ../doc/1.7/book/box/box_schema.rst:426
#: ../doc/1.7/book/box/box_schema.rst:458
msgid "the name of the role"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:394
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the role does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:399
msgid "box.schema.role.drop('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:407
msgid ""
"Return ``true`` if a role exists; return ``false`` if a role does not "
"exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:414
msgid "box.schema.role.exists('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:424
msgid "Grant :ref:`privileges <authentication-owners_privileges>` to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:430
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the role already has the "
"privilege"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:434
msgid "The role must exist, and the object must exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:439
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name`` -- to grant a role to a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:444
msgid ""
"box.schema.role.grant('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.grant('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.grant('Accountant', 'read,write', 'universe')\n"
"box.schema.role.grant('public', 'Accountant')\n"
"box.schema.role.grant('role1', 'role2', nil, nil, {if_not_exists=false})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:456
msgid "Revoke :ref:`privileges <authentication-owners_privileges>` from a role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:463
msgid ""
"The role must exist, and the object must exist, but it is not an error if"
" the role does not have the privilege."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:469
msgid ""
"**Variation:** instead of ``privilege, object-type, object-name`` say "
"``role-name``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:474
msgid ""
"box.schema.role.revoke('Accountant', 'read', 'space', 'tester')\n"
"box.schema.role.revoke('Accountant', 'execute', 'function', 'f')\n"
"box.schema.role.revoke('Accountant', 'read,write', 'universe')\n"
"box.schema.role.revoke('public', 'Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:485
msgid "Return a description of a role's privileges."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:487
msgid "the name of the role."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:491
msgid "box.schema.role.info('Accountant')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:499
msgid ""
"Create a function tuple. This does not create the function itself -- that"
" is done with Lua -- but if it is necessary to grant privileges for a "
"function, box.schema.func.create must be done first. For explanation of "
"how Tarantool maintains function data, see reference on :ref:`_func "
"<box_space-func>` space."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:508
msgid ""
"``if_not_exists`` = ``true|false`` (default = ``false``) - boolean; "
"``true`` means there should be no error if the ``_func`` tuple already "
"exists."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:511
msgid ""
"``setuid`` = ``true|false`` (default = false) - with ``true`` to make "
"Tarantool treat the function’s caller as the function’s creator, with "
"full privileges. Remember that SETUID works only over :ref:`binary ports "
"<admin-security>`. SETUID doesn't work if you invoke a function via an "
"admin console or inside a Lua script."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:518
msgid "``language`` = 'LUA'|'C' (default = ‘LUA’)."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:520
msgid ""
"name of function, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:522
msgid "``if_not_exists``, ``setuid``, ``language``."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:528
msgid ""
"box.schema.func.create('calculate')\n"
"box.schema.func.create('calculate', {if_not_exists = false})\n"
"box.schema.func.create('calculate', {setuid = false})\n"
"box.schema.func.create('calculate', {language = 'LUA'})"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:539
msgid ""
"Drop a function tuple. For explanation of how Tarantool maintains "
"function data, see reference on :ref:`_func space <box_space-func>`."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:543
#: ../doc/1.7/book/box/box_schema.rst:559
msgid "the name of the function"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:544
msgid ""
"``if_exists`` = ``true|false`` (default = ``false``) - boolean; ``true`` "
"means there should be no error if the _func tuple does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:549
msgid "box.schema.func.drop('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:557
msgid ""
"Return true if a function tuple exists; return false if a function tuple "
"does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_schema.rst:564
msgid "box.schema.func.exists('calculate')"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:33
msgid "Submodule `box.session`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:35
msgid ""
"The ``box.session`` submodule allows querying the session state, writing "
"to a session-specific temporary Lua table, or setting up triggers which "
"will fire when a session starts or ends. A *session* is an object "
"associated with each client connection."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:44
msgid ""
"the unique identifier (ID) for the current session. The result can be 0 "
"meaning there is no session."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:50
msgid "1 if the session exists, 0 if the session does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:55
msgid ""
"This function works only if there is a peer, that is, if a connection has"
" been made to a separate Tarantool instance."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:58
msgid ""
"The host address and port of the session peer, for example "
"\"127.0.0.1:55457\". If the session exists but there is no connection to "
"a separate instance, the return is null. The command is executed on the "
"server instance, so the \"local name\" is the server instance's host and "
"port, and the \"peer name\" is the client's host and port."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:68
msgid "Possible errors: 'session.peer(): session does not exist'"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:74
msgid ""
"the value of the :code:`sync` integer constant used in the `binary "
"protocol "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:83
msgid "the name of the :ref:`current user <authentication-users>`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:91
msgid ""
"Change Tarantool's :ref:`current user <authentication-users>` -- this is "
"analogous to the Unix command ``su``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:94
msgid ""
"Or, if function-to-execute is specified, change Tarantool's :ref:`current"
" user <authentication-users>` temporarily while executing the function --"
" this is analogous to the Unix command ``sudo``."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:99
msgid "name of a target user"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:100
msgid ""
"name of a function, or definition of a function. Additional parameters "
"may be passed to ``box.session.su``, they will be interpreted as "
"parameters of function-to-execute."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:107
msgid ""
"tarantool> function f(a) return box.session.user() .. a end\n"
"---\n"
"...\n"
"\n"
"tarantool> box.session.su('guest', f, '-xxx')\n"
"---\n"
"- guest-xxx\n"
"...\n"
"\n"
"tarantool> box.session.su('guest',function(...) return ... end,1,2)\n"
"---\n"
"- 1\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:129
msgid ""
"A Lua table that can hold arbitrary unordered session-specific names and "
"values, which will last until the session ends. For example, this table "
"could be useful to store current tasks when working with a `Tarantool "
"queue manager <https://github.com/tarantool/queue>`_."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:136
msgid ""
"tarantool> box.session.peer(box.session.id())\n"
"---\n"
"- 127.0.0.1:45129\n"
"...\n"
"tarantool> box.session.storage.random_memorandum = \"Don't forget the "
"eggs\"\n"
"---\n"
"...\n"
"tarantool> box.session.storage.radius_of_mars = 3396\n"
"---\n"
"...\n"
"tarantool> m = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in pairs(box.session.storage) do\n"
"         >   m = m .. k .. '='.. v .. ' '\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> m\n"
"---\n"
"- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:165
msgid ""
"Define a trigger for execution when a new session is created due to an "
"event such as :ref:`console.connect <console-connect>`. The trigger "
"function will be the first thing executed after a new session is created."
" If the trigger execution fails and raises an error, the error is sent to"
" the client and the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:170
#: ../doc/1.7/book/box/box_session.rst:201
#: ../doc/1.7/book/box/box_session.rst:274
#: ../doc/1.7/book/box/box_space.rst:542
msgid "function which will become the trigger function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:171
#: ../doc/1.7/book/box/box_session.rst:202
#: ../doc/1.7/book/box/box_session.rst:275
#: ../doc/1.7/book/box/box_space.rst:544
msgid "existing trigger function which will be replaced by trigger-function"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:172
#: ../doc/1.7/book/box/box_session.rst:203
#: ../doc/1.7/book/box/box_session.rst:276
#: ../doc/1.7/book/box/box_space.rst:547
msgid "nil or function pointer"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:174
#: ../doc/1.7/book/box/box_session.rst:205
#: ../doc/1.7/book/box/box_session.rst:278
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:176
#: ../doc/1.7/book/box/box_session.rst:207
#: ../doc/1.7/book/box/box_session.rst:280
msgid ""
"Details about trigger characteristics are in the :ref:`triggers "
"<triggers-box_triggers>` section."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:180
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_connect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:189
msgid ""
"If a trigger always results in an error, it may become impossible to "
"connect to a server to reset it."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:196
msgid ""
"Define a trigger for execution after a client has disconnected. If the "
"trigger function causes an error, the error is logged but otherwise is "
"ignored. The trigger is invoked while the session associated with the "
"client still exists and can access session properties, such as "
"box.session.id."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:211
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_disconnect(f)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:220
msgid ""
"After the following series of requests, a Tarantool instance will write a"
" message using the :ref:`log <log-module>` module whenever any user "
"connects or disconnects."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:223
msgid ""
"function log_connect ()\n"
"  local log = require('log')\n"
"  local m = 'Connection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"function log_disconnect ()\n"
"  local log = require('log')\n"
"  local m = 'Disconnection. user=' .. box.session.user() .. ' id=' .. "
"box.session.id()\n"
"  log.info(m)\n"
"end\n"
"\n"
"box.session.on_connect(log_connect)\n"
"box.session.on_disconnect(log_disconnect)"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:240
msgid "Here is what might appear in the log file in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:242
msgid ""
"2014-12-15 13:21:34.444 [11360] main/103/iproto I>\n"
"    Connection. user=guest id=3\n"
"2014-12-15 13:22:19.289 [11360] main/103/iproto I>\n"
"    Disconnection. user=guest id=3"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:253
msgid "Define a trigger for execution during authentication."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:255
msgid "The ``on_auth`` trigger function is invoked in these circumstances:"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:257
msgid ""
"The :ref:`console.connect <console-connect>` function includes an "
"authentication check for all users except 'guest'. For this case, the "
"``on_auth`` trigger function is invoked after the ``on_connect`` trigger "
"function, if and only if the connection has succeeded so far."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:262
msgid ""
"The :ref:`binary protocol <admin-security>` has a separate "
":ref:`authentication packet <box_protocol-authentication>`. For this "
"case, connection and authentication are considered to be separate steps."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:266
msgid ""
"Unlike other trigger types, ``on_auth`` trigger functions are invoked "
"**before** the event. Therefore a trigger function like :code:`function "
"auth_function () v = box.session.user(); end` will set :code:`v` to "
"\"guest\", the user name before the authentication is done. To get the "
"user name **after** the authentication is done, use the special syntax: "
":code:`function auth_function (user_name) v = user_name; end`"
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:272
msgid ""
"If the trigger fails by raising an error, the error is sent to the client"
" and the connection is closed."
msgstr ""

#: ../doc/1.7/book/box/box_session.rst:284
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.session.on_auth(f)"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:37
msgid ""
"The ``box.slab`` submodule provides access to slab allocator statistics. "
"The slab allocator is the main allocator used to store tuples. This can "
"be used to monitor the total memory usage and memory fragmentation."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:45
msgid "Show a memory usage report (in bytes) for the Lua runtime."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:49
msgid "``lua`` is the heap size of the Lua garbage collector;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:50
msgid "``maxalloc`` is the maximal memory quota that can be allocated for Lua;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:51
msgid "``used`` is the current memory size used by Lua."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:57
msgid ""
"tarantool> box.runtime.info()\n"
"---\n"
"- lua: 913710\n"
"  maxalloc: 4398046510080\n"
"  used: 12582912\n"
"...\n"
"tarantool> box.runtime.info().used\n"
"---\n"
"- used: 12582912\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:74
msgid "Show an aggregated memory usage report (in bytes) for the slab allocator."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:76
msgid ""
"This report is useful for assessing out-of-memory risks: the risks are "
"high if both ``arena_used_ratio`` and ``quota_used_ratio`` are high "
"(90-95%)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:79
msgid ""
"If ``quota_used_ratio`` is low, then high ``arena_used_ratio`` and/or "
"``items_used_ratio`` indicate that the memory fragmentation is low (i.e. "
"the memory is used efficiently)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:83
msgid ""
"If ``quota_used_ratio`` is high (approaching 100%), then low "
"``arena_used_ratio`` (50-60%) indicates that the memory is heavily "
"fragmentized. Most probably, there is no immediate out-of-memory risk in "
"this case, but generally this is an issue to consider. For example, "
"probable risks are that the entire memory quota is used for tuples, and "
"there is are no slabs left for a piece of an index. Or that all slabs are"
" allocated for storing tuples, but in fact all the slabs are half-empty."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:93
msgid ""
"``items_size`` is the *total* amount of memory (including allocated, but "
"currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:95
msgid ""
"``items_used_ratio`` = ``items_used`` / ``slab_count`` * ``slab_size`` "
"(these are slabs used only for tuples, no indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:97
msgid ""
"``quota_size`` is the maximum amount of memory that the slab allocator "
"can use for both tuples and indexes (as configured in :ref:`memtx_memory "
"<cfg_storage-memtx_memory>` parameter, e.g. the default is 1 gigabyte = "
"2^30 bytes = 1,073,741,824 bytes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:101
msgid "``quota_used_ratio`` = ``quota_used`` / ``quota_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:102
msgid "``arena_used_ratio`` = ``arena_used`` / ``arena_size``;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:103
msgid ""
"``items_used`` is the *efficient* amount of memory (omitting allocated, "
"but currently free slabs) used only for tuples, no indexes;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:105
msgid ""
"``quota_used`` is the amount of memory that is already distributed to the"
" slab allocator;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:107
msgid ""
"``arena_size`` is the *total* memory used for tuples and indexes together"
" (including allocated, but currently free slabs);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:109
msgid ""
"``arena_used`` is the *efficient* memory used for storing tuples and "
"indexes together (omitting allocated, but currently free slabs)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:116
msgid ""
"tarantool> box.slab.info()\n"
"---\n"
"- items_size: 228128\n"
"  items_used_ratio: 1.8%\n"
"  quota_size: 1073741824\n"
"  quota_used_ratio: 0.8%\n"
"  arena_used_ratio: 43.2%\n"
"  items_used: 4208\n"
"  quota_used: 8388608\n"
"  arena_size: 2325176\n"
"  arena_used: 1003632\n"
"...\n"
"\n"
"tarantool> box.slab.info().arena_used\n"
"---\n"
"- 1003632\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:140
msgid ""
"Show a detailed memory usage report (in bytes) for the slab allocator. "
"The report is broken down into groups by *data item size* as well as by "
"*slab size* (64-byte, 136-byte, etc). The report includes the memory "
"allocated for storing both tuples and indexes."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:147
msgid "``mem_free`` is the allocated, but currently unused memory;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:148
msgid ""
"``mem_used`` is the memory used for storing data items (tuples and "
"indexes);"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:149
msgid "``item_count`` is the number of stored items;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:150
msgid "``item_size`` is the size of each data item;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:151
msgid "``slab_count`` is the number of slabs allocated;"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:152
msgid "``slab_size`` is the size of each allocated slab."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:158
msgid "Here is a sample report for the first group:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:160
msgid ""
"tarantool> box.slab.stats()[1]\n"
"---\n"
"- mem_free: 16232\n"
"  mem_used: 48\n"
"  item_count: 2\n"
"  item_size: 24\n"
"  slab_count: 1\n"
"  slab_size: 16384\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:172
msgid ""
"This report is saying that there are 2 data items (``item_count`` = 2) "
"stored in one (``slab_count`` = 1) 24-byte slab (``item_size`` = 24), so "
"``mem_used`` = 2 * 24 = 48 bytes. Also, ``slab_size`` is 16384 bytes, of "
"which 16384 - 48 = 16232 bytes are free (``mem_free``)."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:177
msgid "A complete report would show memory usage statistics for all groups:"
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:179
msgid ""
"tarantool> box.slab.stats()\n"
"---\n"
"- - mem_free: 16232\n"
"    mem_used: 48\n"
"    item_count: 2\n"
"    item_size: 24\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  - mem_free: 15720\n"
"    mem_used: 560\n"
"    item_count: 14\n"
"    item_size: 40\n"
"    slab_count: 1\n"
"    slab_size: 16384\n"
"  <...>\n"
"  - mem_free: 32472\n"
"    mem_used: 192\n"
"    item_count: 1\n"
"    item_size: 192\n"
"    slab_count: 1\n"
"    slab_size: 32768\n"
"  - mem_free: 1097624\n"
"    mem_used: 999424\n"
"    item_count: 61\n"
"    item_size: 16384\n"
"    slab_count: 1\n"
"    slab_size: 2097152\n"
"  ..."
msgstr ""

#: ../doc/1.7/book/box/box_slab.rst:210
msgid ""
"The total ``mem_used`` for all groups in this report equals "
"``arena_used`` in :ref:`box.slab.info() <box_slab_info>` report."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:33
msgid "Submodule `box.space`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:35
msgid ""
"The ``box.space`` submodule has the data-manipulation functions "
"``select``, ``insert``, ``replace``, ``update``, ``upsert``, ``delete``, "
"``get``, ``put``. It also has members, such as id, and whether or not a "
"space is enabled. Submodule source code is available in file "
"`src/box/lua/schema.lua "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/lua/schema.lua>`_."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:41
msgid ""
"A list of all ``box.space`` functions follows, then comes a list of all "
"``box.space`` members."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:44
msgid "**The functions and members of box.space**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:52
msgid "Use"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:54
msgid ":ref:`space_object:auto_increment() <box_space-auto_increment>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:54
msgid "Generate key + Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:57
msgid ":ref:`space_object:bsize() <box_space-bsize>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:57
msgid "Get count of bytes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60
msgid ":ref:`space_object:count() <box_space-count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:60 ../doc/1.7/book/box/box_space.rst:78
msgid "Get count of tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid ":ref:`space_object:create_index() <box_space-create_index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:63
msgid "Create an index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66
msgid ":ref:`space_object:delete() <box_space-delete>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:66
msgid "Delete a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid ":ref:`space_object:drop() <box_space-drop>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:69
msgid "Destroy a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid ":ref:`space_object:get() <box_space-get>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:72
msgid "Select a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid ":ref:`space_object:insert() <box_space-insert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:75
msgid "Insert a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:78
msgid ":ref:`space_object:len() <box_space-len>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid ":ref:`space_object:on_replace() <box_space-on_replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:81
msgid "Create a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid ":ref:`space_object:pairs() <box_space-pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:84
msgid "Prepare for iterating"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87
msgid ":ref:`space_object:put() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:87 ../doc/1.7/book/box/box_space.rst:93
msgid "Insert or replace a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid ":ref:`space_object:rename() <box_space-rename>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:90
msgid "Rename a space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:93
msgid ":ref:`space_object:replace() <box_space-replace>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid ":ref:`space_object:run_triggers() <box_space-run_triggers>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:96
msgid "Enable/disable a replace trigger"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid ":ref:`space_object:select() <box_space-select>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:99
msgid "Select one or more tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid ":ref:`space_object:truncate() <box_space-truncate>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:102
msgid "Delete all tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105
msgid ":ref:`space_object:update() <box_space-update>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:105 ../doc/1.7/book/box/box_space.rst:108
msgid "Update a tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:108
msgid ":ref:`space_object:upsert() <box_space-upsert>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid ":ref:`space_object.enabled <box_space-enabled>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:111
msgid "Flag, true if space is enabled"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid ":ref:`space_object.field_count <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:114
msgid "Required number of fields"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid ":ref:`space_object.id <box_space-id>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:117
msgid "Numeric identifier of space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid ":ref:`space_object.index <box_space-field_count>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:120
msgid "Container of space's indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid ":ref:`box.space._cluster <box_space-cluster>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:123
msgid "(Metadata) List of replica sets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid ":ref:`box.space._func <box_space-func>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:126
msgid "(Metadata) List of function tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid ":ref:`box.space._index <box_space-index>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:129
msgid "(Metadata) List of indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid ":ref:`box.space._priv <box_space-priv>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:132
msgid "(Metadata) List of privileges"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid ":ref:`box.space._schema <box_space-schema>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:135
msgid "(Metadata) List of schemas"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid ":ref:`box.space._space <box_space-space>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:138
msgid "(Metadata) List of spaces"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid ":ref:`box.space._user <box_space-user>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:141
msgid "(Metadata) List of users"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:153
msgid ""
"Insert a new tuple using an auto-increment primary key. The space "
"specified by space_object must have an ``unsigned`` or ``integer`` or "
"``numeric`` primary key index of type ``TREE``. The primary-key field "
"will be incremented before the insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:158 ../doc/1.7/book/box/box_space.rst:188
#: ../doc/1.7/book/box/box_space.rst:211 ../doc/1.7/book/box/box_space.rst:237
#: ../doc/1.7/book/box/box_space.rst:401 ../doc/1.7/book/box/box_space.rst:439
#: ../doc/1.7/book/box/box_space.rst:461 ../doc/1.7/book/box/box_space.rst:493
#: ../doc/1.7/book/box/box_space.rst:516 ../doc/1.7/book/box/box_space.rst:604
#: ../doc/1.7/book/box/box_space.rst:659 ../doc/1.7/book/box/box_space.rst:689
#: ../doc/1.7/book/box/box_space.rst:742 ../doc/1.7/book/box/box_space.rst:816
#: ../doc/1.7/book/box/box_space.rst:876 ../doc/1.7/book/box/box_space.rst:993
msgid "an :ref:`object reference <app_server-object_reference>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:160
msgid "tuple's fields, other than the primary-key field"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:163 ../doc/1.7/book/box/box_space.rst:693
msgid "the inserted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:166 ../doc/1.7/book/box/box_space.rst:446
#: ../doc/1.7/book/box/box_space.rst:471 ../doc/1.7/book/box/box_space.rst:700
msgid ""
"**Complexity factors:** Index size, Index type, Number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:169
msgid ""
"**Possible errors:** index has wrong type or primary-key indexed field is"
" not a number."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:173
msgid ""
"tarantool> box.space.tester:auto_increment{'Fld#1', 'Fld#2'}\n"
"---\n"
"- [1, 'Fld#1', 'Fld#2']\n"
"...\n"
"tarantool> box.space.tester:auto_increment{'Fld#3'}\n"
"---\n"
"- [2, 'Fld#3']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:191
msgid "Number of bytes in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:195
msgid ""
"tarantool> box.space.tester:bsize()\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:202
msgid "Note re storage engine: vinyl does not support ``bsize()``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:213 ../doc/1.7/book/box/box_space.rst:403
#: ../doc/1.7/book/box/box_space.rst:878
msgid ""
"primary-key field values, must be passed as a Lua table if key is multi-"
"part"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:217
msgid "Number of tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:221
msgid ""
"tarantool> box.space.tester:count(2, {iterator='GE'})\n"
"---\n"
"- 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:232
msgid ""
"Create an index. It is mandatory to create an index for a space before "
"trying to insert tuples into it, or select tuples from it. The first "
"created index, which will be used as the primary-key index, must be "
"unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:239
msgid ""
"name of index, which should not be a number and should not contain "
"special characters"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:243
msgid "index object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:244
msgid "index_object"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:248
msgid "Options for ``space_object:create_index``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "type of index"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "string ('HASH' or 'TREE' or 'BITSET' or 'RTREE')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:258
msgid "'TREE'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:262
msgid "unique identifier"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:262
msgid "last index's id, +1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "index is unique"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:264
msgid "``true``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:266
msgid "no error if duplicate name"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:266
msgid "``false``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "parts"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "field-numbers  + types"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid ""
"{field_no, 'unsigned' or 'string' or 'integer' or 'number' or 'array' or "
"'scalar'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:269
msgid "``{1, 'unsigned'}``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274
msgid "dimension"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:276
msgid "affects RTREE only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:274 ../doc/1.7/book/box/box_space.rst:1392
msgid "2"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "distance"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "string ('euclid' or 'manhattan')"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:276
msgid "'euclid'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "bloom_fpr"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279 ../doc/1.7/book/box/box_space.rst:281
#: ../doc/1.7/book/box/box_space.rst:283 ../doc/1.7/book/box/box_space.rst:285
#: ../doc/1.7/book/box/box_space.rst:287
msgid "affects vinyl only"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:279
msgid "``vinyl_bloom_fpr``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:281
msgid "page_size"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:281
msgid "``vinyl_page_size``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:283
msgid "range_size"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:283
msgid "``vinyl_range_size``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "run_count_per_level"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:285
msgid "``vinyl_run_count_per_level``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:287
msgid "run_size_ratio"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:287
msgid "``vinyl_run_size_ratio``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:290
msgid ""
"Note re storage engine: vinyl has extra options which by default are "
"based on configuration parameters :ref:`vinyl_bloom_fpr <cfg_storage-"
"vinyl_bloom_fpr>`, :ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`, "
":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`, "
":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`,"
" and :ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>` -- "
"see the description of those parameters. The current values can be seen "
"by selecting from :ref:`box.space._index <box_space-index>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:301
msgid ""
"**Possible errors:** too many parts. Index '...' already exists. Primary "
"key must be unique."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:303
msgid ""
"tarantool> s = box.space.space55\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary', {unique = true, parts = {1, "
"'unsigned', 2, 'string'}})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:314
msgid "Details about index field types:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:316
msgid ""
"The six index field types (unsigned | string | integer | number | array |"
" scalar) differ depending on what values are allowed, and what index "
"types are allowed."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:320
msgid ""
"**unsigned**: unsigned integers between 0 and 18446744073709551615, about"
" 18 quintillion. May also be called 'uint' or 'num', but 'num' is "
"deprecated. Legal in memtx TREE or HASH indexes, and in vinyl TREE "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:324
msgid ""
"**string**: any set of octets, up to the :ref:`maximum length "
"<limitations_bytes_in_index_key>`. May also be called 'str'. Legal in "
"memtx TREE or HASH or BITSET indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:327
msgid ""
"**integer**: integers between -9223372036854775808 and "
"18446744073709551615. May also be called 'int'. Legal in memtx TREE or "
"HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:330
msgid ""
"**number**: integers between -9223372036854775808 and "
"18446744073709551615, single-precision floating point numbers, or double-"
"precision floating point numbers. Legal in memtx TREE or HASH indexes, "
"and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:334
msgid ""
"**array**: array of integers between -9223372036854775808 and "
"9223372036854775807. Legal in memtx RTREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:336
msgid ""
"**scalar**: null (input with msgpack.NULL or yaml.NULL or json.NULL), "
"booleans (true or false), or integers between -9223372036854775808 and "
"18446744073709551615, or single-precision floating point numbers, or "
"double-precison floating-point numbers, or strings. When there is a mix "
"of types, the key order is: null, then booleans, then numbers, then "
"strings. Legal in memtx TREE or HASH indexes, and in vinyl TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:346
msgid "**Index field types to use in create_index**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "Index field type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "What can be in it"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355
msgid "Where is it legal"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:355 ../doc/1.7/book/box/data_model.rst:275
#: ../doc/1.7/reference/reference_lua/socket.rst:584
msgid "Examples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "**unsigned**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "integers between 0 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357 ../doc/1.7/book/box/box_space.rst:364
#: ../doc/1.7/book/box/box_space.rst:368 ../doc/1.7/book/box/box_space.rst:380
msgid "memtx TREE or HASH indexes, |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:357
msgid "123456 |br|"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "**string**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "strings -- any set of octets"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "memtx TREE or HASH indexes |br| vinyl TREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:361
msgid "'A B C' |br| '\\\\65 \\\\66 \\\\67'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "**integer**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "integers between -9223372036854775808 and 18446744073709551615"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:364
msgid "-2^63 |br|"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368 ../doc/1.7/book/box/data_model.rst:288
msgid "**number**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368
msgid ""
"integers between -9223372036854775808 and 18446744073709551615, single-"
"precision floating point numbers, double-precision floating point numbers"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:368
msgid "1.234 |br| -44 |br| 1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376 ../doc/1.7/book/box/data_model.rst:302
msgid "**array**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "array of integers between -9223372036854775808 and 9223372036854775807"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "memtx RTREE indexes"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:376
msgid "{10, 11} |br| {3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:380 ../doc/1.7/book/box/data_model.rst:307
msgid "**scalar**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:380
msgid ""
"null, booleans (true or false), integers between -9223372036854775808 and"
" 18446744073709551615, single-precision floating point numbers, double-"
"precision floating point numbers, strings"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:380
msgid "null |br| true |br| -1 |br| 1.234 |br| '' |br| 'ру'"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:391
msgid ""
"Note re storage engine: vinyl supports only the TREE index type, and "
"vinyl secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:399
msgid "Delete a tuple identified by a primary key."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:406
msgid "the deleted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:409
msgid "**Complexity factors:** Index size, Index type"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst
msgid "vinyl will return ``nil``, rather than the deleted tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:418
msgid ""
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"- [1, 'My first tuple']\n"
"...\n"
"tarantool> box.space.tester:delete(1)\n"
"---\n"
"...\n"
"tarantool> box.space.tester:delete('a')\n"
"---\n"
"- error: 'Supplied key type of part 0 does not match index part type:\n"
"  expected unsigned'\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:437
msgid "Drop a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:444
msgid "**Possible errors:** If ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:451
msgid "box.space.space_that_does_not_exist:drop()"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:459
msgid "Search for a tuple in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:463 ../doc/1.7/book/box/box_space.rst:744
msgid "value to be matched against the index key, which may be multi-part."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:466
msgid "the tuple whose index key matches ``key``, or ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:469
msgid "**Possible errors:** If space_object does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:474
msgid ""
"The ``box.space...select`` function returns a set of tuples as a Lua "
"table; the ``box.space...get`` function returns at most a single tuple. "
"And it is possible to get the first tuple in a space by appending "
"``[1]``. Therefore ``box.space.tester:get{1}`` has the same effect as "
"``box.space.tester:select{1}[1]``, if exactly one tuple is found."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:482
msgid "box.space.tester:get{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:491
msgid "Insert a tuple into a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:495
msgid "tuple to be inserted."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:497
msgid "the inserted tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:500
msgid ""
"**Possible errors:** If a tuple with the same unique-key value already "
"exists, returns :errcode:`ER_TUPLE_FOUND`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:505
msgid ""
"tarantool> box.space.tester:insert{5000,'tuple number five thousand'}\n"
"---\n"
"- [5000, 'tuple number five thousand']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:519
msgid "Number of tuples in the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:523
msgid ""
"tarantool> box.space.tester:len()\n"
"---\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:530
msgid ""
"Note re storage engine: vinyl does not support ``len()``. One possible "
"workaround is to say ``#select(...)``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:538
msgid ""
"Create a \"replace trigger\". The ``trigger-function`` will be executed "
"whenever a ``replace()`` or ``insert()`` or ``update()`` or ``upsert()`` "
"or ``delete()`` happens to a tuple in ``<space-name>``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:549
msgid ""
"If the parameters are (nil, old-trigger-function), then the old trigger "
"is deleted. Details about trigger characteristics are in the "
":ref:`triggers <triggers-box_triggers>` section."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:553 ../doc/1.7/book/box/box_space.rst:1281
msgid "**Example #1:**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:555
msgid ""
"tarantool> function f ()\n"
"         >   x = x + 1\n"
"         > end\n"
"tarantool> box.space.X:on_replace(f)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:562
msgid ""
"The ``trigger-function`` can have two parameters: old tuple, new tuple. "
"For example, the following code causes nil to be printed when the insert "
"request is processed, and causes [1, 'Hi'] to be printed when the delete "
"request is processed:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:567
msgid ""
"box.schema.space.create('space_1')\n"
"box.space.space_1:create_index('space_1_index',{})\n"
"function on_replace_function (old, new) print(old) end\n"
"box.space.space_1:on_replace(on_replace_function)\n"
"box.space.space_1:insert{1,'Hi'}\n"
"box.space.space_1:delete{1}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:576 ../doc/1.7/book/box/box_space.rst:1326
msgid "**Example #2:**"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:578
msgid ""
"The following series of requests will create a space, create an index, "
"create a function which increments a counter, create a trigger, do two "
"inserts, drop the space, and display the counter value - which is 2, "
"because the function is executed once after each insert."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:583
msgid ""
"tarantool> s = box.schema.space.create('space53')\n"
"tarantool> s:create_index('primary', {parts = {1, 'unsigned'}})\n"
"tarantool> function replace_trigger()\n"
"         >   replace_counter = replace_counter + 1\n"
"         > end\n"
"tarantool> s:on_replace(replace_trigger)\n"
"tarantool> replace_counter = 0\n"
"tarantool> t = s:insert{1, 'First replace'}\n"
"tarantool> t = s:insert{2, 'Second replace'}\n"
"tarantool> s:drop()\n"
"tarantool> replace_counter"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:601
msgid ""
"Search for a tuple or a set of tuples in the given space, and allow "
"iterating over one tuple at a time."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:608
msgid "see :ref:`index_object:pairs <box_index-index_pairs>`"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:615 ../doc/1.7/book/box/box_space.rst:754
msgid "**Possible errors:** No such space; wrong type."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:619
msgid ""
"For examples of complex ``pairs`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\"), see the later section :ref:`index_object:pairs "
"<box_index-index_pairs>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:626
msgid ""
"tarantool> s = box.schema.space.create('space33')\n"
"---\n"
"...\n"
"tarantool> -- index 'X' has default parts {1, 'unsigned'}\n"
"tarantool> s:create_index('X', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{0, 'Hello my '}, s:insert{1, 'Lua world'}\n"
"---\n"
"- [0, 'Hello my ']\n"
"- [1, 'Lua world']\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in s:pairs() do\n"
"         >   tmp = tmp .. v[2]\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Hello my Lua world\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:657
msgid "Rename a space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:661
msgid "new name for space"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:665
msgid "**Possible errors:** ``space_object`` does not exist."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:669
msgid ""
"tarantool> box.space.space55:rename('space56')\n"
"---\n"
"...\n"
"tarantool> box.space.space56:rename('space55')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:683
msgid ""
"Insert a tuple into a space. If a tuple with the same primary key already"
" exists, ``box.space...:replace()`` replaces the existing tuple with a "
"new one. The syntax variants ``box.space...:replace()`` and "
"``box.space...:put()`` have the same effect; the latter is sometimes used"
" to show that the effect is the converse of ``box.space...:get()``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:691
msgid "tuple to be inserted"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:696
msgid ""
"**Possible errors:** If a different tuple with the same unique-key value "
"already exists, returns :errcode:`ER_TUPLE_FOUND`. (This will only happen"
" if there is a unique secondary index.)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:705
msgid "box.space.tester:replace{5000, 'tuple number five thousand'}"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:714
msgid ""
"At the time that a trigger is defined, it is automatically enabled - that"
" is, it will be executed. Replace triggers can be disabled with "
":samp:`box.space.{space-name}:run_triggers(false)` and re-enabled with "
":samp:`box.space.{space-name}:run_triggers(true)`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:723
msgid ""
"The following series of requests will associate an existing function "
"named F with an existing space named T, associate the function a second "
"time with the same space (so it will be called twice), disable all "
"triggers of T, and delete each trigger by replacing with ``nil``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:728
msgid ""
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:on_replace(F)\n"
"tarantool> box.space.T:run_triggers(false)\n"
"tarantool> box.space.T:on_replace(nil, F)\n"
"tarantool> box.space.T:on_replace(nil, F)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:740
msgid "Search for a tuple or a set of tuples in the given space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:747
msgid ""
"the tuples whose primary-key fields are equal to the fields of the passed"
" key. If the number of passed fields is less than the number of fields in"
" the primary key, then only the passed fields are compared, so "
"``select{1,2}`` will match a tuple whose primary key is ``{1,2,3}``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:760
msgid ""
"tarantool> s = box.schema.space.create('tmp', {temporary=true})\n"
"---\n"
"...\n"
"tarantool> s:create_index('primary',{parts = {1,'unsigned', 2, "
"'string'}})\n"
"---\n"
"...\n"
"tarantool> s:insert{1,'A'}\n"
"---\n"
"- [1, 'A']\n"
"...\n"
"tarantool> s:insert{1,'B'}\n"
"---\n"
"- [1, 'B']\n"
"...\n"
"tarantool> s:insert{1,'C'}\n"
"---\n"
"- [1, 'C']\n"
"...\n"
"tarantool> s:insert{2,'D'}\n"
"---\n"
"- [2, 'D']\n"
"...\n"
"tarantool> -- must equal both primary-key fields\n"
"tarantool> s:select{1,'B'}\n"
"---\n"
"- - [1, 'B']\n"
"...\n"
"tarantool> -- must equal only one primary-key field\n"
"tarantool> s:select{1}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"...\n"
"tarantool> -- must equal 0 fields, so returns all tuples\n"
"tarantool> s:select{}\n"
"---\n"
"- - [1, 'A']\n"
"  - [1, 'B']\n"
"  - [1, 'C']\n"
"  - [2, 'D']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:805
msgid ""
"For examples of complex ``select`` requests, where one can specify which "
"index to search and what condition to use (for example \"greater than\" "
"instead of \"equal to\") and how many tuples to return, see the later "
"section :ref:`index_object:select <box_index-select>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:814
msgid "Deletes all tuples."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:825
msgid ""
"Note that ``truncate`` must be called only by the user who created the "
"space OR under a `setuid` function created by that user. Read more about "
"`setuid` functions in reference on :ref:`box.schema.func.create() "
"<box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:832
msgid ""
"tarantool> box.space.tester:truncate()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:len()\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:848
msgid ""
"The ``update`` function supports operations on fields — assignment, "
"arithmetic (if the field is numeric), cutting and pasting fragments of a "
"field, deleting or inserting a field. Multiple operations can be combined"
" in a single update request, and in this case they are performed "
"atomically and sequentially. Each operation requires specification of a "
"field number. When multiple operations are present, the field number for "
"each operation is assumed to be relative to the most recent state of the "
"tuple, that is, as if all previous operations in a multi-operation update"
" have already been applied. In other words, it is always safe to merge "
"multiple ``update`` invocations into a single invocation, with no change "
"in semantics."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:860
msgid "Possible operators are:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:862
msgid "``+`` for addition (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:863
msgid "``-`` for subtraction (values must be numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:864
msgid "``&`` for bitwise AND (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:865
msgid "``|`` for bitwise OR (values must be unsigned numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:866
msgid ""
"``^`` for bitwise :abbr:`XOR(exclusive OR)` (values must be unsigned "
"numeric)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:868
msgid "``:`` for string splice"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:869
msgid "``!`` for insertion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:870
msgid "``#`` for deletion"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:871
msgid "``=`` for assignment"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:873
msgid ""
"For ``!`` and ``=`` operations the field number can be ``-1``, meaning "
"the last field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:890
msgid "**Possible errors:** it is illegal to modify a primary-key field."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:892 ../doc/1.7/book/box/box_space.rst:1009
msgid ""
"**Complexity factors:** Index size, Index type, number of indexes "
"accessed, WAL settings."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:895
msgid "Thus, in the instruction:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:897
msgid "s:update(44, {{'+', 1, 55 }, {'=', 3, 'x'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:901
msgid ""
"the primary-key value is ``44``, the operators are ``'+'`` and ``'='`` "
"meaning *add a value to a field and then assign a value to a field*, the "
"first affected field is field ``1`` and the value which will be added to "
"it is ``55``, the second affected field is field ``3`` and the value "
"which will be assigned to it is ``'x'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:909
msgid ""
"Assume that initially there is a space named ``tester`` with a primary-"
"key index whose type is ``unsigned``. There is one tuple, with "
"``field[1]`` = ``999`` and ``field[2]`` = ``'A'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:913
msgid ""
"In the update: |br| ``box.space.tester:update(999, {{'=', 2, 'B'}})`` "
"|br| The first argument is ``tester``, that is, the affected space is "
"``tester``. The second argument is ``999``, that is, the affected tuple "
"is identified by primary key value = 999. The third argument is ``=``, "
"that is, there is one operation — *assignment to a field*. The fourth "
"argument is ``2``, that is, the affected field is ``field[2]``. The fifth"
" argument is ``'B'``, that is, ``field[2]`` contents change to ``'B'``. "
"Therefore, after this update, ``field[1]`` = ``999`` and ``field[2]`` = "
"``'B'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:924
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'B'}})`` "
"|br| the arguments are the same, except that the key is passed as a Lua "
"table (inside braces). This is unnecessary when the primary key has only "
"one field, but would be necessary if the primary key had more than one "
"field. Therefore, after this update, ``field[1]`` = ``999`` and "
"``field[2]`` = ``'B'`` (no change)."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:931
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 3, 1}})`` "
"|br| the arguments are the same, except that the fourth argument is "
"``3``, that is, the affected field is ``field[3]``. It is okay that, "
"until now, ``field[3]`` has not existed. It gets added. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``'B'``, ``field[3]``"
" = ``1``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:938
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'+', 3, 1}})`` "
"|br| the arguments are the same, except that the third argument is "
"``'+'``, that is, the operation is addition rather than assignment. Since"
" ``field[3]`` previously contained ``1``, this means we're adding ``1`` "
"to ``1``. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'B'``, ``field[3]`` = ``2``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:946
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'|', 3, 1}, {'=', "
"2, 'C'}})`` |br| the idea is to modify two fields at once. The formats "
"are ``'|'`` and ``=``, that is, there are two operations, OR and "
"assignment. The fourth and fifth arguments mean that ``field[3]`` gets "
"OR'ed with ``1``. The seventh and eighth arguments mean that ``field[2]``"
" gets assigned ``'C'``. Therefore, after this update, ``field[1]`` = "
"``999``, ``field[2]`` = ``'C'``, ``field[3]`` = ``3``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:955
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'#', 2, 1}, {'-', "
"2, 3}})`` |br| The idea is to delete ``field[2]``, then subtract ``3`` "
"from ``field[3]``. But after the delete, there is a renumbering, so "
"``field[3]`` becomes ``field[2]``` before we subtract ``3`` from it, and "
"that's why the seventh argument is ``2``, not ``3``. Therefore, after "
"this update, ``field[1]`` = ``999``, ``field[2]`` = ``0``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:963
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{'=', 2, 'XYZ'}})``"
" |br| we're making a long string so that splice will work in the next "
"example. Therefore, after this update, ``field[1]`` = ``999``, "
"``field[2]`` = ``'XYZ'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:968
msgid ""
"In the update: |br| ``box.space.tester:update({999}, {{':', 2, 2, 1, "
"'!!'}})`` |br| The third argument is ``':'``, that is, this is the "
"example of splice. The fourth argument is ``2`` because the change will "
"occur in ``field[2]``. The fifth argument is 2 because deletion will "
"begin with the second byte. The sixth argument is 1 because the number of"
" bytes to delete is 1. The seventh argument is ``'!!'``, because ``'!!'``"
" is to be added at this position. Therefore, after this update, "
"``field[1]`` = ``999``, ``field[2]`` = ``'X!!Z'``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:981
msgid "Update or insert a tuple."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:983
msgid ""
"If there is an existing tuple which matches the key fields of "
"``tuple_value``, then the request has the same effect as "
":ref:`space_object:update() <box_space-update>` and the ``{{operator, "
"field_no, value}, ...}`` parameter is used. If there is no existing tuple"
" which matches the key fields of ``tuple_value``, then the request has "
"the same effect as :ref:`space_object:insert() <box_space-insert>` and "
"the ``{tuple_value}`` parameter is used. However, unlike ``insert`` or "
"``update``, ``upsert`` will not read a tuple and perform error checks "
"before returning -- this is a design feature which enhances throughput "
"but requires more caution on the part of the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:995
msgid "default tuple to be inserted, if analogue isn't found"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1004
msgid "null"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1006
msgid ""
"**Possible errors:** it is illegal to modify a primary-key field. It is "
"illegal to use upsert with a space that has a unique secondary index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1014
msgid "box.space.tester:upsert({12,'c'}, {{'=', 3, 'a'}, {'=', 4, 'b'}})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1027
msgid ""
"Whether or not this space is enabled. The value is ``false`` if the space"
" has no index."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1034
msgid ""
"The required field count for all tuples in this space. The field_count "
"can be set initially with:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1040
msgid ""
"box.schema.space.create(..., {\n"
"    ... ,\n"
"    field_count = *field_count_value* ,\n"
"    ...\n"
"})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1046
msgid "The default value is ``0``, which means there is no required field count."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1050
msgid ""
"tarantool> box.space.tester.field_count\n"
"---\n"
"- 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1062
msgid ""
"Ordinal space number. Spaces can be referenced by either name or number. "
"Thus, if space ``tester`` has ``id = 800``, then "
"``box.space.tester:insert{0}`` and ``box.space[800]:insert{0}`` are "
"equivalent requests."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1069
msgid ""
"tarantool> box.space.tester.id\n"
"---\n"
"- 512\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1078
msgid ""
"A container for all defined indexes. There is a Lua object of type "
":ref:`box.index <box_index>` with methods to search tuples and iterate "
"over them in predefined order."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1086
msgid ""
"tarantool> #box.space.tester.index\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> box.space.tester.index.primary.type\n"
"---\n"
"- TREE\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1101
msgid ""
"``_cluster`` is a system space for support of the :ref:`replication "
"feature <replication>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1108
msgid ""
"``_func`` is a system space with function tuples made by "
":ref:`box.schema.func.create() <box_schema-func_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1111
#: ../doc/1.7/book/box/box_space.rst:1163
#: ../doc/1.7/book/box/box_space.rst:1201
#: ../doc/1.7/book/box/box_space.rst:1271
#: ../doc/1.7/book/box/box_space.rst:1365
msgid "Tuples in this space contain the following fields:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1113
msgid "the numeric function id, a number,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1114
msgid "the function name,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1115
msgid "flag,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1116
msgid "a language name (optional): 'LUA' (default) or 'C'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1118
msgid ""
"The ``_func`` space does not include the function’s body. You continue to"
" create Lua functions in the usual way, by saying ``function "
"function_name () ... end``, without adding anything in the ``_func`` "
"space. The ``_func`` space only exists for storing function tuples so "
"that their names can be used within grant/revoke functions."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1125
#: ../doc/1.7/book/box/box_space.rst:1210
msgid "You can:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1127
msgid ""
"Create a ``_func`` tuple with :ref:`box.schema.func.create() <box_schema-"
"func_create>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1129
msgid ""
"Drop a ``_func`` tuple with :ref:`box.schema.func.drop() <box_schema-"
"func_drop>`,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1131
msgid ""
"Check whether a ``_func`` tuple exists with "
":ref:`box.schema.func.exists() <box_schema-func_exists>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1136
msgid ""
"In the following example, we create a function named ‘f7’, put it into "
"Tarantool's ``_func`` space and grant 'execute' privilege for this "
"function to 'guest' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1140
msgid ""
"tarantool> function f7()\n"
"         >  box.session.uid()\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest', 'execute', 'function', 'f7')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.revoke('guest', 'execute', 'function', 'f7')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1161
msgid "``_index`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1165
msgid "``id`` (= id of space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1166
msgid "``iid`` (= index number within space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1167
msgid "``name``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1168
msgid "``type``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1169
msgid ""
"``opts`` (e.g. unique option), [``tuple-field-no``, ``tuple-field-type`` "
"...]."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1171
msgid "Here is what ``_index`` contains in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1173
msgid ""
"tarantool> box.space._index:select{}\n"
"---\n"
"- - [272, 0, 'primary', 'tree', {'unique': true}, [[0, 'string']]]\n"
"  - [280, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [280, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [280, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [281, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [281, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [281, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"  - [288, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [288, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [289, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned'], [1, "
"'unsigned']]]\n"
"  - [289, 2, 'name', 'tree', {'unique': true}, [[0, 'unsigned'], [2, "
"'string']]]\n"
"  - [296, 0, 'primary', 'tree', {'unique': true}, [[0, 'unsigned']]]\n"
"  - [296, 1, 'owner', 'tree', {'unique': false}, [[1, 'unsigned']]]\n"
"  - [296, 2, 'name', 'tree', {'unique': true}, [[2, 'string']]]\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1198
msgid ""
"``_priv`` is a system space where :ref:`privileges <authentication-"
"owners_privileges>` are stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1203
msgid "the numeric id of the user who gave the privilege (\"grantor_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1204
msgid "the numeric id of the user who received the privilege (\"grantee_id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1205
msgid "the type of object: 'space', 'function' or 'universe',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1206
msgid "the numeric id of the object,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1207
msgid ""
"the type of operation: \"read\" = 1, \"write\" = 2, \"execute\" = 4, or a"
" combination such as \"read,write,execute\"."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1212
msgid ""
"Grant a privilege with :ref:`box.schema.user.grant() <box_schema-"
"user_grant>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1213
msgid ""
"Revoke a privilege with :ref:`box.schema.user.revoke() <box_schema-"
"user_revoke>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1217
msgid ""
"Generally, privileges are granted or revoked by the owner of the object "
"(the user who created it), or by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1220
msgid ""
"Before dropping any objects or users, make sure that all their associated"
" privileges have been revoked."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1223
msgid "Only the 'admin' user can grant privileges for the 'universe'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1225
msgid ""
"Only the 'admin' user or the creator of a space can drop, alter, or "
"truncate the space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1228
msgid ""
"Only the 'admin' user or the creator of a user can change a different "
"user’s password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1235
msgid "``_schema`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1237
msgid "This space contains the following tuples:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1239
msgid "``version`` tuple with version information for this Tarantool instance,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1240
msgid "``cluster`` tuple with the instance's replica set ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1241
msgid "``max_id`` tuple with the maximal space ID,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1242
msgid ""
"``once...`` tuples that correspond to specific :ref:`box.once() <box-"
"once>` blocks from the instance's :ref:`initialization file <index-"
"init_label>`. The first field in these tuples contains the ``key`` value "
"from the corresponding ``box.once()`` block prefixed with 'once' (e.g. "
"`oncehello`), so you can easily find a tuple that corresponds to a "
"specific ``box.once()`` block."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1252
msgid ""
"Here is what ``_schema`` contains in a typical installation (notice the "
"tuples for two ``box.once()`` blocks, ``'oncebye'`` and ``'oncehello'``):"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1255
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1269
msgid "``_space`` is a system space."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1273
msgid "``id``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1274
msgid "``owner`` (= id of user who owns the space),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1275
msgid "``name``, ``engine``, ``field_count``,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1276
msgid "``flags`` (e.g. temporary), ``format``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1278
msgid ""
"These fields are established by :ref:`space.create() <box_schema-"
"space_create>`."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1283
msgid ""
"The following function will display all simple fields in all tuples of "
"``_space``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1286
msgid ""
"function example()\n"
"  local ta = {}\n"
"  local i, line\n"
"  for k, v in box.space._space:pairs() do\n"
"    i = 1\n"
"    line = ''\n"
"    while i <= #v do\n"
"      if type(v[i]) ~= 'table' then\n"
"        line = line .. v[i] .. ' '\n"
"      end\n"
"    i = i + 1\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1305
msgid "Here is what ``example()`` returns in a typical installation:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1307
msgid ""
"tarantool> example()\n"
"---\n"
"- - '272 1 _schema memtx 0  '\n"
"  - '280 1 _space memtx 0  '\n"
"  - '281 1 _vspace sysview 0  '\n"
"  - '288 1 _index memtx 0  '\n"
"  - '296 1 _func memtx 0  '\n"
"  - '304 1 _user memtx 0  '\n"
"  - '305 1 _vuser sysview 0  '\n"
"  - '312 1 _priv memtx 0  '\n"
"  - '313 1 _vpriv sysview 0  '\n"
"  - '320 1 _cluster memtx 0  '\n"
"  - '512 1 tester memtx 0  '\n"
"  - '513 1 origin vinyl 0  '\n"
"  - '514 1 archive memtx 0  '\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1328
msgid ""
"The following requests will create a space using "
"``box.schema.space.create()`` with a ``format`` clause. Then it retrieves"
" the ``_space`` tuple for the new space. This illustrates the typical use"
" of the ``format`` clause, it shows the recommended names and data types "
"for the fields."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1334
msgid ""
"tarantool> box.schema.space.create('TM', {\n"
"         >   id = 12345,\n"
"         >   format = {\n"
"         >     [1] = {[\"name\"] = \"field_1\"},\n"
"         >     [2] = {[\"type\"] = \"unsigned\"}\n"
"         >   }\n"
"         > })\n"
"---\n"
"- index: []\n"
"  on_replace: 'function: 0x41c67338'\n"
"  temporary: false\n"
"  id: 12345\n"
"  engine: memtx\n"
"  enabled: false\n"
"  name: TM\n"
"  field_count: 0\n"
"- created\n"
"...\n"
"tarantool> box.space._space:select(12345)\n"
"---\n"
"- - [12345, 1, 'TM', 'memtx', 0, {}, [{'name': 'field_1'}, {'type': "
"'unsigned'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1363
msgid ""
"``_user`` is a system space where user-names and password hashes are "
"stored."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1367
msgid "the numeric id of the tuple (\"id\"),"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1368
msgid "the numeric id of the tuple’s creator,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1369
msgid "the name,"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1370
msgid "the type: 'user' or 'role',"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1371
msgid "optional password."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1373
msgid ""
"There are four special tuples in the ``_user`` space: 'guest', 'admin', "
"'public' and 'replication'."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1384
msgid "ID"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid "guest"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid "0"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1386
msgid ""
"Default user when connecting remotely. Usually an untrusted user with few"
" privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid "admin"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid "1"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1389
msgid ""
"Default user when using Tarantool as a console. Usually an administrative"
" user with all privileges."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
msgid "public"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
#: ../doc/1.7/book/box/box_space.rst:1400
msgid "role"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1392
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, automatically assigned to"
" new users when they are created with ``box.schema.user.create(user-"
"name)``. Therefore, a convenient way to grant 'read' on space 't' to "
"every user that will ever exist is with "
"``box.schema.role.grant('public','read','space','t')``."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid "replication"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid "3"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1400
msgid ""
"Pre-defined :ref:`role <authentication-roles>`, assigned by the 'admin' "
"user to users who need to use :ref:`replication <replication>` features."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1405
msgid ""
"To select a tuple from the ``_user`` space, use "
"``box.space._user:select()``. For example, here is what happens with a "
"select for user id = 0, which is the 'guest' user, which by default has "
"no password:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1409
msgid ""
"tarantool> box.space._user:select{0}\n"
"---\n"
"- - [0, 1, 'guest', 'user']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1418
msgid ""
"To change tuples in the ``_user`` space, do not use ordinary "
"``box.space`` functions for insert or update or delete. The ``_user`` "
"space is special, so there are special functions which have appropriate "
"error checking."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1422
msgid ""
"To create a new user, use :ref:`box.schema.user.create() <box_schema-"
"user_create>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1427
msgid ""
"box.schema.user.create(*user-name*)\n"
"box.schema.user.create(*user-name*, {if_not_exists = true})\n"
"box.schema.user.create(*user-name*, {password = *password*})"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1431
msgid ""
"To change the user's password, use :ref:`box.schema.user.password() "
"<box_schema-user_password>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1436
msgid ""
"-- To change the current user's password\n"
"box.schema.user.passwd(*password*)\n"
"\n"
"-- To change a different user's password\n"
"-- (usually only 'admin' can do it)\n"
"box.schema.user.passwd(*user-name*, *password*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1444
msgid "To drop a user, use :ref:`box.schema.user.drop() <box_schema-user_drop>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1449
msgid "box.schema.user.drop(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1451
msgid ""
"To check whether a user exists, use :ref:`box.schema.user.exists() "
"<box_schema-user_exists>`, which returns ``true`` or ``false``:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1457
msgid "box.schema.user.exists(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1459
msgid ""
"To find what privileges a user has, use :ref:`box.schema.user.info() "
"<box_schema-user_info>`:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1464
msgid "box.schema.user.info(*user-name*)"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1472
msgid ""
"Here is a session which creates a new user with a strong password, "
"selects a tuple in the ``_user`` space, and then drops the user."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1475
msgid ""
"tarantool> box.schema.user.create('JeanMartin', {password = "
"'Iwtso_6_os$$'})\n"
"---\n"
"...\n"
"tarantool> box.space._user.index.name:select{'JeanMartin'}\n"
"---\n"
"- - [17, 1, 'JeanMartin', 'user', {'chap-sha1': "
"'t3xjUpQdrt857O+YRvGbMY5py8Q='}]\n"
"...\n"
"tarantool> box.schema.user.drop('JeanMartin')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1491
msgid "Example: use box.space functions to read _space tuples"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1493
msgid ""
"This function will illustrate how to look at all the spaces, and for each"
" display: approximately how many tuples it contains, and the first field "
"of its first tuple. The function uses Tarantool ``box.space`` functions "
"``len()`` and ``pairs()``. The iteration through the spaces is coded as a"
" scan of the ``_space`` system space, which contains metadata. The third "
"field in ``_space`` contains the space name, so the key instruction "
"``space_name = v[3]`` means ``space_name`` is the ``space_name`` field in"
" the tuple of ``_space`` that we've just fetched with ``pairs()``. The "
"function returns a table:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1503
msgid ""
"function example()\n"
"  local tuple_count, space_name, line\n"
"  local ta = {}\n"
"  for k, v in box.space._space:pairs() do\n"
"    space_name = v[3]\n"
"    if box.space[space_name].index[0] ~= nil then\n"
"      tuple_count = '1 or more'\n"
"    else\n"
"      tuple_count = '0'\n"
"    end\n"
"    line = space_name .. ' tuple_count =' .. tuple_count\n"
"    if tuple_count == '1 or more' then\n"
"      for k1, v1 in box.space[space_name]:pairs() do\n"
"        line = line .. '. first field in first tuple = ' .. v1[1]\n"
"        break\n"
"      end\n"
"    end\n"
"    table.insert(ta, line)\n"
"  end\n"
"  return ta\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1527
msgid "And here is what happens when one invokes the function:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1529
msgid ""
"tarantool> example()\n"
"---\n"
"- - _schema tuple_count =1 or more. first field in first tuple = cluster\n"
"  - _space tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vspace tuple_count =1 or more. first field in first tuple = 272\n"
"  - _index tuple_count =1 or more. first field in first tuple = 272\n"
"  - _vindex tuple_count =1 or more. first field in first tuple = 272\n"
"  - _func tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vfunc tuple_count =1 or more. first field in first tuple = 1\n"
"  - _user tuple_count =1 or more. first field in first tuple = 0\n"
"  - _vuser tuple_count =1 or more. first field in first tuple = 0\n"
"  - _priv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _vpriv tuple_count =1 or more. first field in first tuple = 1\n"
"  - _cluster tuple_count =1 or more. first field in first tuple = 1\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1549
msgid "Example: use box.space functions to organize a _space tuple"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1551
msgid ""
"The objective is to display field names and field types of a system space"
" -- using metadata to find metadata."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1554
msgid "To begin: how can one select the _space tuple that describes _space?"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1556
msgid ""
"A simple way is to look at the constants in box.schema, which tell us "
"that there is an item named SPACE_ID == 288, so these statements will "
"retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1560
msgid "``box.space._space:select{ 288 }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1561
#: ../doc/1.7/dev_guide/lua_style_guide.rst:403
msgid "or"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1562
msgid "``box.space._space:select{ box.schema.SPACE_ID }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1564
msgid ""
"Another way is to look at the tuples in box.space._index, which tell us "
"that there is a secondary index named 'name' for space number 288, so "
"this statement also will retrieve the correct tuple:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1568
msgid "``box.space._space.index.name:select{ '_space' }``"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1570
msgid "However, the retrieved tuple is not easy to read:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1572
msgid ""
"tarantool> box.space._space.index.name:select{'_space'}\n"
"---\n"
"- - [280, 1, '_space', 'memtx', 0, {}, [{'name': 'id', 'type': 'num'}, "
"{'name': 'owner',\n"
"        'type': 'num'}, {'name': 'name', 'type': 'str'}, {'name': "
"'engine', 'type': 'str'},\n"
"      {'name': 'field_count', 'type': 'num'}, {'name': 'flags', 'type': "
"'str'}, {\n"
"        'name': 'format', 'type': '*'}]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1582
msgid ""
"It looks disorganized because field number 7 has been formatted with "
"recommended names and data types. How can one get those specific sub-"
"fields? Since it's visible that field number 7 is an array of maps, this "
"`for` loop will do the organizing:"
msgstr ""

#: ../doc/1.7/book/box/box_space.rst:1587
msgid ""
"tarantool> do\n"
"         >   local tuple_of_space = "
"box.space._space.index.name:get{'_space'}\n"
"         >   for _, field in ipairs(tuple_of_space[7]) do\n"
"         >     print(field.name .. ', ' .. field.type)\n"
"         >   end\n"
"         > end\n"
"id, num\n"
"owner, num\n"
"name, str\n"
"engine, str\n"
"field_count, num\n"
"flags, str\n"
"format, *\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_stat.rst:39
msgid ""
"tarantool> type(box.stat), type(box.stat.net) -- virtual tables\n"
"---\n"
"- table\n"
"- table\n"
"...\n"
"tarantool> box.stat, box.stat.net\n"
"---\n"
"- net: &0 []\n"
"- *0\n"
"...\n"
"tarantool> box.stat()\n"
"---\n"
"- DELETE:\n"
"    total: 1873949\n"
"    rps: 123\n"
"  SELECT:\n"
"    total: 1237723\n"
"    rps: 4099\n"
"  INSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVAL:\n"
"    total: 0\n"
"    rps: 0\n"
"  CALL:\n"
"    total: 0\n"
"    rps: 0\n"
"  REPLACE:\n"
"    total: 1239123\n"
"    rps: 7849\n"
"  UPSERT:\n"
"    total: 0\n"
"    rps: 0\n"
"  AUTH:\n"
"    total: 0\n"
"    rps: 0\n"
"  ERROR:\n"
"    total: 0\n"
"    rps: 0\n"
"  UPDATE:\n"
"    total: 0\n"
"    rps: 0\n"
"...\n"
"tarantool> box.stat().DELETE -- a selected item of the table\n"
"---\n"
"- total: 0\n"
"  rps: 0\n"
"...\n"
"tarantool> box.stat.net()\n"
"---\n"
"- SENT:\n"
"    total: 0\n"
"    rps: 0\n"
"  EVENTS:\n"
"    total: 2\n"
"    rps: 0\n"
"  LOCKS:\n"
"    total: 6\n"
"    rps: 0\n"
"  RECEIVED:\n"
"    total: 0\n"
"    rps: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:33
msgid "Submodule `box.tuple`"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:37
msgid ""
"The ``box.tuple`` submodule provides read-only access for the ``tuple`` "
"userdata type. It allows, for a single tuple: selective retrieval of the "
"field contents, retrieval of information about size, iteration over all "
"the fields, and conversion to a Lua table."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:46
msgid ""
"Construct a new tuple from either a scalar or a Lua table. Alternatively,"
" one can get new tuples from tarantool's :ref:`select <box_space-select>`"
" or :ref:`insert <box_space-insert>` or :ref:`replace <box_space-"
"replace>` or :ref:`update <box_space-update>` requests, which can be "
"regarded as statements that do ``new()`` implicitly."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:53
msgid "the value that will become the tuple contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:55
msgid "a new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:58
msgid ""
"In the following example, ``x`` will be a new table object containing one"
" tuple and ``t`` will be a new tuple object. Saying ``t`` returns the "
"entire tuple ``t``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:64
msgid ""
"tarantool> x = box.space.tester:insert{\n"
"         >   33,\n"
"         >   tonumber('1'),\n"
"         >   tonumber64('2')\n"
"         > }:totable()\n"
"---\n"
"...\n"
"tarantool> t = box.tuple.new{'abc', 'def', 'ghi', 'abc'}\n"
"---\n"
"...\n"
"tarantool> t\n"
"---\n"
"- ['abc', 'def', 'ghi', 'abc']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:85
msgid ""
"The ``#`` operator in Lua means \"return count of components\". So, if "
"``t`` is a tuple instance, ``#t`` will return the number of fields."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:90
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"number of fields in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:93
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> #t\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:105
msgid ""
"If ``t`` is a tuple instance, ``t:bsize()`` will return the number of "
"bytes in the tuple. With the memtx storage engine the default maximum "
"number is :ref:`one megabyte <cfg_storage-memtx_max_tuple_size>`. Every "
"field has one or more \"length\" bytes preceding the actual contents, so "
"``bsize()`` returns a value which is slightly greater than the sum of the"
" lengths of the contents."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:115
msgid ""
"In the following example, a tuple named ``t`` is created which has three "
"fields, and for each field it takes one byte to store the length and "
"three bytes to store the contents, and a bit for overhead, so ``bsize()``"
" returns ``3*(1+3)+1``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:120
msgid ""
"tarantool> t = box.tuple.new{'aaa', 'bbb', 'ccc'}\n"
"---\n"
"...\n"
"tarantool> t:bsize()\n"
"---\n"
"- 13\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:132
msgid ""
"If ``t`` is a tuple instance, ``t[field-number]`` will return the field "
"numbered field-number in the tuple. The first field is ``t[1]``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:135
msgid "field value."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:136
msgid "lua-value"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:138
msgid ""
"In the following example, a tuple named ``t`` is created and then the "
"second field in ``t`` is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:141
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4'}\n"
"---\n"
"...\n"
"tarantool> t[2]\n"
"---\n"
"- Fld#2\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:154
msgid ""
"If ``t`` is a tuple instance, ``t:find(search-value)`` will return the "
"number of the first field in ``t`` that matches the search value, and "
"``t:findall(search-value [, search-value ...])`` will return numbers of "
"all fields in ``t`` that match the search value. Optionally one can put a"
" numeric argument ``field-number`` before the search-value to indicate "
"“start searching at field number ``field-number``.”"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:161
msgid "the number of the field in the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:164
msgid ""
"In the following example, a tuple named ``t`` is created and then: the "
"number of the first field in ``t`` which matches 'a' is returned, then "
"the numbers of all the fields in ``t`` which match 'a' are returned, then"
" the numbers of all the fields in t which match 'a' and are at or after "
"the second field are returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:170
msgid ""
"tarantool> t = box.tuple.new{'a', 'b', 'c', 'a'}\n"
"---\n"
"...\n"
"tarantool> t:find('a')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> t:findall('a')\n"
"---\n"
"- 1\n"
"- 4\n"
"...\n"
"tarantool> t:findall(2, 'a')\n"
"---\n"
"- 4\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:191
msgid ""
"If ``t`` is a tuple instance, :samp:`t:transform({start-field-number"
"},{fields-to-remove})` will return a tuple where, starting from field "
"``start-field-number``, a number of fields (``fields-to-remove``) are "
"removed. Optionally one can add more arguments after ``fields-to-remove``"
" to indicate new values that will replace what was removed."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:197
msgid "base 1, may be negative"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:203
msgid ""
"In the following example, a tuple named ``t`` is created and then, "
"starting from the second field, two fields are removed but one new one is"
" added, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:207
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:transform(2, 2, 'x')\n"
"---\n"
"- ['Fld#1', 'x', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:219
msgid ""
"If ``t`` is a tuple instance, ``t:unpack()`` will return all fields, "
"``t:unpack(1)`` will return all fields starting with field number 1, "
"``t:unpack(1,5)`` will return all fields between field number 1 and field"
" number 5."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:223
msgid "field(s) from the tuple."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:224
msgid "lua-value(s)"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:226
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:229
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:unpack()\n"
"---\n"
"- Fld#1\n"
"- Fld#2\n"
"- Fld#3\n"
"- Fld#4\n"
"- Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:245
msgid ""
"If ``t`` is a tuple instance, ``t:totable()`` will return all fields, "
"``t:totable(1)`` will return all fields starting with field number 1, "
"``t:totable(1,5)`` will return all fields between field number 1 and "
"field number 5. It is preferable to use ``t:totable()`` rather than "
"``t:unpack()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:250
msgid "field(s) from the tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:251
msgid "lua-table"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:253
msgid ""
"In the following example, a tuple named ``t`` is created, then all its "
"fields are selected, then the result is returned."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:256
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:totable()\n"
"---\n"
"- ['Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:269
msgid ""
"In Lua, ``lua-table-value:pairs()`` is a method which returns: "
"``function``, ``lua-table-value``, ``nil``. Tarantool has extended this "
"so that ``tuple-value:pairs()`` returns: ``function``, ``tuple-value``, "
"``nil``. It is useful for Lua iterators, because Lua iterators traverse a"
" value's components until an end marker is reached."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:275
msgid "function, tuple-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:276
msgid "function, lua-value, nil"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:278
msgid ""
"In the following example, a tuple named ``t`` is created and then all its"
" fields are selected using a Lua for-end loop."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:281
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> tmp = ''\n"
"---\n"
"...\n"
"tarantool> for k, v in t:pairs() do\n"
"         >   tmp = tmp .. v\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> tmp\n"
"---\n"
"- Fld#1Fld#2Fld#3Fld#4Fld#5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:303
msgid ""
"This function updates a tuple which is not in a space. Compare the "
"function :extsamp:`box.space.{*{space-name}*}:update({*{key}*}, "
"{{{*{format}*}, {*{field_no}*}, {*{value}*}}, ...})` which updates a "
"tuple in a space."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:307
msgid ""
"For details: see the description for ``operator``, ``field_no``, and "
"``value`` in the section :ref:`box.space.space-name:update{key, format, "
"{field_number, value}...) <box_space-update>`."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:311
msgid "operation type represented in string (e.g. '``=``' for 'assign new value')"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:319
msgid "new tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:322
msgid ""
"In the following example, a tuple named ``t`` is created and then its "
"second field is updated to equal 'B'."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:325
msgid ""
"tarantool> t = box.tuple.new{'Fld#1', 'Fld#2', 'Fld#3', 'Fld#4', 'Fld#5'}"
"\n"
"---\n"
"...\n"
"tarantool> t:update({{'=', 2, 'B'}})\n"
"---\n"
"- ['Fld#1', 'B', 'Fld#3', 'Fld#4', 'Fld#5']\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:337
#: ../doc/1.7/reference/configuration/index.rst:119
#: ../doc/1.7/reference/reference_lua/digest.rst:224
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:154
#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:262
#: ../doc/1.7/reference/reference_lua/log.rst:72
#: ../doc/1.7/reference/reference_lua/msgpack.rst:68
#: ../doc/1.7/reference/reference_lua/net_box.rst:331
#: ../doc/1.7/reference/reference_lua/tap.rst:206
#: ../doc/1.7/reference/reference_lua/uuid.rst:138
#: ../doc/1.7/reference/reference_lua/yaml.rst:64
#: ../doc/1.7/reference/reference_rock/dbms.rst:277
#: ../doc/1.7/reference/reference_rock/dbms.rst:619
msgid "Example"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:339
msgid ""
"This function will illustrate how to convert tuples to/from Lua tables "
"and lists of scalars:"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:342
msgid ""
"tuple = box.tuple.new({scalar1, scalar2, ... scalar_n}) -- scalars to "
"tuple\n"
"lua_table = {tuple:unpack()}                            -- tuple to Lua "
"table\n"
"lua_table = tuple:totable()                             -- tuple to Lua "
"table\n"
"scalar1, scalar2, ... scalar_n = tuple:unpack()         -- tuple to "
"scalars\n"
"tuple = box.tuple.new(lua_table)                        -- Lua table to "
"tuple"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:350
msgid ""
"Then it will find the field that contains 'b', remove that field from the"
" tuple, and display how many bytes remain in the tuple. The function uses"
" Tarantool ``box.tuple`` functions ``new()``, ``unpack()``, ``find()``, "
"``transform()``, ``bsize()``."
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:355
msgid ""
"function example()\n"
"  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, "
"field_number\n"
"  local luatable1 = {}\n"
"  tuple1 = box.tuple.new({'a', 'b', 'c'})\n"
"  luatable1 = tuple1:totable()\n"
"  scalar1, scalar2, scalar3 = tuple1:unpack()\n"
"  tuple2 = box.tuple.new(luatable1[1],luatable1[2],luatable1[3])\n"
"  field_number = tuple2:find('b')\n"
"  tuple2 = tuple2:transform(field_number, 1)\n"
"  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()\n"
"end"
msgstr ""

#: ../doc/1.7/book/box/box_tuple.rst:371
msgid ""
"tarantool> example()\n"
"---\n"
"- tuple2 =\n"
"- ['a', 'c']\n"
"- ' # of bytes = '\n"
"- 5\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:33
msgid "Functions for transaction management"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:35
msgid ""
"For general information and examples, see section :ref:`Transaction "
"control <atomic-atomic_execution>`."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:38
msgid "Observe the following rules when working with transactions:"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:40
msgid "Rule #1"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:43
msgid ""
"The requests in a transaction must be sent to a server as a single block."
" It is not enough to enclose them between begin and commit or rollback. "
"To ensure they are sent as a single block: put them in a function, or put"
" them all on one line, or use a delimiter so that multi-line requests are"
" handled together."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:49
msgid "Rule #2"
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:52
msgid ""
"All database operations in a transaction should use the same storage "
"engine. It is not safe to access tuple sets that are defined with "
"``{engine='vinyl'}`` and also access tuple sets that are defined with "
"``{engine='memtx'}``, in the same transaction."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:61
msgid ""
"Begin the transaction. Disable implicit yields until the transaction "
"ends. Signal that writes to the write-ahead log will be deferred until "
"the transaction ends. In effect the fiber which executes ``box.begin()`` "
"is starting an \"active multi-request transaction\", blocking all other "
"fibers."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:70
msgid "End the transaction, and make all its data-change operations permanent."
msgstr ""

#: ../doc/1.7/book/box/box_txn_management.rst:76
msgid ""
"End the transaction, but cancel all its data-change operations. An "
"explicit call to functions outside ``box.space`` that always yield, such "
"as :ref:`fiber.sleep() <fiber-sleep>` or :ref:`fiber.yield() <fiber-"
"yield>`, will have the same effect."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:33
msgid "Data model"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:35
msgid ""
"This section describes how Tarantool stores values and what operations "
"with data it supports."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:38
msgid ""
"If you tried to create a database as suggested in our :ref:`\"Getting "
"started\" exercises <getting_started>`, then your test database now looks"
" like this:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:48
msgid "Space"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:50
msgid "A **space** -- 'tester' in our example -- is a container."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:52
msgid ""
"When Tarantool is being used to store data, there is always at least one "
"space. Each space has a unique **name** specified by the user. Besides, "
"each space has a unique **numeric identifier** which can be specified by "
"the user, but usually is assigned automatically by Tarantool. Finally, a "
"space always has an **engine**: *memtx* (default) -- in-memory engine, "
"fast but limited in size, or *vinyl* -- on-disk engine for huge data "
"sets."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:59
msgid ""
"A space is a container for :ref:`tuples <index-box_tuple>`. To be "
"functional, it needs to have a :ref:`primary index <index-box_index>`. It"
" can also have secondary indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:67
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:46
msgid "Tuple"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:69
msgid ""
"A **tuple** plays the same role as a “row” or a “record”, and the "
"components of a tuple (which we call “fields”) play the same role as a "
"“row column” or “record field”, except that:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:73
msgid "fields can be composite structures, such as arrays or maps, and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:74
msgid "fields don't need to have names."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:76
msgid ""
"Any given tuple may have any number of fields, and the fields may be of "
"different :ref:`types <index-box_data-types>`. The identifier of a field "
"is the field's number, base 1 (in Lua and other 1-based languages) or "
"base 0 (in PHP or C/C++). For example, “1” or \"0\" can be used in some "
"contexts to refer to the first field of a tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:83
msgid ""
"Tuples in Tarantool are stored as `MsgPack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ arrays."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:86
msgid ""
"When Tarantool returns a tuple value in console, it uses the `YAML "
"<https://en.wikipedia.org/wiki/YAML>`_ format, for example: ``[3, 'Ace of"
" Base', 1993]``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:94
msgid "Index"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:96
msgid "An **index** is a group of key values and pointers."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:98
msgid ""
"As with spaces, you should specify the index **name**, and let Tarantool "
"come up with a unique **numeric identifier** (\"index id\")."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:101
msgid ""
"An index always has a **type**. The default index type is 'TREE'. TREE "
"indexes are provided by all Tarantool engines, can index unique and non-"
"unique values, support partial key searches, comparisons and ordered "
"results. Additionally, memtx engine supports HASH, RTREE and BITSET "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:106
msgid ""
"An index may be **multi-part**, that is, you can declare that an index "
"key value is composed of two or more fields in the tuple, in any order. "
"For example, for an ordinary TREE index, the maximum number of parts is "
"255."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:110
msgid ""
"An index may be **unique**, that is, you can declare that it would be "
"illegal to have the same key value twice."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:113
msgid ""
"The first index defined on a space is called the **primary key index**, "
"and it must be unique. All other indexes are called **secondary "
"indexes**, and they may be non-unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:117
msgid ""
"An index definition may include identifiers of tuple fields and their "
"expected **types** (see allowed :ref:`indexed field types <index-"
"box_indexed-field-types>` below)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:121
msgid ""
"In our example, we first defined the primary index (named 'primary') "
"based on field #1 of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:124
msgid ""
"tarantool> i = s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:128
msgid ""
"The effect is that, for all tuples in space 'tester', field #1 must exist"
" and must contain an unsigned integer. The index type is 'hash', so "
"values in field #1 must be unique, because keys in HASH indexes are "
"unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:133
msgid ""
"After that, we defined a secondary index (named 'secondary') based on "
"field #2 of each tuple:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:136
msgid ""
"tarantool> i = s:create_index('secondary', {type = 'tree', parts = {2, "
"'string'}})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:140
msgid ""
"The effect is that, for all tuples in space 'tester', field #2 must exist"
" and must contain a string. The index type is 'tree', so values in field "
"#2 must not be unique, because keys in TREE indexes may be non-unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:147
msgid ""
"Space definitions and index definitions are stored permanently in "
"Tarantool's system spaces :ref:`_space <box_space-space>` and "
":ref:`_index <box_space-index>` (for details, see reference on "
":ref:`box.space <box_space>` submodule)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:151
msgid ""
"You can add, drop, or alter the definitions at runtime, with some "
"restrictions. See syntax details in reference on :ref:`box <box-module>` "
"module."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:158
msgid "Data types"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:160
msgid ""
"Tarantool is both a database and an application server. Hence a developer"
" often deals with two type sets: the programming language types (e.g. "
"Lua) and the types of the Tarantool storage format (MsgPack)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:169
msgid "Lua vs MsgPack"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
msgid "Scalar / compound"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
msgid "MsgPack |nbsp| type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
msgid "Lua type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:179
msgid "Example value"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:181
#: ../doc/1.7/book/box/data_model.rst:183
#: ../doc/1.7/book/box/data_model.rst:185
#: ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/book/box/data_model.rst:189
msgid "scalar"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:181
msgid "\"`nil`_\""
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:181
#: ../doc/1.7/book/box/data_model.rst:307
#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "msgpack.NULL"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:183
msgid "\"`boolean`_\""
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:183
#: ../doc/1.7/book/box/data_model.rst:309
#: ../doc/1.7/reference/reference_lua/msgpack.rst:167
msgid "true"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:185
msgid "\"`string`_\""
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:185
msgid "'A B C'"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/reference/reference_lua/errno.rst:54
msgid "integer"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:187
#: ../doc/1.7/book/box/data_model.rst:189
msgid "\"`number`_\""
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:187
msgid "12345"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:189
msgid "double"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:189
msgid "1,2345"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
#: ../doc/1.7/book/box/data_model.rst:193
#: ../doc/1.7/book/box/data_model.rst:195
msgid "compound"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "map"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "\"`table`_\" (with string keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:191
msgid "table: 0x410f8b10"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193
#: ../doc/1.7/book/box/data_model.rst:195
msgid "array"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193
msgid "\"`table`_\" (with integer keys)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:193
msgid "[1, 2, 3, 4, 5]"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:195
msgid "tuple (\"`cdata`_\")"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:195
msgid "[12345, 'A B C']"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:205
msgid ""
"In Lua, a **nil** type has only one possible value, also called *nil* "
"(displayed as **null** on Tarantool's command line, since the output is "
"in the YAML format). Nils may be compared to values of any types with == "
"(is-equal) or ~= (is-not-equal), but other operations will not work. Nils"
" may not be used in Lua tables; the workaround is to use "
":ref:`msgpack.NULL <msgpack-null>`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:213
msgid "A **boolean** is either ``true`` or ``false``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:215
msgid ""
"A **string** is a variable-length sequence of bytes, usually represented "
"with alphanumeric characters inside single quotes. In both Lua and "
"MsgPack, strings are treated as binary data, with no attempts to "
"determine a string's character set or to perform any string conversion. "
"So, string sorting and comparison are done byte-by-byte, without any "
"special collation rules applied. (Example: numbers are ordered by their "
"point on the number line, so 2345 is greater than 500; meanwhile, strings"
" are ordered by the encoding of the first byte, then the encoding of the "
"second byte, and so on, so '2345' is less than '500'.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:225
msgid ""
"In Lua, a **number** is double-precision floating-point, but Tarantool "
"allows both integer and floating-point values. Tarantool will try to "
"store a Lua number as floating-point if the value contains a decimal "
"point or is very large (greater than 100 trillion = 1e14), otherwise "
"Tarantool will store it as an integer. To ensure that even very large "
"numbers are stored as integers, use the :ref:`tonumber64 <other-"
"tonumber64>` function, or the LL (Long Long) suffix, or the ULL (Unsigned"
" Long Long) suffix. Here are examples of numbers using regular notation, "
"exponential notation, the ULL suffix and the ``tonumber64`` function: "
"``-55``, ``-2.7e+20``, ``100000000000000ULL``, "
"``tonumber64('18446744073709551615')``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:236
msgid ""
"Lua **tables** with string keys are stored as MsgPack maps; Lua tables "
"with integer keys starting with 1 -- as MsgPack arrays. Nils may not be "
"used in Lua tables; the workaround is to use :ref:`msgpack.NULL <msgpack-"
"null>`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:241
msgid ""
"A **tuple** is a light reference to a MsgPack array stored in the "
"database. It is a special type (cdata) to avoid conversion to a Lua table"
" on retrieval. A few functions may return tables with multiple tuples. "
"For more tuple examples, see :ref:`box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:248
msgid ""
"Tarantool uses the MsgPack format for database storage, which is "
"variable-length. So, for example, the smallest number requires only one "
"byte, but the largest number requires nine bytes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:256
msgid "Indexed field types"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:258
msgid ""
"Indexes restrict values which Tarantool's MsgPack may contain. This is "
"why, for example, 'unsigned' is a separate **indexed field type**, "
"compared to ‘integer’ data type in MsgPack: they both store ‘integer’ "
"values, but an 'unsigned' index contains only *non-negative* integer "
"values and an ‘integer’ index contains *all* integer values."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:264
msgid "Here's how Tarantool indexed field types correspond to MsgPack data types."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:275
msgid "Indexed field type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:275
msgid "MsgPack data type |br| (and possible values)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:275
#: ../doc/1.7/book/box/data_model.rst:642
msgid "Index type"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
msgid "**unsigned** (may also be called ‘uint’ or ‘num’, but ‘num’ is deprecated)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
msgid ""
"**integer** (integer between 0 and 18446744073709551615, i.e. about 18 "
"quintillion)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
msgid "TREE, BITSET or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:278
msgid "123456"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
msgid "**integer** (may also be called ‘int’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
#: ../doc/1.7/book/box/data_model.rst:288
#: ../doc/1.7/book/box/data_model.rst:312
msgid ""
"**integer** (integer between -9223372036854775808 and "
"18446744073709551615)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
#: ../doc/1.7/book/box/data_model.rst:288
#: ../doc/1.7/book/box/data_model.rst:298
#: ../doc/1.7/book/box/data_model.rst:307
msgid "TREE or HASH"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:283
msgid "-2^63"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:293
#: ../doc/1.7/book/box/data_model.rst:317
msgid ""
"**double** (single-precision floating point number or double-precision "
"floating point number)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:288
#: ../doc/1.7/book/box/data_model.rst:313
msgid "1.234"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:290
msgid "-44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:292
msgid "1.447e+44"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "**string** (may also be called ‘str’)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "**string** (any set of octets, up to the maximum length)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:298
msgid "‘A B C’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:300
msgid "‘\\65 \\66 \\67’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302
msgid ""
"**array** (arrays of integers between -9223372036854775808 and "
"9223372036854775807)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302
msgid "RTREE"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:302
msgid "{10, 11}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:304
msgid "{3, 5, 9, 10}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:307
msgid "**null**"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:309
msgid "**boolean** (true or false)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:322
msgid "**string** (any set of octets)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:324
msgid ""
"Note: When there is a mix of types, the key order is: null, then "
"booleans, then numbers, then strings."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:311
msgid "-1"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:315
msgid "‘’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:317
msgid "‘ру’"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:334
msgid "Persistence"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:336
msgid ""
"In Tarantool, updates to the database are recorded in the so-called "
"**write ahead log (WAL)** files. This ensures data persistence. When a "
"power outage occurs or the Tarantool instance is killed incidentally, the"
" in-memory database is lost. In this situation, WAL files are used to "
"restore the data. Namely, Tarantool reads the WAL files and redoes the "
"requests (this is called the \"recovery process\"). You can change the "
"timing of the WAL writer, or turn it off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:345
msgid ""
"Tarantool also maintains a set of **snapshot files**. These files contain"
" an on-disk copy of the entire data set for a given moment. Instead of "
"reading every WAL file since the databases were created, the recovery "
"process can load the latest snapshot file and then read only those WAL "
"files that were produced after the snapshot file was made. After "
"checkpointing, old WAL files can be removed to free up space."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:352
msgid ""
"To force immediate creation of a snapshot file, you can use Tarantool's "
":ref:`box.snapshot() <box-snapshot>` request. To enable automatic "
"creation of snapshot files, you can use Tarantool's :ref:`checkpoint "
"daemon <book_cfg_checkpoint_daemon>`. The checkpoint daemon sets "
"intervals for forced checkpoints. It makes sure that the states of both "
"memtx and vinyl storage engines are synchronized and saved to disk, and "
"automatically removes old WAL files."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:360
msgid "Snapshot files can be created even if there is no WAL file."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:364
msgid ""
"The memtx engine makes only regular checkpoints with the interval set in "
":ref:`checkpoint daemon <book_cfg_checkpoint_daemon>` configuration."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:367
msgid "The vinyl engine runs checkpointing in the background at all times."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:369
msgid ""
"See the :ref:`Internals <internals-data_persistence>` section for more "
"details about the WAL writer and the recovery process."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:374
msgid "Operations"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:380
msgid "Data operations"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:382
msgid "The basic data operations supported in Tarantool are:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:384
msgid "one data-retrieval operation (SELECT), and"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:385
msgid ""
"five data-manipulation operations (INSERT, UPDATE, UPSERT, DELETE, "
"REPLACE)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:387
msgid ""
"All of them are implemented as functions in :ref:`box.space <box_space>` "
"submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:389
#: ../doc/1.7/book/box/data_model.rst:560
msgid "**Examples**"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:391
msgid "INSERT: Add a new tuple to space 'tester'."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:393
msgid "The first field, field[1], will be 999 (MsgPack type is `integer`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:395
msgid "The second field, field[2], will be 'Taranto' (MsgPack type is `string`)."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:397
msgid "tarantool> box.space.tester:insert{999, 'Taranto'}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:401
msgid "UPDATE: Update the tuple, changing field field[2]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:403
msgid ""
"The clause \"{999}\", which has the value to look up in the index of the "
"tuple's primary-key field, is mandatory, because ``update()`` requests "
"must always have a clause that specifies a unique key, which in this case"
" is field[1]."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:407
msgid ""
"The clause \"{{'=', 2, 'Tarantino'}}\" specifies that assignment will "
"happen to field[2] with the new value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:410
msgid "tarantool> box.space.tester:update({999}, {{'=', 2, 'Tarantino'}})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:414
msgid "UPSERT: Upsert the tuple, changing field field[2] again."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:416
msgid ""
"The syntax of ``upsert()`` is similar to the syntax of ``update()``. "
"However, the execution logic of these two requests is different. UPSERT "
"is either UPDATE or INSERT, depending on the database's state. Also, "
"UPSERT execution is postponed after transaction commit, so, unlike "
"``update()``, ``upsert()`` doesn't return data back."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:422
msgid "tarantool> box.space.tester:upsert({999}, {{'=', 2, 'Tarantism'}})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:426
msgid "REPLACE: Replace the tuple, adding a new field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:428
msgid ""
"This is also possible with the ``update()`` request, but the ``update()``"
" request is usually more complicated."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:431
msgid "tarantool> box.space.tester:replace{999, 'Tarantella', 'Tarantula'}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:435
msgid "SELECT: Retrieve the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:437
msgid ""
"The clause \"{999}\" is still mandatory, although it does not have to "
"mention the primary key."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:439
msgid "tarantool> box.space.tester:select{999}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:442
msgid "DELETE: Delete the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:444
msgid "In this example, we identify the primary-key field."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:446
msgid "tarantool> box.space.tester:delete{999}"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:450
msgid ""
"All the functions operate on tuples and accept only unique key values. "
"So, the number of tuples in the space is always 0 or 1, since the keys "
"are unique."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:453
msgid ""
"Functions ``insert()``, ``upsert()`` and ``replace()`` accept only "
"primary-key values. Functions ``select()``, ``delete()`` and ``update()``"
" may accept either a primary-key value or a secondary-key value."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:459
msgid ""
"Besides Lua, you can use :ref:`Perl, PHP, Python or other programming "
"language connectors <index-box_connectors>`. The client server protocol "
"is open and documented. See this :ref:`annotated BNF <box_protocol-"
"iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:466
msgid "Index operations"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:468
msgid ""
"Index operations are automatic: if a data-manipulation request changes a "
"tuple, then it also changes the index keys defined for the tuple."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:471
msgid "The simple index-creation operation that we've illustrated before is:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:476
msgid ":samp:`box.space.{space-name}:create_index('{index-name}')`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:478
msgid ""
"This creates a unique TREE index on the first field of all tuples (often "
"called \"Field#1\"), which is assumed to be numeric."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:481
msgid "The simple SELECT request that we've illustrated before is:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:486
msgid ":extsamp:`box.space.{*{space-name}*}:select({*{value}*})`"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:488
msgid ""
"This looks for a single tuple via the first index. Since the first index "
"is always unique, the maximum number of returned tuples will be: one."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:491
msgid "The following SELECT variations exist:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:493
msgid "The search can use comparisons other than equality."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:500
msgid ""
"The comparison operators are LT, LE, EQ, REQ, GE, GT (for \"less than\", "
"\"less than or equal\", \"equal\", \"reversed equal\", \"greater than or "
"equal\", \"greater than\" respectively). Comparisons make sense if and "
"only if the index type is ‘TREE'."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:505
msgid ""
"This type of search may return more than one tuple; if so, the tuples "
"will be in descending order by key when the comparison operator is LT or "
"LE or REQ, otherwise in ascending order."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:509
msgid "The search can use a secondary index."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:516
msgid ""
"For a primary-key search, it is optional to specify an index name. For a "
"secondary-key search, it is mandatory."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:519
msgid "The search may be for some or all key parts."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:540
msgid "The search may be for all fields, using a table for the value:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:547
msgid "or the search can be for one field, using a table or a scalar:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:554
msgid ""
"In the second case, the result will be two tuples: ``{1, 'A'}`` and ``{1,"
" 'B'}``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:557
msgid ""
"You can specify even zero fields, causing all three tuples to be "
"returned. (Notice that partial key searches are available only in TREE "
"indexes.)"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:562
msgid "BITSET example:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:564
msgid ""
"tarantool> box.schema.space.create('bitset_example')\n"
"tarantool> box.space.bitset_example:create_index('primary')\n"
"tarantool> "
"box.space.bitset_example:create_index('bitset',{unique=false,type='BITSET',"
" parts={2,'unsigned'}})\n"
"tarantool> box.space.bitset_example:insert{1,1}\n"
"tarantool> box.space.bitset_example:insert{2,4}\n"
"tarantool> box.space.bitset_example:insert{3,7}\n"
"tarantool> box.space.bitset_example:insert{4,3}\n"
"tarantool> box.space.bitset_example.index.bitset:select(2, "
"{iterator='BITS_ANY_SET'})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:575
#: ../doc/1.7/book/box/data_model.rst:597
#: ../doc/1.7/tutorials/lua_tutorials.rst:869
msgid "The result will be:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:577
msgid ""
"---\n"
"- - [3, 7]\n"
"  - [4, 3]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:584
msgid "because (7 AND 2) is not equal to 0, and (3 AND 2) is not equal to 0."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:586
msgid "RTREE example:"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:588
msgid ""
"tarantool> box.schema.space.create('rtree_example')\n"
"tarantool> box.space.rtree_example:create_index('primary')\n"
"tarantool> "
"box.space.rtree_example:create_index('rtree',{unique=false,type='RTREE', "
"parts={2,'ARRAY'}})\n"
"tarantool> box.space.rtree_example:insert{1, {3, 5, 9, 10}}\n"
"tarantool> box.space.rtree_example:insert{2, {10, 11}}\n"
"tarantool> box.space.rtree_example.index.rtree:select({4, 7, 5, 9}, "
"{iterator = 'GT'})"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:599
msgid ""
"---\n"
"- - [1, [3, 5, 9, 10]]\n"
"..."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:605
msgid ""
"because a rectangle whose corners are at coordinates ``4,7,5,9`` is "
"entirely within a rectangle whose corners are at coordinates "
"``3,5,9,10``."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:608
msgid ""
"Additionally, there exist :ref:`index iterator operations <box_index-"
"index_pairs>`. They can only be used with code in Lua and C/C++. Index "
"iterators are for traversing indexes one key at a time, taking advantage "
"of features that are specific to an index type, for example evaluating "
"Boolean expressions when traversing BITSET indexes, or going in "
"descending order when traversing TREE indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:614
msgid ""
"See also other index operations like :ref:`alter() <box_index-alter>` and"
" :ref:`drop() <box_index-drop>` in reference for :ref:`box.index "
"<box_index>` submodule."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:619
msgid "Complexity factors"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:621
msgid ""
"In reference for :ref:`box.space <box_space>` and :ref:`box.index "
"<box_index>` submodules, there are notes about which complexity factors "
"might affect the resource usage of each function."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:631
msgid "Complexity factor"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:634
msgid "Index size"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:634
msgid ""
"The number of index keys is the same as the number of tuples in the data "
"set. For a TREE index, if there are more keys, then the lookup time will "
"be greater, although of course the effect is not linear. For a HASH "
"index, if there are more keys, then there is more RAM used, but the "
"number of low-level steps tends to remain constant."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:642
msgid ""
"Typically, a HASH index is faster than a TREE index if the number of "
"tuples in the space is greater than one."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:646
msgid "Number of indexes accessed"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:646
msgid ""
"Ordinarily, only one index is accessed to retrieve one tuple. But to "
"update the tuple, there must be N accesses if the space has N different "
"indexes."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:650
msgid ""
"Note re storage engine: Vinyl optimizes away such accesses if secondary "
"index fields are unchanged by the update. So, this complexity factor "
"applies only to memtx, since it always makes a full-tuple copy on every "
"update."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:656
msgid "Number of tuples accessed"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:656
msgid ""
"A few requests, for example SELECT, can retrieve multiple tuples. This "
"factor is usually less important than the others."
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:660
msgid "WAL settings"
msgstr ""

#: ../doc/1.7/book/box/data_model.rst:660
msgid ""
"The important setting for the write-ahead log is :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>`. If the setting causes no "
"writing or delayed writing, this factor is unimportant. If the setting "
"causes every data-change request to wait for writing to finish on a slow "
"device, this factor is more important than all the others."
msgstr ""

#: ../doc/1.7/book/box/index.rst:33
msgid "Database"
msgstr ""

#: ../doc/1.7/book/box/index.rst:35
msgid ""
"In this chapter, we introduce the basic concepts of working with "
"Tarantool as a database manager."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:33
msgid "Limitations"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:35
msgid "**Number of parts in an index**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:37
msgid ""
"For TREE or HASH indexes, the maximum is 255 "
"(``box.schema.INDEX_PART_MAX``). For RTREE indexes, the maximum is 1 but "
"the field is an ARRAY of up to 20 dimensions. For BITSET indexes, the "
"maximum is 1."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:44
msgid "**Number of indexes in a space**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:46
msgid "128 (``box.schema.INDEX_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:50
msgid "**Number of fields in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:52
msgid ""
"The theoretical maximum is 2,147,483,647 (``box.schema.FIELD_MAX``). The "
"practical maximum is whatever is specified by the space's "
":ref:`field_count <box_space-field_count>` member, or the maximal tuple "
"length."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:59
msgid "**Number of bytes in a tuple**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:61
msgid ""
"The maximal number of bytes in a tuple is roughly equal to "
":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>` (with a "
"metadata overhead of about 20 bytes per tuple, which is added on top of "
"useful bytes). By default, the value of ``memtx_max_tuple_size`` is "
"1,048,576. To increase it, specify a larger value when starting the "
"Tarantool instance. For example, "
"``box.cfg{memtx_max_tuple_size=2*1048576}``."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:70
msgid "**Slab size**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:72
msgid ""
"The maximal size of an allocatable memory unit (slab) is equal to one "
"quarter of :ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
" (by default, approximately 262,000 bytes). To see memory usage "
"statistics broken down by slab size, use :ref:`box.slab.stats() "
"<box_slab_stats>`."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:79
msgid "**Number of bytes in an index key**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:81
msgid ""
"If a field in a tuple can contain a million bytes, then the index key can"
" contain a million bytes, so the maximum is determined by factors such as"
" :ref:`Number of bytes in a tuple <limitations_bytes_in_tuple>`, not by "
"the index support."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:88
msgid "**Number of spaces**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:90
msgid "The theoretical maximum is 65,000 (``box.schema.SPACE_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:94
msgid "**Number of connections**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:96
msgid ""
"The practical limit is the number of file descriptors that one can set "
"with the operating system."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:101
msgid "**Space size**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:103
msgid ""
"The total maximum size for all spaces is in effect set by "
":ref:`memtx_memory <cfg_storage-memtx_memory>`, which in turn is limited "
"by the total available memory."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:109
msgid "**Update operations count**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:111
msgid ""
"The maximum number of operations that can be in a single update is 4000 "
"(``BOX_UPDATE_OP_CNT_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:116
msgid "**Number of users and roles**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:118
msgid "32 (BOX_USER_MAX)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:122
msgid "**Length of an index name or space name or user name**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:124
msgid "32 (``box.schema.NAME_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:128
msgid "**Number of replicas in a replica set**"
msgstr ""

#: ../doc/1.7/book/box/limitations.rst:130
msgid "32 (``box.schema.REPLICA_MAX``)."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:34
msgid "Triggers"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:36
msgid ""
"**Triggers**, also known as **callbacks**, are functions which the server"
" executes when certain events happen."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:39
msgid "There are three types of triggers in Tarantool:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:41
msgid ""
":ref:`connection triggers <box_session-on_connect>`, which are executed "
"when a session begins or ends,"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:44
msgid ""
":ref:`authentication triggers <box_session-on_auth>`, which are executed "
"during authentication, and"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:47
msgid ""
":ref:`replace triggers <box_space-on_replace>`, which are for database "
"events."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:50
msgid "All triggers have the following characteristics:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:52
msgid ""
"Triggers associate a function with an event. The request to \"define a "
"trigger\" implies passing the trigger’s function to one of the "
"\"on_event-name()\" functions: :ref:`box.session.on_connect() "
"<box_session-on_connect>`, :ref:`box.session.on_auth() <box_session-"
"on_auth>`, :ref:`box.session.on_disconnect() <box_session-"
"on_disconnect>`, or :ref:`space_object:on_replace() <box_space-"
"on_replace>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:60
msgid "Triggers are defined only by the 'admin' user."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:62
msgid ""
"Triggers are stored in the Tarantool instance's memory, not in the "
"database. Therefore triggers disappear when the instance is shut down. To"
" make them permanent, put function definitions and trigger settings into "
"Tarantool's :ref:`initialization script <index-init_label>`."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:67
msgid ""
"Triggers have low overhead. If a trigger is not defined, then the "
"overhead is minimal: merely a pointer dereference and check. If a trigger"
" is defined, then its overhead is equivalent to the overhead of calling a"
" function."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:71
msgid ""
"There can be multiple triggers for one event. In this case, triggers are "
"executed in the reverse order that they were defined in."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:74
msgid ""
"Triggers must work within the event context. However, effects are "
"undefined if a function contains requests which normally could not occur "
"immediately after the event, but only before the return from the event. "
"For example, putting `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_ or "
":ref:`box.rollback() <box-rollback>` in a trigger function would be "
"bringing in requests outside the event context."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:81
msgid ""
"Triggers are replaceable. The request to \"redefine a trigger\" implies "
"passing a new trigger function and an old trigger function to one of the "
"\"on_event-name()\" functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:85
msgid ""
"The \"on_event_name()\" functions all have parameters which are function "
"pointers, and they all return function pointers. Remember that a Lua "
"function definition such as \"function f() x = x + 1 end\" is the same as"
" \"f = function () x = x + 1 end\" -- in both cases ``f`` gets a function"
" pointer. And \"trigger = box.session.on_connect(f)\" is the same as "
"\"trigger = box.session.on_connect(function () x = x + 1 end)\" -- in "
"both cases ``trigger`` gets the function pointer which was passed."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:93
msgid "To get a list of triggers, you can use:"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:95
msgid ""
"on_connect() – with no arguments – to return a table of all connect-"
"trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:96
msgid "on_auth() to return all authentication-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:97
msgid "on_disconnect() to return all disconnect-trigger functions;"
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:98
msgid "on_replace() to return all replace-trigger functions."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:102
msgid "Here we log connect and disconnect events into Tarantool server log."
msgstr ""

#: ../doc/1.7/book/box/triggers.rst:104
msgid ""
"log = require('log')\n"
"\n"
"function on_connect_impl()\n"
"  log.info(\"connected \"..box.session.peer()..\", sid "
"\"..box.session.id())\n"
"end\n"
"\n"
"function on_disconnect_impl()\n"
"  log.info(\"disconnected, sid \"..box.session.id())\n"
"end\n"
"\n"
"function on_auth_impl(user)\n"
"  log.info(\"authenticated sid \"..box.session.id()..\" as \"..user)\n"
"end\n"
"\n"
"function on_connect() pcall(on_connect_impl) end\n"
"function on_disconnect() pcall(on_disconnect_impl) end\n"
"function on_auth(user) pcall(on_auth_impl, user) end\n"
"\n"
"box.session.on_connect(on_connect)\n"
"box.session.on_disconnect(on_disconnect)\n"
"box.session.on_auth(on_auth)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:31
msgid ""
"A storage engine is a set of very-low-level routines which actually store"
" and retrieve tuple values. Tarantool offers a choice of two storage "
"engines:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:34
msgid ""
"memtx (the in-memory storage engine) is the default and was the first to "
"arrive."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:37
msgid ""
"vinyl (the on-disk storage engine) is a working key-value engine and will"
" especially appeal to users who like to see data go directly to disk, so "
"that recovery time might be shorter and database size might be larger. On"
" the other hand, vinyl lacks some functions and options that are "
"available with memtx. Where that is the case, the relevant description in"
" this manual will contain a note beginning with the words \"Note re "
"storage engine\". See also a coverage for all :ref:`the differences "
"between memtx and vinyl <vinyl_diff>` further on this page."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:46
msgid ""
"To specify that the engine should be vinyl, add the clause ``engine = "
"'vinyl'`` when creating a space, for example: ``space = "
"box.schema.space.create('name', {engine='vinyl'})``."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:54
msgid "Differences between memtx and vinyl storage engines"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:56
msgid ""
"The primary difference between memtx and vinyl is that memtx is an \"in-"
"memory\" engine while vinyl is an \"on-disk\" engine. An in-memory "
"storage engine is generally faster, and the memtx engine is justifiably "
"the default for Tarantool, but there are two situations where an on-disk "
"engine such as vinyl would be preferable:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:62
msgid ""
"when the database is larger than the available memory and adding more "
"memory is not a realistic option;"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:64
msgid ""
"when the server frequently goes down due to errors or a simple desire to "
"save power -- bringing the server back up and restoring a memtx database "
"into memory takes time."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:68
msgid ""
"Here are behavior differences which affect programmers. All of these "
"differences have been noted elsewhere in sentences that begin with the "
"words \"Note re storage engine: vinyl\"."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, the index type can be TREE or HASH or RTREE or BITSET."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, the only index type is TREE."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, :ref:`create_index <box_space-create_index>` can be done at "
"any time."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, secondary indexes must be created before tuples are inserted."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, for index searches, ``nil`` may be allowed within a search "
"key."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, ``nil`` is only allowed at the end of a search key."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, temporary spaces are supported."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, they are not."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, the :ref:`alter() <box_index-alter>` and :ref:`len() "
"<box_space-len>` and :ref:`random() <box_index-random>` functions are "
"supported."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid ""
"With memtx, the :ref:`count() <box_index-count>` function takes a "
"constant amount of time."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, it takes a variable amount of time depending on index size."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With memtx, delete will return deleted tuple, if any."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst
msgid "With vinyl, delete will always return nil."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:95
msgid ""
"It was explained :ref:`earlier <index-yields_must_happen>` that memtx "
"does not \"yield\" on a select request, it yields only on data-change "
"requests. However, vinyl does yield on a select request, or on an "
"equivalent such as ``get()`` or ``pairs()``. This has significance for "
":ref:`cooperative multitasking <atomic-cooperative_multitasking>`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:103
msgid "Vinyl features"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:105
msgid "Full ACID compliance"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:106
msgid "Multi-Version Concurrency Control (MVCC)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:107
msgid "Pure Append-Only"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:108
msgid "Multi-threaded (Client access and Engine scalability)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:109
msgid "Multi-databases support (Single environment and WAL)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:110
msgid ""
"Multi-Statement and Single-Statement Transactions (Snapshot Isolation "
"(SI), multi-databases)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:112
msgid ""
"Asynchronous or synchronous transaction execution (Callback triggered "
"versus blocking)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:114
msgid ""
"Separate storage formats: key-value (Default), or document (Keys are part"
" of value)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:116
msgid "Update without read"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:117
msgid "Consistent Cursors"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:118
msgid "Prefix search"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:119
msgid "Point-in-Time Snapshots"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:120
msgid "Versional database creation and asynchronous shutdown/drop"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:121
msgid "Asynchronous Online/Hot Backup"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:122
msgid "Compression (Per region, both lz4 and zstd are supported)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:123
msgid "Metadata Compression (By default)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:124
msgid "Key Compression (Compress key duplicates, including suffixes)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:125
msgid "Easy to use (Minimalist API)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:126
msgid "Easy to integrate (Native support of using as storage engine)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:127
msgid ""
"Easy to write bindings (Very FFI-friendly, API designed to be stable in "
"future)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:128
msgid "Easy to build in (Amalgamated, compiles into two C files)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:129
msgid "Event loop friendly"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:130
msgid "Zero-Configuration (Tuned by default)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:131
msgid "Implemented as a small library **written in C** with zero dependencies"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:132
msgid "BSD Licensed"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:134
msgid ""
"It is appropriate for databases that cannot fit in memory, where access "
"via secondary keys is not required."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:137
msgid "In vinyl terminology:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:139
msgid "There is one **Environment**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:140
msgid ""
"An Environment has N **Databases** - a vinyl database is like a Tarantool"
" `space`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:141
msgid "A Database has N **Ranges**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:142
msgid "A Range has one **Range File**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:143
msgid "A Range File has N **Runs**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:144
msgid "A Run has N **Regions** - a vinyl Region is like a B-tree `page`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:145
msgid ""
"A Region has **keys** and **values** - a vinyl key-value is like a "
"Tarantool `tuple`."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:147
msgid ""
"A key and its associated value are together, so when one accesses a key "
"one gets the whole tuple. In other words, in vinyl the data is stored in "
"the index. There are up to two in-memory copies of an index, as well as "
"the copy in the Range File."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:151
msgid ""
"For operations that insert or update tuples - called Set operations in "
"vinyl - vinyl makes changes to in-memory copies of the index, and writes "
"to Tarantool's Write-ahead Log. A scheduler assigns tasks to multiple "
"background threads for transferring index data from memory to disk, and "
"for reorganizing Runs. To support transactions, Set operations can be "
"delayed until an explicit commit. If multiple users access the same "
"tuples simultaneously, the concurrency control method is `MVCC`_ and the "
"isolation level is `Snapshot`_."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:162
msgid ""
"Formally, in terms of disk accesses, vinyl has the following algorithmic "
"complexity:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:164
msgid ""
"**Set** - the worst case is O(*1*) append-only key writes to the Write-"
"Ahead Log + in-memory Range index searches + in-memory index inserts"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:166
msgid ""
"**Delete** - the worst case is O(*1*) key writes and in-memory index "
"inserts (the same as **Set**)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:168
msgid ""
"**Get** - the worst case is `amortized`_ "
"O(*max\\_run\\_count\\_per\\_node*) random Region reads from a single "
"Range file, which itself does in-memory index search + in-memory Region "
"search"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:171
msgid ""
"**Range** - queries, the worst case of full Database scan is amortized "
"O(*total\\_Region\\_count*) + in-memory key-index searches for each Range"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:178
msgid "Under the hood"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:180
msgid "In this section, to illustrate internals, we will discuss this example:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:182
msgid ""
"filling an empty database with one million tuples (we'll call them "
"\"keys\" to emphasize the indexed nature)"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:184
msgid "reading all stored tuples in the original order."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:188
msgid "Inserting the first 200.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:190
msgid ""
"During the first 200,000 Set operations, inserted keys first go to the "
"in-memory index. To maintain persistence, information about each Set "
"operation is written to Tarantool's Write-ahead Log."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:198
msgid ""
"At this point, we have keys in an in-memory index and records in the "
"Write-ahead Log."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:202
msgid "Inserting the next 300.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:204
msgid ""
"As the in-memory index becomes too large for available memory, the index "
"must be copied from memory to disk. The on-disk copy of the in-memory "
"index is called a Run. To save the Run, a new file is created, the Range "
"File. We will call it **db file** for this example."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:209
msgid ""
"The scheduler wakes a worker thread in the background, a Run Creation "
"Thread. The thread creates a second in-memory index. If there are Set "
"operations taking place while the thread is working, their contention "
"effect will be small because they will operate on the second in-memory "
"index."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:218
msgid ""
"When the Run Creation Thread finishes the task, the first in-memory index"
" is freed."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:227
msgid "Inserting the next 200.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:229
msgid ""
"Several times, the in-memory index becomes too large and a Run Creation "
"Thread transfers the keys to a Run. The Runs have been appended to the "
"end of db file. The number of created Runs becomes large."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:237
msgid ""
"There is a user-settable maximum number of Runs per Range. When the "
"number of Runs reaches this maximum, the vinyl scheduler wakes a "
"**Compaction Thread** for the db file. The Compaction Thread merges the "
"keys in all the Runs, and creates one or more new db files."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:246
msgid ""
"Now there are multiple pairs of in-memory indexes, and each pair has an "
"associated db file. The combination of the in-memory indexes and the db "
"file is called a **Range**, and the db file is called a **Range File**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:254
msgid ""
"Thus the contents of a Range are: a range of sorted key values, stored in"
" Runs of a Range File and (when necessary) in memory. Since the ranges do"
" not overlap, each Range can be handled independently. Therefore, while "
"one of the background threads is working on Range 1, another background "
"thread can be working on Range 2, without contention. That means that all"
" the background operations (Run Creation, Compaction, Garbage Collection,"
" and Backup) can take place in parallel on multiple threads."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:262
msgid "The foregoing explanation will now be repeated with different wording."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:264
msgid ""
"Before the Compaction there was one Range, which was created "
"automatically when the Database was initialized. The Range had:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:267
msgid "an in-memory index with some keys in it,"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:268
msgid "a Range File with several Runs,"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:269
msgid ""
"a Write-Ahead Log file recording the Set operations, in the order they "
"happened."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:271
msgid ""
"The number of Runs became too big, so the vinyl scheduler starts the "
"Compaction Thread and creates two new Ranges."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:278
msgid ""
"So, each of the two new Range Files contains half of the keys that were "
"in the original Range. The Range's in-memory indexes are split in the "
"same way."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:281
msgid ""
"After the splitting, vinyl must take into account that: while the "
"Compaction was going on in the background, there might have been more Set"
" operations taking place in parallel. These Set operations would have "
"changed one of the in-memory indexes, and these changes too will be "
"merged."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:286
msgid ""
"When the Compaction Thread finishes, the original Range is deleted, and "
"information about the new Ranges is inserted into an in-memory **Range "
"Index**."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:293
msgid ""
"This Range Index is used for all Set operations and all searches. Since "
"the Range Index has the minimum and maximum key values that are in each "
"Range, it is straightforward to scan it to find what Range would contain "
"a particular key value."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:303
msgid "Inserting the last 300.000 keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:305
msgid ""
"The final 300,000 Set operations take place; the background threads "
"continue to create new Runs and do more Compactions. After the millionth "
"insertion, the Database has four Ranges."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:313
msgid ""
"The inserting is done. Now, because the words \"memory\" and \"disk\" "
"have appeared in this explanation several times, here are a few words "
"about how vinyl is designed to use these resources most efficiently:"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:317
msgid ""
"If there is more memory available, then Run Creation and Compaction will "
"be less frequent, and there will be fewer disk accesses."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:319
msgid ""
"The best vinyl performance will occur if there is no setting of a memory "
"limit, but this must be balanced against other considerations, such as "
"requirements for the memtx storage engine. If there is a setting of a "
"memory limit, the vinyl scheduler will give priority to the Ranges that "
"have the largest in-memory indexes, so that the largest memory blocks are"
" freed first."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:324
msgid ""
"To make the most of hard drives and Flash, vinyl will delay operations "
"that require disk access (except the writing of the Write-ahead Log which"
" is specially tunable), so that the accesses are done in large sequential"
" blocks."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:327
msgid "Overwriting does not occur; vinyl is an \"append-only\" engine."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:331
msgid "Reading million keys"
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:333
msgid ""
"We will now start to read the million rows in the order that they were "
"inserted, which was random."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:340
msgid ""
"During the Get (search), vinyl first finds the correct Range by looking "
"in the Range Index. Then it searches the Range's first in-memory index, "
"and/or the Range's second in-memory index, and/or each Run of the Range, "
"starting from the end of the Range File."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:345
msgid ""
"Remember that a Run is divided into Regions, which are like what would be"
" called \"pages\" or \"blocks\" in a B-tree. For each Run, there is a "
"list of the Regions and their minimum/maximum key values - the Region "
"Index - as well as some metadata."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:354
msgid ""
"Region Indexes are loaded into memory when the Database is opened. Since "
"the Database's Range Index and the Region Indexes are normally in-memory,"
" searching and retrieving a tuple might require only zero or one disk "
"accesses. However, when memory is limited and there are many Runs, search"
" time may rise. For each additional Run there is a possible additional "
"disk access during a search. Also, it is impossible to maintain memory "
"limits without doing a Run Creation process, because new Set operations "
"might occur more quickly than the Compaction process can run."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:367
msgid ""
"Vinyl is read optimized. It is very likely that the most recently created"
" Runs (hot data) will be in the file system cache. The scheduler will "
"give priority to the Ranges which have the largest in-memory indexes and "
"the most Runs."
msgstr ""

#: ../doc/1.7/book/box/vinyl.rst:372
msgid ""
"The scheduler may also try to arrange that a Range will have only one "
"Run, which will ensure the average number of disk seeks for each search "
"is O(*1*)."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:3 ../doc/1.7/book/connectors/__c.rst:31
msgid "C"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:5 ../doc/1.7/book/connectors/__c.rst:33
msgid "Here follow two examples of using Tarantool's high-level C API."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:9 ../doc/1.7/book/connectors/__c.rst:37
msgid "Example 1"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:11 ../doc/1.7/book/connectors/__c.rst:39
msgid ""
"Here is a complete C program that inserts :code:`[99999,'B']` into space "
":code:`examples` via the high-level C API."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:14 ../doc/1.7/book/connectors/__c.rst:42
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"void main() {\n"
"   struct tnt_stream *tnt = tnt_net(NULL);          /* See note = SETUP "
"*/\n"
"   tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                      /* See note = CONNECT"
" */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *tuple = tnt_object(NULL);     /* See note = MAKE "
"REQUEST */\n"
"   tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");\n"
"   tnt_insert(tnt, 999, tuple);                     /* See note = SEND "
"REQUEST */\n"
"   tnt_flush(tnt);\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply); /* See note = GET "
"REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"       printf(\"Insert failed %lu.\\n\", reply.code);\n"
"   }\n"
"   tnt_close(tnt);                                  /* See below = "
"TEARDOWN */\n"
"   tnt_stream_free(tuple);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:44 ../doc/1.7/book/connectors/__c.rst:72
msgid ""
"Paste the code into a file named :file:`example.c` and install "
"``tarantool-c``. One way to install ``tarantool-c`` (using Ubuntu) is:"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:47 ../doc/1.7/book/connectors/__c.rst:75
msgid ""
"$ git clone git://github.com/tarantool/tarantool-c.git ~/tarantool-c\n"
"$ cd ~/tarantool-c\n"
"$ git submodule init\n"
"$ git submodule update\n"
"$ cmake .\n"
"$ make\n"
"$ make install"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:57 ../doc/1.7/book/connectors/__c.rst:85
#: ../doc/1.7/book/connectors/__c.rst:288
#: ../doc/1.7/book/connectors/__c.rst:316
msgid "To compile and link the program, say:"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:59 ../doc/1.7/book/connectors/__c.rst:87
msgid ""
"$ # sometimes this is necessary:\n"
"$ export LD_LIBRARY_PATH=/usr/local/lib\n"
"$ gcc -o example example.c -ltarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:65 ../doc/1.7/book/connectors/__c.rst:93
msgid ""
"Before trying to run, check that a server instance is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`. To run the program, "
"say :samp:`./example`. The program will connect to the Tarantool "
"instance, and will send the request. If Tarantool is not running on "
"localhost with listen address = 3301, the program will print “Connection "
"refused”. If the insert fails, the program will print \"Insert failed\" "
"and an error number (see all error codes in the source file "
"`/src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_)."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:77 ../doc/1.7/book/connectors/__c.rst:105
msgid "Here are notes corresponding to comments in the example program."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:79 ../doc/1.7/book/connectors/__c.rst:107
msgid "**SETUP:** The setup begins by creating a stream."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:81 ../doc/1.7/book/connectors/__c.rst:109
msgid ""
"struct tnt_stream *tnt = tnt_net(NULL);\n"
"tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:86 ../doc/1.7/book/connectors/__c.rst:114
msgid ""
"In this program, the stream will be named ``tnt``. Before connecting on "
"the ``tnt`` stream, some options may have to be set. The most important "
"option is TNT_OPT_URI. In this program, the URI is ``localhost:3301``, "
"since that is where the Tarantool instance is supposed to be listening."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:92 ../doc/1.7/book/connectors/__c.rst:108
#: ../doc/1.7/book/connectors/__c.rst:120
#: ../doc/1.7/book/connectors/__c.rst:136
#: ../doc/1.7/book/connectors/__c.rst:156
#: ../doc/1.7/book/connectors/__c.rst:164
#: ../doc/1.7/book/connectors/__c.rst:181
#: ../doc/1.7/book/connectors/__c.rst:184
#: ../doc/1.7/book/connectors/__c.rst:200
#: ../doc/1.7/book/connectors/__c.rst:209
#: ../doc/1.7/book/connectors/__c.rst:228
msgid "Function description:"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:125
#: ../doc/1.7/book/connectors/__c.rst:574
msgid ""
"`struct tnt_stream *tnt_net(struct tnt_stream *s)`\n"
"`int tnt_set(struct tnt_stream *s, int option, variant option-value)`"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:100
#: ../doc/1.7/book/connectors/__c.rst:128
msgid ""
"**CONNECT:** Now that the stream named ``tnt`` exists and is associated "
"with a URI, this example program can connect to a server."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:103
#: ../doc/1.7/book/connectors/__c.rst:131
msgid ""
"if (tnt_connect(tnt) < 0)\n"
"   { printf(\"Connection refused\\n\"); exit(-1); }"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:141
#: ../doc/1.7/book/connectors/__c.rst:590
msgid "int tnt_connect(struct tnt_stream \\*s)"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:115
#: ../doc/1.7/book/connectors/__c.rst:143
msgid ""
"The connection might fail for a variety of reasons, such as: the server "
"is not running, or the URI contains an invalid password. If the "
"connection fails, the return value will be -1."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:119
#: ../doc/1.7/book/connectors/__c.rst:147
msgid ""
"**MAKE REQUEST:** Most requests require passing a structured value, such "
"as the contents of a tuple."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:122
#: ../doc/1.7/book/connectors/__c.rst:150
#, python-format
msgid ""
"struct tnt_stream *tuple = tnt_object(NULL);\n"
"tnt_object_format(tuple, \"[%d%s]\", 99999, \"B\");"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:127
#: ../doc/1.7/book/connectors/__c.rst:155
#, python-format
msgid ""
"In this program, the request will be an INSERT, and the tuple contents "
"will be an integer and a string. This is a simple serial set of values, "
"that is, there are no sub-structures or arrays. Therefore it is easy in "
"this case to format what will be passed using the same sort of arguments "
"that one would use with a C ``printf()`` function: ``%d`` for the "
"integer, ``%s`` for the string, then the integer value, then a pointer to"
" the string value."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:169
#: ../doc/1.7/book/connectors/__c.rst:618
msgid "ssize_t tnt_object_format(struct tnt_stream \\*s, const char \\*fmt, ...)"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:143
#: ../doc/1.7/book/connectors/__c.rst:171
msgid ""
"**SEND REQUEST:** The database-manipulation requests are analogous to the"
" requests in the box library."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:146
#: ../doc/1.7/book/connectors/__c.rst:174
msgid ""
"tnt_insert(tnt, 999, tuple);\n"
"tnt_flush(tnt);"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:151
#: ../doc/1.7/book/connectors/__c.rst:179
msgid ""
"In this program, the choice is to do an INSERT request, so the program "
"passes the ``tnt_stream`` that was used for connection (``tnt``) and the "
"``tnt_stream`` that was set up with "
":c:func:`tarantoolc:tnt_object_format` (``tuple``)."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:189
#: ../doc/1.7/book/connectors/__c.rst:638
msgid ""
"ssize_t tnt_insert(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_replace(struct tnt_stream \\*s, uint32_t space, struct "
"tnt_stream \\*tuple)\n"
"ssize_t tnt_select(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   uint32_t limit, uint32_t offset, uint8_t iterator,\n"
"                   struct tnt_stream \\*key)\n"
"ssize_t tnt_update(struct tnt_stream \\*s, uint32_t space, uint32_t "
"index,\n"
"                   struct tnt_stream \\*key, struct tnt_stream \\*ops)"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:169
#: ../doc/1.7/book/connectors/__c.rst:197
msgid ""
"**GET REPLY:** For most requests, the client will receive a reply "
"containing some indication whether the result was successful, and a set "
"of tuples."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:172
#: ../doc/1.7/book/connectors/__c.rst:200
#, python-format
msgid ""
"struct tnt_reply reply;  tnt_reply_init(&reply);\n"
"tnt->read_reply(tnt, &reply);\n"
"if (reply.code != 0)\n"
"   { printf(\"Insert failed %lu.\\n\", reply.code); }"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:179
#: ../doc/1.7/book/connectors/__c.rst:207
msgid "This program checks for success but does not decode the rest of the reply."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:214
#: ../doc/1.7/book/connectors/__c.rst:663
msgid ""
"struct tnt_reply \\*tnt_reply_init(struct tnt_reply \\*r)\n"
"tnt->read_reply(struct tnt_stream \\*s, struct tnt_reply \\*r)\n"
"void tnt_reply_free(struct tnt_reply \\*r)"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:190
#: ../doc/1.7/book/connectors/__c.rst:218
msgid ""
"**TEARDOWN:** When a session ends, the connection that was made with "
":c:func:`tarantoolc:tnt_connect()` should be closed, and the objects that"
" were made in the setup should be destroyed."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:194
#: ../doc/1.7/book/connectors/__c.rst:222
msgid ""
"tnt_close(tnt);\n"
"tnt_stream_free(tuple);\n"
"tnt_stream_free(tnt);"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:233
#: ../doc/1.7/book/connectors/__c.rst:682
msgid ""
"void tnt_close(struct tnt_stream \\*s)\n"
"void tnt_stream_free(struct tnt_stream \\*s)"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:210
#: ../doc/1.7/book/connectors/__c.rst:238
msgid "Example 2"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:212
#: ../doc/1.7/book/connectors/__c.rst:240
msgid ""
"Here is a complete C program that selects, using index key ``[99999]``, "
"from space ``examples`` via the high-level C API. To display the results,"
" the program uses functions in the `MsgPuck "
"<http://rtsisyk.github.io/msgpuck/>`_ library which allow decoding of "
"`MessagePack <https://en.wikipedia.org/wiki/MessagePack>`_  arrays."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:218
#: ../doc/1.7/book/connectors/__c.rst:246
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"\n"
"#define MP_SOURCE 1\n"
"#include <msgpuck.h>\n"
"\n"
"void main() {\n"
"    struct tnt_stream *tnt = tnt_net(NULL);\n"
"    tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"    if (tnt_connect(tnt) < 0) {\n"
"        printf(\"Connection refused\\n\");\n"
"        exit(1);\n"
"    }\n"
"    struct tnt_stream *tuple = tnt_object(NULL);\n"
"    tnt_object_format(tuple, \"[%d]\", 99999); /* tuple = search key */\n"
"    tnt_select(tnt, 999, 0, (2^32) - 1, 0, 0, tuple);\n"
"    tnt_flush(tnt);\n"
"    struct tnt_reply reply; tnt_reply_init(&reply);\n"
"    tnt->read_reply(tnt, &reply);\n"
"    if (reply.code != 0) {\n"
"        printf(\"Select failed.\\n\");\n"
"        exit(1);\n"
"    }\n"
"    char field_type;\n"
"    field_type = mp_typeof(*reply.data);\n"
"    if (field_type != MP_ARRAY) {\n"
"        printf(\"no tuple array\\n\");\n"
"        exit(1);\n"
"    }\n"
"    long unsigned int row_count;\n"
"    uint32_t tuple_count = mp_decode_array(&reply.data);\n"
"    printf(\"tuple count=%u\\n\", tuple_count);\n"
"    unsigned int i, j;\n"
"    for (i = 0; i < tuple_count; ++i) {\n"
"        field_type = mp_typeof(*reply.data);\n"
"        if (field_type != MP_ARRAY) {\n"
"            printf(\"no field array\\n\");\n"
"            exit(1);\n"
"        }\n"
"        uint32_t field_count = mp_decode_array(&reply.data);\n"
"        printf(\"  field count=%u\\n\", field_count);\n"
"        for (j = 0; j < field_count; ++j) {\n"
"            field_type = mp_typeof(*reply.data);\n"
"            if (field_type == MP_UINT) {\n"
"                uint64_t num_value = mp_decode_uint(&reply.data);\n"
"                printf(\"    value=%lu.\\n\", num_value);\n"
"            } else if (field_type == MP_STR) {\n"
"                const char *str_value;\n"
"                uint32_t str_value_length;\n"
"                str_value = mp_decode_str(&reply.data, "
"&str_value_length);\n"
"                printf(\"    value=%.*s.\\n\", str_value_length, "
"str_value);\n"
"            } else {\n"
"                printf(\"wrong field type\\n\");\n"
"                exit(1);\n"
"            }\n"
"        }\n"
"    }\n"
"    tnt_close(tnt);\n"
"    tnt_stream_free(tuple);\n"
"    tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:285
#: ../doc/1.7/book/connectors/__c.rst:313
msgid ""
"Similarly to the first example, paste the code into a file named "
":file:`example2.c`."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:290
#: ../doc/1.7/book/connectors/__c.rst:318
msgid "$ gcc -o example2 example2.c -ltarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:294
#: ../doc/1.7/book/connectors/__c.rst:322
msgid "To run the program, say :samp:`./example2`."
msgstr ""

#: ../doc/1.7/book/connectors/__c.rst:296
#: ../doc/1.7/book/connectors/__c.rst:324
msgid ""
"The two example programs only show a few requests and do not show all "
"that's necessary for good practice. See more in the `tarantool-c "
"documentation at GitHub <http://github.com/tarantool/tarantool-c>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:3
#: ../doc/1.7/book/connectors/__csharp.rst:31
msgid "C#"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:5
#: ../doc/1.7/book/connectors/__csharp.rst:33
msgid ""
"The most commonly used C# driver is `progaudi.tarantool "
"<https://github.com/progaudi/progaudi.tarantool>`_, previously named "
"``tarantool-csharp``. It is not supplied as part of the Tarantool "
"repository; it must be installed separately. The makers recommend `cross-"
"platform installation using Nuget "
"<https://www.nuget.org/packages/progaudi.tarantool>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:11
#: ../doc/1.7/book/connectors/__csharp.rst:39
msgid ""
"To be consistent with the other instructions in this chapter, here is a "
"way to install the driver directly on Ubuntu 16.04."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:14
#: ../doc/1.7/book/connectors/__csharp.rst:42
msgid ""
"Install .net core from Microsoft. Follow `.net core installation "
"instructions <https://www.microsoft.com/net/core#ubuntu>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:19
#: ../doc/1.7/book/connectors/__csharp.rst:47
msgid ""
"Mono will not work, nor will .Net from xbuild. Only .net core supported "
"on Linux and Mac."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:21
#: ../doc/1.7/book/connectors/__csharp.rst:49
msgid ""
"Read the Microsoft End User License Agreement first, because it is not an"
" ordinary open-source agreement and there will be a message during "
"installation saying \"This software may collect information about you and"
" your use of the software, and send that to Microsoft.\" Still you can "
"`set environment variables <https://docs.microsoft.com/en-"
"us/dotnet/core/tools/telemetry#behavior>`_ to opt out from telemetry."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:29
#: ../doc/1.7/book/connectors/__csharp.rst:57
msgid "Create a new console project."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:31
#: ../doc/1.7/book/connectors/__csharp.rst:59
msgid ""
"$ cd ~\n"
"$ mkdir progaudi.tarantool.test\n"
"$ cd progaudi.tarantool.test\n"
"$ dotnet new console"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:38
#: ../doc/1.7/book/connectors/__csharp.rst:66
msgid "Add ``progaudi.tarantool`` reference."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:40
#: ../doc/1.7/book/connectors/__csharp.rst:68
msgid "$ dotnet add package progaudi.tarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:44
#: ../doc/1.7/book/connectors/__csharp.rst:72
msgid "Change code in ``Program.cs``."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:46
#: ../doc/1.7/book/connectors/__csharp.rst:74
msgid ""
"$ cat <<EOT > Program.cs\n"
"using System;\n"
"using System.Threading.Tasks;\n"
"using ProGaudi.Tarantool.Client;\n"
"\n"
"public class HelloWorld\n"
"{\n"
"  static public void Main ()\n"
"  {\n"
"    Test().GetAwaiter().GetResult();\n"
"  }\n"
"  static async Task Test()\n"
"  {\n"
"    var box = await Box.Connect(\"127.0.0.1:3301\");\n"
"    var schema = box.GetSchema();\n"
"    var space = await schema.GetSpace(\"examples\");\n"
"    await space.Insert((99999, \"BB\"));\n"
"  }\n"
"}\n"
"EOT"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:69
#: ../doc/1.7/book/connectors/__csharp.rst:97
msgid "Build and run your application."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:71
#: ../doc/1.7/book/connectors/__csharp.rst:99
msgid ""
"Before trying to run, check that the server is listening at "
"``localhost:3301`` and that the space ``examples`` exists, as "
":ref:`described earlier <index-connector_setting>`."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:75
#: ../doc/1.7/book/connectors/__csharp.rst:103
msgid ""
"$ dotnet restore\n"
"$ dotnet run"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:80
#: ../doc/1.7/book/connectors/__csharp.rst:108
msgid "The program will:"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:82
#: ../doc/1.7/book/connectors/__csharp.rst:110
msgid "connect using an application-specific definition of the space,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:83
#: ../doc/1.7/book/connectors/__csharp.rst:111
msgid "open a socket connection with the Tarantool server at `localhost:3301`,"
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:84
#: ../doc/1.7/book/connectors/__csharp.rst:112
msgid ""
"send an INSERT request, and — if all is well — end without saying "
"anything."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:86
#: ../doc/1.7/book/connectors/__csharp.rst:114
msgid ""
"If Tarantool is not running on localhost with listen port = 3301, or if "
"user 'guest' does not have authorization to connect, or if the INSERT "
"request fails for any reason, the program will print an error message, "
"among other things (stacktrace, etc)."
msgstr ""

#: ../doc/1.7/book/connectors/__csharp.rst:91
#: ../doc/1.7/book/connectors/__csharp.rst:119
msgid ""
"The example program only shows one request and does not show all that’s "
"necessary for good practice. For that, please see the `progaudi.tarantool"
" driver repository <https://github.com/progaudi/progaudi.tarantool>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__erlang.rst:3
#: ../doc/1.7/book/connectors/__erlang.rst:31
msgid "Erlang"
msgstr ""

#: ../doc/1.7/book/connectors/__erlang.rst:5
#: ../doc/1.7/book/connectors/__erlang.rst:33
msgid "See `Erlang tarantool driver <https://github.com/stofel/taran>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__go.rst:3 ../doc/1.7/book/connectors/__go.rst:31
msgid "Go"
msgstr ""

#: ../doc/1.7/book/connectors/__go.rst:5 ../doc/1.7/book/connectors/__go.rst:33
msgid "Please see https://github.com/mialinx/go-tarantool."
msgstr ""

#: ../doc/1.7/book/connectors/__java.rst:3
#: ../doc/1.7/book/connectors/__java.rst:31
msgid "Java"
msgstr ""

#: ../doc/1.7/book/connectors/__java.rst:5
#: ../doc/1.7/book/connectors/__java.rst:33
msgid "See http://github.com/tarantool/tarantool-java/."
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:3
#: ../doc/1.7/book/connectors/__nodejs.rst:31
msgid "Node.js"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:5
#: ../doc/1.7/book/connectors/__nodejs.rst:33
msgid ""
"The most commonly used node.js driver is the `Node Tarantool driver "
"<https://github.com/KlonD90/node-tarantool-driver>`_. It is not supplied "
"as part of the Tarantool repository; it must be installed separately. The"
" most common way to install it is with `npm <https://www.sitepoint.com"
"/beginners-guide-node-package-manager/>`_. For example, on Ubuntu, the "
"installation could look like this after npm has been installed:"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:13
#: ../doc/1.7/book/connectors/__nodejs.rst:41
msgid "npm install tarantool-driver --global"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:17
#: ../doc/1.7/book/connectors/__nodejs.rst:45
msgid ""
"Here is a complete node.js program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the node.js API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.rs` and say ``node example.rs``. The program will connect "
"using an application-specific definition of the space. The program will "
"open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"end after saying \"Insert succeeded\". If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connect "
"failed”. If user ``guest`` does not have authorization to connect, the "
"program will print \"Auth failed\". If the insert request fails for any "
"reason, for example because the tuple already exists, the program will "
"print \"Insert failed\"."
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:31
#: ../doc/1.7/book/connectors/__nodejs.rst:59
msgid ""
"var TarantoolConnection = require('tarantool-driver');\n"
"var conn = new TarantoolConnection({port: 3301});\n"
"var insertTuple = [99999, \"BB\"];\n"
"conn.connect().then(function() {\n"
"    conn.auth(\"guest\", \"\").then(function() {\n"
"        conn.insert(999, insertTuple).then(function() {\n"
"            console.log(\"Insert succeeded\");\n"
"            process.exit(0);\n"
"    }, function(e) { console.log(\"Insert failed\");  process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Auth failed\");    process.exit(1); "
"});\n"
"    }, function(e) { console.log(\"Connect failed\"); process.exit(1); });"
msgstr ""

#: ../doc/1.7/book/connectors/__nodejs.rst:45
#: ../doc/1.7/book/connectors/__nodejs.rst:73
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see  `The node.js driver "
"repository <https://github.com/KlonD90/node-tarantool-driver>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:3
#: ../doc/1.7/book/connectors/__perl.rst:31
msgid "Perl"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:5
#: ../doc/1.7/book/connectors/__perl.rst:33
msgid ""
"The most commonly used Perl driver is `DR::Tarantool "
"<http://search.cpan.org/~unera/DR-Tarantool/>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately. The "
"most common way to install it is with `CPAN, the Comprehensive Perl "
"Archive Network <https://en.wikipedia.org/wiki/Cpan>`_. ``DR::Tarantool``"
" requires other modules which should be installed first. For example, on "
"Ubuntu, the installation could look like this:"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:13
#: ../doc/1.7/book/connectors/__perl.rst:41
msgid ""
"$ sudo cpan install AnyEvent\n"
"$ sudo cpan install Devel::GlobalDestruction\n"
"$ sudo cpan install Coro\n"
"$ sudo cpan install Test::Pod\n"
"$ sudo cpan install Test::Spelling\n"
"$ sudo cpan install PAR::Dist\n"
"$ sudo cpan install List::MoreUtils\n"
"$ sudo cpan install DR::Tarantool"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:24
#: ../doc/1.7/book/connectors/__perl.rst:52
msgid ""
"Here is a complete Perl program that inserts ``[99999,'BB']`` into "
"``space[999]`` via the Perl API. Before trying to run, check that the "
"server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.pl` and say :samp:`perl example.pl`. The program will "
"connect using an application-specific definition of the space. The "
"program will open a socket connection with the Tarantool instance at "
"``localhost:3301``, then send an INSERT request, then — if all is well — "
"end without displaying any messages. If Tarantool is not running on "
"``localhost`` with listen port = 3301, the program will print “Connection"
" refused”."
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:36
#: ../doc/1.7/book/connectors/__perl.rst:64
msgid ""
"#!/usr/bin/perl\n"
"use DR::Tarantool ':constant', 'tarantool';\n"
"use DR::Tarantool ':all';\n"
"use DR::Tarantool::MsgPack::SyncClient;\n"
"\n"
"my $tnt = DR::Tarantool::MsgPack::SyncClient->connect(\n"
"  host    => '127.0.0.1',                      # look for tarantool on "
"localhost\n"
"  port    => 3301,                             # on port 3301\n"
"  user    => 'guest',                          # username. one could also"
" say 'password=>...'\n"
"\n"
"  spaces  => {\n"
"    999 => {                                   # definition of space[999]"
" ...\n"
"      name => 'examples',                      #   space[999] name = "
"'examples'\n"
"      default_type => 'STR',                   #   space[999] field type "
"is 'STR' if undefined\n"
"      fields => [ {                            #   definition of "
"space[999].fields ...\n"
"          name => 'field1', type => 'NUM' } ], #     space[999].field[1] "
"name='field1',type='NUM'\n"
"      indexes => {                             #   definition of "
"space[999] indexes ...\n"
"        0 => {\n"
"          name => 'primary', fields => [ 'field1' ] } } } } );\n"
"\n"
"$tnt->insert('examples' => [ 99999, 'BB' ]);"
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:60
#: ../doc/1.7/book/connectors/__perl.rst:88
msgid ""
"The example program uses field type names 'STR' and 'NUM' instead of "
"'string' and 'unsigned', due to a temporary Perl limitation."
msgstr ""

#: ../doc/1.7/book/connectors/__perl.rst:63
#: ../doc/1.7/book/connectors/__perl.rst:91
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `DR::Tarantool CPAN "
"repository <http://search.cpan.org/~unera/DR-Tarantool/>`_."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:3
#: ../doc/1.7/book/connectors/__php.rst:31
msgid "PHP"
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:5
#: ../doc/1.7/book/connectors/__php.rst:33
msgid ""
"The most commonly used PHP driver is `tarantool-php "
"<https://github.com/tarantool/tarantool-php>`_. It is not supplied as "
"part of the Tarantool repository; it must be installed separately, for "
"example with :program:`git`. See `installation instructions "
"<https://github.com/tarantool/tarantool-php/blob/master/#installing-and-"
"building>`_. in the driver's :file:`README` file."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:12
#: ../doc/1.7/book/connectors/__php.rst:40
msgid ""
"Here is a complete PHP program that inserts ``[99999,'BB']`` into a space"
" named ``examples`` via the PHP API. Before trying to run, check that the"
" server instance is listening at ``localhost:3301`` and that the space "
"``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run, paste the code into a file named "
":file:`example.php` and say ``php -d extension=~/tarantool-"
"php/modules/tarantool.so example.php``. The program will open a socket "
"connection with the Tarantool instance at ``localhost:3301``, then send "
"an INSERT request, then — if all is well — print \"Insert succeeded\". If"
" the tuple already exists, the program will print “Duplicate key exists "
"in unique index 'primary' in space 'examples'”."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:23
#: ../doc/1.7/book/connectors/__php.rst:51
msgid ""
"<?php\n"
"$tarantool = new Tarantool('localhost', 3301);\n"
"\n"
"try {\n"
"    $tarantool->insert('examples', array(99999, 'BB'));\n"
"    echo \"Insert succeeded\\n\";\n"
"} catch (Exception $e) {\n"
"    echo \"Exception: \", $e->getMessage(), \"\\n\";\n"
"}"
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:35
#: ../doc/1.7/book/connectors/__php.rst:63
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool/tarantool-"
"php <https://github.com/tarantool/tarantool-php>`_ project at GitHub."
msgstr ""

#: ../doc/1.7/book/connectors/__php.rst:40
#: ../doc/1.7/book/connectors/__php.rst:68
msgid ""
"Besides, you can use an alternative PHP driver from another GitHub "
"project: it includes a *client* (see `tarantool-php/client "
"<https://github.com/tarantool-php/client>`_) and a *mapper* for that "
"client (see `tarantool-php/mapper <https://github.com/tarantool-"
"php/mapper>`_)."
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:3
#: ../doc/1.7/book/connectors/__python.rst:31
msgid "Python"
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:5
#: ../doc/1.7/book/connectors/__python.rst:33
msgid ""
"Here is a complete Python program that inserts "
"``[99999,'Value','Value']`` into space ``examples`` via the high-level "
"Python API."
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:8
#: ../doc/1.7/book/connectors/__python.rst:36
msgid ""
"#!/usr/bin/python\n"
"from tarantool import Connection\n"
"\n"
"c = Connection(\"127.0.0.1\", 3301)\n"
"result = c.insert(\"examples\",(99999,'Value', 'Value'))\n"
"print result"
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:17
#: ../doc/1.7/book/connectors/__python.rst:45
msgid ""
"To prepare, paste the code into a file named :file:`example.py` and "
"install the ``tarantool-python`` connector with either :samp:`pip install"
" tarantool\\>0.4` to install in :file:`/usr` (requires **root** "
"privilege) or :samp:`pip install tarantool\\>0.4 --user` to install in "
":file:`~` i.e. user's default directory. Before trying to run, check that"
" the server instance is listening at ``localhost:3301`` and that the "
"space ``examples`` exists, as :ref:`described earlier <index-"
"connector_setting>`. To run the program, say :samp:`python example.py`. "
"The program will connect to the Tarantool server, will send the request, "
"and will not throw any exception if all went well. If the tuple already "
"exists, the program will throw ``tarantool.error.DatabaseError: (3, "
"\"Duplicate key exists in unique index 'primary' in space "
"'examples'\")``."
msgstr ""

#: ../doc/1.7/book/connectors/__python.rst:29
#: ../doc/1.7/book/connectors/__python.rst:57
msgid ""
"The example program only shows one request and does not show all that's "
"necessary for good practice. For that, please see `tarantool-python "
"<http://github.com/tarantool/tarantool-python>`_ project at GitHub. For "
"an example of using Python API with `queue managers for Tarantool "
"<https://github.com/tarantool/queue>`_, see `queue-python "
"<https://github.com/tarantool/queue-python>`_ project at GitHub."
msgstr ""

#: ../doc/1.7/book/connectors/__r.rst:3 ../doc/1.7/book/connectors/__r.rst:31
msgid "R"
msgstr ""

#: ../doc/1.7/book/connectors/__r.rst:5 ../doc/1.7/book/connectors/__r.rst:33
msgid "See https://github.com/thekvs/tarantoolr."
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:4
#: ../doc/1.7/book/connectors/__results.rst:32
msgid "Interpreting function return values"
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:6
#: ../doc/1.7/book/connectors/__results.rst:34
msgid ""
"For all connectors, calling a function via Tarantool causes a return in "
"the MsgPack format. If the function is called using the connector's API, "
"some conversions may occur. All scalar values are returned as tuples "
"(with a MsgPack type-identifier followed by a value); all non-scalar "
"values are returned as a group of tuples (with a MsgPack array-identifier"
" followed by the scalar values). If the function is called via the binary"
" protocol command layer -- \"eval\" -- rather than via the connector's "
"API, no conversions occur."
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:14
#: ../doc/1.7/book/connectors/__results.rst:42
msgid ""
"In the following example, a Lua function will be created. Since it will "
"be accessed externally by a 'guest' user, a ``grant`` of an execute "
"privilege will be necessary. The function returns an empty array, a "
"scalar string, two booleans, and a short integer. The values are the ones"
" described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:20
#: ../doc/1.7/book/connectors/__results.rst:48
msgid ""
"tarantool> box.cfg{listen=3301}\n"
"2016-03-03 18:45:52.802 [27381] main/101/interactive I> ready to accept "
"requests\n"
"---\n"
"...\n"
"tarantool> function f() return {},'a',false,true,127; end\n"
"---\n"
"...\n"
"tarantool> box.schema.func.create('f')\n"
"---\n"
"...\n"
"tarantool> box.schema.user.grant('guest','execute','function','f')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:36
#: ../doc/1.7/book/connectors/__results.rst:64
msgid ""
"Here is a C program which calls the function. Although C is being used "
"for the example, the result would be precisely the same if the calling "
"program was written in Perl, PHP, Python, Go, or Java."
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:40
#: ../doc/1.7/book/connectors/__results.rst:68
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <tarantool/tarantool.h>\n"
"#include <tarantool/tnt_net.h>\n"
"#include <tarantool/tnt_opt.h>\n"
"void main() {\n"
"  struct tnt_stream *tnt = tnt_net(NULL);              /* SETUP */\n"
"  tnt_set(tnt, TNT_OPT_URI, \"localhost:3301\");\n"
"   if (tnt_connect(tnt) < 0) {                         /* CONNECT */\n"
"       printf(\"Connection refused\\n\");\n"
"       exit(-1);\n"
"   }\n"
"   struct tnt_stream *arg; arg = tnt_object(NULL);     /* MAKE REQUEST */"
"\n"
"   tnt_object_add_array(arg, 0);\n"
"   struct tnt_request *req1 = tnt_request_call(NULL);  /* CALL function "
"f() */\n"
"   tnt_request_set_funcz(req1, \"f\");\n"
"   uint64_t sync1 = tnt_request_compile(tnt, req1);\n"
"   tnt_flush(tnt);                                     /* SEND REQUEST */"
"\n"
"   struct tnt_reply reply;  tnt_reply_init(&reply);    /* GET REPLY */\n"
"   tnt->read_reply(tnt, &reply);\n"
"   if (reply.code != 0) {\n"
"     printf(\"Call failed %lu.\\n\", reply.code);\n"
"     exit(-1);\n"
"   }\n"
"   const unsigned char *p= (unsigned char*)reply.data; /* PRINT REPLY */\n"
"   while (p < (unsigned char *) reply.data_end)\n"
"   {\n"
"     printf(\"%x \", *p);\n"
"     ++p;\n"
"   }\n"
"   printf(\"\\n\");\n"
"   tnt_close(tnt);                                     /* TEARDOWN */\n"
"   tnt_stream_free(arg);\n"
"   tnt_stream_free(tnt);\n"
"}"
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:78
#: ../doc/1.7/book/connectors/__results.rst:106
msgid "When this program is executed, it will print:"
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:80
#: ../doc/1.7/book/connectors/__results.rst:108
msgid "dd 0 0 0 5 90 91 a1 61 91 c2 91 c3 91 7f"
msgstr ""

#: ../doc/1.7/book/connectors/__results.rst:84
#: ../doc/1.7/book/connectors/__results.rst:112
msgid ""
"The first five bytes -- ``dd 0 0 0 5`` -- are the MsgPack encoding for "
"\"32-bit array header with value 5\" (see `MsgPack specification "
"<http://github.com/msgpack/msgpack/blob/master/spec.md>`_). The rest are "
"as described in the table :ref:`Common Types and MsgPack Encodings "
"<msgpack-common_types_and_msgpack_encodings>`."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:33
msgid "Connectors"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:35
msgid "This chapter documents APIs for various programming languages."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:39
msgid "Protocol"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:41
msgid ""
"Tarantool's binary protocol was designed with a focus on asynchronous I/O"
" and easy integration with proxies. Each client request starts with a "
"variable-length binary header, containing request id, request type, "
"instance id, log sequence number, and so on."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:46
msgid ""
"The mandatory length, present in request header simplifies client or "
"proxy I/O. A response to a request is sent to the client as soon as it is"
" ready. It always carries in its header the same type and id as in the "
"request. The id makes it possible to match a request to a response, even "
"if the latter arrived out of order."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:52
msgid ""
"Unless implementing a client driver, you needn't concern yourself with "
"the complications of the binary protocol. Language-specific drivers "
"provide a friendly way to store domain language data structures in "
"Tarantool. A complete description of the binary protocol is maintained in"
" annotated Backus-Naur form in the source tree: please see the page about"
" :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:61
msgid "Packet example"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:63
msgid ""
"The Tarantool API exists so that a client program can send a request "
"packet to a server instance, and receive a response. Here is an example "
"of a what the client would send for ``box.space[513]:insert{'A', 'BB'}``."
" The BNF description of the components is on the page about "
":ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Component"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #0"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #1"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #2"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:79
msgid "Byte #3"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:81
msgid "code for insert"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:81
#: ../doc/1.7/book/connectors/index.rst:85
msgid "02"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:83
msgid "rest of header"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:83
msgid "..."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:85
msgid "2-digit number: space id"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:85
msgid "cd"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:85
msgid "01"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:87
msgid "code for tuple"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:87
msgid "21"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:89
msgid "1-digit number: field count = 2"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:89
msgid "92"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:91
msgid "1-character string: field[1]"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:91
msgid "a1"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:91
msgid "41"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:93
msgid "2-character string: field[2]"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:93
msgid "a2"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:93
msgid "42"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:96
msgid ""
"Now, you could send that packet to the Tarantool instance, and interpret "
"the response (the page about :ref:`Tarantool's binary protocol "
"<box_protocol-iproto_protocol>` has a description of the packet format "
"for responses as well as requests). But it would be easier, and less "
"error-prone, if you could invoke a routine that formats the packet "
"according to typed parameters. Something like ``response = "
"tarantool_routine(\"insert\", 513, \"A\", \"B\");``. And that is why APIs"
" exist for drivers for Perl, Python, PHP, and so on."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:109
msgid "Setting up the server for connector examples"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:111
msgid ""
"This chapter has examples that show how to connect to a Tarantool "
"instance via the Perl, PHP, Python, node.js, and C connectors. The "
"examples contain hard code that will work if and only if the following "
"conditions are met:"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:115
msgid ""
"the Tarantool instance (tarantool) is running on localhost (127.0.0.1) "
"and is listening on port 3301 (``box.cfg.listen = '3301'``),"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:118
msgid ""
"space ``examples`` has id = 999 (``box.space.examples.id = 999``) and has"
" a primary-key index for a numeric field "
"(``box.space[999].index[0].parts[1].type = \"unsigned\"``),"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:122
msgid "user 'guest' has privileges for reading and writing."
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:124
msgid ""
"It is easy to meet all the conditions by starting the instance and "
"executing this script:"
msgstr ""

#: ../doc/1.7/book/connectors/index.rst:127
msgid ""
"box.cfg{listen=3301}\n"
"box.schema.space.create('examples',{id=999})\n"
"box.space.examples:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"box.schema.user.grant('guest','read,write','space','examples')\n"
"box.schema.user.grant('guest','read','space','_space')"
msgstr ""

#: ../doc/1.7/book/faq.rst:33
msgid "FAQ"
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid "Q"
msgstr ""

#: ../doc/1.7/book/faq.rst:37
msgid "Why Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid "A"
msgstr ""

#: ../doc/1.7/book/faq.rst:38
msgid ""
"Tarantool is the latest generation of a family of in-memory data servers "
"developed for web applications. It is the result of practical experience "
"and trials within Mail.Ru since development began in 2008."
msgstr ""

#: ../doc/1.7/book/faq.rst:42
msgid "Why Lua?"
msgstr ""

#: ../doc/1.7/book/faq.rst:43
msgid ""
"Lua is a lightweight, fast, extensible multi-paradigm language. Lua also "
"happens to be very easy to embed. Lua coroutines relate very closely to "
"Tarantool fibers, and Lua architecture works well with Tarantool "
"internals. Lua acts well as a stored program language for Tarantool, "
"although connecting with other languages is also easy."
msgstr ""

#: ../doc/1.7/book/faq.rst:49
msgid "What's the key advantage of Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"Tarantool provides a rich database feature set (HASH, TREE, RTREE, BITSET"
" indexes, secondary indexes, composite indexes, transactions, triggers, "
"asynchronous replication) in a flexible environment of a Lua interpreter."
msgstr ""

#: ../doc/1.7/book/faq.rst
msgid ""
"These two properties make it possible to be a fast, atomic and reliable "
"in-memory data server which handles non-trivial application-specific "
"logic. The advantage over traditional SQL servers is in performance: low-"
"overhead, lock-free architecture means Tarantool can serve an order of "
"magnitude more requests per second, on comparable hardware. The advantage"
" over NoSQL alternatives is in flexibility: Lua allows flexible "
"processing of data stored in a compact, denormalized format."
msgstr ""

#: ../doc/1.7/book/faq.rst:63
msgid "What are your development plans?"
msgstr ""

#: ../doc/1.7/book/faq.rst:64
msgid ""
"We continuously improve server performance. On the feature front, "
"automatic sharding and synchronous replication, and a subset of SQL are "
"the major goals for 2016-2018. We have an open roadmap to which we "
"encourage anyone to add feature requests."
msgstr ""

#: ../doc/1.7/book/faq.rst:69
msgid "Who is developing Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:70
msgid ""
"There is an engineering team employed by Mail.Ru -- check out our commit "
"logs on `github.com/tarantool <http://github.com/tarantool/>`_. The "
"development is fully open. Most of the connectors' authors, and the "
"maintainers for different distributions, come from the wider community."
msgstr ""

#: ../doc/1.7/book/faq.rst:75
msgid "How serious is Mail.Ru about Tarantool?"
msgstr ""

#: ../doc/1.7/book/faq.rst:76
msgid ""
"Tarantool is an open source project, distributed under a BSD license, so "
"it does not depend on any one sponsor. However, it is an integral part of"
" the Mail.Ru backbone, so it gets a lot of support from Mail.Ru."
msgstr ""

#: ../doc/1.7/book/faq.rst:80
msgid "Are there problems associated with being an in-memory server?"
msgstr ""

#: ../doc/1.7/book/faq.rst:81
msgid ""
"The principal storage engine is designed for RAM plus persistent storage."
" It is immune to data loss because there is a write-ahead log. Its "
"memory-allocation and compression techniques ensure there is no waste. "
"And if Tarantool runs out of memory, then it will stop accepting updates "
"until more memory is available, but will continue to handle read and "
"delete requests without difficulty. However, for databases which are much"
" larger than the available RAM space, Tarantool has a second storage "
"engine which is only limited by the available disk space."
msgstr ""

#: ../doc/1.7/book/getting_started/index.rst:33
msgid "Getting started"
msgstr ""

#: ../doc/1.7/book/getting_started/index.rst:35
msgid ""
"In this chapter, we explain how to install Tarantool, how to start it, "
"and how to create a simple database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:33
msgid "Using a binary package"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:35
msgid ""
"For production purposes, we recommend `official binary packages "
"<http://tarantool.org/download.html>`_. You can choose from three "
"Tarantool versions: 1.6 (stable), 1.7 (release candidate) or 1.8 (alpha)."
" An automatic build system creates, tests and publishes packages for "
"every push into a corresponding branch (``1.6``, ``1.7`` or ``1.8``) at "
"`Tarantool's GitHub repository "
"<https://github.com/tarantool/tarantool>`_."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:43
msgid ""
"To download and install the package that’s appropriate for your OS, start"
" a shell (terminal) and enter the command-line instructions provided for "
"your OS at Tarantool's `download page "
"<http://tarantool.org/download.html>`_."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:49
msgid "Starting Tarantool"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:51
msgid "To start a Tarantool instance, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:53
msgid ""
"$ # if you downloaded a binary with apt-get or yum, say this:\n"
"$ /usr/bin/tarantool\n"
"$ # if you downloaded and untarred a binary tarball to ~/tarantool, say "
"this:\n"
"$ ~/tarantool/bin/tarantool"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:60
msgid "Tarantool starts in the interactive mode and displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:62
msgid "tarantool>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:66
#: ../doc/1.7/book/getting_started/using_docker.rst:112
msgid "Now you can enter requests on the command line."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:70
#: ../doc/1.7/book/getting_started/using_docker.rst:116
msgid ""
"On production machines, Tarantool's interactive mode is for system "
"administration only. But we use it for most examples in this manual, "
"because the interactive mode is convenient for learning."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:76
#: ../doc/1.7/book/getting_started/using_docker.rst:122
msgid "Creating a database"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:78
msgid "Here is how to create a simple test database after installing."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:80
msgid ""
"Create a new directory (it’s just for tests, so you can delete it when "
"the tests are over):"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:83
msgid ""
"$ mkdir ~/tarantool_sandbox\n"
"$ cd ~/tarantool_sandbox"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:88
msgid ""
"To start Tarantool's database module and make the instance accept TCP "
"requests on port 3301, say this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:91
msgid "tarantool> box.cfg{listen = 3301}"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:95
#: ../doc/1.7/book/getting_started/using_docker.rst:126
msgid ""
"First, create the first :ref:`space <index-box_space>` (named 'tester') "
"and the first :ref:`index <index-box_index>` (named 'primary'):"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:98
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"tarantool> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:106
#: ../doc/1.7/book/getting_started/using_docker.rst:137
msgid ""
"Next, insert three :ref:`tuples <index-box_tuple>` (our name for "
"\"records\") into the space:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:109
msgid ""
"tarantool> t = s:insert({1, 'Roxette'})\n"
"tarantool> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:116
#: ../doc/1.7/book/getting_started/using_docker.rst:146
msgid ""
"To select a tuple from the first space of the database, using the first "
"defined key, say:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:119
msgid "tarantool> s:select{3}"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:123
#: ../doc/1.7/book/getting_started/using_docker.rst:153
msgid "The terminal screen now looks like this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:125
msgid ""
"tarantool> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool>s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:151
msgid "Connecting remotely"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:153
msgid ""
"In the request ``box.cfg{listen = 3301}`` that we made earlier, the "
"``listen`` value can be any form of a :ref:`URI <index-uri>` (uniform "
"resource identifier). In this case, it’s just a local port: port 3301. "
"You can send requests to the listen URI via:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:158
msgid "``telnet``,"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:159
msgid "a :ref:`connector <index-box_connectors>`,"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:160
msgid ""
"another instance of Tarantool (using the :ref:`console <console-module>` "
"module), or"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:161
msgid ":ref:`tarantoolctl <tarantoolctl>` utility."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:163
msgid "Let’s try (4)."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:165
msgid ""
"Switch to another terminal. On Linux, for example, this means starting "
"another instance of a Bash shell. You can switch to any working directory"
" in the new terminal, not necessarily to ``~/tarantool_sandbox``."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:169
msgid "Start the ``tarantoolctl`` utility:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:171
msgid "$ tarantoolctl connect '3301'"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:175
msgid ""
"This means \"use ``tarantoolctl connect`` to connect to the Tarantool "
"instance that’s listening on ``localhost:3301``\"."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:178
msgid "Try this request:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:180
msgid "tarantool> box.space.tester:select{2}"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:184
msgid ""
"This means \"send a request to that Tarantool instance, and display the "
"result\". The result in this case is one of the tuples that was inserted "
"earlier. Your terminal screen should now look like this:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:188
msgid ""
"$ tarantoolctl connect 3301\n"
"/usr/local/bin/tarantoolctl: connected to localhost:3301\n"
"localhost:3301> box.space.tester:select{2}\n"
"---\n"
"- - [2, 'Scorpions', 2015]\n"
"...\n"
"\n"
"localhost:3301>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:199
msgid ""
"You can repeat ``box.space...:insert{}`` and ``box.space...:select{}`` "
"indefinitely, on either Tarantool instance."
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:202
msgid "When the testing is over:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:204
msgid "To drop the space: ``s:drop()``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:205
msgid "To stop ``tarantoolctl``: Ctrl+C or Ctrl+D"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:206
msgid ""
"To stop Tarantool (an alternative): the standard Lua function `os.exit() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.exit>`_"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:208
msgid "To stop Tarantool (from another terminal): ``sudo pkill -f tarantool``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_binary.rst:209
msgid "To destroy the test: ``rm -r ~/tarantool_sandbox``"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:33
msgid "Using a Docker image"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:35
msgid ""
"For trial and test purposes, we recommend using `official Tarantool "
"images for Docker <https://github.com/tarantool/docker>`_. An official "
"image contains a particular Tarantool version (1.6 or 1.7) and all "
"popular external modules for Tarantool. Everything is already installed "
"and configured in Linux. These images are the easiest way to install and "
"use Tarantool."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:44
msgid ""
"If you're new to Docker, we recommend going over `this tutorial "
"<https://docs.docker.com/engine/getstarted/step_one/>`_ before proceeding"
" with this chapter."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:52
msgid "Launching a container"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:54
msgid ""
"If you don't have Docker installed, please follow the official "
"`installation guide "
"<https://docs.docker.com/engine/getstarted/step_one/#/step-1-get-"
"docker>`_ for your OS."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:58
msgid ""
"To start a fully functional Tarantool instance, run a container with "
"minimal options:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:61
msgid ""
"$ docker run \\\n"
"  --name mytarantool \\\n"
"  -d -p 3301:3301 \\\n"
"  -v /data/dir/on/host:/var/lib/tarantool \\\n"
"  tarantool/tarantool:1.7"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:69
msgid ""
"This command runs a new container named 'mytarantool'. Docker starts it "
"from an official image named 'tarantool/tarantool:1.7', with Tarantool "
"version 1.7 and all external modules already installed."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:73
msgid ""
"Tarantool will be accepting incoming connections on ``localhost:3301``. "
"You may start using it as a key-value storage right away."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:76
msgid ""
"Tarantool :ref:`persists data <index-box_persistence>` inside the "
"container. To make your test data available after you stop the container,"
" this command also mounts the host's directory ``/data/dir/on/host`` (you"
" need to specify here an absolute path to an existing local directory) in"
" the container's directory ``/var/lib/tarantool`` (by convention, "
"Tarantool in a container uses this directory to persist data). So, all "
"changes made in the mounted directory on the container's side are applied"
" to the host's disk."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:85
msgid ""
"Tarantool's database module in the container is already :ref:`configured "
"<box_introspection-box_cfg>` and started. You needn't do it manually, "
"unless you use Tarantool as an :ref:`application server <app_server>` and"
" run it with an application."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:92
msgid "Attaching to Tarantool"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:94
msgid "To attach to Tarantool that runs inside the container, say:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:96
msgid "$ docker exec -i -t mytarantool console"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:100
msgid "This command:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:102
msgid ""
"Instructs Tarantool to open an interactive console port for incoming "
"connections."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:103
msgid ""
"Attaches to the Tarantool server inside the container under 'admin' user "
"via a standard Unix socket."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:106
msgid "Tarantool displays a prompt:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:108
msgid "tarantool.sock>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:124
msgid "While you're attached to the console, let's create a simple test database."
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:129
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"tarantool.sock> s:create_index('primary', {\n"
"              >  type = 'hash',\n"
"              >  parts = {1, 'unsigned'}\n"
"              > })"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:140
msgid ""
"tarantool.sock> t = s:insert({1, 'Roxette'})\n"
"tarantool.sock> t = s:insert({2, 'Scorpions', 2015})\n"
"tarantool.sock> t = s:insert({3, 'Ace of Base', 1993})"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:149
msgid "tarantool.sock> s:select{3}"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:155
msgid ""
"tarantool.sock> s = box.schema.space.create('tester')\n"
"2017-01-17 12:04:18.158 ... creating "
"'./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool.sock> s:create_index('primary', {type = 'hash', parts = {1, "
"'unsigned'}})\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{1, 'Roxette'}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{2, 'Scorpions', 2015}\n"
"---\n"
"...\n"
"tarantool.sock> t = s:insert{3, 'Ace of Base', 1993}\n"
"---\n"
"...\n"
"tarantool.sock> s:select{3}\n"
"---\n"
"- - [3, 'Ace of Base', 1993]\n"
"...\n"
"tarantool.sock>"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:181
msgid "Stopping a container"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:183
msgid "When the testing is over, stop the container politely:"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:185
msgid "$ docker stop mytarantool"
msgstr ""

#: ../doc/1.7/book/getting_started/using_docker.rst:189
msgid ""
"This was a temporary container, and its disk/memory data were flushed "
"when you stopped it. But since you mounted a data directory from the host"
" in the container, Tarantool's data files were persisted to the host's "
"disk. Now if you start a new container and mount that data directory in "
"it, Tarantool will recover all data from disk and continue working with "
"the persisted data."
msgstr ""

#: ../doc/1.7/book/index.rst:33
msgid "User's Guide"
msgstr ""

#: ../doc/1.7/book/intro.rst:31
msgid "Preface"
msgstr ""

#: ../doc/1.7/book/intro.rst:33
msgid ""
"Welcome to Tarantool! This is the User's Guide. We recommend reading it "
"first, and consulting :ref:`Reference <reference>` materials for more "
"detail afterwards, if needed."
msgstr ""

#: ../doc/1.7/book/intro.rst:39
msgid "How to read the documentation"
msgstr ""

#: ../doc/1.7/book/intro.rst:41
msgid ""
"To get started, you can install and launch Tarantool using :ref:`a Docker"
" container <getting_started-using_docker>`, :ref:`a binary package "
"<getting_started-using_binary>`, or the online Tarantool server at "
"http://try.tarantool.org. Either way, as the first tryout, you can follow"
" the introductory exercises from :ref:`Chapter 2 \"Getting started\" "
"<getting_started>`. If you want more hands-on experience, proceed to "
":ref:`Tutorials <tutorials>` after you are through with Chapter 2."
msgstr ""

#: ../doc/1.7/book/intro.rst:50
msgid ""
":ref:`Chapter 3 \"Database\" <database-chapter>` is about using Tarantool"
" as a NoSQL DBMS, whereas :ref:`Chapter 4 \"Application server\" "
"<app_server>` is about using Tarantool as an application server."
msgstr ""

#: ../doc/1.7/book/intro.rst:54
msgid ""
":ref:`Chapter 5 \"Server administration\" <admin>` and :ref:`Chapter 6 "
"\"Replication\" <replication>` are primarily for administrators."
msgstr ""

#: ../doc/1.7/book/intro.rst:57
msgid ""
":ref:`Chapter 7 \"Connectors\" <index-box_connectors>` is strictly for "
"users who are connecting from a different language such as C or Perl or "
"Python — other users will find no immediate need for this chapter."
msgstr ""

#: ../doc/1.7/book/intro.rst:61
msgid ""
":ref:`Chapter 8 \"FAQ\" <faq>` gives answers to some frequently asked "
"questions about Tarantool."
msgstr ""

#: ../doc/1.7/book/intro.rst:64
msgid ""
"For experienced users, there are also :ref:`Reference <reference>` "
"materials, a :ref:`Contributor's Guide <contrib_guide>` and an extensive "
"set of comments in the source code."
msgstr ""

#: ../doc/1.7/book/intro.rst:70
msgid "Getting in touch with the Tarantool community"
msgstr ""

#: ../doc/1.7/book/intro.rst:72
msgid ""
"Please report bugs or make feature requests at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/1.7/book/intro.rst:74
msgid ""
"You can contact developers directly in `telegram "
"<http://telegram.me/tarantool>`_ or in a Tarantool discussion group "
"(`English <https://groups.google.com/forum/#!forum/tarantool>`_ or "
"`Russian <https://googlegroups.com/group/tarantool-ru>`_)."
msgstr ""

#: ../doc/1.7/book/intro.rst:81
msgid "Conventions used in this manual"
msgstr ""

#: ../doc/1.7/book/intro.rst:83
msgid "Square brackets [ and ] enclose optional syntax."
msgstr ""

#: ../doc/1.7/book/intro.rst:85
msgid "Two dots in a row .. mean the preceding tokens may be repeated."
msgstr ""

#: ../doc/1.7/book/intro.rst:87
msgid ""
"A vertical bar | means the preceding and following tokens are mutually "
"exclusive alternatives."
msgstr ""

#: ../doc/1.7/book/replication/1_1.rst:29
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"$ cd ~/tarantool_test_node_1\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"$ ~/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{listen = 3301}\n"
"<... ...>\n"
"tarantool> box.schema.user.create('replicator', {password = 'password'})\n"
"<...> I> creating ./00000000000000000000.xlog.inprogress'\n"
"---\n"
"...\n"
"tarantool> "
"box.schema.user.grant('replicator','execute','role','replication')\n"
"---\n"
"...\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/1_2.rst:29
msgid "$"
msgstr ""

#: ../doc/1.7/book/replication/2_1.rst:29
msgid ""
"$ # Terminal 1\n"
"$ mkdir -p ~/tarantool_test_node_1\n"
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"...\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""

#: ../doc/1.7/book/replication/2_2.rst:29
#: ../doc/1.7/book/replication/3_2.rst:29
msgid ""
"$ # Terminal 2\n"
"$ mkdir -p ~/tarantool_test_node_2\n"
"$ cd ~/tarantool_test_node_2\n"
"$ rm -R ./*\n"
"$ ~/tarantool/src/tarantool\n"
"/home/username/tarantool/src/tarantool: version 1.7.0-1724-g033ed69\n"
"type 'help' for interactive help\n"
"tarantool> box.cfg{\n"
"         >   listen = 3302,\n"
"         >   replication = 'replicator:password@localhost:3301'\n"
"         > }\n"
"<...>\n"
"<...> [11243] main/101/interactive I> mapping 1073741824 bytes for tuple "
"arena...\n"
"<...> [11243] main/101/interactive C> starting replication from "
"localhost:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> authenticated\n"
"<...> [11243] main/102/applier/localhost:3301 I> downloading a snapshot "
"from 127.0.0.1:3301\n"
"<...> [11243] main/102/applier/localhost:3301 I> done\n"
"<...> [11243] snapshot/101/main I> creating "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> saving snapshot "
"`./00000000000000000000.snap.inprogress'\n"
"<...> [11243] snapshot/101/main I> done\n"
"<...> [11243] iproto I> binary: started\n"
"<...> [11243] iproto I> binary: bound to 0.0.0.0:3302\n"
"<...> [11243] wal/101/main I> creating "
"`./00000000000000000000.xlog.inprogress'\n"
"<...> [11243] main/101/interactive I> ready to accept requests\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/3_1.rst:29
#: ../doc/1.7/book/replication/4_1.rst:29
msgid ""
"<... ...>\n"
"tarantool>\n"
"tarantool>\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovery start\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recovering from "
"`./00000000000000000000.snap'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> snapshot sent\n"
"<...> [11031] relay/127.0.0.1:58734/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11031] relay/127.0.0.1:58734/101/main recovery.cc:211 W> file\n"
"      `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11031] relay/127.0.0.1:58734/102/main I> recover from "
"`./00000000000000000000.xlog'\n"
"tarantool> s = box.schema.space.create('tester')\n"
"---\n"
"...\n"
"tarantool> i = s:create_index('primary', {})\n"
"---\n"
"...\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/4_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> box.space._cluster:select({0}, {iterator = 'GE'})\n"
"- - [1, '6190d919-1133-4452-b123-beca0b178b32']\n"
"  - [2, '236230b8-af3e-406b-b709-15a60b44c20c']\n"
"...\n"
"tarantool> s = box.space.tester\n"
"---\n"
"...\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/5_1.rst:29
#: ../doc/1.7/book/replication/6_1.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$"
msgstr ""

#: ../doc/1.7/book/replication/5_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:select({1}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 second"
msgstr ""

#: ../doc/1.7/book/replication/6_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [11243] main/105/applier/localhost:3301 I> can't read row\n"
"<...> [11243] main/105/applier/localhost:3301 coio.cc:352 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 6, aka 127.0.0.1:58734, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [11243] main/105/applier/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/7_1.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{1, 'Tuple inserted on Terminal #1'}\n"
"---\n"
"- [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> os.exit()\n"
"$ ls -l ~/tarantool_test_node_1\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:12 00000000000000000000.snap\n"
"-rw-rw-r-- 1   634 May  5 11:45 00000000000000000000.xlog\n"
"$ ls -l ~/tarantool_test_node_2/\n"
"total 8\n"
"-rw-rw-r-- 1  4925 May  5 11:20 00000000000000000000.snap\n"
"-rw-rw-r-- 1   704 May  5 11:38 00000000000000000000.xlog\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/7_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated"
msgstr ""

#: ../doc/1.7/book/replication/8_1.rst:29
msgid ""
"<... ...>\n"
"$ ~/tarantool/src/tarantool\n"
"<...>\n"
"tarantool> box.cfg{listen = 3301}\n"
"<...> [22612] main/101/interactive I> ready to accept requests\n"
"<... ...>\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"...\n"
"tarantool> box.cfg{\n"
"         >   replication = 'replicator:password@localhost:3302'\n"
"         > }\n"
"[28987] main/101/interactive C> starting replication from localhost:3302\n"
"---\n"
"...\n"
"[22612] main/101/interactive C> starting replication from localhost:3302\n"
"[22612] main/101/interactive I> set 'replication' configuration\n"
"        option to \"replicator:password@localhost:3302\"\n"
"[22612] main/104/applier/localhost:3302 I> connected to 1.7.0 at "
"127.0.0.1:3302\n"
"[22612] main/104/applier/localhost:3302 I> authenticated\n"
"[22612] wal/101/main I> creating `./00000000000000000008.xlog.inprogress'"
"\n"
"[22612] relay/127.0.0.1:33510/102/main I> done "
"`./00000000000000000000.xlog'\n"
"[22612] relay/127.0.0.1:33510/102/main I> recover from "
"`./00000000000000000008.xlog'\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"  - [3, 'Another']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/8_2.rst:29
msgid ""
"<... ...>\n"
"tarantool> s:insert{2, 'Tuple inserted on Terminal #2'}\n"
"---\n"
"- [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool>\n"
"<...> [25579] main/103/replica/localhost:3301 I> can't read row\n"
"<...> [25579] main/103/replica/localhost:3301 !> SystemError\n"
"  unexpected EOF when reading from socket,\n"
"  called on fd 10, aka 127.0.0.1:50884, peer of 127.0.0.1:3301: Broken "
"pipe\n"
"<...> [25579] main/103/replica/localhost:3301 I> will retry every 1 "
"second\n"
"tarantool> box.space.tester:select({0}, {iterator = 'GE'})\n"
"---\n"
"- - [1, 'Tuple inserted on Terminal #1']\n"
"  - [2, 'Tuple inserted on Terminal #2']\n"
"...\n"
"tarantool> box.space.tester:insert{3, 'Another'}\n"
"---\n"
"- [3, 'Another']\n"
"...\n"
"<...> [11243] main/105/applier/localhost:3301 I> connected to 1.7.0 at "
"127.0.0.1:3301\n"
"<...> [11243] main/105/applier/localhost:3301 I> authenticated\n"
"tarantool>\n"
"<...> [11243] relay/127.0.0.1:36150/101/main I> recover from "
"`./00000000000000000000.xlog'\n"
"<...> [11243] relay/127.0.0.1:36150/101/main recovery.cc:211 W> file\n"
"     `./00000000000000000000.xlog` wasn't correctly closed\n"
"<...> [11243] relay/127.0.0.1:36150/102/main I> recover from "
"`./00000000000000000000.xlog'"
msgstr ""

#: ../doc/1.7/book/replication/index.rst:33
#: ../doc/1.7/reference/configuration/index.rst:251
msgid "Replication"
msgstr ""

#: ../doc/1.7/book/replication/index.rst:35
msgid ""
"Replication allows multiple Tarantool instances to work on copies of the "
"same databases. The databases are kept in sync because each instance can "
"communicate its changes to all the other instances."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:33
msgid "Adding instances"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:39
msgid "Adding a replica"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:44
msgid ""
"To add a second **replica** instance to the **master-replica** set from "
"our :ref:`bootstrapping example <replication-master_replica_bootstrap>`, "
"we need an analog of the instance file that we created for the first "
"replica in that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:48
msgid ""
"-- instance file for replica #2\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = ('replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301',  -- replica #1"
" URI\n"
"                 'replicator:password@192.168.0.103:3301'), -- replica #2"
" URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica #2')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:66
msgid ""
"Here we add replica #2 URI to :ref:`replication <cfg_replication-"
"replication>` parameter, so now it contains three URIs."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:69
msgid ""
"After we launch the new replica instance, it gets connected to the master"
" instance and retrieves the master's write ahead log and snapshot files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:72
msgid ""
"$ # launching replica #2\n"
"$ tarantool replica2.lua\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:54:33.927 [46945] main/101/replica2.lua C> log level 5\n"
"2017-06-14 14:54:33.928 [46945] main/101/replica2.lua I> mapping "
"268435456 bytes for tuple arena...\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:54:33.930 [46945] main/104/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 14:54:33.930 [46945] main/101/replica2.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 14:54:33.933 [46945] main/104/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica2/00000000000000000010.snap.inprogress'\n"
"2017-06-14 14:54:33.934 [46945] snapshot/101/main I> done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> vinyl checkpoint"
" done\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> ready to accept "
"requests\n"
"2017-06-14 14:54:33.935 [46945] main/101/replica2.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:54:33.936 [46945] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:91
msgid ""
"Since we're adding a read-only instance, there is no need to dynamically "
"update ``replication`` parameter on the other running instances. This "
"update would be required if we :ref:`added a master instance "
"<replication-add_master>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:95
msgid ""
"However, we recommend to specify replica #3 URI in all instance files of "
"the replica set. This will keep all the files consistent with each other "
"and with the current replication topology, and so will help to avoid "
"configuration errors in case of further reconfigurations and replica set "
"restart."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:104
msgid "Adding a master"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:109
msgid ""
"To add a third master instance to the **master-master** set from our "
":ref:`bootstrapping example <replication-master_master_bootstrap>`, we "
"need an analog of the instance files that we created to bootstrap the "
"other master instances in that set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:114
msgid ""
"-- instance file for master #3\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master#1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301',  -- master#2 "
"URI\n"
"                 'replicator:password@192.168.0.103:3301'}, -- master#3 "
"URI\n"
"  read_only   = true, -- temporarily read-only\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication’) -- grant "
"\"replication\" role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:131
msgid "Here we make the following changes:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:133
msgid ""
"Add master#3 URI to :ref:`replication <cfg_replication-replication>` "
"parameter."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:135
msgid ""
"Temporarily specify :ref:`read_only=true <cfg_basic-read_only>` to "
"disable data-change operations on the instance. After launch, master #3 "
"will act as a replica until it retrieves all data from the other masters "
"in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:139
msgid ""
"After we launch the third master instance, it gets connected to the other"
" master instances and retrieves their write ahead logs and snapshot "
"files:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:142
msgid ""
"$ # launching master #3\n"
"$ tarantool master3.lua\n"
"2017-06-14 17:10:00.556 [47121] main/101/master3.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua C> log level 5\n"
"2017-06-14 17:10:00.557 [47121] main/101/master3.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 17:10:00.559 [47121] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 17:10:00.559 [47121] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 17:10:00.559 [47121] main/106/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.103:3301\n"
"2017-06-14 17:10:00.559 [47121] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 17:10:00.559 [47121] main/101/master3.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 17:10:00.562 [47121] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master3_dir/00000000000000000009.snap.inprogress'\n"
"2017-06-14 17:10:00.562 [47121] snapshot/101/main I> done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 17:10:00.564 [47121] main/101/master3.lua I> ready to accept "
"requests\n"
"2017-06-14 17:10:00.565 [47121] main/101/master3.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 17:10:00.565 [47121] main C> entering the event loop\n"
"2017-06-14 17:10:00.565 [47121] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:165
msgid ""
"Next, we add master#3 URI to ``replication`` parameter on the existing "
"two masters. Replication-related parameters are dynamic, so we only need "
"to make a ``box.cfg{}`` request on each of the running instances:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:169
msgid ""
"# adding master #3 URI to replication sources\n"
"tarantool> box.cfg{replication =\n"
"         > {'replicator:password@192.168.0.101:3301',\n"
"         > 'replicator:password@192.168.0.102:3301',\n"
"         > 'replicator:password@192.168.0.103:3301'}}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:179
msgid ""
"When master #3 catches up with the other masters' state, we can disable "
"read-only mode for this instance:"
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:182
msgid ""
"# making master #3 a real master\n"
"tarantool> box.cfg{read_only=false}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_add_instances.rst:189
msgid ""
"We also recommend to specify master #3 URI in all instance files in order"
" to keep all the files consistent with each other and with the current "
"replication topology."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:33
msgid "Replication architecture"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:39
msgid "Replication mechanism"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:41
msgid ""
"A pack of instances which operate on copies of the same databases make up"
" a **replica set**. Each instance in a replica set has a role, **master**"
" or **replica**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:45
msgid ""
"A replica gets all updates from the master by continuously fetching and "
"applying its write ahead log (**WAL**). Each record in the WAL represents"
" a single Tarantool data-change request such as INSERT, UPDATE or DELETE,"
" and is assigned a monotonically growing log sequence number (**LSN**). "
"In essence, Tarantool replication is **row-based**: each data-change "
"request is fully deterministic and operates on a single tuple. However, "
"unlike a classical row-based log, which contains entire copies of the "
"changed rows, Tarantool's WAL contains copies of the requests. For "
"example, for UPDATE requests, Tarantool only stores the primary key of "
"the row and the update operations, to save space."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:55
msgid ""
"Invocations of **stored programs** are not written to the WAL. Instead, "
"records of the actual **data-change requests, performed by the Lua "
"code**, are written to the WAL. This ensures that possible non-"
"determinism of Lua does not cause replication to go out of sync."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:60
msgid ""
"Data definition operations on **temporary spaces**, such as "
"creating/dropping, adding indexes, truncating, etc., are written to the "
"WAL, since information about temporary spaces is stored in non-temporary "
"system spaces, such as :ref:`box.space._space <box_space-space>`. Data "
"change operations on temporary spaces are not written to the WAL and are "
"not replicated."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:66
msgid ""
"To create a valid initial state, to which WAL changes can be applied, "
"every instance of a replica set requires a start set of :ref:`checkpoint "
"files <index-box_persistence>`, such as .snap files for memtx and .run "
"files for vinyl. A replica joining an existing replica set, chooses an "
"existing master and automatically downloads the initial state from it. "
"This is called an **initial join**."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:73
msgid ""
"When an entire replica set is bootstrapped for the first time, there is "
"no master which could provide the initial checkpoint. In such case, "
"replicas connect to each other, elect a master, which then creates the "
"starting set of checkpoint files, and distributes it across all other "
"replicas. This is called an **automatic bootstrap** of a replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:79
msgid ""
"When a replica contacts a master (there can be many masters) for the "
"first time, it becomes part of a replica set. On subsequent occasions, it"
" should always contact a master in the same replica set. Once connected "
"to the master, the replica requests all changes that happened after the "
"latest local LSN (there can be many LSNs -- each master has its own LSN)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:85
msgid ""
"Each replica set is identified by a globally unique identifier, called "
"**replica set UUID**. The identifier is created by the master which "
"creates the very first checkpoint, and is part of the checkpoint file. It"
" is stored in system space :ref:`box.space._schema <box_space-schema>`. "
"For example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:90
msgid ""
"tarantool> box.space._schema:select{'cluster'}\n"
"---\n"
"- - ['cluster', '6308acb9-9788-42fa-8101-2e0cb9d3c9a0']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:97
msgid ""
"Additionally, each instance in a replica set is assigned its own UUID, "
"when it joins the replica set. It is called an **instance UUID** and is a"
" globally unique identifier. This UUID is used to ensure that instances "
"do not join a different replica set, e.g. because of a configuration "
"error. A unique instance identifier is also necessary to apply rows "
"originating from different masters only once, that is, implement multi-"
"master replication. This is why each row in the write ahead log, in "
"addition to its log sequence number, stores the instance identifier of "
"the instance on which it was created. But using UUID as such an "
"identifier would take too much space in the write ahead log, thus a "
"shorter integer number is assigned to the instance when it joins a "
"replica set. This number is then used to refer to the instance in the "
"write ahead log. It is called **instance id**. All identifiers are stored"
" in system space :ref:`box.space._cluster <box_space-cluster>`. For "
"example:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:118
msgid ""
"Here the instance ID is ``1`` (unique within the replica set), and the "
"instance UUID is ``88580b5c-4474-43ab-bd2b-2409a9af80d2`` (globally "
"unique)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:121
msgid ""
"Using shorter numeric identifiers is also handy to track the state of the"
" entire replica set. For example, :ref:`box.info.vclock "
"<box_introspection-box_info>` describes the state of replication in "
"regard to each connected peer."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:125
msgid ""
"box.info.vclock\n"
"---\n"
"- {1: 827, 2: 584}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:132
msgid ""
"Here ``vclock`` contains log sequence numbers (827 and 584) for instances"
" with short identifiers 1 and 2."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:139
msgid "Replication setup"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:141
msgid ""
"To enable replication, you need to specify two parameters in a "
"``box.cfg{}`` request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:144
msgid ""
":ref:`replication <cfg_replication-replication>` parameter which defines "
"the replication source(s), and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:146
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter which is ``true`` for a "
"replica and ``false`` for a master."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:149
msgid ""
"Both these parameters are \"dynamic\". This allows a replica to become a "
"master and vice versa on the fly with the help of a ``box.cfg{}`` "
"request."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:152
msgid ""
"Further we're giving a detailed example of :ref:`bootstrapping a replica "
"set <replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:159
msgid "Replication roles: master and replica"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:161
msgid ""
"Replication role (master or replica) is set in :ref:`read_only "
"<cfg_basic-read_only>` configuration parameter. The recommended role for "
"**all-but-one** instances in a replica set is \"read-only\" (replica)."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:165
msgid ""
"In a master-replica configuration, every change that happens on the "
"master will be visible on the replicas, but not vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:171
msgid ""
"A simple two-instance replica set with the master on one machine and the "
"replica on a different machine provides two benefits:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:174
msgid ""
"**failover**, because if the master goes down then the replica can take "
"over, and"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:176
msgid ""
"**load balancing**, because clients can connect to either the master or "
"the replica for read requests."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:179
msgid ""
"In a **master-master** configuration (also called \"multi-master\"), "
"every change that happens on either instance will be visible on the other"
" one."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:185
msgid ""
"The failover benefit in this case is still present, and the load-"
"balancing benefit is enhanced, because any instance can handle both read "
"and write requests. Meanwhile, for multi-master configurations, it is "
"necessary to understand the **replication guarantees** provided by the "
"asynchronous protocol that Tarantool implements."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:191
msgid ""
"Tarantool multi-master replication guarantees that each change on each "
"master is propagated to all instances and is applied only once. Changes "
"from the same instance are applied in the same order as on the "
"originating instance. Changes from different instances, however, can mix "
"and apply in a different order on different instances. This may lead to "
"replication going out of sync in certain cases."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:198
msgid ""
"For example, assuming the database is only appended to (i.e. it contains "
"only insertions), it is safe to set each instance to a master. If there "
"are also deletions, but it is not mission critical that deletion happens "
"in the same order on all replicas (e.g. the DELETE is used to prune "
"expired data), a master-master configuration is also safe."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:204
msgid ""
"UPDATE operations, however, can easily go out of sync. For example, "
"assignment and increment are not commutative, and may yield different "
"results if applied in different order on different instances."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:208
msgid ""
"More generally, it is only safe to use Tarantool master-master "
"replication if all database changes are **commutative**: the end result "
"does not depend on the order in which the changes are applied. You can "
"start learning more about conflict-free replicated data types `here "
"<https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>`_."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:218
msgid "Replication topologies: cascade, ring and full mesh"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:220
msgid ""
"Replication topology is set in :ref:`replication <cfg_replication-"
"replication>` configuration parameter. The recommended topology is a "
"**full mesh**, because it makes potential failover easy."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:224
msgid ""
"Some database products offer **cascading replication** topologies: "
"creating a replica on a replica. Tarantool does not recommend such setup."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:230
msgid ""
"The problem with a cascading replica set is that some instances have no "
"connection to other instances and may not receive changes from them. One "
"essential change that must be propagated across all instances in a "
"replica set is an entry in ``box.space._cluster`` system space with "
"replica set UUID. Without knowing a replica set UUID, a master refuses to"
" accept connections from such instances when replication topology "
"changes. Here is how this can happen:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:240
msgid ""
"We have a chain of three instances. Instance #1 contains entries for "
"instances #1 and #2 in its ``_cluster`` space. Instances #2 and #3 "
"contain entries for instances #1, #2 and #3 in their ``_cluster`` spaces."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:247
msgid ""
"Now instance #2 is faulty. Instance #3 tries connecting to instance #1 as"
" its new master, but the master refuses the connection since it has no "
"entry for instance #3."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:251
msgid "**Ring replication** topology is, however, supported:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:256
msgid ""
"So, if you need a cascading topology, you may first create a ring to "
"ensure all instances know each other’s UUID, and then disconnect the "
"chain in the place you desire."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:260
msgid ""
"A stock recommendation for a master-master replication topology, however,"
" is a **full mesh**:"
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:266
msgid ""
"You then can decide where to locate instances of the mesh -- within the "
"same data center, or spread across a few data centers. Tarantool will "
"automatically ensure that each row is applied only once on each instance."
" To remove a degraded instance from a mesh, simply change ``replication``"
" configuration parameter."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:271
msgid ""
"This ensures full cluster availability in case of a local failure, e.g. "
"one of the instances failing in one of the data centers, as well as in "
"case of an entire data center failure."
msgstr ""

#: ../doc/1.7/book/replication/repl_architecture.rst:275
msgid "The maximal number of replicas in a mesh is 32."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:33
msgid "Bootstrapping a replica set"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:39
msgid "Master-replica bootstrap"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:41
msgid ""
"Let's first bootstrap a simple **master-replica** set containing two "
"instances, each located on its own machine. For easier administration, we"
" make the :ref:`instance files <admin-instance_file>` almost identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:48
msgid "Here is an example of the master's instance file:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:50
msgid ""
"-- instance file for the master\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:69
msgid ""
":ref:`listen <cfg_basic-listen>` parameter from ``box.cfg{}`` defines a "
"URI (port 3301 in our example), on which the master can accept "
"connections from replicas."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:72
msgid ""
":ref:`replication <cfg_replication-replication>` parameter defines the "
"URIs at which all instances in the replica set can accept connections. It"
" includes the replica's URI as well, although the replica is not a "
"replication source right now."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:79
msgid ""
"For security reasons, we recommend to prevent unauthorized replication "
"sources by associating a password with every user that has a replication "
":ref:`role <authentication-roles>`. That way, the :ref:`URI <index-uri>` "
"for ``replication`` parameter must have the long form "
"``username:password@host:port``."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:85
msgid ""
":ref:`read_only <cfg_basic-read_only>` parameter enables data-change "
"operations on the instance and makes this Tarantool instance act as a "
"master, not as a replica. *That's the only parameter in our instance "
"files that will differ.*"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:89
msgid ""
":ref:`box.once() <box-once>` function contains database initialization "
"logic that should be executed only once during the replica set lifetime."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:92
msgid ""
"In this example, we create a space with a primary index, and a user for "
"replication purposes. We also say ``print('box.once executed on "
"master')`` to see later in console whether ``box.once()`` is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:98
msgid ""
"Replication requires privileges. We can grant privileges for accessing "
"spaces directly to the user who will start the instance. However, it is "
"more usual to grant privileges for accessing spaces to a :ref:`role "
"<authentication-roles>`, and then grant the role to the user who will "
"start the replica."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:104
msgid ""
"Here we use Tarantool's predefined role named \"replication\" which by "
"default grants \"read\" privileges for all database objects "
"(\"universe\"), and we can further set up privileges for this role as "
"required."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:108
msgid ""
"In the replica's instance file, we only set read-only parameter to "
"\"true\", and say ``print('box.once executed on replica')`` to make sure "
"that box.once() is not executed more than once. Otherwise the replica's "
"instance file is fully identical to the master's instance file."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:113
msgid ""
"-- instance file for the replica\n"
"box.cfg{\n"
"  listen = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master URI"
"\n"
"                 'replicator:password@192.168.0.102:3301'}, -- replica "
"URI\n"
"  read_only = true\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') - grant replication"
" role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on replica')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:132
msgid ""
"The replica does not inherit the master’s configuration parameters, such "
"as those making the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`"
" run on the master. To get the same behavior, please set the relevant "
"parameters explicitly so that they are the same on both master and "
"replica."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:137
msgid "Now we can launch the two instances. The master..."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:139
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:12:03.847 [18933] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:03.848 [18933] main/101/master.lua C> log level 5\n"
"2017-06-14 14:12:03.849 [18933] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:12:03.859 [18933] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:56736: Connection refused\n"
"2017-06-14 14:12:03.861 [18933] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:12:03.861 [18933] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.878 [18933] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:12:19.879 [18933] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:12:19.908 [18933] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:12:19.914 [18933] snapshot/101/main I> done\n"
"2017-06-14 14:12:19.914 [18933] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:19.917 [18933] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.918 [18933] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:12:19.920 [18933] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:162
msgid "... (yep, ``box.once()`` got executed on the master) -- and the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:164
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:12:19.486 [18934] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:12:19.487 [18934] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:12:19.494 [18934] iproto/101/main I> binary: bound to "
"[::]:3311\n"
"2017-06-14 14:12:19.495 [18934] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:12:19.495 [18934] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3302\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:12:19.496 [18934] main/104/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:177
msgid ""
"In both logs, there are messages saying that the replica got bootstrapped"
" from the master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:179
msgid ""
"$ # bootstrapping the replica (from the master's log)\n"
"<...>\n"
"2017-06-14 14:12:20.503 [18933] main/106/main I> initial data sent.\n"
"2017-06-14 14:12:20.505 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.505 [18933] main/106/main I> final data sent.\n"
"2017-06-14 14:12:20.522 [18933] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master_dir/00000000000000000000.xlog'\n"
"2017-06-14 14:12:20.922 [18933] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:189
msgid ""
"$ # bootstrapping the replica (from the replica's log)\n"
"<...>\n"
"2017-06-14 14:12:20.498 [18934] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:12:20.498 [18934] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.101:3301\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:12:20.512 [18934] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:12:20.517 [18934] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:12:20.518 [18934] snapshot/101/main I> done\n"
"2017-06-14 14:12:20.519 [18934] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:12:20.520 [18934] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:12:20.520 [18934] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:204
msgid ""
"Notice that ``box.once()`` was executed only at the master, although we "
"added ``box.once()`` to both instance files."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:207
msgid "We could as well launch the replica first:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:209
msgid ""
"$ # launching the replica\n"
"$ tarantool replica.lua\n"
"2017-06-14 14:35:36.763 [18952] main/101/replica.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua C> log level 5\n"
"2017-06-14 14:35:36.765 [18952] main/101/replica.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 14:35:36.772 [18952] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" can't connect to master\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. "
"coio.cc:105 !> SystemError connect, called on fd 13, aka "
"192.168.0.101:56820: Connection refused\n"
"2017-06-14 14:35:36.772 [18952] main/104/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 14:35:36.772 [18952] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:222
msgid "... and the master later:"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:224
msgid ""
"$ # launching the master\n"
"$ tarantool master.lua\n"
"2017-06-14 14:35:43.701 [18953] main/101/master.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua C> log level 5\n"
"2017-06-14 14:35:43.702 [18953] main/101/master.lua I> mapping 268435456 "
"bytes for tuple arena...\n"
"2017-06-14 14:35:43.709 [18953] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 14:35:43.709 [18953] main/105/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 14:35:43.709 [18953] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.709 [18953] main/101/master.lua I> initializing an "
"empty data directory\n"
"2017-06-14 14:35:43.721 [18953] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/master/00000000000000000000.snap.inprogress'\n"
"2017-06-14 14:35:43.722 [18953] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.723 [18953] main/101/master.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. I>"
" failed to authenticate\n"
"2017-06-14 14:35:43.724 [18953] main/105/applier/replicator@192.168.0. "
"xrow.cc:431 E> ER_LOADING: Instance bootstrap hasn't finished yet\n"
"box.once executed on master\n"
"2017-06-14 14:35:43.726 [18953] main C> entering the event loop\n"
"2017-06-14 14:35:43.779 [18953] main/103/main I> initial data sent.\n"
"2017-06-14 14:35:43.780 [18953] relay/[::ffff:192.168.0.101]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:43.780 [18953] main/103/main I> final data sent.\n"
"2017-06-14 14:35:43.796 [18953] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/var/lib/tarantool/master/00000000000000000000.xlog'\n"
"2017-06-14 14:35:44.726 [18953] main/105/applier/replicator@192.168.0. I>"
" authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:249
msgid ""
"In this case, the replica would wait for the master to become available, "
"so the launch order doesn't matter. Our ``box.once()`` logic would also "
"be executed only once, at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:253
msgid ""
"$ # the replica has eventually connected to the master\n"
"$ # and got bootstrapped (from the replica's log)\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 14:35:43.777 [18952] main/104/applier/replicator@192.168.0. I>"
" authenticated\n"
"2017-06-14 14:35:43.777 [18952] main/101/replica.lua I> bootstrapping "
"replica from 192.168.0.199:3310\n"
"2017-06-14 14:35:43.788 [18952] main/104/applier/replicator@192.168.0. I>"
" initial data received\n"
"2017-06-14 14:35:43.789 [18952] main/104/applier/replicator@192.168.0. I>"
" final data received\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> saving snapshot "
"`/var/lib/tarantool/replica/00000000000000000005.snap.inprogress'\n"
"2017-06-14 14:35:43.793 [18952] snapshot/101/main I> done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> ready to accept "
"requests\n"
"2017-06-14 14:35:43.795 [18952] main/101/replica.lua I> set 'read_only' "
"configuration option to true\n"
"2017-06-14 14:35:43.795 [18952] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:273
msgid "Controlled failover"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:275
msgid ""
"To perform a **controlled failover**, that is, swap the roles of the "
"master and replica, all we need to do is to set ``read_only=true`` at the"
" master, and ``read_only=false`` at the replica. The **order of actions**"
" is important here. If a system is running in production, we don’t want "
"concurrent writes happen both at the replica and the master. Nor do we "
"want the new replica to accept any writes until it has finished fetching "
"all replication data from the old master. To compare replica and master "
"state, we can use :ref:`box.info.signature <box_introspection-box_info>`."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:284
msgid "Set ``read_only=true`` at the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:286
msgid ""
"# at the master\n"
"tarantool> box.cfg{read_only=true}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:291
msgid ""
"Record the master’s current position with ``box.info.signature``, "
"containing the sum of all LSNs in the master’s vector clock."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:294
msgid ""
"# at the master\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:299
msgid "Wait until the replica’s signature is the same as the master’s."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:301
msgid ""
"# at the replica\n"
"tarantool> box.info.signature"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:306
msgid "Set ``read_only=false`` at the replica to enable write operations."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:308
msgid ""
"# at the replica\n"
"tarantool> box.cfg{read_only=false}"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:313
msgid ""
"These 4 steps ensure that the replica doesn’t accept new writes until "
"it’s done fetching writes from the master."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:320
msgid "Master-master bootstrap"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:322
msgid ""
"Now let's bootstrap a two-instance **master-master** set. For easier "
"administration, we make master#1 and master#2 instance files fully "
"identical."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:328
msgid ""
"We re-use the master's instance file from the :ref:`master-replica "
"example <replication-master_replica_bootstrap>` above."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:331
msgid ""
"-- instance file for any of the two masters\n"
"box.cfg{\n"
"  listen      = 3301,\n"
"  replication = {'replicator:password@192.168.0.101:3301',  -- master1 "
"URI\n"
"                 'replicator:password@192.168.0.102:3301'}, -- master2 "
"URI\n"
"  read_only   = false\n"
"}\n"
"box.once(\"schema\", function()\n"
"   box.schema.user.create('replicator', {password = 'password'})\n"
"   box.schema.user.grant('replicator', 'replication') -- grant "
"replication role\n"
"   box.schema.space.create(\"test\")\n"
"   box.space.test:create_index(\"primary\")\n"
"   print('box.once executed on master #1')\n"
"end)"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:348
msgid ""
"In :ref:`replication <cfg_replication-replication>` parameter, we define "
"the URIs of both masters in the replica set and say ``print('box.once "
"executed on master #1')`` to see when and where the ``box.once()`` logic "
"is executed."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:353
msgid ""
"Now we can launch the two masters. Again, the launch order doesn't "
"matter. The ``box.once()`` logic will also be executed only once, at the "
"master which is elected as the replica set leader at bootstrap."
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:357
msgid ""
"$ # launching master #1\n"
"$ tarantool master1.lua\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:03.062 [47021] main/101/master1.lua C> log level 5\n"
"2017-06-14 15:39:03.063 [47021] main/101/master1.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:03.065 [47021] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> can't connect to master\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"coio.cc:107 !> SystemError connect, called on fd 14, aka "
"192.168.0.102:57110: Connection refused\n"
"2017-06-14 15:39:03.065 [47021] main/105/applier/replicator@192.168.0.10 "
"I> will retry every 1 second\n"
"2017-06-14 15:39:03.065 [47021] main/104/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:08.070 [47021] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:08.071 [47021] main/105/applier/replicator@192.168.0.10 "
"I> authenticated\n"
"2017-06-14 15:39:08.071 [47021] main/101/master1.lua I> bootstrapping "
"replica from 192.168.0.102:3301\n"
"2017-06-14 15:39:08.073 [47021] main/105/applier/replicator@192.168.0.10 "
"I> initial data received\n"
"2017-06-14 15:39:08.074 [47021] main/105/applier/replicator@192.168.0.10 "
"I> final data received\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master1_dir/00000000000000000008.snap.inprogress'\n"
"2017-06-14 15:39:08.074 [47021] snapshot/101/main I> done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:08.076 [47021] main/101/master1.lua I> ready to accept "
"requests\n"
"box.once executed on master #1\n"
"2017-06-14 15:39:08.077 [47021] main C> entering the event loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_bootstrap.rst:381
msgid ""
"$ # launching master #2\n"
"$ tarantool master2.lua\n"
"2017-06-14 15:39:07.452 [47022] main/101/master2.lua C> version "
"1.7.4-52-g980d30092\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua C> log level 5\n"
"2017-06-14 15:39:07.453 [47022] main/101/master2.lua I> mapping 268435456"
" bytes for tuple arena...\n"
"2017-06-14 15:39:07.455 [47022] iproto/101/main I> binary: bound to "
"[::]:3301\n"
"2017-06-14 15:39:07.455 [47022] main/104/applier/replicator@192.168.0.19 "
"I> remote master is 1.7.4 at 192.168.0.101:3301\n"
"2017-06-14 15:39:07.455 [47022] main/105/applier/replicator@192.168.0.10 "
"I> remote master is 1.7.4 at 192.168.0.102:3301\n"
"2017-06-14 15:39:07.455 [47022] main/101/master2.lua I> initializing an "
"empty data directory\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> saving snapshot "
"`/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.snap.inprogress'\n"
"2017-06-14 15:39:07.457 [47022] snapshot/101/main I> done\n"
"2017-06-14 15:39:07.458 [47022] main/101/master2.lua I> vinyl checkpoint "
"done\n"
"2017-06-14 15:39:07.459 [47022] main/101/master2.lua I> ready to accept "
"requests\n"
"2017-06-14 15:39:07.460 [47022] main C> entering the event loop\n"
"2017-06-14 15:39:08.072 [47022] main/103/main I> initial data sent.\n"
"2017-06-14 15:39:08.073 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.073 [47022] main/103/main I> final data sent.\n"
"2017-06-14 15:39:08.077 [47022] relay/[::ffff:192.168.0.102]:/101/main I>"
" recover from `/Users/e.shebunyaeva/work/tarantool-test-"
"repl/master2_dir/00000000000000000000.xlog'\n"
"2017-06-14 15:39:08.461 [47022] main/104/applier/replicator@192.168.0.10 "
"I> authenticated"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:33
msgid "Preventing duplicate actions"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:35
msgid ""
"Tarantool guarantees that every update is applied only once at every "
"replica. However, due to asynchronous nature of the replication, the "
"order of updates is not guaranteed. Further we analyse this problem in "
"more details, provide examples of replication going out of sync, and "
"suggest solutions."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:44
msgid "Replication stops"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:46
msgid ""
"In a replica set of two masters, suppose master #1 tries to do something "
"that master #2 has already done. For example, try to simultaneously "
"insert a tuple with the same unique key:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:50
msgid "tarantool> box.space.tester:insert{1, 'data'}"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:54
msgid ""
"This would cause an error saying ``Duplicate key exists in unique index "
"'primary' in space 'tester'`` and the replication would be stopped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:57
msgid ""
"$ # error messages from master #1\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30444] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.233 [30444] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop\n"
"\n"
"$ # error messages from master #2\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 I>"
" can't read row\n"
"2017-06-26 21:17:03.233 [30445] main/104/applier/rep_user@100.96.166.1 "
"memtx_hash.cc:226 E> ER_TUPLE_FOUND:\n"
"Duplicate key exists in unique index 'primary' in space 'tester'\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-26 21:17:03.234 [30445] relay/[::ffff:100.96.166.178]/101/main C>"
" exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:73
msgid ""
"If we check replication statuses with ``box.info``, we'll see that "
"replication at master #1 is stopped (``1.upstream.status = stopped``). "
"Additionally, no data is replicated from that master (section "
"``1.downstream`` is missing in the report), because the downstream has "
"encountered the same error:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:78
msgid ""
"# replication statuses (report from master #3)\n"
"tarantool> box.info\n"
"---\n"
"- version: 1.7.4-52-g980d30092\n"
"  id: 3\n"
"  ro: false\n"
"  vclock: {1: 9, 2: 1000000, 3: 3}\n"
"  uptime: 557\n"
"  lsn: 3\n"
"  vinyl: []\n"
"  cluster:\n"
"    uuid: 34d13b1a-f851-45bb-8f57-57489d3b3c8b\n"
"  pid: 30445\n"
"  status: running\n"
"  signature: 1000012\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: 7ab6dee7-dc0f-4477-af2b-0e63452573cf\n"
"      lsn: 9\n"
"      upstream:\n"
"        status: stopped\n"
"        idle: 445.8626639843\n"
"        message: Duplicate key exists in unique index 'primary' in space "
"'tester'\n"
"        lag: 0.00050592422485352\n"
"    2:\n"
"      id: 2\n"
"      uuid: 9afbe2d9-db84-4d05-9a7b-e0cbbf861e28\n"
"      lsn: 1000000\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 201.99915885925\n"
"        lag: 0.0015020370483398\n"
"      downstream:\n"
"        vclock: {1: 8, 2: 1000000, 3: 3}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"      lsn: 3\n"
"  uuid: e826a667-eed7-48d5-a290-64299b159571\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:122
msgid "When replication is later manually resumed:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:124
msgid ""
"# resuming stopped replication (at all masters)\n"
"tarantool> original_value = box.cfg.replication\n"
"tarantool> box.cfg{replication={}}\n"
"tarantool> box.cfg{replication=original_value}"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:131
msgid "... the faulty row in the write ahead log files is skipped."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:137
msgid "Replication runs out of sync"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:139
msgid ""
"In a master-master cluster of two instances, suppose we make the "
"following operation:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:142
msgid "tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:146
msgid "When we get this operation applied on both instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:148
msgid ""
"-- at master #1\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})\n"
"-- at master #2\n"
"tarantool> box.space.tester:upsert({1}, {{'=', 2, box.info.uuid}})"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:155
msgid ""
"... we can have the following results, depending on the order of "
"execution:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:157
msgid "each master’s row contains the uuid from master #1,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:158
msgid "each master’s row contains the uuid from master #2,"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:159
msgid "master #1 has the uuid of master #2, and vice versa."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:165
msgid "Commutative changes"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:167
msgid ""
"The cases described in previous paragraphs represent examples of **non-"
"commutative** operations, i.e. operations, which result depends on the "
"execution order. On the contrary, for **commutative operations**, the "
"execution order doesn’t matter."
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:172
msgid "Consider for example the following command:"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:174
msgid "tarantool> box.space.tester:upsert{{1, 0}, {{'+', 2, 1)}"
msgstr ""

#: ../doc/1.7/book/replication/repl_duplicates.rst:178
msgid ""
"This operation is commutative: we get the same result no matter in which "
"order the update is applied on the other masters."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:33
msgid "Monitoring a replica set"
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:35
msgid ""
"To learn what instances belong in the replica set, and obtain statistics "
"for all these instances, use ``box.info.replication`` request:"
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:38
msgid ""
"box.info.replication\n"
"---\n"
"  replication:\n"
"    1:\n"
"      id: 1\n"
"      uuid: b8a7db60-745f-41b3-bf68-5fcce7a1e019\n"
"      lsn: 88\n"
"    2:\n"
"      id: 2\n"
"      uuid: cd3c7da2-a638-4c5d-ae63-e7767c3a6896\n"
"      lsn: 31\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187747001648\n"
"        lag: 0\n"
"      downstream:\n"
"     vclock: {1: 31}\n"
"    3:\n"
"      id: 3\n"
"      uuid: e38ef895-5804-43b9-81ac-9f2cd872b9c4\n"
"      lsn: 54\n"
"      upstream:\n"
"        status: follow\n"
"        idle: 43.187621831894\n"
"        lag: 2\n"
"      downstream:\n"
"        vclock: {1: 54}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:69
msgid ""
"This report is for a master-master replica set of three instances, each "
"having its own instance id, UUID and log sequence number."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:75
msgid ""
"The request was issued at master #1, and the reply includes statistics "
"for the other two masters, given in regard to master #1."
msgstr ""

#: ../doc/1.7/book/replication/repl_monitoring.rst:78
msgid ""
"The primary indicators of replication health are ``idle`` and ``lag`` "
"parameters (see reference on :ref:`box.info.replication "
"<box_info_replication>` for details)."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:33
msgid "Recovering from a degraded state"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:35
msgid ""
"\"Degraded state\" is a situation when the master becomes unavailable -- "
"due to hardware or network failure, or due to a programming bug."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:41
msgid ""
"In a master-replica set, if a master disappears, error messages appear on"
" the replicas stating that the connection is lost:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:44
msgid ""
"$ # messages from a replica's log\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" can't read row\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. "
"coio.cc:349 !> SystemError\n"
"unexpected EOF when reading from socket, called on fd 17, aka "
"192.168.0.101:57815,\n"
"peer of 192.168.0.101:3301: Broken pipe\n"
"2017-06-14 16:23:10.993 [19153] main/105/applier/replicator@192.168.0. I>"
" will retry every 1 second\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main I>"
" the replica has closed its socket, exiting\n"
"2017-06-14 16:23:10.993 [19153] relay/[::ffff:192.168.0.101]:/101/main C>"
" exiting the relay loop"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:55
msgid "... and the master's status is reported as \"disconnected\":"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:57
msgid ""
"# report from replica #1\n"
"tarantool> box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 182.36929893494\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58244\n"
"      lag: 0.00026607513427734\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"    downstream:\n"
"      vclock: {1: 542}\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:83
msgid ""
"# report from replica #2\n"
"box.info.replication\n"
"---\n"
"- 1:\n"
"    id: 1\n"
"    uuid: 70e8e9dc-e38d-4046-99e5-d25419267229\n"
"    lsn: 542\n"
"    upstream:\n"
"      status: disconnected\n"
"      idle: 186.76988101006\n"
"      message: connect, called on fd 13, aka 192.168.0.101:58253\n"
"      lag: 0.00027203559875488\n"
"  2:\n"
"    id: 2\n"
"    uuid: fb252ac7-5c34-4459-84d0-54d248b8c87e\n"
"    lsn: 0\n"
"    upstream:\n"
"      status: follow\n"
"      idle: 186.76960110664\n"
"      lag: 0.00020599365234375\n"
"  3:\n"
"    id: 3\n"
"    uuid: fd7681d8-255f-4237-b8bb-c4fb9d99024d\n"
"    lsn: 0\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:111
msgid "To declare that one of the replicas must now take over as a new master:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:113
msgid "Make sure that the old master is gone for good:"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:115
msgid ""
"change network routing rules to avoid any more packets being delivered to"
" the master, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:117
msgid "shut down the master instance, if you have access to the machine, or"
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:118
msgid "power off the container or the machine."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:120
msgid ""
"Say ``box.cfg{read_only=false, listen=URI}`` on the replica, and "
"``box.cfg{replication=URI}`` on the other replicas in the set."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:125
msgid ""
"If there are updates on the old master that were not propagated before "
"the old master went down, :ref:`re-apply them manually <admin-"
"disaster_recovery-master_replica>` to the new master using ``tarantoolctl"
" cat`` and ``tarantoolctl play`` commands."
msgstr ""

#: ../doc/1.7/book/replication/repl_recover.rst:130
msgid ""
"There is no automatic way for a replica to detect that the master is gone"
" forever, since sources of failure and replication environments vary "
"significantly. So the detection of degraded state requires an external "
"observer."
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:33
msgid "Removing instances"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:35
msgid "To politely remove an instance from a replica set, follow these steps:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:37
msgid "On the instance, run ``box.cfg{}`` with a blank replication source:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:39
msgid ""
"tarantool> box.cfg{replication=''}\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:45
msgid ""
"The other instances in the replica set will carry on. If later the "
"removed instance rejoins, it will receive all the updates that the other "
"instances made while it was away."
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:49
msgid ""
"If the instance is decommissioned forever, delete the instance's record "
"from the following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:52
msgid ""
":ref:`replication <cfg_replication-replication>` parameter at all running"
" instances in the replica set:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:55
msgid "tarantool> box.cfg{replication=...}"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:59
msgid ""
":ref:`box.space._cluster <box_space-cluster>` on any master instance in "
"the replica set. For example, a record with instance id = 3:"
msgstr ""

#: ../doc/1.7/book/replication/repl_remove_instances.rst:62
msgid ""
"tarantool> box.space._cluster:select{}\n"
"---\n"
"- - [1, '913f99c8-aee3-47f2-b414-53ed0ec5bf27']\n"
"  - [2, 'eac1aee7-cfeb-46cc-8503-3f8eb4c7de1e']\n"
"  - [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"...\n"
"tarantool> box.space._cluster:delete(3)\n"
"---\n"
"- [3, '97f2d65f-2e03-4dc8-8df3-2469bd9ce61e']\n"
"..."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:33
msgid "Reseeding a replica"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:35
msgid ""
"If any of a replica's .xlog/.snap/.run files are corrupted or deleted, "
"you can \"re-seed\" the replica:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:38
msgid ""
"Stop the replica and destroy all local database files (the ones with "
"extensions .xlog/.snap/.run/.inprogress)."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:41
msgid "Delete the replica's record from the following locations:"
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:43
msgid "``replication`` parameter at all running instances in the replica set."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:44
msgid "``box.space._cluster`` on the master instance."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:46
msgid ""
"See section :ref:`Removing instances <replication-remove_instances>` for "
"details."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:49
msgid ""
"Restart the replica with the same instance file to contact the master "
"again. The replica will then catch up with the master by retrieving all "
"the master’s tuples."
msgstr ""

#: ../doc/1.7/book/replication/repl_reseed.rst:55
msgid ""
"Remember that this procedure works only if the master’s WAL files are "
"present."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:5
#: ../doc/1.7/dev_guide/box_protocol.rst:33
msgid "Tarantool's binary protocol"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:7
#: ../doc/1.7/dev_guide/box_protocol.rst:35
msgid "Tarantool's binary protocol is a binary request/response protocol."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:11
#: ../doc/1.7/dev_guide/box_protocol.rst:39
msgid "Notation in diagrams"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:13
#: ../doc/1.7/dev_guide/box_protocol.rst:41
msgid ""
"0    X\n"
"+----+\n"
"|    | - X bytes\n"
"+----+\n"
" TYPE - type of MsgPack value (if it is a MsgPack object)\n"
"\n"
"+====+\n"
"|    | - Variable size MsgPack object\n"
"+====+\n"
" TYPE - type of MsgPack value\n"
"\n"
"+~~~~+\n"
"|    | - Variable size MsgPack Array/Map\n"
"+~~~~+\n"
" TYPE - type of MsgPack value"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:32
#: ../doc/1.7/dev_guide/box_protocol.rst:60
msgid "MsgPack data types:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:34
#: ../doc/1.7/dev_guide/box_protocol.rst:62
msgid "**MP_INT** - Integer"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:35
#: ../doc/1.7/dev_guide/box_protocol.rst:63
msgid "**MP_MAP** - Map"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:36
#: ../doc/1.7/dev_guide/box_protocol.rst:64
msgid "**MP_ARR** - Array"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:37
#: ../doc/1.7/dev_guide/box_protocol.rst:65
msgid "**MP_STRING** - String"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:38
#: ../doc/1.7/dev_guide/box_protocol.rst:66
msgid "**MP_FIXSTR** - Fixed size string"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:39
#: ../doc/1.7/dev_guide/box_protocol.rst:67
msgid "**MP_OBJECT** - Any MsgPack object"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:40
#: ../doc/1.7/dev_guide/box_protocol.rst:68
msgid "**MP_BIN** - MsgPack binary format"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:44
#: ../doc/1.7/dev_guide/box_protocol.rst:72
msgid "Greeting packet"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:46
#: ../doc/1.7/dev_guide/box_protocol.rst:74
msgid ""
"TARANTOOL'S GREETING:\n"
"\n"
"0                                     63\n"
"+--------------------------------------+\n"
"|                                      |\n"
"| Tarantool Greeting (server version)  |\n"
"|               64 bytes               |\n"
"+---------------------+----------------+\n"
"|                     |                |\n"
"| BASE64 encoded SALT |      NULL      |\n"
"|      44 bytes       |                |\n"
"+---------------------+----------------+\n"
"64                  107              127"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:62
#: ../doc/1.7/dev_guide/box_protocol.rst:90
msgid ""
"The server instance begins the dialogue by sending a fixed-size "
"(128-byte) text greeting to the client. The greeting always contains two "
"64-byte lines of ASCII text, each line ending with a newline character "
"('\\\\n'). The first line contains the instance version and protocol "
"type. The second line contains up to 44 bytes of base64-encoded random "
"string, to use in the authentication packet, and ends with up to 23 "
"spaces."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:70
#: ../doc/1.7/dev_guide/box_protocol.rst:98
msgid "Unified packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:72
#: ../doc/1.7/dev_guide/box_protocol.rst:100
msgid ""
"Once a greeting is read, the protocol becomes pure request/response and "
"features a complete access to Tarantool functionality, including:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:75
#: ../doc/1.7/dev_guide/box_protocol.rst:103
msgid ""
"request multiplexing, e.g. ability to asynchronously issue multiple "
"requests via the same connection"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:77
#: ../doc/1.7/dev_guide/box_protocol.rst:105
msgid "response format that supports zero-copy writes"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:79
#: ../doc/1.7/dev_guide/box_protocol.rst:107
msgid ""
"For data structuring and encoding, the protocol uses msgpack data format,"
" see http://msgpack.org"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:82
#: ../doc/1.7/dev_guide/box_protocol.rst:110
msgid ""
"The Tarantool protocol mandates use of a few integer constants serving as"
" keys in maps used in the protocol. These constants are defined in "
"`src/box/iproto_constants.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/iproto_constants.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:86
#: ../doc/1.7/dev_guide/box_protocol.rst:114
msgid "We list them here too:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:88
#: ../doc/1.7/dev_guide/box_protocol.rst:116
msgid ""
"-- user keys\n"
"<code>          ::= 0x00\n"
"<sync>          ::= 0x01\n"
"<schema_id>     ::= 0x05\n"
"<space_id>      ::= 0x10\n"
"<index_id>      ::= 0x11\n"
"<limit>         ::= 0x12\n"
"<offset>        ::= 0x13\n"
"<iterator>      ::= 0x14\n"
"<key>           ::= 0x20\n"
"<tuple>         ::= 0x21\n"
"<function_name> ::= 0x22\n"
"<username>      ::= 0x23\n"
"<expression>    ::= 0x27\n"
"<ops>           ::= 0x28\n"
"<data>          ::= 0x30\n"
"<error>         ::= 0x31"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:108
#: ../doc/1.7/dev_guide/box_protocol.rst:136
msgid ""
"-- -- Value for <code> key in request can be:\n"
"-- User command codes\n"
"<select>  ::= 0x01\n"
"<insert>  ::= 0x02\n"
"<replace> ::= 0x03\n"
"<update>  ::= 0x04\n"
"<delete>  ::= 0x05\n"
"<call_16> ::= 0x06\n"
"<auth>    ::= 0x07\n"
"<eval>    ::= 0x08\n"
"<upsert>  ::= 0x09\n"
"<call>    ::= 0x0a\n"
"-- Admin command codes\n"
"<ping>    ::= 0x40\n"
"\n"
"-- -- Value for <code> key in response can be:\n"
"<OK>      ::= 0x00\n"
"<ERROR>   ::= 0x8XXX"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:130
#: ../doc/1.7/dev_guide/box_protocol.rst:158
msgid "Both :code:`<header>` and :code:`<body>` are msgpack maps:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:132
#: ../doc/1.7/dev_guide/box_protocol.rst:160
msgid ""
"Request/Response:\n"
"\n"
"0        5\n"
"+--------+ +============+ +===================================+\n"
"| BODY + | |            | |                                   |\n"
"| HEADER | |   HEADER   | |               BODY                |\n"
"|  SIZE  | |            | |                                   |\n"
"+--------+ +============+ +===================================+\n"
"  MP_INT       MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:144
#: ../doc/1.7/dev_guide/box_protocol.rst:172
msgid ""
"UNIFIED HEADER:\n"
"\n"
"+================+================+=====================+\n"
"|                |                |                     |\n"
"|   0x00: CODE   |   0x01: SYNC   |    0x05: SCHEMA_ID  |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT |  MP_INT: MP_INT     |\n"
"|                |                |                     |\n"
"+================+================+=====================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:156
#: ../doc/1.7/dev_guide/box_protocol.rst:184
msgid ""
"They only differ in the allowed set of keys and values. The key defines "
"the type of value that follows. If a body has no keys, the entire msgpack"
" map for the body may be missing. Such is the case, for example, for a "
"<ping> request. ``schema_id`` may be absent in the request's header, "
"meaning that there will be no version checking, but it must be present in"
" the response. If ``schema_id`` is sent in the header, then it will be "
"checked."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:167
#: ../doc/1.7/dev_guide/box_protocol.rst:195
msgid "Authentication"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:169
#: ../doc/1.7/dev_guide/box_protocol.rst:197
msgid ""
"When a client connects to the server instance, the instance responds with"
" a 128-byte text greeting message. Part of the greeting is base-64 "
"encoded session salt - a random string which can be used for "
"authentication. The length of decoded salt (44 bytes) exceeds the amount "
"necessary to sign the authentication message (first 20 bytes). An excess "
"is reserved for future authentication schemas."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:176
#: ../doc/1.7/dev_guide/box_protocol.rst:204
msgid ""
"PREPARE SCRAMBLE:\n"
"\n"
"    LEN(ENCODED_SALT) = 44;\n"
"    LEN(SCRAMBLE)     = 20;\n"
"\n"
"prepare 'chap-sha1' scramble:\n"
"\n"
"    salt = base64_decode(encoded_salt);\n"
"    step_1 = sha1(password);\n"
"    step_2 = sha1(step_1);\n"
"    step_3 = sha1(salt, step_2);\n"
"    scramble = xor(step_1, step_3);\n"
"    return scramble;\n"
"\n"
"AUTHORIZATION BODY: CODE = 0x07\n"
"\n"
"+==================+====================================+\n"
"|                  |        +-------------+-----------+ |\n"
"|  (KEY)           | (TUPLE)|  len == 9   | len == 20 | |\n"
"|   0x23:USERNAME  |   0x21:| \"chap-sha1\" |  SCRAMBLE | |\n"
"| MP_INT:MP_STRING | MP_INT:|  MP_STRING  |  MP_BIN   | |\n"
"|                  |        +-------------+-----------+ |\n"
"|                  |                   MP_ARRAY         |\n"
"+==================+====================================+\n"
"                        MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:204
#: ../doc/1.7/dev_guide/box_protocol.rst:232
msgid ""
":code:`<key>` holds the user name. :code:`<tuple>` must be an array of 2 "
"fields: authentication mechanism (\"chap-sha1\" is the only supported "
"mechanism right now) and password, encrypted according to the specified "
"mechanism. Authentication in Tarantool is optional, if no authentication "
"is performed, session user is 'guest'. The instance responds to "
"authentication packet with a standard response with 0 tuples."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:212
#: ../doc/1.7/dev_guide/box_protocol.rst:240
msgid "Requests"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:214
#: ../doc/1.7/dev_guide/box_protocol.rst:242
msgid "SELECT: CODE - 0x01 Find tuples matching the search pattern"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:217
#: ../doc/1.7/dev_guide/box_protocol.rst:245
msgid ""
"SELECT BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x12: LIMIT    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_INT   |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x13: OFFSET   |   0x14: ITERATOR |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:234
#: ../doc/1.7/dev_guide/box_protocol.rst:262
msgid ""
"INSERT:  CODE - 0x02 Inserts tuple into the space, if no tuple with same "
"unique keys exists. Otherwise throw *duplicate key* error."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:236
#: ../doc/1.7/dev_guide/box_protocol.rst:264
msgid ""
"REPLACE: CODE - 0x03 Insert a tuple into the space or replace an existing"
" one."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:239
#: ../doc/1.7/dev_guide/box_protocol.rst:267
msgid ""
"INSERT/REPLACE BODY:\n"
"\n"
"+==================+==================+\n"
"|                  |                  |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |\n"
"+==================+==================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:252
#: ../doc/1.7/dev_guide/box_protocol.rst:280
msgid "UPDATE: CODE - 0x04 Update a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:255
#: ../doc/1.7/dev_guide/box_protocol.rst:283
msgid ""
"UPDATE BODY:\n"
"\n"
"+==================+=======================+\n"
"|                  |                       |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT        |\n"
"|                  |                       |\n"
"+==================+=======================+\n"
"|                  |          +~~~~~~~~~~+ |\n"
"|                  |          |          | |\n"
"|                  | (TUPLE)  |    OP    | |\n"
"|   0x20: KEY      |    0x21: |          | |\n"
"| MP_INT: MP_ARRAY |  MP_INT: +~~~~~~~~~~+ |\n"
"|                  |            MP_ARRAY   |\n"
"+==================+=======================+\n"
"                 MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:274
#: ../doc/1.7/dev_guide/box_protocol.rst:302
msgid ""
"OP:\n"
"    Works only for integer fields:\n"
"    * Addition    OP = '+' . space[key][field_no] += argument\n"
"    * Subtraction OP = '-' . space[key][field_no] -= argument\n"
"    * Bitwise AND OP = '&' . space[key][field_no] &= argument\n"
"    * Bitwise XOR OP = '^' . space[key][field_no] ^= argument\n"
"    * Bitwise OR  OP = '|' . space[key][field_no] |= argument\n"
"    Works on any fields:\n"
"    * Delete      OP = '#'\n"
"      delete <argument> fields starting\n"
"      from <field_no> in the space[<key>]\n"
"\n"
"0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:297
#: ../doc/1.7/dev_guide/box_protocol.rst:325
msgid ""
"    * Insert      OP = '!'\n"
"      insert <argument> before <field_no>\n"
"    * Assign      OP = '='\n"
"      assign <argument> to field <field_no>.\n"
"      will extend the tuple if <field_no> == <max_field_no> + 1\n"
"\n"
"0           2\n"
"+-----------+==========+===========+\n"
"|           |          |           |\n"
"|    OP     | FIELD_NO | ARGUMENT  |\n"
"| MP_FIXSTR |  MP_INT  | MP_OBJECT |\n"
"|           |          |           |\n"
"+-----------+==========+===========+\n"
"              MP_ARRAY\n"
"\n"
"    Works on string fields:\n"
"    * Splice      OP = ':'\n"
"      take the string from space[key][field_no] and\n"
"      substitute <offset> bytes from <position> with <argument>"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:319
#: ../doc/1.7/dev_guide/box_protocol.rst:347
msgid ""
"0           2\n"
"+-----------+==========+==========+========+==========+\n"
"|           |          |          |        |          |\n"
"|    ':'    | FIELD_NO | POSITION | OFFSET | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  | MP_INT |  MP_STR  |\n"
"|           |          |          |        |          |\n"
"+-----------+==========+==========+========+==========+\n"
"                         MP_ARRAY"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:331
#: ../doc/1.7/dev_guide/box_protocol.rst:359
msgid ""
"It is an error to specify an argument of a type that differs from the "
"expected type."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:333
#: ../doc/1.7/dev_guide/box_protocol.rst:361
msgid "DELETE: CODE - 0x05 Delete a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:336
#: ../doc/1.7/dev_guide/box_protocol.rst:364
msgid ""
"DELETE BODY:\n"
"\n"
"+==================+==================+==================+\n"
"|                  |                  |                  |\n"
"|   0x10: SPACE_ID |   0x11: INDEX_ID |   0x20: KEY      |\n"
"| MP_INT: MP_INT   | MP_INT: MP_INT   | MP_INT: MP_ARRAY |\n"
"|                  |                  |                  |\n"
"+==================+==================+==================+\n"
"                          MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:349
#: ../doc/1.7/dev_guide/box_protocol.rst:377
msgid ""
"CALL_16: CODE - 0x06 Call a stored function, returning an array of "
"tuples. This is deprecated; CALL (0x0a) is recommended instead."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:352
#: ../doc/1.7/dev_guide/box_protocol.rst:380
msgid ""
"CALL_16 BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:366
#: ../doc/1.7/dev_guide/box_protocol.rst:394
msgid "EVAL: CODE - 0x08 Evaulate Lua expression"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:369
#: ../doc/1.7/dev_guide/box_protocol.rst:397
msgid ""
"EVAL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x27: EXPRESSION    |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:382
#: ../doc/1.7/dev_guide/box_protocol.rst:410
msgid ""
"UPSERT: CODE - 0x09 Update tuple if it would be found elsewhere try to "
"insert tuple. Always use primary index for key."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:385
#: ../doc/1.7/dev_guide/box_protocol.rst:413
msgid ""
"UPSERT BODY:\n"
"\n"
"+==================+==================+==========================+\n"
"|                  |                  |             +~~~~~~~~~~+ |\n"
"|                  |                  |             |          | |\n"
"|   0x10: SPACE_ID |   0x21: TUPLE    |       (OPS) |    OP    | |\n"
"| MP_INT: MP_INT   | MP_INT: MP_ARRAY |       0x28: |          | |\n"
"|                  |                  |     MP_INT: +~~~~~~~~~~+ |\n"
"|                  |                  |               MP_ARRAY   |\n"
"+==================+==================+==========================+\n"
"                                MP_MAP\n"
"\n"
"Operations structure same as for UPDATE operation.\n"
"   0           2\n"
"+-----------+==========+==========+\n"
"|           |          |          |\n"
"|    OP     | FIELD_NO | ARGUMENT |\n"
"| MP_FIXSTR |  MP_INT  |  MP_INT  |\n"
"|           |          |          |\n"
"+-----------+==========+==========+\n"
"              MP_ARRAY\n"
"\n"
"Supported operations:\n"
"\n"
"'+' - add a value to a numeric field. If the filed is not numeric, it's\n"
"      changed to 0 first. If the field does not exist, the operation is\n"
"      skipped. There is no error in case of overflow either, the value\n"
"      simply wraps around in C style. The range of the integer is "
"MsgPack:\n"
"      from -2^63 to 2^64-1\n"
"'-' - same as the previous, but subtract a value\n"
"'=' - assign a field to a value. The field must exist, if it does not "
"exist,\n"
"      the operation is skipped.\n"
"'!' - insert a field. It's only possible to insert a field if this create"
" no\n"
"      nil \"gaps\" between fields. E.g. it's possible to add a field "
"between\n"
"      existing fields or as the last field of the tuple.\n"
"'#' - delete a field. If the field does not exist, the operation is "
"skipped.\n"
"      It's not possible to change with update operations a part of the "
"primary\n"
"      key (this is validated before performing upsert)."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:426
#: ../doc/1.7/dev_guide/box_protocol.rst:454
msgid ""
"CALL: CODE - 0x0a Similar to CALL_16, but -- like EVAL, CALL returns a "
"list of values, unconverted"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:429
#: ../doc/1.7/dev_guide/box_protocol.rst:457
msgid ""
"CALL BODY:\n"
"\n"
"+=======================+==================+\n"
"|                       |                  |\n"
"|   0x22: FUNCTION_NAME |   0x21: TUPLE    |\n"
"| MP_INT: MP_STRING     | MP_INT: MP_ARRAY |\n"
"|                       |                  |\n"
"+=======================+==================+\n"
"                    MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:444
#: ../doc/1.7/dev_guide/box_protocol.rst:472
msgid "Response packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:446
#: ../doc/1.7/dev_guide/box_protocol.rst:474
msgid "We will show whole packets here:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:448
#: ../doc/1.7/dev_guide/box_protocol.rst:476
msgid ""
"OK:    LEN + HEADER + BODY\n"
"\n"
"0      5                                          OPTIONAL\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x00   |   0x01: SYNC   ||   0x30: DATA      |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_OBJECT |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:462
#: ../doc/1.7/dev_guide/box_protocol.rst:490
msgid ""
"Set of tuples in the response :code:`<data>` expects a msgpack array of "
"tuples as value EVAL command returns arbitrary `MP_ARRAY` with arbitrary "
"MsgPack values."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:465
#: ../doc/1.7/dev_guide/box_protocol.rst:493
msgid ""
"ERROR: LEN + HEADER + BODY\n"
"\n"
"0      5\n"
"+------++================+================++===================+\n"
"|      ||                |                ||                   |\n"
"| BODY ||   0x00: 0x8XXX |   0x01: SYNC   ||   0x31: ERROR     |\n"
"|HEADER|| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"| SIZE ||                |                ||                   |\n"
"+------++================+================++===================+\n"
" MP_INT                MP_MAP                      MP_MAP\n"
"\n"
"Where 0xXXX is ERRCODE."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:480
#: ../doc/1.7/dev_guide/box_protocol.rst:508
msgid ""
"An error message is present in the response only if there is an error; "
":code:`<error>` expects as value a msgpack string."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:483
#: ../doc/1.7/dev_guide/box_protocol.rst:511
msgid ""
"Convenience macros which define hexadecimal constants for return codes "
"can be found in `src/box/errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:489
#: ../doc/1.7/dev_guide/box_protocol.rst:517
msgid "Replication packet structure"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:491
#: ../doc/1.7/dev_guide/box_protocol.rst:519
msgid ""
"-- replication keys\n"
"<server_id>     ::= 0x02\n"
"<lsn>           ::= 0x03\n"
"<timestamp>     ::= 0x04\n"
"<server_uuid>   ::= 0x24\n"
"<cluster_uuid>  ::= 0x25\n"
"<vclock>        ::= 0x26"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:501
#: ../doc/1.7/dev_guide/box_protocol.rst:529
msgid ""
"-- replication codes\n"
"<join>      ::= 0x41\n"
"<subscribe> ::= 0x42"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:508
#: ../doc/1.7/dev_guide/box_protocol.rst:536
msgid ""
"JOIN:\n"
"\n"
"In the beginning you must send initial JOIN\n"
"               HEADER                      BODY\n"
"+================+================++===================+\n"
"|                |                ||   SERVER_UUID     |\n"
"|   0x00: 0x41   |   0x01: SYNC   ||   0x24: UUID      |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT: MP_STRING |\n"
"|                |                ||                   |\n"
"+================+================++===================+\n"
"               MP_MAP                     MP_MAP\n"
"\n"
"Then instance, which we connect to, will send last SNAP file by, simply,\n"
"creating a number of INSERTs (with additional LSN and ServerID)\n"
"(don't reply). Then it'll send a vclock's MP_MAP and close a socket.\n"
"\n"
"+================+================++============================+\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||        |                 | |\n"
"|   0x00: 0x00   |   0x01: SYNC   ||   0x26:| SRV_ID: SRV_LSN | |\n"
"| MP_INT: MP_INT | MP_INT: MP_INT || MP_INT:| MP_INT: MP_INT  | |\n"
"|                |                ||        +~~~~~~~~~~~~~~~~~+ |\n"
"|                |                ||               MP_MAP       |\n"
"+================+================++============================+\n"
"               MP_MAP                      MP_MAP\n"
"\n"
"SUBSCRIBE:\n"
"\n"
"Then you must send SUBSCRIBE:\n"
"\n"
"                              HEADER\n"
"+===================+===================+\n"
"|                   |                   |\n"
"|     0x00: 0x41    |    0x01: SYNC     |\n"
"|   MP_INT: MP_INT  |  MP_INT: MP_INT   |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"|    SERVER_UUID    |    CLUSTER_UUID   |\n"
"|   0x24: UUID      |   0x25: UUID      |\n"
"| MP_INT: MP_STRING | MP_INT: MP_STRING |\n"
"|                   |                   |\n"
"+===================+===================+\n"
"                 MP_MAP\n"
"\n"
"      BODY\n"
"+================+\n"
"|                |\n"
"|   0x26: VCLOCK |\n"
"| MP_INT: MP_INT |\n"
"|                |\n"
"+================+\n"
"      MP_MAP\n"
"\n"
"Then you must process every query that'll came through other masters.\n"
"Every request between masters will have Additional LSN and SERVER_ID."
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:568
#: ../doc/1.7/dev_guide/box_protocol.rst:596
msgid "XLOG / SNAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:570
#: ../doc/1.7/dev_guide/box_protocol.rst:598
msgid "XLOG and SNAP files have nearly the same format. The header looks like:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:572
#: ../doc/1.7/dev_guide/box_protocol.rst:600
msgid ""
"<type>\\n                  SNAP\\n or XLOG\\n\n"
"<version>\\n               currently 0.13\\n\n"
"Server: <server_uuid>\\n   where UUID is a 36-byte string\n"
"VClock: <vclock_map>\\n    e.g. {1: 0}\\n\n"
"\\n"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:580
#: ../doc/1.7/dev_guide/box_protocol.rst:608
msgid ""
"After the file header come the data tuples. Tuples begin with a row "
"marker ``0xd5ba0bab`` and the last tuple may be followed by an EOF marker"
" ``0xd510aded``. Thus, between the file header and the EOF marker, there "
"may be data tuples that have this form:"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:587
#: ../doc/1.7/dev_guide/box_protocol.rst:615
msgid ""
"0            3 4                                         17\n"
"+-------------+========+============+===========+=========+\n"
"|             |        |            |           |         |\n"
"| 0xd5ba0bab  | LENGTH | CRC32 PREV | CRC32 CUR | PADDING |\n"
"|             |        |            |           |         |\n"
"+-------------+========+============+===========+=========+\n"
"  MP_FIXEXT2    MP_INT     MP_INT       MP_INT      ---\n"
"\n"
"+============+ +===================================+\n"
"|            | |                                   |\n"
"|   HEADER   | |                BODY               |\n"
"|            | |                                   |\n"
"+============+ +===================================+\n"
"    MP_MAP                     MP_MAP"
msgstr ""

#: ../doc/1.7/dev_guide/box_protocol.rst:604
#: ../doc/1.7/dev_guide/box_protocol.rst:632
msgid "See the example in the following section."
msgstr ""

#: ../doc/1.7/dev_guide/build_contribute_index.rst:31
msgid "Build and contribute"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:33
msgid "Building documentation"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:35
msgid ""
"Tarantool documentation is built using a simplified markup system named "
"``Sphinx`` (see http://sphinx-doc.org). You can build a local version of "
"this documentation and you can contribute to Tarantool's version."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:39
msgid "You need to install these packages:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:41
msgid "``git`` (a program for downloading source repositories)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:42
msgid "``CMake`` version 2.8 or later (a program for managing the build process)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:43
msgid ""
"``Python`` version greater than 2.6 -- preferably 2.7 -- and less than "
"3.0 (Sphinx is a Python-based tool)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:45
msgid ""
"``LaTeX`` (a system for document preparation, the installable package "
"name usually begins with the word texlive or tetex, on Ubuntu the name is"
" texlive-latex-base)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:49
msgid "You need to install these Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:51
#: ../doc/1.7/dev_guide/building_from_source.rst:84
msgid "`pip <https://pypi.python.org/pypi/pip>`_, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:52
msgid "`Sphinx <https://pypi.python.org/pypi/Sphinx>`_ version 1.4.4 or later"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:53
msgid "`sphinx-intl <https://pypi.python.org/pypi/sphinx-intl>`_ version 0.9.9"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:54
msgid "`lupa <https://pypi.python.org/pypi/lupa>`_ -- any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:56
msgid ""
"See more details about installation in the :ref:`build-from-source "
"<building_from_source>` section of this documentation."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:59
msgid ""
"Use ``git`` to download the latest source code of this documentation from"
" the GitHub repository ``tarantool/doc``, branch 1.7. For example, to "
"download to a local directory named ``~/tarantool-doc``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:63
msgid "git clone https://github.com/tarantool/doc.git ~/tarantool-doc"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:67
msgid "Use ``CMake`` to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:69
msgid ""
"cd ~/tarantool-doc\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # initiate"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:76
msgid "Build a local version of the documentation."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:78
msgid ""
"Run the ``make`` command with an appropriate option to specify which "
"documentation version to build."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:81
msgid ""
"cd ~/tarantool-doc\n"
"make sphinx-html           # multi-page English version\n"
"make sphinx-singlehtml     # one-page English version\n"
"make sphinx-html-ru        # multi-page Russian version\n"
"make sphinx-singlehtml-ru  # one-page Russian version\n"
"make all                   # all versions plus the entire web-site"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:90
msgid "Documentation will be created in subdirectories of ``/output``:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:92
msgid "``/output/en`` (files of the English version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:93
msgid "``/output/ru`` (files of the Russian version)"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:95
msgid ""
"The entry point for each version is the ``index.html`` file in the "
"appropriate directory."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:98
msgid "Set up a web-server."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:100
msgid ""
"Run the following command to set up a web-server. The example below is "
"for Ubuntu, but the procedure is similar for other supported operating "
"systems. Make sure to run it from the documentation output folder, "
"``output/en`` or ``output/ru``, as in the example below:"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:105
msgid ""
"cd ~/tarantool-doc/output/en\n"
"python -m SimpleHTTPServer 8000"
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:110
msgid ""
"Open your browser and enter ``127.0.0.1:8000/doc/1.7`` into the address "
"box. If your local documentation build is valid, the manual will appear "
"in the browser."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:113
msgid ""
"To contribute to documentation, use the ``.rst`` format for drafting and "
"submit your updates as a `pull request "
"<https://help.github.com/articles/creating-a-pull-request/>`_ via GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:118
msgid ""
"To comply with the writing and formatting style, use the :ref:`guidelines"
" <documentation_guidelines>` provided in the documentation, common sense "
"and existing documents."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:124
msgid ""
"If you suggest creating a new documentation section (a whole new page), "
"it has to be saved to the relevant section at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_documentation.rst:127
msgid ""
"If you want to contribute to localizing this documentation (for example "
"into Russian), add your translation strings to ``.po`` files stored in "
"the corresponding locale directory (for example "
"``/locale/ru/LC_MESSAGES/`` for Russian). See more about localizing with "
"Sphinx at http://www.sphinx-doc.org/en/stable/intl.html"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:33
msgid "Building from source"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:35
msgid ""
"For downloading Tarantool source and building it, the platforms can "
"differ and the preferences can differ. But the steps are always the same."
" Here in the manual we'll explain what the steps are, and after that you "
"can look at some example scripts on the Internet."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:40
msgid "Get tools and libraries that will be necessary for building and testing."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:43
msgid "The absolutely necessary ones are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:45
msgid ""
"A program for downloading source repositories. |br| For all platforms, "
"this is ``git``. It allows to download the latest complete set of source "
"files from the Tarantool repository at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:49
msgid ""
"A C/C++ compiler. |br| Ordinarily, this is ``gcc`` and ``g++`` version "
"4.6 or later. On Mac OS X, this is ``Clang`` version 3.2 or later."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:52
msgid ""
"A program for managing the build process. |br| For all platforms, this is"
" ``CMake``. The CMake version should be 2.8 or later."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:55
msgid ""
"Command-line interpreter for Python-based code (namely, for Tarantool "
"test suite). |br| For all platforms, this is ``python``. The Python "
"version should be greater than 2.6 -- preferably 2.7 -- and less than "
"3.0."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:59
msgid ""
"Here are names of tools and libraries which may have to be installed in "
"advance, using ``sudo apt-get`` (for Ubuntu), ``sudo yum install`` (for "
"CentOS), or the equivalent on other platforms. Different platforms may "
"use slightly different names. Ignore the ones marked `optional, only in "
"Mac OS scripts` unless the platform is Mac OS."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:65
msgid "**gcc** and **g++**, or **clang** (see above)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:66
msgid "**git** (see above)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:67
msgid "**cmake** (see above)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:68
msgid "**python** (see above; for test suite)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:69
msgid ""
"**libreadline-dev** or **libreadline6-dev** or **readline-devel** (for "
"interactive mode)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:71
msgid "**libssl-dev** (for :ref:`digest <digest>` module)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:72
msgid ""
"**libcurl4-gnutls-dev** or **libcurl4-openssl-dev** or **libcurl4-nss-"
"dev** (for :ref:`http <http-module>` module)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:74
msgid "**autoconf** (optional, only in Mac OS scripts)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:75
msgid "**zlib1g** or **zlib** (optional, only in Mac OS scripts)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:77
msgid "Set up Python modules for running the test suite."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:79
msgid ""
"This step is optional. Python modules are not necessary for building "
"Tarantool itself, unless you intend to use the \"Run the test suite\" "
"option in step 7."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:82
msgid "You need the following Python modules:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:85
msgid "`dev <https://pypi.python.org/pypi/dev>`_, any version"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:86
msgid "`pyYAML <https://pypi.python.org/pypi/PyYAML>`_ version 3.10"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:87
msgid "`argparse <https://pypi.python.org/pypi/argparse>`_ version 1.1"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:88
msgid ""
"`msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_ version "
"0.4.6"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:89
msgid "`gevent <https://pypi.python.org/pypi/gevent>`_ version 1.1b5"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:90
msgid "`six <https://pypi.python.org/pypi/six>`_ version 1.8.0"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:92
msgid "On Ubuntu, you can get the modules from the repository:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:94
msgid "sudo apt-get install python-pip python-dev python-yaml <...>"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:98
msgid "On CentOS 6, you can likewise get the modules from the repository:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:100
msgid "sudo yum install python26 python26-PyYAML <...>"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:104
msgid ""
"If some modules are not available on a repository, it is best to set up "
"the modules by getting a tarball and doing the setup with ``python "
"setup.py``, thus:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:108
msgid ""
"# On some machines, this initial command may be necessary:\n"
"# wget https://bootstrap.pypa.io/ez_setup.py -O - | sudo python\n"
"\n"
"# Python module for parsing YAML (pyYAML), for test suite:\n"
"# (If wget fails, check at http://pyyaml.org/wiki/PyYAML\n"
"# what the current version is.)\n"
"cd ~\n"
"wget http://pyyaml.org/download/pyyaml/PyYAML-3.10.tar.gz\n"
"tar -xzf PyYAML-3.10.tar.gz\n"
"cd PyYAML-3.10\n"
"sudo python setup.py install"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:122
msgid ""
"Finally, use Python :code:`pip` to bring in Python packages that may not "
"be up-to-date in the distro repositories. (On CentOS 7, it will be "
"necessary to install ``pip`` first, with :code:`sudo yum install epel-"
"release` followed by :code:`sudo yum install python-pip`.)"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:128
msgid "pip install tarantool\\>0.4 --user"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:132
msgid ""
"Use ``git`` to download the latest Tarantool source code from the GitHub "
"repository ``tarantool/tarantool``, branch 1.7. For example, to a local "
"directory named `~/tarantool`:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:136
msgid "git clone https://github.com/tarantool/tarantool.git ~/tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:140
msgid "Use ``git`` again so that third-party contributions will be seen as well."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:142
msgid "The build depends on the following external libraries:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:144
msgid "Readline development files (``libreadline-dev/readline-devel`` package)."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:145
msgid "OpenSSL development files (``libssl-dev/openssl-devel`` package)."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:146
msgid "``libyaml`` (``libyaml-dev/libyaml-devel`` package)."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:147
msgid "``liblz4`` (``liblz4-dev/lz4-devel`` package)."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:148
msgid ""
"GNU ``bfd`` which is the part of GNU ``binutils`` (``binutils-dev"
"/binutils-devel`` package)."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:151
msgid "This step is only necessary once, the first time you do a download."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:153
msgid ""
"cd ~/tarantool\n"
"git submodule init\n"
"git submodule update --recursive\n"
"cd ../"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:160
msgid ""
"On rare occasions, the submodules will need to be updated again with the "
"command:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:163
msgid "git submodule update --init --recursive"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:167
msgid ""
"Note: There is an alternative -- to say ``git clone --recursive`` earlier"
" in step 3, -- but we prefer the method above because it works with older"
" versions of ``git``."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:171
msgid "Use CMake to initiate the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:173
msgid ""
"cd ~/tarantool\n"
"make clean         # unnecessary, added for good luck\n"
"rm CMakeCache.txt  # unnecessary, added for good luck\n"
"cmake .            # start initiating with build type=Debug"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:180
msgid ""
"On some platforms, it may be necessary to specify the C and C++ versions,"
" for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:183
msgid "CC=gcc-4.8 CXX=g++-4.8 cmake ."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:187
msgid ""
"The CMake option for specifying build type is "
":samp:`-DCMAKE_BUILD_TYPE={type}`, where :samp:`{type}` can be:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:190
msgid "``Debug`` -- used by project maintainers"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:191
msgid "``Release`` -- used only if the highest performance is required"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:192
msgid ""
"``RelWithDebInfo`` -- used for production, also provides debugging "
"capabilities"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:194
msgid ""
"The CMake option for hinting that the result will be distributed is "
":code:`-DENABLE_DIST=ON`. If this option is on, then later ``make "
"install`` will install tarantoolctl files in addition to tarantool files."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:198
msgid "Use ``make`` to complete the build."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:200
msgid "make"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:204
msgid "This creates the 'tarantool' executable in the directory `src/`"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:206
msgid ""
"Next, it's highly recommended to say ``make install`` to install "
"Tarantool to the `/usr/local` directory and keep your system clean. "
"However, it is possible to run the Tarantool executable without "
"installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:210
msgid "Run the test suite."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:212
msgid ""
"This step is optional. Tarantool's developers always run the test suite "
"before they publish new versions. You should run the test suite too, if "
"you make any changes in the code. Assuming you downloaded to "
"``~/tarantool``, the principal steps are:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:217
msgid ""
"# make a subdirectory named `bin`\n"
"mkdir ~/tarantool/bin\n"
"# link python to bin (this may require superuser privilege)\n"
"ln /usr/bin/python ~/tarantool/bin/python\n"
"# get on the test subdirectory\n"
"cd ~/tarantool/test\n"
"# run tests using python\n"
"PATH=~/tarantool/bin:$PATH ./test-run.py"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:228
msgid "The output should contain reassuring reports, for example:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:230
msgid ""
"======================================================================\n"
"TEST                                            RESULT\n"
"------------------------------------------------------------\n"
"box/bad_trigger.test.py                         [ pass ]\n"
"box/call.test.py                                [ pass ]\n"
"box/iproto.test.py                              [ pass ]\n"
"box/xlog.test.py                                [ pass ]\n"
"box/admin.test.lua                              [ pass ]\n"
"box/auth_access.test.lua                        [ pass ]\n"
"... etc."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:243
msgid "To prevent later confusion, clean up what's in the `bin` subdirectory:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:245
msgid ""
"rm ~/tarantool/bin/python\n"
"rmdir ~/tarantool/bin"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:250
msgid "Make an rpm package."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:252
msgid ""
"This step is optional. It's only for people who want to redistribute "
"Tarantool. Package maintainers who want to build with ``rpmbuild`` should"
" consult the ``rpm-build`` instructions for the appropriate platform."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:256
msgid "Verify your Tarantool installation."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:258
msgid "tarantool $ ./src/tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:262
msgid "This will start Tarantool in the interactive mode."
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:264
msgid ""
"For your added convenience, we provide OS-specific README files with "
"example scripts at GitHub:"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:267
msgid ""
"`README.FreeBSD "
"<https://github.com/tarantool/tarantool/blob/1.7/README.FreeBSD>`_ for "
"FreeBSD 10.1"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:269
msgid ""
"`README.MacOSX "
"<https://github.com/tarantool/tarantool/blob/1.7/README.MacOSX>`_ for Mac"
" OS X `El Capitan`"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:271
msgid ""
"`README.md <https://github.com/tarantool/tarantool/blob/1.7/README.md>`_ "
"for generic GNU/Linux"
msgstr ""

#: ../doc/1.7/dev_guide/building_from_source.rst:273
msgid ""
"These example scripts assume that the intent is to download from the 1.7 "
"branch, build the server and run tests after build."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:31
msgid "C Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:33
msgid ""
"The project's coding style is based on a version of the Linux kernel "
"coding style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:35
msgid ""
"The latest version of the Linux style can be found at: "
"http://www.kernel.org/doc/Documentation/CodingStyle"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:38
msgid ""
"Since it is open for changes, the version of style that we follow, one "
"from 2007-July-13, will be also copied later in this document."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:41
msgid ""
"There are a few additional guidelines, either unique to Tarantool or "
"deviating from the Kernel guidelines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:44
msgid ""
"Chapters 10 \"Kconfig configuration files\", 11 \"Data structures\", 13 "
"\"Printing kernel messages\", 14 \"Allocating memory\" and 17 \"Don't re-"
"invent the kernel macros\" do not apply, since they are specific to Linux"
" kernel programming environment."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:49
msgid "The rest of Linux Kernel Coding Style is amended as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:53
msgid "General guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:55
msgid ""
"We use Git for revision control. The latest development is happening in "
"the 'master' branch. Our git repository is hosted on github, and can be "
"checked out with git clone git://github.com/tarantool/tarantool.git # "
"anonymous read-only access"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:59
msgid ""
"If you have any questions about Tarantool internals, please post them on "
"the developer discussion list, "
"https://groups.google.com/forum/#!forum/tarantool. However, please be "
"warned: Launchpad silently deletes posts from non-subscribed members, "
"thus please be sure to have subscribed to the list prior to posting. "
"Additionally, some engineers are always present on #tarantool channel on "
"irc.freenode.net."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:67
msgid "Commenting style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:69
msgid ""
"Use Doxygen comment format, Javadoc flavor, i.e. `@tag` rather than "
"`\\tag`. The main tags in use are @param, @retval, @return, @see, @note "
"and @todo."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:72
msgid ""
"Every function, except perhaps a very short and obvious one, should have "
"a comment. A sample function comment may look like below:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:75
msgid ""
"/** Write all data to a descriptor.\n"
" *\n"
" * This function is equivalent to 'write', except it would ensure\n"
" * that all data is written to the file unless a non-ignorable\n"
" * error occurs.\n"
" *\n"
" * @retval 0  Success\n"
" *\n"
" * @reval  1  An error occurred (not EINTR)\n"
" * /\n"
"static int\n"
"write_all(int fd, void \\*data, size_t len);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:90
msgid ""
"Public structures and important structure members should be commented as "
"well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:94
msgid "Header files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:96
msgid ""
"Use header guards. Put the header guard in the first line in the header, "
"before the copyright or declarations. Use all-uppercase name for the "
"header guard. Derive the header guard name from the file name, and append"
" _INCLUDED to get a macro name. For example, core/log_io.h -> "
"CORE_LOG_IO_H_INCLUDED. In ``.c`` (implementation) file, include the "
"respective declaration header before all other headers, to ensure that "
"the header is self- sufficient. Header \"header.h\" is self-sufficient if"
" the following compiles without errors:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:104
msgid "#include \"header.h\""
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:110
msgid "Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:112
msgid ""
"Prefer the supplied slab (salloc) and pool (palloc) allocators to "
"malloc()/free() for any performance-intensive or large  memory "
"allocations. Repetitive use of malloc()/free() can lead to memory "
"fragmentation and should therefore be avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:116
msgid ""
"Always free all allocated memory, even allocated  at start-up. We aim at "
"being valgrind leak-check clean, and in most cases it's just as easy to "
"free() the allocated memory as it is to write a valgrind suppression. "
"Freeing all allocated memory is also dynamic-load friendly: assuming a "
"plug-in can be dynamically loaded and unloaded multiple times, reload "
"should not lead to a memory leak."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:124
msgid "Other"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:126
msgid ""
"Select GNU C99 extensions are acceptable. It's OK to mix declarations and"
" statements, use true and false."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:129
msgid ""
"The not-so-current list of all GCC C extensions can be found at: "
"http://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/C-Extensions.html"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:134
msgid "Linux kernel coding style"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:136
msgid ""
"This is a short document describing the preferred coding style for the "
"linux kernel.  Coding style is very personal, and I won't _force_ my "
"views on anybody, but this is what goes for anything that I have to be "
"able to maintain, and I'd prefer it for most other things too.  Please at"
" least consider the points made here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:142
msgid ""
"First off, I'd suggest printing out a copy of the GNU coding standards, "
"and NOT read it.  Burn them, it's a great symbolic gesture."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:145
msgid "Anyway, here goes:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:149
msgid "Chapter 1: Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:151
msgid ""
"Tabs are 8 characters, and thus indentations are also 8 characters. There"
" are heretic movements that try to make indentations 4 (or even 2!) "
"characters deep, and that is akin to trying to define the value of PI to "
"be 3."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:156
msgid ""
"Rationale: The whole idea behind indentation is to clearly define where a"
" block of control starts and ends.  Especially when you've been looking "
"at your screen for 20 straight hours, you'll find it a lot easier to see "
"how the indentation works if you have large indentations."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:161
msgid ""
"Now, some people will claim that having 8-character indentations makes "
"the code move too far to the right, and makes it hard to read on a "
"80-character terminal screen.  The answer to that is that if you need "
"more than 3 levels of indentation, you're screwed anyway, and should fix "
"your program."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:167
msgid ""
"In short, 8-char indents make things easier to read, and have the added "
"benefit of warning you when you're nesting your functions too deep. Heed "
"that warning."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:171
msgid ""
"The preferred way to ease multiple indentation levels in a switch "
"statement is to align the \"switch\" and its subordinate \"case\" labels "
"in the same column instead of \"double-indenting\" the \"case\" labels. "
"e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:175
msgid ""
"switch (suffix) {\n"
"case 'G':\n"
"case 'g':\n"
"    mem <<= 30;\n"
"    break;\n"
"case 'M':\n"
"case 'm':\n"
"    mem <<= 20;\n"
"    break;\n"
"case 'K':\n"
"case 'k':\n"
"    mem <<= 10;\n"
"    /* fall through */\n"
"default:\n"
"    break;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:195
msgid ""
"Don't put multiple statements on a single line unless you have something "
"to hide:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:198
msgid ""
"if (condition) do_this;\n"
"  do_something_everytime;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:203
msgid ""
"Don't put multiple assignments on a single line either. Kernel coding "
"style is super simple. Avoid tricky expressions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:206
msgid ""
"Outside of comments, documentation and except in Kconfig, spaces are "
"never used for indentation, and the above example is deliberately broken."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:209
msgid "Get a decent editor and don't leave whitespace at the end of lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:214
msgid "Chapter 2: Breaking long lines and strings"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:216
msgid ""
"Coding style is all about readability and maintainability using commonly "
"available tools."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:219
msgid ""
"The limit on the length of lines is 80 columns and this is a strongly "
"preferred limit."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:222
msgid ""
"Statements longer than 80 columns will be broken into sensible chunks. "
"Descendants are always substantially shorter than the parent and are "
"placed substantially to the right. The same applies to function headers "
"with a long argument list. Long strings are as well broken into shorter "
"strings. The only exception to this is where exceeding 80 columns "
"significantly increases readability and does not hide information."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:229
#, python-format
msgid ""
"void fun(int a, int b, int c)\n"
"{\n"
"    if (condition)\n"
"        printk(KERN_WARNING \"Warning this is a long printk with \"\n"
"                        \"3 parameters a: %u b: %u \"\n"
"                        \"c: %u \\n\", a, b, c);\n"
"    else\n"
"        next_statement;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:243
msgid "Chapter 3: Placing Braces and Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:245
msgid ""
"The other issue that always comes up in C styling is the placement of "
"braces.  Unlike the indent size, there are few technical reasons to "
"choose one placement strategy over the other, but the preferred way, as "
"shown to us by the prophets Kernighan and Ritchie, is to put the opening "
"brace last on the line, and put the closing brace first, thusly:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:251
msgid ""
"if (x is true) {\n"
"    we do y\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:257
msgid ""
"This applies to all non-function statement blocks (if, switch, for, "
"while, do). e.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:260
msgid ""
"switch (action) {\n"
"case KOBJ_ADD:\n"
"    return \"add\";\n"
"case KOBJ_REMOVE:\n"
"    return \"remove\";\n"
"case KOBJ_CHANGE:\n"
"    return \"change\";\n"
"default:\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:273
msgid ""
"However, there is one special case, namely functions: they have the "
"opening brace at the beginning of the next line, thus:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:276
msgid ""
"int function(int x)\n"
"{\n"
"    body of function;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:283
msgid ""
"Heretic people all over the world have claimed that this inconsistency is"
" ...  well ...  inconsistent, but all right-thinking people know that (a)"
" K&R are _right_ and (b) K&R are right.  Besides, functions are special "
"anyway (you can't nest them in C)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:288
msgid ""
"Note that the closing brace is empty on a line of its own, _except_ in "
"the cases where it is followed by a continuation of the same statement, "
"ie a \"while\" in a do-statement or an \"else\" in an if-statement, like "
"this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:293
msgid ""
"do {\n"
"    body of do-loop;\n"
"} while (condition);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:299
msgid "and"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:301
msgid ""
"if (x == y) {\n"
"    ..\n"
"} else if (x > y) {\n"
"    ...\n"
"} else {\n"
"    ....\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:311
msgid "Rationale: K&R."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:313
msgid ""
"Also, note that this brace-placement also minimizes the number of empty "
"(or almost empty) lines, without any loss of readability.  Thus, as the "
"supply of new-lines on your screen is not a renewable resource (think "
"25-line terminal screens here), you have more empty lines to put comments"
" on."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:319
msgid "Do not unnecessarily use braces where a single statement will do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:321
msgid ""
"if (condition)\n"
"    action();"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:326
msgid ""
"This does not apply if one branch of a conditional statement is a single "
"statement. Use braces in both branches."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:329
msgid ""
"if (condition) {\n"
"    do_this();\n"
"    do_that();\n"
"} else {\n"
"    otherwise();\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:340
msgid "Chapter 3.1:  Spaces"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:342
msgid ""
"Linux kernel style for use of spaces depends (mostly) on function-versus-"
"keyword usage.  Use a space after (most) keywords.  The notable "
"exceptions are sizeof, typeof, alignof, and __attribute__, which look "
"somewhat like functions (and are usually used with parentheses in Linux, "
"although they are not required in the language, as in: \"sizeof info\" "
"after \"struct fileinfo info;\" is declared)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:349
msgid ""
"So use a space after these keywords: if, switch, case, for, do, while but"
" not with sizeof, typeof, alignof, or __attribute__.  E.g.,"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:352
msgid "s = sizeof(struct file);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:356
msgid ""
"Do not add spaces around (inside) parenthesized expressions. This example"
" is **bad**:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:359
msgid "s = sizeof( struct file );"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:363
msgid ""
"When declaring pointer data or a function that returns a pointer type, "
"the preferred use of '*' is adjacent to the data name or function name "
"and not adjacent to the type name.  Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:367
msgid ""
"char *linux_banner;\n"
"unsigned long long memparse(char *ptr, char **retptr);\n"
"char *match_strdup(substring_t *s);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:373
msgid ""
"Use one space around (on each side of) most binary and ternary operators,"
" such as any of these:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:376
msgid "=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:378
msgid "but no space after unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:380
msgid "&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:382
msgid "no space before the postfix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:384
#: ../doc/1.7/dev_guide/c_style_guide.rst:388
msgid "++  --"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:386
msgid "no space after the prefix increment & decrement unary operators:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:390
msgid "and no space around the '.' and \"->\" structure member operators."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:392
msgid ""
"Do not leave trailing whitespace at the ends of lines.  Some editors with"
" \"smart\" indentation will insert whitespace at the beginning of new "
"lines as appropriate, so you can start typing the next line of code right"
" away. However, some such editors do not remove the whitespace if you end"
" up not putting a line of code there, such as if you leave a blank line."
"  As a result, you end up with lines containing trailing whitespace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:399
msgid ""
"Git will warn you about patches that introduce trailing whitespace, and "
"can optionally strip the trailing whitespace for you; however, if "
"applying a series of patches, this may make later patches in the series "
"fail by changing their context lines."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:407
msgid "Chapter 4: Naming"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:409
msgid ""
"C is a Spartan language, and so should your naming be.  Unlike Modula-2 "
"and Pascal programmers, C programmers do not use cute names like "
"ThisVariableIsATemporaryCounter.  A C programmer would call that variable"
" \"tmp\", which is much easier to write, and not the least more difficult"
" to understand."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:415
msgid ""
"HOWEVER, while mixed-case names are frowned upon, descriptive names for "
"global variables are a must.  To call a global function \"foo\" is a "
"shooting offense."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:419
msgid ""
"GLOBAL variables (to be used only if you _really_ need them) need to have"
" descriptive names, as do global functions.  If you have a function that "
"counts the number of active users, you should call that "
"\"count_active_users()\" or similar, you should _not_ call it "
"\"cntusr()\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:424
msgid ""
"Encoding the type of a function into the name (so-called Hungarian "
"notation) is brain damaged - the compiler knows the types anyway and can "
"check those, and it only confuses the programmer.  No wonder MicroSoft "
"makes buggy programs."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:429
msgid ""
"LOCAL variable names should be short, and to the point.  If you have some"
" random integer loop counter, it should probably be called \"i\". Calling"
" it \"loop_counter\" is non-productive, if there is no chance of it being"
" mis-understood.  Similarly, \"tmp\" can be just about any type of "
"variable that is used to hold a temporary value."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:435
msgid ""
"If you are afraid to mix up your local variable names, you have another "
"problem, which is called the function-growth-hormone-imbalance syndrome. "
"See chapter 6 (Functions)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:442
msgid "Chapter 5: Typedefs"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:444
msgid "Please don't use things like \"vps_t\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:446
msgid ""
"It's a _mistake_ to use typedef for structures and pointers. When you see"
" a"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:448
msgid "vps_t a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:452
msgid "in the source, what does it mean?"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:454
msgid "In contrast, if it says"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:456
msgid "struct virtual_container *a;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:460
msgid "you can actually tell what \"a\" is."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:462
msgid ""
"Lots of people think that typedefs \"help readability\". Not so. They are"
" useful only for:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:465
msgid ""
"totally opaque objects (where the typedef is actively used to _hide_ what"
" the object is)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:468
msgid ""
"Example: \"pte_t\" etc. opaque objects that you can only access using the"
" proper accessor functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:471
msgid ""
"NOTE! Opaqueness and \"accessor functions\" are not good in themselves. "
"The reason we have them for things like pte_t etc. is that there really "
"is absolutely _zero_ portably accessible information there."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:475
msgid ""
"Clear integer types, where the abstraction _helps_ avoid confusion "
"whether it is \"int\" or \"long\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:478
msgid ""
"u8/u16/u32 are perfectly fine typedefs, although they fit into category "
"(d) better than here."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:481
msgid ""
"NOTE! Again - there needs to be a _reason_ for this. If something is "
"\"unsigned long\", then there's no reason to do"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:484
msgid "typedef unsigned long myflags_t;"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:488
msgid ""
"but if there is a clear reason for why it under certain circumstances "
"might be an \"unsigned int\" and under other configurations might be "
"\"unsigned long\", then by all means go ahead and use a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:492
msgid "when you use sparse to literally create a _new_ type for type-checking."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:495
msgid ""
"New types which are identical to standard C99 types, in certain "
"exceptional circumstances."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:498
msgid ""
"Although it would only take a short amount of time for the eyes and brain"
" to become accustomed to the standard types like 'uint32_t', some people "
"object to their use anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:502
msgid ""
"Therefore, the Linux-specific 'u8/u16/u32/u64' types and their signed "
"equivalents which are identical to standard types are permitted -- "
"although they are not mandatory in new code of your own."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:507
msgid ""
"When editing existing code which already uses one or the other set of "
"types, you should conform to the existing choices in that code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:510
msgid "Types safe for use in userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:512
msgid ""
"In certain structures which are visible to userspace, we cannot require "
"C99 types and cannot use the 'u32' form above. Thus, we use __u32 and "
"similar types in all structures which are shared with userspace."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:517
msgid ""
"Maybe there are other cases too, but the rule should basically be to "
"NEVER EVER use a typedef unless you can clearly match one of those rules."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:520
msgid ""
"In general, a pointer, or a struct that has elements that can reasonably "
"be directly accessed should **never** be a typedef."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:526
msgid "Chapter 6: Functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:528
msgid ""
"Functions should be short and sweet, and do just one thing.  They should "
"fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24, "
"as we all know), and do one thing and do that well."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:532
msgid ""
"The maximum length of a function is inversely proportional to the "
"complexity and indentation level of that function.  So, if you have a "
"conceptually simple function that is just one long (but simple) case-"
"statement, where you have to do lots of small things for a lot of "
"different cases, it's OK to have a longer function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:538
msgid ""
"However, if you have a complex function, and you suspect that a less-"
"than-gifted first-year high-school student might not even understand what"
" the function is all about, you should adhere to the maximum limits all "
"the more closely.  Use helper functions with descriptive names (you can "
"ask the compiler to in-line them if you think it's performance-critical, "
"and it will probably do a better job of it than you would have done)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:546
msgid ""
"Another measure of the function is the number of local variables.  They "
"shouldn't exceed 5-10, or you're doing something wrong.  Re-think the "
"function, and split it into smaller pieces.  A human brain can generally "
"easily keep track of about 7 different things, anything more and it gets "
"confu/sed.  You know you're brilliant, but maybe you'd like to understand"
" what you did 2 weeks from now."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:553
msgid ""
"In source files, separate functions with one blank line.  If the function"
" is exported, the EXPORT* macro for it should follow immediately after "
"the closing function brace line.  E.g.:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:557
msgid ""
"int system_is_up(void)\n"
"{\n"
"    return system_state == SYSTEM_RUNNING;\n"
"}\n"
"EXPORT_SYMBOL(system_is_up);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:565
msgid ""
"In function prototypes, include parameter names with their data types. "
"Although this is not required by the C language, it is preferred in Linux"
" because it is a simple way to add valuable information for the reader."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:571
msgid "Chapter 7: Centralized exiting of functions"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:573
msgid ""
"Albeit deprecated by some people, the equivalent of the goto statement is"
" used frequently by compilers in form of the unconditional jump "
"instruction."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:576
msgid ""
"The goto statement comes in handy when a function exits from multiple "
"locations and some common work such as cleanup has to be done."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:579
msgid "The rationale is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:581
msgid "unconditional statements are easier to understand and follow"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:582
msgid "nesting is reduced"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:583
msgid ""
"errors by not updating individual exit points when making modifications "
"are prevented"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:585
msgid "saves the compiler work to optimize redundant code away ;)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:587
msgid ""
"int fun(int a)\n"
"{\n"
"    int result = 0;\n"
"    char *buffer = kmalloc(SIZE);\n"
"\n"
"    if (buffer == NULL)\n"
"        return -ENOMEM;\n"
"\n"
"    if (condition1) {\n"
"        while (loop1) {\n"
"            ...\n"
"        }\n"
"        result = 1;\n"
"        goto out;\n"
"    }\n"
"    ...\n"
"out:\n"
"    kfree(buffer);\n"
"    return result;\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:612
msgid "Chapter 8: Commenting"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:614
msgid ""
"Comments are good, but there is also a danger of over-commenting. NEVER "
"try to explain HOW your code works in a comment: it's much better to "
"write the code so that the _working_ is obvious, and it's a waste of time"
" to explain badly written code. с Generally, you want your comments to "
"tell WHAT your code does, not HOW. Also, try to avoid putting comments "
"inside a function body: if the function is so complex that you need to "
"separately comment parts of it, you should probably go back to chapter 6 "
"for a while.  You can make small comments to note or warn about something"
" particularly clever (or ugly), but try to avoid excess.  Instead, put "
"the comments at the head of the function, telling people what it does, "
"and possibly WHY it does it."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:628
msgid ""
"When commenting the kernel API functions, please use the kernel-doc "
"format. See the files Documentation/kernel-doc-nano-HOWTO.txt and scripts"
"/kernel-doc for details."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:632
msgid ""
"Linux style for comments is the C89 ``\"/\\* ... \\*/\"`` style. Don't "
"use C99-style ``\"// ...\"`` comments."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:635
msgid "The preferred style for long (multi-line) comments is:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:637
msgid ""
"/*\n"
" * This is the preferred style for multi-line\n"
" * comments in the Linux kernel source code.\n"
" * Please use it consistently.\n"
" *\n"
" * Description:  A column of asterisks on the left side,\n"
" * with beginning and ending almost-blank lines.\n"
" */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:648
msgid ""
"It's also important to comment data, whether they are basic types or "
"derived types.  To this end, use just one data declaration per line (no "
"commas for multiple data declarations).  This leaves you room for a small"
" comment on each item, explaining its use."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:655
msgid "Chapter 9: You've made a mess of it"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:657
msgid ""
"That's OK, we all do.  You've probably been told by your long-time Unix "
"user helper that \"GNU emacs\" automatically formats the C sources for "
"you, and you've noticed that yes, it does do that, but the defaults it "
"uses are less than desirable (in fact, they are worse than random typing "
"- an infinite number of monkeys typing into GNU emacs would never make a "
"good program)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:664
msgid ""
"So, you can either get rid of GNU emacs, or change it to use saner "
"values.  To do the latter, you can stick the following in your .emacs "
"file:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:667
msgid ""
"(defun c-lineup-arglist-tabs-only (ignored)\n"
"\"Line up argument lists by tabs, not spaces\"\n"
"(let* ((anchor (c-langelem-pos c-syntactic-element))\n"
"    (column (c-langelem-2nd-pos c-syntactic-element))\n"
"    (offset (- (1+ column) anchor))\n"
"    (steps (floor offset c-basic-offset)))\n"
"    (* (max steps 1)\n"
"    c-basic-offset)))\n"
"\n"
"(add-hook 'c-mode-common-hook\n"
"        (lambda ()\n"
"            ;; Add kernel style\n"
"            (c-add-style\n"
"            \"linux-tabs-only\"\n"
"            '(\"linux\" (c-offsets-alist\n"
"                        (arglist-cont-nonempty\n"
"                        c-lineup-gcc-asm-reg\n"
"                        c-lineup-arglist-tabs-only))))))\n"
"\n"
"(add-hook 'c-mode-hook\n"
"        (lambda ()\n"
"            (let ((filename (buffer-file-name)))\n"
"            ;; Enable kernel mode for the appropriate files\n"
"            (when (and filename\n"
"                        (string-match (expand-file-name \"~/src/linux-"
"trees\")\n"
"                                    filename))\n"
"                (setq indent-tabs-mode t)\n"
"                (c-set-style \"linux-tabs-only\")))))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:698
msgid ""
"This will make emacs go better with the kernel coding style for C files "
"below ~/src/linux-trees."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:701
msgid ""
"But even if you fail in getting emacs to do sane formatting, not "
"everything is lost: use \"indent\"."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:704
msgid ""
"Now, again, GNU indent has the same brain-dead settings that GNU emacs "
"has, which is why you need to give it a few command line options. "
"However, that's not too bad, because even the makers of GNU indent "
"recognize the authority of K&R (the GNU people aren't evil, they are just"
" severely misguided in this matter), so you just give indent the options "
"\"-kr -i8\" (stands for \"K&R, 8 character indents\"), or use "
"\"scripts/Lindent\", which indents in the latest style."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:712
msgid ""
"\"indent\" has a lot of options, and especially when it comes to comment "
"re-formatting you may want to take a look at the man page.  But remember:"
" \"indent\" is not a fix for bad programming."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:719
msgid "Chapter 10: Kconfig configuration files"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:721
msgid ""
"For all of the Kconfig* configuration files throughout the source tree, "
"the indentation is somewhat different.  Lines under a \"config\" "
"definition are indented with one tab, while help text is indented an "
"additional two spaces. Example:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:726
msgid ""
"config AUDIT\n"
"    bool \"Auditing support\"\n"
"    depends on NET\n"
"    help\n"
"    Enable auditing infrastructure that can be used with another\n"
"    kernel subsystem, such as SELinux (which requires this for\n"
"    logging of avc messages output).  Does not do system-call\n"
"    auditing without CONFIG_AUDITSYSCALL."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:737
msgid ""
"Features that might still be considered unstable should be defined as "
"dependent on \"EXPERIMENTAL\":"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:740
msgid ""
"config SLUB\n"
"    depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT\n"
"    bool \"SLUB (Unqueued Allocator)\"\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:747
msgid ""
"while seriously dangerous features (such as write support for certain "
"filesystems) should advertise this prominently in their prompt string:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:750
msgid ""
"config ADFS_FS_RW\n"
"    bool \"ADFS write support (DANGEROUS)\"\n"
"    depends on ADFS_FS\n"
"    ..."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:757
msgid ""
"For full documentation on the configuration files, see the file "
"Documentation/kbuild/kconfig-language.txt."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:763
msgid "Chapter 11: Data structures"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:765
msgid ""
"Data structures that have visibility outside the single-threaded "
"environment they are created and destroyed in should always have "
"reference counts.  In the kernel, garbage collection doesn't exist (and "
"outside the kernel garbage collection is slow and inefficient), which "
"means that you absolutely _have_ to reference count all your uses."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:771
msgid ""
"Reference counting means that you can avoid locking, and allows multiple "
"users to have access to the data structure in parallel - and not having "
"to worry about the structure suddenly going away from under them just "
"because they slept or did something else for a while."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:776
msgid ""
"Note that locking is _not_ a replacement for reference counting. Locking "
"is used to keep data structures coherent, while reference counting is a "
"memory management technique.  Usually both are needed, and they are not "
"to be confused with each other."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:781
msgid ""
"Many data structures can indeed have two levels of reference counting, "
"when there are users of different \"classes\".  The subclass count counts"
" the number of subclass users, and decrements the global count just once "
"when the subclass count goes to zero."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:786
msgid ""
"Examples of this kind of \"multi-level-reference-counting\" can be found "
"in memory management (\"struct mm_struct\": mm_users and mm_count), and "
"in filesystem code (\"struct super_block\": s_count and s_active)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:790
msgid ""
"Remember: if another thread can find your data structure, and you don't "
"have a reference count on it, you almost certainly have a bug."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:795
msgid "Chapter 12: Macros, Enums and RTL"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:797
msgid "Names of macros defining constants and labels in enums are capitalized."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:799
msgid "#define CONSTANT 0x12345"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:803
msgid "Enums are preferred when defining several related constants."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:805
msgid ""
"CAPITALIZED macro names are appreciated but macros resembling functions "
"may be named in lower case."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:808
msgid "Generally, inline functions are preferable to macros resembling functions."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:810
msgid "Macros with multiple statements should be enclosed in a do - while block:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:812
msgid ""
"#define macrofun(a, b, c)   \\\n"
"    do {                    \\\n"
"        if (a == 5)         \\\n"
"            do_this(b, c);  \\\n"
"    } while (0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:820
msgid "Things to avoid when using macros:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:822
msgid "macros that affect control flow:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:824
msgid ""
"#define FOO(x)                  \\\n"
"    do {                        \\\n"
"        if (blah(x) < 0)        \\\n"
"            return -EBUGGERED;  \\\n"
"    } while(0)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:832
msgid ""
"is a _very_ bad idea.  It looks like a function call but exits the "
"\"calling\" function; don't break the internal parsers of those who will "
"read the code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:835
msgid "macros that depend on having a local variable with a magic name:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:837
msgid "#define FOO(val) bar(index, val)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:841
msgid ""
"might look like a good thing, but it's confusing as hell when one reads "
"the code and it's prone to breakage from seemingly innocent changes."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:844
msgid ""
"macros with arguments that are used as l-values: FOO(x) = y; will bite "
"you if somebody e.g. turns FOO into an inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:847
msgid ""
"forgetting about precedence: macros defining constants using expressions "
"must enclose the expression in parentheses. Beware of similar issues with"
" macros using parameters."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:851
msgid ""
"#define CONSTANT 0x4000\n"
"#define CONSTEXP (CONSTANT | 3)"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:856
msgid ""
"The cpp manual deals with macros exhaustively. The gcc internals manual "
"also covers RTL which is used frequently with assembly language in the "
"kernel."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:861
msgid "Chapter 13: Printing kernel messages"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:863
msgid ""
"Kernel developers like to be seen as literate. Do mind the spelling of "
"kernel messages to make a good impression. Do not use crippled words like"
" \"dont\"; use \"do not\" or \"don't\" instead.  Make the messages "
"concise, clear, and unambiguous."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:868
msgid "Kernel messages do not have to be terminated with a period."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:870
#, python-format
msgid "Printing numbers in parentheses (%d) adds no value and should be avoided."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:872
msgid ""
"There are a number of driver model diagnostic macros in <linux/device.h> "
"which you should use to make sure messages are matched to the right "
"device and driver, and are tagged with the right level:  dev_err(), "
"dev_warn(), dev_info(), and so forth.  For messages that aren't "
"associated with a particular device, <linux/kernel.h> defines pr_debug() "
"and pr_info()."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:878
msgid ""
"Coming up with good debugging messages can be quite a challenge; and once"
" you have them, they can be a huge help for remote troubleshooting.  Such"
" messages should be compiled out when the DEBUG symbol is not defined "
"(that is, by default they are not included).  When you use dev_dbg() or "
"pr_debug(), that's automatic.  Many subsystems have Kconfig options to "
"turn on -DDEBUG. A related convention uses VERBOSE_DEBUG to add "
"dev_vdbg() messages to the ones already enabled by DEBUG."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:888
msgid "Chapter 14: Allocating memory"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:890
msgid ""
"The kernel provides the following general purpose memory allocators: "
"kmalloc(), kzalloc(), kcalloc(), and vmalloc().  Please refer to the API "
"documentation for further information about them."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:894
msgid "The preferred form for passing a size of a struct is the following:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:896
msgid "p = kmalloc(sizeof(*p), ...);"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:900
msgid ""
"The alternative form where struct name is spelled out hurts readability "
"and introduces an opportunity for a bug when the pointer variable type is"
" changed but the corresponding sizeof that is passed to a memory "
"allocator is not."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:904
msgid ""
"Casting the return value which is a void pointer is redundant. The "
"conversion from void pointer to any other pointer type is guaranteed by "
"the C programming language."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:910
msgid "Chapter 15: The inline disease"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:912
msgid ""
"There appears to be a common misperception that gcc has a magic \"make me"
" faster\" speedup option called \"inline\". While the use of inlines can "
"be appropriate (for example as a means of replacing macros, see Chapter "
"12), it very often is not. Abundant use of the inline keyword leads to a "
"much bigger kernel, which in turn slows the system as a whole down, due "
"to a bigger icache footprint for the CPU and simply because there is less"
" memory available for the pagecache. Just think about it; a pagecache "
"miss causes a disk seek, which easily takes 5 milliseconds. There are a "
"LOT of cpu cycles that can go into these 5 milliseconds."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:922
msgid ""
"A reasonable rule of thumb is to not put inline at functions that have "
"more than 3 lines of code in them. An exception to this rule are the "
"cases where a parameter is known to be a compiletime constant, and as a "
"result of this constantness you *know* the compiler will be able to "
"optimize most of your function away at compile time. For a good example "
"of this later case, see the kmalloc() inline function."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:929
msgid ""
"Often people argue that adding inline to functions that are static and "
"used only once is always a win since there is no space tradeoff. While "
"this is technically correct, gcc is capable of inlining these "
"automatically without help, and the maintenance issue of removing the "
"inline when a second user appears outweighs the potential value of the "
"hint that tells gcc to do something it would have done anyway."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:938
msgid "Chapter 16: Function return values and names"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:940
msgid ""
"Functions can return values of many different kinds, and one of the most "
"common is a value indicating whether the function succeeded or failed.  "
"Such a value can be represented as an error-code integer (-Exxx = "
"failure, 0 = success) or a \"succeeded\" boolean (0 = failure, non-zero ="
" success)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:946
msgid ""
"Mixing up these two sorts of representations is a fertile source of "
"difficult-to-find bugs.  If the C language included a strong distinction "
"between integers and booleans then the compiler would find these mistakes"
" for us... but it doesn't.  To help prevent such bugs, always follow this"
" convention:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:954
msgid ""
"If the name of a function is an action or an imperative command,\n"
"the function should return an error-code integer.  If the name\n"
"is a predicate, the function should return a \"succeeded\" boolean."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:958
msgid ""
"For example, \"add work\" is a command, and the add_work() function "
"returns 0 for success or -EBUSY for failure.  In the same way, \"PCI "
"device present\" is a predicate, and the pci_dev_present() function "
"returns 1 if it succeeds in finding a matching device or 0 if it doesn't."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:963
msgid ""
"All EXPORTed functions must respect this convention, and so should all "
"public functions.  Private (static) functions need not, but it is "
"recommended that they do."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:967
msgid ""
"Functions whose return value is the actual result of a computation, "
"rather than an indication of whether the computation succeeded, are not "
"subject to this rule.  Generally they indicate failure by returning some "
"out-of-range result.  Typical examples would be functions that return "
"pointers; they use NULL or the ERR_PTR mechanism to report failure."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:976
msgid "Chapter 17:  Don't re-invent the kernel macros"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:978
msgid ""
"The header file include/linux/kernel.h contains a number of macros that "
"you should use, rather than explicitly coding some variant of them "
"yourself. For example, if you need to calculate the length of an array, "
"take advantage of the macro"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:983
msgid "#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:987
msgid "Similarly, if you need to calculate the size of some structure member, use"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:989
msgid "#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:993
msgid ""
"There are also min() and max() macros that do strict type checking if you"
" need them.  Feel free to peruse that header file to see what else is "
"already defined that you shouldn't reproduce in your code."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:999
msgid "Chapter 18:  Editor modelines and other cruft"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1001
msgid ""
"Some editors can interpret configuration information embedded in source "
"files, indicated with special markers.  For example, emacs interprets "
"lines marked like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1005
msgid "-*- mode: c -*-"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1009
msgid "Or like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1011
msgid ""
"/*\n"
"Local Variables:\n"
"compile-command: \"gcc -DMAGIC_DEBUG_FLAG foo.c\"\n"
"End:\n"
"*/"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1019
msgid "Vim interprets markers that look like this:"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1021
msgid "/* vim:set sw=8 noet */"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1025
msgid ""
"Do not include any of these in source files.  People have their own "
"personal editor configurations, and your source files should not override"
" them.  This includes markers for indentation and mode configuration.  "
"People may use their own custom mode, or may have some other magic method"
" for making indentation work correctly."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1033
msgid "Appendix I: References"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1035
msgid ""
"`The C Programming Language, Second Edition "
"<https://en.wikipedia.org/wiki/The_C_Programming_Language>`_ by Brian W. "
"Kernighan and Dennis M. Ritchie. |br| Prentice Hall, Inc., 1988. |br| "
"ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback)."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1040
msgid ""
"`The Practice of Programming "
"<https://en.wikipedia.org/wiki/The_Practice_of_Programming>`_ by Brian W."
" Kernighan and Rob Pike. |br| Addison-Wesley, Inc., 1999. |br| ISBN "
"0-201-61586-X."
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1045
msgid ""
"`GNU manuals <http://www.gnu.org/manual/>`_ - where in compliance with "
"K&R and this text - for **cpp**, **gcc**, **gcc internals** and "
"**indent**"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1048
msgid ""
"`WG14 International standardization workgroup for the programming "
"language C <http://www.open-std.org/JTC1/SC22/WG14/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/c_style_guide.rst:1051
msgid ""
"`Kernel CodingStyle, by greg@kroah.com at OLS 2002 "
"<http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:31
msgid "Developer guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:37
msgid "How to work on a bug"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:39
msgid ""
"Any defect, even minor, if it changes the user-visible server behavior, "
"needs a bug report. Report a bug at "
"http://github.com/tarantool/tarantool/issues."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:42
msgid ""
"When reporting a bug, try to come up with a test case right away. Set the"
" current maintenance milestone for the bug fix, and specify the series. "
"Assign the bug to yourself. Put the status to 'In progress' Once the "
"patch is ready, put the bug the bug to 'In review' and solicit a review "
"for the fix."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:47
msgid ""
"Once there is a positive code review, push the patch and set the status "
"to 'Closed'"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:49
msgid ""
"Patches for bugs should contain a reference to the respective Launchpad "
"bug page or at least bug id. Each patch should have a test, unless coming"
" up with one is difficult in the current framework, in which case QA "
"should be alerted."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:53
msgid ""
"There are two things you need to do when your patch makes it into the "
"master:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:55
msgid "put the bug to 'fix committed',"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:56
msgid "delete the remote branch."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:62
msgid "How to write a commit message"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:64
msgid ""
"Any commit needs a helpful message. Mind the following guidelines when "
"committing to any of Tarantool repositories at GitHub."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:67
msgid "Separate subject from body with a blank line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:68
msgid "Try to limit the subject line to **50 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:69
msgid ""
"Start the subject line with a capital letter unless it prefixed with a "
"subsystem name and semicolon:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:72
msgid "memtx:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:73
msgid "vinyl:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:74
msgid "xlog:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:75
msgid "replication:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:76
msgid "recovery:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:77
msgid "iproto:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:78
msgid "net.box:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:79
msgid "lua:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:81
msgid "Do not end the subject line with a period."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:82
msgid "Do not put \"gh-xx\", \"closes #xxx\" to the subject line."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:83
msgid ""
"Use the imperative mood in the subject line. A properly formed Git commit"
" subject line should always be able to complete the following sentence: "
"\"If applied, this commit will */your subject line here/*\"."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:86
msgid "Wrap the body to **72 characters** or so."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:87
msgid "Use the body to explain **what and why** vs. how."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:88
msgid ""
"Link GitHub issues on the lasts lines (`see how "
"<https://help.github.com/articles/closing-issues-via-commit-messages>`_)."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:90
msgid ""
"Use your real name and real email address. For Tarantool team members, "
"**@tarantool.org** email is preferred, but not mandatory."
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:94
msgid "A template:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:96
msgid ""
"Summarize changes in 50 characters or less\n"
"\n"
"More detailed explanatory text, if necessary.\n"
"Wrap it to 72 characters or so.\n"
"In some contexts, the first line is treated as the subject of the\n"
"commit, and the rest of the text as the body.\n"
"The blank line separating the summary from the body is critical\n"
"(unless you omit the body entirely); various tools like `log`,\n"
"`shortlog` and `rebase` can get confused if you run the two together.\n"
"\n"
"Explain the problem that this commit is solving. Focus on why you\n"
"are making this change as opposed to how (the code explains that).\n"
"Are there side effects or other unintuitive consequences of this\n"
"change? Here's the place to explain them.\n"
"\n"
"Further paragraphs come after blank lines.\n"
"\n"
"- Bullet points are okay, too.\n"
"\n"
"- Typically a hyphen or asterisk is used for the bullet, preceded\n"
"  by a single space, with blank lines in between, but conventions\n"
"  vary here.\n"
"\n"
"Fixes: #123\n"
"Closes: #456\n"
"Needed for: #859\n"
"See also: #343, #789"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:126
msgid "Some real-world examples:"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:128
msgid ""
"`tarantool/tarantool@2993a75 "
"<https://github.com/tarantool/tarantool/commit/2993a75858352f101deb4a15cefd497ae6a78cf7>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:129
msgid ""
"`tarantool/tarantool@ccacba2 "
"<https://github.com/tarantool/tarantool/commit/ccacba28f813fb99fd9eaf07fb41bf604dd341bc>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:130
msgid ""
"`tarantool/tarantool@386df3d "
"<https://github.com/tarantool/tarantool/commit/386df3d3eb9c5239fc83fd4dd3292d1b49446b89>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:131
msgid ""
"`tarantool/tarantool@076a842 "
"<https://github.com/tarantool/tarantool/commit/076a842011e09c84c25fb5e68f1b23c9917a3750>`_"
msgstr ""

#: ../doc/1.7/dev_guide/developer_guidelines.rst:133
msgid "Based on [1_] and [2_]."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:33
msgid "Documentation guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:35
msgid ""
"These guidelines are updated on the on-demand basis, covering only those "
"issues that cause pains to the existing writers. At this point, we do not"
" aim to come up with an exhaustive Documentation Style Guide for the "
"Tarantool project."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:41
msgid "Markup issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:45
msgid "Wrapping text"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:47
msgid ""
"The limit is 80 characters per line for plain text, and no limit for any "
"other constructions when wrapping affects ReST readability and/or HTML "
"output. Also, it makes no sense to wrap text into lines shorter than 80 "
"characters unless you have a good reason to do so."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:52
msgid ""
"The 80-character limit comes from the ISO/ANSI 80x24 screen resolution, "
"and it's unlikely that readers/writers will use 80-character consoles. "
"Yet it's still a standard for many coding guidelines (including "
"Tarantool). As for writers, the benefit is that an 80-character page "
"guide allows keeping the text window rather narrow most of the time, "
"leaving more space for other applications in a wide-screen environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:61
msgid "Formatting code snippets"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:63
msgid ""
"For code snippets, we mainly use the ``code-block`` directive with an "
"appropriate highlighting language. The most commonly used highlighting "
"languages are:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:67
msgid "``.. code-block:: tarantoolsession``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:68
msgid "``.. code-block:: console``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:69
msgid "``.. code-block:: lua``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:71
msgid "For example (a code snippet in Lua):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:73
msgid ""
"for page in paged_iter(\"X\", 10) do\n"
"  print(\"New Page. Number Of Tuples = \" .. #page)\n"
"  for i=1,#page,1 do print(page[i]) end\n"
"end"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:80
msgid ""
"In rare cases, when we need custom highlight for specific parts of a code"
" snippet and the ``code-block`` directive is not enough, we use the per-"
"line ``codenormal`` directive together and explicit output formatting "
"(defined in :file:`doc/sphinx/_static/sphinx_design.css`)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:85
msgid "Examples:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:87
msgid "Function syntax (the placeholder `space-name` is displayed in italics):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:89
msgid ""
":codenormal:`box.space.`:codeitalic:`space-"
"name`:codenormal:`:create_index('index-name')`"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:91
msgid ""
"A tdb session (user input is in bold, command prompt is in blue, computer"
" output is in green):"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:103
msgid ""
"Warning: Every entry of explicit output formatting (``codenormal``, "
"``codebold``, etc) tends to cause troubles when this documentation is "
"translated to other languages. Please avoid using explicit output "
"formatting unless it is REALLY needed."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:110
msgid "Using separated links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:112
msgid "Avoid separating the link and the target definition (ref), like this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:114
msgid ""
"This is a paragraph that contains `a link`_.\n"
"\n"
".. _a link: http://example.com/"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:120
msgid "Use non-separated links instead:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:122
msgid "This is a paragraph that contains `a link <http://example.com/>`_."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:126
msgid ""
"Warning: Every separated link tends to cause troubles when this "
"documentation is translated to other languages. Please avoid using "
"separated links unless it is REALLY needed (e.g. in tables)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:132
msgid "Creating labels for local links"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:134
msgid ""
"We avoid using links that sphinx generates automatically for most "
"objects. Instead, we add our own labels for linking to any place in this "
"documentation."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:137
msgid "Our naming convention is as follows:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:139
msgid "Character set: a through z, 0 through 9, dash, underscore."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:141
msgid "Format: ``path dash filename dash tag``"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:143
msgid ""
"Example: ``_c_api-box_index-iterator_type`` |br| where: |br| ``c_api`` is"
" the directory name, |br| ``box_index`` is the file name (without "
"\".rst\"), and |br| ``iterator_type`` is the tag."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:149
msgid ""
"The file name is useful for knowing, when you see \"ref\", where it is "
"pointing to. And if the file name is meaningful, you see that better."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:152
msgid ""
"The file name alone, without a path, is enough when the file name is "
"unique within ``doc/sphinx``. So, for ``fiber.rst`` it should be just "
"\"fiber\", not \"reference-fiber\". While for \"index.rst\" (we have a "
"handful of \"index.rst\" in different directories) please specify the "
"path before the file name, e.g. \"reference-index\"."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:159
msgid ""
"Use a dash \"-\" to delimit the path and the file name. In the "
"documentation source, we use only underscores \"_\" in paths and file "
"names, reserving dash \"-\" as the delimiter for local links."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:163
msgid ""
"The tag can be anything meaningful. The only guideline is for Tarantool "
"syntax items (such as members), where the preferred tag syntax is "
"``module_or_object_name dash member_name``. For example, ``box_space-"
"drop``."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:169
msgid "Making comments"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:171
msgid ""
"Sometimes we may need to leave comments in a ReST file. To make sphinx "
"ignore some text during processing, use the following per-line notation "
"with \".. //\" as the comment marker:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:175
msgid ".. // your comment here"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:179
msgid ""
"The starting symbols \".. //\" do not interfere with the other ReST "
"markup, and they are easy to find both visually and using grep. There are"
" no symbols to escape in grep search, just go ahead with something like "
"this:"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:183
msgid "grep \".. //\" doc/sphinx/dev_guide/*.rst"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:187
msgid ""
"These comments don't work properly in nested documentation, though (e.g. "
"if you leave a comment in module -> object -> method, sphinx ignores the "
"comment and all nested content that follows in the method description)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:193
msgid "Language and style issues"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:197
msgid "US vs British spelling"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:199
msgid "We use English US spelling."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:203
msgid "Instance vs server"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:205
msgid ""
"We say \"instance\" rather than \"server\" to refer to an instance of "
"Tarantool server. This keeps the manual terminology consistent with names"
" like ``/etc/tarantool/instances.enabled`` in the Tarantool environment."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:209
msgid ""
"Wrong usage: \"Replication allows multiple Tarantool *servers* to work on"
" copies of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:212
msgid ""
"Correct usage: \"Replication allows multiple Tarantool *instances* to "
"work on copies of the same databases.\""
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:217
msgid "Examples and templates"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:221
msgid "Module and function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:223
msgid ""
"Here is an example of documenting a module (``my_fiber``) and a function "
"(``my_fiber.create``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:230
msgid ""
"Create and start a ``my_fiber`` object. The object is created and begins "
"to run immediately."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:233
msgid "the function to be associated with the ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:234
#: ../doc/1.7/reference/reference_lua/fiber.rst:88
msgid "what will be passed to function"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:236
msgid "created ``my_fiber`` object"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:241
msgid ""
"tarantool> my_fiber = require('my_fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   my_fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> my_fiber_object = my_fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:257
msgid "Module, class and method"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:259
msgid ""
"Here is an example of documenting a module (``my_box.index``), a class "
"(``my_index_object``) and a function (``my_index_object.rename``)."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:270
msgid "an object reference"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:271
msgid "a new name for the index (type = string)"
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:275
msgid "Possible errors: index_object does not exist."
msgstr ""

#: ../doc/1.7/dev_guide/documentation_guidelines.rst:285
msgid "Complexity Factors: Index size, Index type, Number of tuples accessed."
msgstr ""

#: ../doc/1.7/dev_guide/guidelines_index.rst:31
msgid "Guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/index.rst:33
msgid "Contributor's Guide"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:9 ../doc/1.7/dev_guide/internals.rst:37
msgid "Data persistence and the WAL file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:11 ../doc/1.7/dev_guide/internals.rst:39
msgid ""
"To maintain data persistence, Tarantool writes each data change request "
"(insert, update, delete, replace, upsert) into a write-ahead log (WAL) "
"file in the :ref:`wal_dir <cfg_basic-wal_dir>` directory. A new WAL file "
"is created for every :ref:`rows_per_wal <cfg_binary_logging_snapshots-"
"rows_per_wal>` records. Each data change request gets assigned a "
"continuously growing 64-bit log sequence number. The name of the WAL file"
" is based on the log sequence number of the first record in the file, "
"plus an extension ``.xlog``."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:19 ../doc/1.7/dev_guide/internals.rst:47
msgid ""
"Apart from a log sequence number and the data change request (formatted "
"as in :ref:`Tarantool's binary protocol <box_protocol-iproto_protocol>`),"
" each WAL record contains a header, some metadata, and then the data "
"formatted according to `msgpack "
"<https://en.wikipedia.org/wiki/MessagePack>`_ rules. For example, this is"
" what the WAL file looks like after the first INSERT request "
"(\"s:insert({1})\") for the sandbox database created in our "
":ref:`\"Getting started\" exercises <getting_started>`. On the left are "
"the hexadecimal bytes that you would see with:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:28 ../doc/1.7/dev_guide/internals.rst:56
msgid "$ hexdump 00000000000000000000.xlog"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:32 ../doc/1.7/dev_guide/internals.rst:60
msgid "and on the right are comments."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:34 ../doc/1.7/dev_guide/internals.rst:62
msgid ""
"Hex dump of WAL file       Comment\n"
"--------------------       -------\n"
"58 4c 4f 47 0a             \"XLOG\\n\"\n"
"30 2e 31 33 0a             \"0.13\\n\" = version\n"
"53 65 72 76 65 72 3a 20    \"Server: \"\n"
"38 62 66 32 32 33 65 30 2d [Server UUID]\\n\n"
"36 39 31 34 2d 34 62 35 35\n"
"2d 39 34 64 32 2d 64 32 62\n"
"36 64 30 39 62 30 31 39 36\n"
"0a\n"
"56 43 6c 6f 63 6b 3a 20    \"Vclock: \"\n"
"7b 7d                      \"{}\" = vclock value, initially blank\n"
"...                        (not shown = tuples for system spaces)\n"
"d5 ba 0b ab                Magic row marker always = 0xab0bbad5\n"
"19                         Length, not including length of header, = 25 "
"bytes\n"
"00                           Record header: previous crc32\n"
"ce 8c 3e d6 70               Record header: current crc32\n"
"a7 cc 73 7f 00 00 66 39      Record header: padding\n"
"84                         msgpack code meaning \"Map of 4 elements\" "
"follows\n"
"00 02                         element#1: tag=request type, "
"value=0x02=IPROTO_INSERT\n"
"02 01                         element#2: tag=server id, value=0x01\n"
"03 04                         element#3: tag=lsn, value=0x04\n"
"04 cb 41 d4 e2 2f 62 fd d5 d4 element#4: tag=timestamp, value=an 8-byte "
"\"Float64\"\n"
"82                         msgpack code meaning \"map of 2 elements\" "
"follows\n"
"10 cd 02 00                   element#1: tag=space id, value=512, big "
"byte first\n"
"21 91 01                      element#2: tag=tuple, value=1-element fixed"
" array={1}"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:63 ../doc/1.7/dev_guide/internals.rst:91
msgid ""
"Tarantool processes requests atomically: a change is either accepted and "
"recorded in the WAL, or discarded completely. Let's clarify how this "
"happens, using the REPLACE request as an example:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:67 ../doc/1.7/dev_guide/internals.rst:95
msgid ""
"The server instance attempts to locate the original tuple by primary key."
" If found, a reference to the tuple is retained for later use."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:70 ../doc/1.7/dev_guide/internals.rst:98
msgid ""
"The new tuple is validated. If for example it does not contain an indexed"
" field, or it has an indexed field whose type does not match the type "
"according to the index definition, the change is aborted."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:74 ../doc/1.7/dev_guide/internals.rst:102
msgid "The new tuple replaces the old tuple in all existing indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:76 ../doc/1.7/dev_guide/internals.rst:104
msgid ""
"A message is sent to the WAL writer running in a separate thread, "
"requesting that the change be recorded in the WAL. The instance switches "
"to work on the next request until the write is acknowledged."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:80 ../doc/1.7/dev_guide/internals.rst:108
msgid ""
"On success, a confirmation is sent to the client. On failure, a rollback "
"procedure is begun. During the rollback procedure, the transaction "
"processor rolls back all changes to the database which occurred after the"
" first failed change, from latest to oldest, up to the first failed "
"change. All rolled back requests are aborted with :errcode:`ER_WAL_IO "
"<ER_WAL_IO>` error. No new change is applied while rollback is in "
"progress. When the rollback procedure is finished, the server restarts "
"the processing pipeline."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:88 ../doc/1.7/dev_guide/internals.rst:116
msgid ""
"One advantage of the described algorithm is that complete request "
"pipelining is achieved, even for requests on the same value of the "
"primary key. As a result, database performance doesn't degrade even if "
"all requests refer to the same key in the same space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:93 ../doc/1.7/dev_guide/internals.rst:121
msgid ""
"The transaction processor thread communicates with the WAL writer thread "
"using asynchronous (yet reliable) messaging; the transaction processor "
"thread, not being blocked on WAL tasks, continues to handle requests "
"quickly even at high volumes of disk I/O. A response to a request is sent"
" as soon as it is ready, even if there were earlier incomplete requests "
"on the same connection. In particular, SELECT performance, even for "
"SELECTs running on a connection packed with UPDATEs and DELETEs, remains "
"unaffected by disk load."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:101
#: ../doc/1.7/dev_guide/internals.rst:129
msgid ""
"The WAL writer employs a number of durability modes, as defined in "
"configuration variable :ref:`wal_mode <index-wal_mode>`. It is possible "
"to turn the write-ahead log completely off, by setting :ref:`wal_mode "
"<cfg_binary_logging_snapshots-wal_mode>` to *none*. Even without the "
"write-ahead log it's still possible to take a persistent copy of the "
"entire data set with the :ref:`box.snapshot() <box-snapshot>` request."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:108
#: ../doc/1.7/dev_guide/internals.rst:136
msgid ""
"An .xlog file always contains changes based on the primary key. Even if "
"the client requested an update or delete using a secondary key, the "
"record in the .xlog file will contain the primary key."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:114
#: ../doc/1.7/dev_guide/internals.rst:142
msgid "The snapshot file format"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:116
#: ../doc/1.7/dev_guide/internals.rst:144
msgid ""
"The format of a snapshot .snap file is nearly the same as the format of a"
" WAL .xlog file. However, the snapshot header differs: it contains the "
"instance's global unique identifier and the snapshot file's position in "
"history, relative to earlier snapshot files. Also, the content differs: "
"an .xlog file may contain records for any data-change requests (inserts, "
"updates, upserts, and deletes), a .snap file may only contain records of "
"inserts to memtx spaces."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:123
#: ../doc/1.7/dev_guide/internals.rst:151
msgid ""
"Primarily, the .snap file's records are ordered by space id. Therefore "
"the records of system spaces -- such as ``_schema``, ``_space``, "
"``_index``, ``_func``, ``_priv`` and ``_cluster`` -- will be at the start"
" of the .snap file, before the records of any spaces that were created by"
" users."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:128
#: ../doc/1.7/dev_guide/internals.rst:156
msgid ""
"Secondarily, the .snap file's records are ordered by primary key within "
"space id."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:134
#: ../doc/1.7/dev_guide/internals.rst:162
msgid "The recovery process"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:136
#: ../doc/1.7/dev_guide/internals.rst:164
msgid ""
"The recovery process begins when box.cfg{} happens for the first time "
"after the Tarantool server instance starts."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:139
#: ../doc/1.7/dev_guide/internals.rst:167
msgid ""
"The recovery process must recover the databases as of the moment when the"
" instance was last shut down. For this it may use the latest snapshot "
"file and any WAL files that were written after the snapshot. One "
"complicating factor is that Tarantool has two engines -- the memtx data "
"must be reconstructed entirely from the snapshot and the WAL files, while"
" the vinyl data will be on disk but might require updating around the "
"time of a checkpoint. (When a snapshot happens, Tarantool tells the vinyl"
" engine to make a checkpoint, and the snapshot operation is rolled back "
"if anything goes wrong, so vinyl's checkpoint is at least as fresh as the"
" snapshot file.)"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:156
#: ../doc/1.7/dev_guide/internals.rst:184
msgid "Step 1"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:152
#: ../doc/1.7/dev_guide/internals.rst:180
msgid ""
"Read the configuration parameters in the ``box.cfg{}`` request. "
"Parameters which affect recovery may include :ref:`work_dir <cfg_basic-"
"work_dir>`, :ref:`wal_dir <cfg_basic-wal_dir>`, :ref:`memtx_dir "
"<cfg_basic-memtx_dir>`, :ref:`vinyl_dir <cfg_basic-vinyl_dir>` and "
":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:176
#: ../doc/1.7/dev_guide/internals.rst:204
msgid "Step 2"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:159
#: ../doc/1.7/dev_guide/internals.rst:187
msgid ""
"Find the latest snapshot file. Use its data to reconstruct the in-memory "
"databases. Instruct the vinyl engine to recover to the latest checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:162
#: ../doc/1.7/dev_guide/internals.rst:190
msgid ""
"There are actually two variations of the reconstruction procedure for "
"memtx databases, depending on whether the recovery process is "
"\"default\"."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:165
#: ../doc/1.7/dev_guide/internals.rst:193
msgid ""
"If the recovery process is default (``force_recovery`` is ``false``), "
"memtx can read data in the snapshot with all indexes disabled. First, all"
" tuples are read into memory. Then, primary keys are built in bulk, "
"taking advantage of the fact that the data is already sorted by primary "
"key within each space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:171
#: ../doc/1.7/dev_guide/internals.rst:199
msgid ""
"If the recovery process is non-default (``force_recovery`` is ``true``), "
"Tarantool performs additional checking. Indexes are enabled at the start,"
" and tuples are added one by one. This means that any unique-key "
"constraint violations will be caught, and any duplicates will be skipped."
" Normally there will be no constraint violations or duplicates, so these "
"checks are only made if an error has occurred."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:183
#: ../doc/1.7/dev_guide/internals.rst:211
msgid "Step 3"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:179
#: ../doc/1.7/dev_guide/internals.rst:207
msgid ""
"Find the WAL file that was made at the time of, or after, the snapshot "
"file. Read its log entries until the log-entry LSN is greater than the "
"LSN of the snapshot, or greater than the LSN of the vinyl checkpoint. "
"This is the recovery process's \"start position\"; it matches the current"
" state of the engines."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:187
#: ../doc/1.7/dev_guide/internals.rst:215
msgid "Step 4"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:186
#: ../doc/1.7/dev_guide/internals.rst:214
msgid ""
"Redo the log entries, from the start position to the end of the WAL. The "
"engine skips a redo instruction if it is older than the engine's "
"checkpoint."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:190
#: ../doc/1.7/dev_guide/internals.rst:218
msgid "Step 5"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:190
#: ../doc/1.7/dev_guide/internals.rst:218
msgid "For the memtx engine, re-create all secondary indexes."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:196
#: ../doc/1.7/dev_guide/internals.rst:224
msgid "Server startup with replication"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:198
#: ../doc/1.7/dev_guide/internals.rst:226
msgid ""
"In addition to the recovery process described above, the server must take"
" additional steps and precautions if :ref:`replication <replication>` is "
"enabled."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:201
#: ../doc/1.7/dev_guide/internals.rst:229
msgid ""
"Once again the startup procedure is initiated by the ``box.cfg{}`` "
"request. One of the ``box.cfg`` parameters may be :ref:`replication "
"<cfg_replication-replication>` that specifies replication source(-s). We "
"will refer to this replica, which is starting up due to ``box.cfg``, as "
"the \"local\" replica to distinguish it from the other replicas in a "
"replica set, which we will refer to as \"distant\" replicas."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:208
#: ../doc/1.7/dev_guide/internals.rst:236
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is "
"empty*: |br| then the local replica assumes it is an unreplicated "
"\"standalone\" instance, or is the first replica of a new replica set. It"
" will generate new UUIDs for itself and for the replica set. The replica "
"UUID is stored in the ``_cluster`` space; the replica set UUID is stored "
"in the ``_schema`` space. Since a snapshot contains all the data in all "
"the spaces, that means the local replica's snapshot will contain the "
"replica UUID and the replica set UUID. Therefore, when the local replica "
"restarts on later occasions, it will be able to recover these UUIDs when "
"it reads the .snap file."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:218
#: ../doc/1.7/dev_guide/internals.rst:246
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is "
"not empty and the ``_cluster`` space contains no other replica UUIDs*: "
"|br| then the local replica assumes it is not a standalone instance, but "
"is not yet part of a replica set. It must now join the replica set. It "
"will send its replica UUID to the first distant replica which is listed "
"in ``replication`` and which will act as a master. This is called the "
"\"join request\". When a distant replica receives a join request, it will"
" send back:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:226
#: ../doc/1.7/dev_guide/internals.rst:254
msgid "the distant replica's replica set UUID,"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:227
#: ../doc/1.7/dev_guide/internals.rst:255
msgid ""
"the contents of the distant replica's .snap file. |br| When the local "
"replica receives this information, it puts the replica set UUID in its "
"``_schema`` space, puts the distant replica's UUID and connection "
"information in its ``_cluster`` space, and makes a snapshot containing "
"all the data sent by the distant replica. Then, if the local replica has "
"data in its WAL .xlog files, it sends that data to the distant replica. "
"The distant replica will receive this and update its own copy of the "
"data, and add the local replica's UUID to its ``_cluster`` space."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:236
#: ../doc/1.7/dev_guide/internals.rst:264
msgid ""
"*If there is no snapshot .snap file and the ``replication`` parameter is "
"not empty and the ``_cluster`` space contains other replica UUIDs*: |br| "
"then the local replica assumes it is not a standalone instance, and is "
"already part of a replica set. It will send its replica UUID and replica "
"set UUID to all the distant replicas which are listed in ``replication``."
" This is called the \"on-connect handshake\". When a distant replica "
"receives an on-connect handshake: |br|"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:243
#: ../doc/1.7/dev_guide/internals.rst:271
msgid ""
"the distant replica compares its own copy of the replica set UUID to the "
"one in the on-connect handshake. If there is no match, then the handshake"
" fails and the local replica will display an error."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:246
#: ../doc/1.7/dev_guide/internals.rst:274
msgid ""
"the distant replica looks for a record of the connecting instance in its "
"``_cluster`` space. If there is none, then the handshake fails. |br| "
"Otherwise the handshake is successful. The distant replica will read any "
"new information from its own .snap and .xlog files, and send the new "
"requests to the local replica."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:252
#: ../doc/1.7/dev_guide/internals.rst:280
msgid ""
"In the end ... the local replica knows what replica set it belongs to, "
"the distant replica knows that the local replica is a member of the "
"replica set, and both replicas have the same database contents."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:258
#: ../doc/1.7/dev_guide/internals.rst:286
msgid ""
"*If there is a snapshot file and replication source is not empty*: |br| "
"first the local replica goes through the recovery process described in "
"the previous section, using its own .snap and .xlog files. Then it sends "
"a \"subscribe\" request to all the other replicas of the replica set. The"
" subscribe request contains the server vector clock. The vector clock has"
" a collection of pairs 'server id, lsn' for every replica in the "
"``_cluster`` system space. Each distant replica, upon receiving a "
"subscribe request, will read its .xlog files' requests and send them to "
"the local replica if (lsn of .xlog file request) is greater than (lsn of "
"the vector clock in the subscribe request). After all the other replicas "
"of the replica set have responded to the local replica's subscribe "
"request, the replica startup is complete."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:270
#: ../doc/1.7/dev_guide/internals.rst:298
msgid "The following temporary limitations apply for version 1.7:"
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:272
#: ../doc/1.7/dev_guide/internals.rst:300
msgid ""
"The URIs in the ``replication`` parameter should all be in the same order"
" on all replicas. This is not mandatory but is an aid to consistency."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:274
#: ../doc/1.7/dev_guide/internals.rst:302
msgid ""
"The replicas of a replica set should be started up at slightly different "
"times. This is not mandatory but prevents a situation where each replica "
"is waiting for the other replica to be ready."
msgstr ""

#: ../doc/1.7/dev_guide/internals.rst:277
#: ../doc/1.7/dev_guide/internals.rst:305
msgid ""
"The maximum number of entries in the ``_cluster`` space is 32. Tuples for"
" out-of-date replicas are not automatically re-used, so if this "
"32-replica limit is reached, users may have to reorganize the "
"``_cluster`` space manually."
msgstr ""

#: ../doc/1.7/dev_guide/internals_index.rst:31
msgid "Internals"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:31
msgid "Lua Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:33
msgid "Inspiration:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:35
msgid "https://github.com/Olivine-Labs/lua-style-guide"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:36
msgid "http://dev.minetest.net/Lua_code_style_guidelines"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:37
msgid "http://sputnik.freewisdom.org/en/Coding_Standard"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:39
msgid ""
"Programming style is an art. There is some arbitrariness to the rules, "
"but there are sound rationales for them. It is useful not only to provide"
" sound advice on style but to understand the underlying rationale and "
"human aspect of why the style recommendations are formed:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:44
msgid "http://mindprod.com/jgloss/unmain.html"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:45
msgid "http://www.oreilly.com/catalog/perlbp/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:46
msgid "http://books.google.com/books?id=QnghAQAAIAAJ"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:48
msgid "Zen of Python is good; understand it and use wisely:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Beautiful is better than ugly."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Explicit is better than implicit."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Simple is better than complex."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Complex is better than complicated."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Flat is better than nested."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Sparse is better than dense."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Readability counts."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Special cases aren't special enough to break the rules."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although practicality beats purity."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Errors should never pass silently."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Unless explicitly silenced."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "In the face of ambiguity, refuse the temptation to guess."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "There should be one -- and preferably only one -- obvious way to do it."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although that way may not be obvious at first unless you're Dutch."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Now is better than never."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Although never is often better than *right* now."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is hard to explain, it's a bad idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "If the implementation is easy to explain, it may be a good idea."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "Namespaces are one honking great idea -- let's do more of those!"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst
msgid "https://www.python.org/dev/peps/pep-0020/"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:74
msgid "Indentation and Formatting"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:76
msgid ""
"4 spaces instead tabs. PIL suggests using of two spaces, but programmer "
"looks at code 4 up to 8 hours a day, so it's simplier to distinguish "
"indentation with 4 spaces. Why spaces? Similar representation everywhere."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:80
msgid "You can use vim modelines:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:82
msgid "-- vim:ts=4 ss=4 sw=4 expandtab"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:86
msgid ""
"A file should ends w/ one newline symbol, but shouldn't ends w/ blank "
"line (two newline symbols)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:89
msgid "Every do/while/for/if/function should indent 4 spaces."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:91
msgid ""
"related ``or``/``and`` in ``if`` must be enclosed in the round brackets "
"(). Example:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:93
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    <...>\n"
"end -- good\n"
"\n"
"if a == true and b == false or a == false and b == true then\n"
"    <...>\n"
"end -- bad\n"
"\n"
"if a ^ b == true then\n"
"end -- good, but not explicit"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:106
msgid "Type conversion"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:108
msgid ""
"Do not use concatenation to convert to string or addition to convert to "
"number (use ``tostring``/``tonumber`` instead):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:111
msgid ""
"local a = 123\n"
"a = a .. ''\n"
"-- bad\n"
"\n"
"local a = 123\n"
"a = tostring(a)\n"
"-- good\n"
"\n"
"local a = '123'\n"
"a = a + 5 -- 128\n"
"-- bad\n"
"\n"
"local a = '123'\n"
"a = tonumber(a) + 5 -- 128\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:129
msgid "Try to avoid multiple nested ``if``'s with common body:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:131
msgid ""
"if (a == true and b == false) or (a == false and b == true) then\n"
"    do_something()\n"
"end\n"
"-- good\n"
"\n"
"if a == true then\n"
"    if b == false then\n"
"        do_something()\n"
"    end\n"
"if b == true then\n"
"    if a == false then\n"
"        do_something()\n"
"    end\n"
"end\n"
"-- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:149
msgid ""
"Avoid multiple concatenations in one statement, use ``string.format`` "
"instead:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:151
#, python-format
msgid ""
"function say_greeting(period, name)\n"
"    local a = \"good  \" .. period .. \", \" .. name\n"
"end\n"
"-- bad\n"
"\n"
"function say_greeting(period, name)\n"
"    local a = string.format(\"good %s, %s\", period, name)\n"
"end\n"
"-- good\n"
"\n"
"local say_greeting_fmt = \"good %s, %s\"\n"
"function say_greeting(period, name)\n"
"    local a = say_greeting_fmt:format(period, name)\n"
"end\n"
"-- best"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:169
msgid "Use ``and``/``or`` for default variable values"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:171
msgid ""
"function(input)\n"
"    input = input or 'default_value'\n"
"end -- good\n"
"\n"
"function(input)\n"
"    if input == nil then\n"
"        input = 'default_value'\n"
"    end\n"
"end -- ok, but excessive"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:183
msgid "``if``'s and return statements:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:185
msgid ""
"if a == true then\n"
"    return do_something()\n"
"end\n"
"do_other_thing() -- good\n"
"\n"
"if a == true then\n"
"    return do_something()\n"
"else\n"
"    do_other_thing()\n"
"end -- bad"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:198
msgid "Using spaces:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:200
msgid ""
"one shouldn't use spaces between function name and opening round bracket,"
" but arguments must be splitted with one whitespace charachter"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:203
msgid ""
"function name (arg1,arg2,...)\n"
"end -- bad\n"
"\n"
"function name(arg1, arg2, ...)\n"
"end -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:211
msgid "use space after comment marker"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:213
msgid ""
"while true do -- inline comment\n"
"-- comment\n"
"do_something()\n"
"end\n"
"--[[\n"
"  multiline\n"
"  comment\n"
"]]--"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:224
msgid "surrounding operators"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:226
msgid ""
"local thing=1\n"
"thing = thing-1\n"
"thing = thing*1\n"
"thing = 'string'..'s'\n"
"-- bad\n"
"\n"
"local thing = 1\n"
"thing = thing - 1\n"
"thing = thing * 1\n"
"thing = 'string' .. 's'\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:240
msgid "use space after commas in tables"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:242
msgid ""
"local thing = {1,2,3}\n"
"thing = {1 , 2 , 3}\n"
"thing = {1 ,2 ,3}\n"
"-- bad\n"
"\n"
"local thing = {1, 2, 3}\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:252
msgid "use space in map definitions around equality sign and commas"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:254
msgid ""
"return {1,2,3,4} -- bad\n"
"return {\n"
"    key1 = val1,key2=val2\n"
"} -- bad\n"
"\n"
"return {\n"
"    1, 2, 3, 4\n"
"    key1 = val1, key2 = val2,\n"
"    key3 = vallll\n"
"} -- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:267
msgid "also, you may use alignment:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:269
msgid ""
"return {\n"
"    long_key  = 'vaaaaalue',\n"
"    key       = 'val',\n"
"    something = 'even better'\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:277
msgid ""
"extra blank lines may be used (sparingly) to separate groups of related "
"functions. Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:281
msgid "use blank lines in function, sparingly, to indicate logical sections"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:283
msgid ""
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"local wat = 7\n"
"-- bad\n"
"\n"
"if thing then\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"function derp()\n"
"    -- ...stuff...\n"
"end\n"
"\n"
"local wat = 7\n"
"-- good"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:305
msgid ""
"Delete whitespace at EOL (strongly forbidden. Use ``:s/\\s\\+$//gc`` in "
"vim to delete them)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:310
msgid "Avoid global variable"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:312
msgid ""
"You must avoid global variables. If you have an exceptional case, use "
"``_G`` variable to set it, add prefix or add table instead of prefix:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:315
msgid ""
"function bad_global_example()\n"
"end -- very, very bad\n"
"\n"
"function good_local_example()\n"
"end\n"
"_G.modulename_good_local_example = good_local_example -- good\n"
"_G.modulename = {}\n"
"_G.modulename.good_local_example = good_local_example -- better"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:326
msgid "Always use prefix to avoid name clash"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:330
msgid "Naming"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:332
msgid "names of variables/\"objects\" and \"methods\"/functions: snake_case"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:333
msgid "names of \"classes\": CamelCase"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:334
msgid ""
"private variables/methods (properties in the future) of object starts "
"with underscores ``<object>._<name>``. Avoid using of ``local function "
"private_methods(self) end``"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:337
msgid ""
"boolean - naming ``is_<...>``, ``isnt_<...>``, ``has_``, ``hasnt_`` is a "
"good style."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:338
msgid ""
"for \"very local\" variables: - ``t`` is for tables - ``i``, ``j`` are "
"for indexing - ``n`` is for counting - ``k``, ``v`` is what you get out "
"of ``pairs()`` (are acceptable, ``_`` if unused) - ``i``, ``v`` is what "
"you get out of ``ipairs()`` (are acceptable, ``_`` if unused) - "
"``k``/``key`` is for table keys - ``v``/``val``/``value`` is for values "
"that are passed around - ``x``/``y``/``z`` is for generic math quantities"
" - ``s``/``str``/``string`` is for strings - ``c`` is for 1-char strings "
"- ``f``/``func``/``cb`` are for functions - ``status, <rv>..`` or ``ok, "
"<rv>..`` is what you get out of pcall/xpcall - ``buf, sz`` is a (buffer, "
"size) pair - ``<name>_p`` is for pointers - ``t0``.. is for timestamps - "
"``err`` is for errors"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:355
msgid ""
"abbrevations are acceptable if they're unambigous and if you'll document "
"(or they're too common) them."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:357
msgid ""
"global variables are written with ALL_CAPS. If it's some system variable,"
" then they're using underscore to define it (``_G``/``_VERSION``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:359
msgid ""
"module naming snake_case (avoid underscores and dashes) - 'luasql', "
"instead of 'Lua-SQL'"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:361
msgid "``*_mt`` and ``*_methods`` defines metatable and methods table"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:365
msgid "Idioms and patterns"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:367
msgid ""
"Always use round brackets in call of functions except multiple cases "
"(common lua style idioms):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:370
msgid "``*.cfg{ }`` functions (``box.cfg``/``memcached.cfg``/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:371
msgid "``ffi.cdef[[ ]]`` function"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:373
msgid "Avoid these kind of constructions:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:375
msgid "<func>'<name>' (strongly avoid require'..')"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:376
msgid ""
"``function object:method() end`` (use ``functon object.method(self) end``"
" instead)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:377
msgid "do not use semicolon as table separator (only comma)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:378
msgid ""
"semicolons at the end of line (only to split multiple statements on one "
"line)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:379
msgid "try to avoid unnecessary function creation (closures/..)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:383
msgid "Modules"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:385
msgid ""
"Don't start modules with license/authors/descriptions, you can write it "
"in LICENSE/AUTHORS/README files. For writing modules use one of the two "
"patterns (dont use ``modules()``):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:389
msgid ""
"local M = {}\n"
"\n"
"function M.foo()\n"
"...\n"
"end\n"
"\n"
"function M.bar()\n"
"...\n"
"end\n"
"\n"
"return M"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:405
msgid ""
"local function foo()\n"
"...\n"
"end\n"
"\n"
"local function bar()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"foo = foo,\n"
"bar = bar,\n"
"}"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:422
msgid "Commenting"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:424
msgid ""
"You should write code the way it shouldn't be described, but don't forget"
" about commenting it. You shouldn't comment Lua syntax (assume that "
"reader already knows Lua language). Try to tell about functions/variable "
"names/etc."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:428
msgid ""
"Multiline comments: use matching (``--[[ ]]--``) instead of simple "
"(``--[[ ]]``)."
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:431
msgid "Public function comments (??):"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:433
msgid ""
"--- Copy any table (shallow and deep version)\n"
"-- * deepcopy: copies all levels\n"
"-- * shallowcopy: copies only first level\n"
"-- Supports __copy metamethod for copying custom tables with metatables\n"
"-- @function gsplit\n"
"-- @table         inp  original table\n"
"-- @shallow[opt]  sep  flag for shallow copy\n"
"-- @returns            table (copy)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:446
msgid "Testing"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:448
msgid "Use ``tap`` module for writing efficient tests. Example of test file:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:450
msgid ""
"#!/usr/bin/env tarantool\n"
"\n"
"local test = require('tap').test('table')\n"
"test:plan(31)\n"
"\n"
"do -- check basic table.copy (deepcopy)\n"
"    local example_table = {\n"
"        {1, 2, 3},\n"
"        {\"help, I'm very nested\", {{{ }}} }\n"
"    }\n"
"\n"
"    local copy_table = table.copy(example_table)\n"
"\n"
"    test:is_deeply(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that deepcopy behaves ok\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table,\n"
"        copy_table,\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[1],\n"
"        copy_table[1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2],\n"
"        copy_table[2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2],\n"
"        copy_table[2][2],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"    test:isnt(\n"
"        example_table[2][2][1],\n"
"        copy_table[2][2][1],\n"
"        \"checking, that tables are different\"\n"
"    )\n"
"end\n"
"\n"
"<...>\n"
"\n"
"os.exit(test:check() == true and 0 or 1)"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:501
msgid "When you'll test your code output will be something like this:"
msgstr ""

#: ../doc/1.7/dev_guide/lua_style_guide.rst:503
msgid ""
"TAP version 13\n"
"1..31\n"
"ok - checking, that deepcopy behaves ok\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"ok - checking, that tables are different\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:31
msgid "Python Style Guide"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:35
msgid "Introduction"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:37
msgid ""
"This document gives coding conventions for the Python code comprising the"
" standard library in the main Python distribution.  Please see the "
"companion informational PEP describing style guidelines for the C code in"
" the C implementation of Python [1]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:42
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from "
"Guido's original Python Style Guide essay, with some additions from "
"Barry's style guide [2]_."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:49
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:51
msgid ""
"One of Guido's key insights is that code is read much more often than it "
"is written.  The guidelines provided here are intended to improve the "
"readability of code and make it consistent across the wide spectrum of "
"Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:56
msgid ""
"A style guide is about consistency.  Consistency with this style guide is"
" important.  Consistency within a project is more important. Consistency "
"within one module or function is the most important."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:60
msgid ""
"But most importantly: know when to be inconsistent -- sometimes the style"
" guide just doesn't apply.  When in doubt, use your best judgment.  Look "
"at other examples and decide what looks best.  And don't hesitate to ask!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:65
msgid "Two good reasons to break a particular rule:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:67
msgid ""
"When applying the rule would make the code less readable, even for "
"someone who is used to reading code that follows the rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:70
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for "
"historic reasons) -- although this is also an opportunity to clean up "
"someone else's mess (in true XP style)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:77
msgid "Code lay-out"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:81
msgid "Indentation"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:83
msgid "Use 4 spaces per indentation level."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:85
msgid ""
"For really old code that you don't want to mess up, you can continue to "
"use 8-space tabs."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:88
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, "
"or using a hanging indent.  When using a hanging indent the following "
"considerations should be applied; there should be no arguments on the "
"first line and further indentation should be used to clearly distinguish "
"itself as a continuation line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:95
#: ../doc/1.7/dev_guide/python_style_guide.rst:352
#: ../doc/1.7/dev_guide/python_style_guide.rst:381
#: ../doc/1.7/dev_guide/python_style_guide.rst:400
#: ../doc/1.7/dev_guide/python_style_guide.rst:413
msgid "Yes::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:97
msgid ""
"# Aligned with opening delimiter\n"
"foo = long_function_name(var_one, var_two,\n"
"                         var_three, var_four)\n"
"\n"
"# More indentation included to distinguish this from the rest.\n"
"def long_function_name(\n"
"        var_one, var_two, var_three,\n"
"        var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:107
#: ../doc/1.7/dev_guide/python_style_guide.rst:358
#: ../doc/1.7/dev_guide/python_style_guide.rst:389
#: ../doc/1.7/dev_guide/python_style_guide.rst:405
msgid "No::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:109
msgid ""
"# Arguments on first line forbidden when not using vertical alignment\n"
"foo = long_function_name(var_one, var_two,\n"
"    var_three, var_four)\n"
"\n"
"# Further indentation required as indentation is not distinguishable\n"
"def long_function_name(\n"
"    var_one, var_two, var_three,\n"
"    var_four):\n"
"    print(var_one)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:119
msgid "Optional::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:121
msgid ""
"# Extra indentation is not necessary.\n"
"foo = long_function_name(\n"
"  var_one, var_two,\n"
"  var_three, var_four)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:126
msgid ""
"The closing brace/bracket/parenthesis on multi-line constructs may either"
" line up under the first non-whitespace character of the last line of "
"list, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:130
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"    ]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
"    )"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:139
msgid ""
"or it may be lined up under the first character of the line that starts "
"the multi-line construct, as in::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:142
msgid ""
"my_list = [\n"
"    1, 2, 3,\n"
"    4, 5, 6,\n"
"]\n"
"result = some_function_that_takes_arguments(\n"
"    'a', 'b', 'c',\n"
"    'd', 'e', 'f',\n"
")"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:154
msgid "Tabs or Spaces?"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:156
msgid "Never mix tabs and spaces."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:158
msgid ""
"The most popular way of indenting Python is with spaces only.  The "
"second-most popular way is with tabs only.  Code indented with a mixture "
"of tabs and spaces should be converted to using spaces exclusively.  When"
" invoking the Python command line interpreter with the ``-t`` option, it "
"issues warnings about code that illegally mixes tabs and spaces.  When "
"using ``-tt`` these warnings become errors. These options are highly "
"recommended!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:166
msgid ""
"For new projects, spaces-only are strongly recommended over tabs. Most "
"editors have features that make this easy to do."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:171
msgid "Maximum Line Length"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:173
msgid "Limit all lines to a maximum of 79 characters."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:175
msgid ""
"There are still many devices around that are limited to 80 character "
"lines; plus, limiting windows to 80 characters makes it possible to have "
"several windows side-by-side.  The default wrapping on such devices "
"disrupts the visual structure of the code, making it more difficult to "
"understand.  Therefore, please limit all lines to a maximum of 79 "
"characters.  For flowing long blocks of text (docstrings or comments), "
"limiting the length to 72 characters is recommended."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:183
msgid ""
"The preferred way of wrapping long lines is by using Python's implied "
"line continuation inside parentheses, brackets and braces.  Long lines "
"can be broken over multiple lines by wrapping expressions in parentheses."
" These should be used in preference to using a backslash for line "
"continuation."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:189
msgid ""
"Backslashes may still be appropriate at times.  For example, long, "
"multiple ``with``-statements cannot use implicit continuation, so "
"backslashes are acceptable::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:193
msgid ""
"with open('/path/to/some/file/you/want/to/read') as file_1, \\\n"
"        open('/path/to/some/file/being/written', 'w') as file_2:\n"
"    file_2.write(file_1.read())"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:197
msgid "Another such case is with ``assert`` statements."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:199
msgid ""
"Make sure to indent the continued line appropriately.  The preferred "
"place to break around a binary operator is *after* the operator, not "
"before it.  Some examples::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:203
#, python-format
msgid ""
"class Rectangle(Blob):\n"
"\n"
"    def __init__(self, width, height,\n"
"                 color='black', emphasis=None, highlight=0):\n"
"        if (width == 0 and height == 0 and\n"
"            color == 'red' and emphasis == 'strong' or\n"
"            highlight > 100):\n"
"            raise ValueError(\"sorry, you lose\")\n"
"        if width == 0 and height == 0 and (color == 'red' or\n"
"                                           emphasis is None):\n"
"            raise ValueError(\"I don't think so -- values are %s, %s\" %\n"
"                             (width, height))\n"
"        Blob.__init__(self, width, height,\n"
"                      color, emphasis, highlight)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:220
msgid "Blank Lines"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:222
msgid "Separate top-level function and class definitions with two blank lines."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:225
msgid "Method definitions inside a class are separated by a single blank line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:228
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:232
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:234
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace;"
" Many tools treat these characters as page separators, so you may use "
"them to separate pages of related sections of your file. Note, some "
"editors and web-based code viewers may not recognize control-L as a form "
"feed and will show another glyph in its place."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:242
msgid "Encodings (PEP 263)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:244
msgid ""
"Code in the core Python distribution should always use the ASCII or "
"Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond, UTF-8 "
"is preferred over Latin-1, see PEP 3120."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:248
msgid ""
"Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8) "
"should only be used when a comment or docstring needs to mention an "
"author name that requires Latin-1; otherwise, using ``\\x``, ``\\u`` or "
"``\\U`` escapes is the preferred way to include non-ASCII data in string "
"literals."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:254
msgid ""
"For Python 3.0 and beyond, the following policy is prescribed for the "
"standard library (see PEP 3131): All identifiers in the Python standard "
"library MUST use ASCII-only identifiers, and SHOULD use English words "
"wherever feasible (in many cases, abbreviations and technical terms are "
"used which aren't English). In addition, string literals and comments "
"must also be in ASCII. The only exceptions are (a) test cases testing the"
" non-ASCII features, and (b) names of authors. Authors whose names are "
"not based on the latin alphabet MUST provide a latin transliteration of "
"their names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:265
msgid ""
"Open source projects with a global audience are encouraged to adopt a "
"similar policy."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:271
msgid "Imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:273
msgid "Imports should usually be on separate lines, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:280
msgid "It's okay to say this though::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:284
msgid ""
"Imports are always put at the top of the file, just after any module "
"comments and docstrings, and before module globals and constants."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:287
msgid "Imports should be grouped in the following order:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:289
msgid "standard library imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:290
msgid "related third party imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:291
msgid "local application/library specific imports"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:293
msgid "You should put a blank line between each group of imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:295
msgid "Put any relevant ``__all__`` specification after the imports."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:297
msgid ""
"Relative imports for intra-package imports are highly discouraged. Always"
" use the absolute package path for all imports.  Even now that PEP 328 is"
" fully implemented in Python 2.5, its style of explicit relative imports "
"is actively discouraged; absolute imports are more portable and usually "
"more readable."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:303
msgid ""
"When importing a class from a class-containing module, it's usually okay "
"to spell this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:309
msgid "If this spelling causes local name clashes, then spell them ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:314
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:319
msgid "Whitespace in Expressions and Statements"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:323
msgid "Pet Peeves"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:325
msgid "Avoid extraneous whitespace in the following situations:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:327
msgid "Immediately inside parentheses, brackets or braces. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:332
msgid "Immediately before a comma, semicolon, or colon::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:337
msgid ""
"Immediately before the open parenthesis that starts the argument list of "
"a function call::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:343
msgid ""
"Immediately before the open parenthesis that starts an indexing or "
"slicing::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:349
msgid ""
"More than one space around an assignment (or other) operator to align it "
"with another."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:367
msgid "Other Recommendations"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:369
msgid ""
"Always surround these binary operators with a single space on either "
"side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), "
"comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, "
"``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, "
"``not``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:375
msgid ""
"If operators with different priorities are used, consider adding "
"whitespace around the operators with the lowest priority(ies). Use your "
"own judgement; however, never use more than one space, and always have "
"the same amount of whitespace on both sides of a binary operator."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:397
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword "
"argument or a default parameter value."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:410
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:421
#: ../doc/1.7/dev_guide/python_style_guide.rst:430
msgid "Rather not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:426
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the"
" same line, never do this for multi-clause statements.  Also avoid "
"folding such long lines!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:436
msgid "Definitely not::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:451
msgid "Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:453
msgid ""
"Comments that contradict the code are worse than no comments.  Always "
"make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:457
msgid ""
"Comments should be complete sentences.  If a comment is a phrase or "
"sentence, its first word should be capitalized, unless it is an "
"identifier that begins with a lower case letter (never alter the case of "
"identifiers!)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:462
msgid ""
"If a comment is short, the period at the end can be omitted.  Block "
"comments generally consist of one or more paragraphs built out of "
"complete sentences, and each sentence should end in a period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:466
msgid "You should use two spaces after a sentence-ending period."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:468
msgid "When writing English, Strunk and White apply."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:470
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your "
"comments in English, unless you are 120% sure that the code will never be"
" read by people who don't speak your language."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:476
msgid "Block Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:478
msgid ""
"Block comments generally apply to some (or all) code that follows them, "
"and are indented to the same level as that code.  Each line of a block "
"comment starts with a ``#`` and a single space (unless it is indented "
"text inside the comment)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:483
msgid ""
"Paragraphs inside a block comment are separated by a line containing a "
"single ``#``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:488
msgid "Inline Comments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:490
msgid "Use inline comments sparingly."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:492
msgid ""
"An inline comment is a comment on the same line as a statement. Inline "
"comments should be separated by at least two spaces from the statement.  "
"They should start with a # and a single space."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:496
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the"
" obvious.  Don't do this::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:499
msgid "x = x + 1                 # Increment x"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:501
msgid "But sometimes, this is useful::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:503
msgid "x = x + 1                 # Compensate for border"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:507
msgid "Documentation Strings"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:509
msgid ""
"Conventions for writing good documentation strings (a.k.a. "
"\"docstrings\") are immortalized in PEP 257."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:512
msgid ""
"Write docstrings for all public modules, functions, classes, and methods."
"  Docstrings are not necessary for non-public methods, but you should "
"have a comment that describes what the method does.  This comment should "
"appear after the ``def`` line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:517
msgid ""
"PEP 257 describes good docstring conventions.  Note that most "
"importantly, the ``\"\"\"`` that ends a multiline docstring should be on "
"a line by itself, and preferably preceded by a blank line, e.g.::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:527
msgid ""
"For one liner docstrings, it's okay to keep the closing ``\"\"\"`` on the"
" same line."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:533
msgid "Version Bookkeeping"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:535
msgid ""
"If you have to have Subversion, CVS, or RCS crud in your source file, do "
"it as follows. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:538
msgid ""
"__version__ = \"$Revision$\"\n"
"# $Source$"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:541
msgid ""
"These lines should be included after the module's docstring, before any "
"other code, separated by a blank line above and below."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:547
msgid "Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:549
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll "
"never get this completely consistent -- nevertheless, here are the "
"currently recommended naming standards.  New modules and packages "
"(including third party frameworks) should be written to these standards, "
"but where an existing library has a different style, internal consistency"
" is preferred."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:558
msgid "Descriptive: Naming Styles"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:560
msgid ""
"There are a lot of different naming styles.  It helps to be able to "
"recognize what naming style is being used, independently from what they "
"are used for."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:564
msgid "The following naming styles are commonly distinguished:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:566
msgid "``b`` (single lowercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:567
msgid "``B`` (single uppercase letter)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:568
msgid "``lowercase``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:569
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:570
msgid "``UPPERCASE``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:571
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:572
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of "
"the bumpy look of its letters [3]_).  This is also sometimes known as "
"StudlyCaps."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:576
msgid ""
"Note: When using abbreviations in CapWords, capitalize all the letters of"
" the abbreviation.  Thus HTTPServerError is better than HttpServerError."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:579
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase "
"character!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:581
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:583
msgid ""
"There's also the style of using a short unique prefix to group related "
"names together.  This is not used much in Python, but it is mentioned for"
" completeness.  For example, the ``os.stat()`` function returns a tuple "
"whose items traditionally have names like ``st_mode``, ``st_size``, "
"``st_mtime`` and so on.  (This is done to emphasize the correspondence "
"with the fields of the POSIX system call struct, which helps programmers "
"familiar with that.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:591
msgid ""
"The X11 library uses a leading X for all its public functions.  In "
"Python, this style is generally deemed unnecessary because attribute and "
"method names are prefixed with an object, and function names are prefixed"
" with a module name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:596
msgid ""
"In addition, the following special forms using leading or trailing "
"underscores are recognized (these can generally be combined with any case"
" convention):"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:600
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. "
"``from M import *`` does not import objects whose name starts with an "
"underscore."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:604
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts "
"with Python keyword, e.g. ::"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:609
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes "
"name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; "
"see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:613
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or "
"attributes that live in user-controlled namespaces. E.g. ``__init__``, "
"``__import__`` or ``__file__``.  Never invent such names; only use them "
"as documented."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:620
msgid "Prescriptive: Naming Conventions"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:624
msgid "Names to Avoid"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:626
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter"
" oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:630
msgid ""
"In some fonts, these characters are indistinguishable from the numerals "
"one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:635
msgid "Package and Module Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:637
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used "
"in the module name if it improves readability.  Python packages should "
"also have short, all-lowercase names, although the use of underscores is "
"discouraged."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:642
msgid ""
"Since module names are mapped to file names, and some file systems are "
"case insensitive and truncate long names, it is important that module "
"names be chosen to be fairly short -- this won't be a problem on Unix, "
"but it may be a problem when the code is transported to older Mac or "
"Windows versions, or DOS."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:648
msgid ""
"When an extension module written in C or C++ has an accompanying Python "
"module that provides a higher level (e.g. more object oriented) "
"interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:655
msgid "Class Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:657
msgid ""
"Almost without exception, class names use the CapWords convention. "
"Classes for internal use have a leading underscore in addition."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:662
msgid "Exception Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:664
msgid ""
"Because exceptions should be classes, the class naming convention applies"
" here.  However, you should use the suffix \"Error\" on your exception "
"names (if the exception actually is an error)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:670
msgid "Global Variable Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:672
msgid ""
"(Let's hope that these variables are meant for use inside one module "
"only.)  The conventions are about the same as those for functions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:675
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older "
"convention of prefixing such globals with an underscore (which you might "
"want to do to indicate these globals are \"module non-public\")."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:683
msgid "Function Names"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:685
msgid ""
"Function names should be lowercase, with words separated by underscores "
"as necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:688
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing"
" style (e.g. threading.py), to retain backwards compatibility."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:694
msgid "Function and method arguments"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:696
msgid "Always use ``self`` for the first argument to instance methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:698
msgid "Always use ``cls`` for the first argument to class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:700
msgid ""
"If a function argument's name clashes with a reserved keyword, it is "
"generally better to append a single trailing underscore rather than use "
"an abbreviation or spelling corruption.  Thus ``class_`` is better than "
"``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:708
msgid "Method Names and Instance Variables"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:710
msgid ""
"Use the function naming rules: lowercase with words separated by "
"underscores as necessary to improve readability."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:713
msgid ""
"Use one leading underscore only for non-public methods and instance "
"variables."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:716
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to "
"invoke Python's name mangling rules."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:719
msgid ""
"Python mangles these names with the class name: if class Foo has an "
"attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An "
"insistent user could still gain access by calling ``Foo._Foo__a``.) "
"Generally, double leading underscores should be used only to avoid name "
"conflicts with attributes in classes designed to be subclassed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:725
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:729
msgid "Constants"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:731
msgid ""
"Constants are usually defined on a module level and written in all "
"capital letters with underscores separating words.  Examples include "
"``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:737
msgid "Designing for inheritance"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:739
msgid ""
"Always decide whether a class's methods and instance variables "
"(collectively: \"attributes\") should be public or non-public.  If in "
"doubt, choose non-public; it's easier to make it public later than to "
"make a public attribute non-public."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:744
msgid ""
"Public attributes are those that you expect unrelated clients of your "
"class to use, with your commitment to avoid backward incompatible "
"changes.  Non-public attributes are those that are not intended to be "
"used by third parties; you make no guarantees that non-public attributes "
"won't change or even be removed."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:750
msgid ""
"We don't use the term \"private\" here, since no attribute is really "
"private in Python (without a generally unnecessary amount of work)."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:753
msgid ""
"Another category of attributes are those that are part of the \"subclass "
"API\" (often called \"protected\" in other languages).  Some classes are "
"designed to be inherited from, either to extend or modify aspects of the "
"class's behavior.  When designing such a class, take care to make "
"explicit decisions about which attributes are public, which are part of "
"the subclass API, and which are truly only to be used by your base class."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:761
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:763
msgid "Public attributes should have no leading underscores."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:765
msgid ""
"If your public attribute name collides with a reserved keyword, append a "
"single trailing underscore to your attribute name.  This is preferable to"
" an abbreviation or corrupted spelling.  (However, not withstanding this "
"rule, 'cls' is the preferred spelling for any variable or argument which "
"is known to be a class, especially the first argument to a class method.)"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:773
#: ../doc/1.7/dev_guide/python_style_guide.rst:784
#: ../doc/1.7/dev_guide/python_style_guide.rst:806
msgid "Note 1:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:773
msgid "See the argument name recommendation above for class methods."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:775
msgid ""
"For simple public data attributes, it is best to expose just the "
"attribute name, without complicated accessor/mutator methods.  Keep in "
"mind that Python provides an easy path to future enhancement, should you "
"find that a simple data attribute needs to grow functional behavior.  In "
"that case, use properties to hide functional implementation behind simple"
" data attribute access syntax."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:784
msgid "Properties only work on new-style classes."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:788
#: ../doc/1.7/dev_guide/python_style_guide.rst:811
msgid "Note 2:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:787
msgid ""
"Try to keep the functional behavior side-effect free, although side-"
"effects such as caching are generally fine."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:793
#: ../doc/1.7/dev_guide/python_style_guide.rst:816
msgid "Note 3:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:791
msgid ""
"Avoid using properties for computationally expensive operations; the "
"attribute notation makes the caller believe that access is (relatively) "
"cheap."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:795
msgid ""
"If your class is intended to be subclassed, and you have attributes that "
"you do not want subclasses to use, consider naming them with double "
"leading underscores and no trailing underscores.  This invokes Python's "
"name mangling algorithm, where the name of the class is mangled into the "
"attribute name.  This helps avoid attribute name collisions should "
"subclasses inadvertently contain attributes with the same name."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:804
msgid ""
"Note that only the simple class name is used in the mangled name, so if a"
" subclass chooses both the same class name and attribute name, you can "
"still get name collisions."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:809
msgid ""
"Name mangling can make certain uses, such as debugging and "
"``__getattr__()``, less convenient.  However the name mangling algorithm "
"is well documented and easy to perform manually."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:814
msgid ""
"Not everyone likes name mangling.  Try to balance the need to avoid "
"accidental name clashes with potential use by advanced callers."
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:820
msgid "References"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:822
msgid ""
"`PEP 7, Style Guide for C Code, van Rossum "
"<https://www.python.org/dev/peps/pep-0007/>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:823
msgid ""
"`Barry's GNU Mailman style guide "
"<http://barry.warsaw.us/software/STYLEGUIDE.txt>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:824
msgid "`CamelCase Wikipedia page <http://www.wikipedia.com/wiki/CamelCase>`_"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:828
msgid "Copyright"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:830
msgid "Author:"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:832
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/python_style_guide.rst:833
msgid "Barry Warsaw <barry@python.org>"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:31
#: ../doc/1.7/reference/reference_lua/box.rst:33
msgid "Module `box`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:35
msgid "Opaque structure passed to the stored C procedure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:39
msgid "Return a tuple from stored C procedure."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:41
msgid "Returned tuple is automatically reference counted by Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:43
msgid "an opaque structure passed to the stored C procedure by Tarantool"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:45
msgid "a tuple to return"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst
#: ../doc/1.7/dev_guide/reference_capi/coio.rst
#: ../doc/1.7/dev_guide/reference_capi/error.rst
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst
#: ../doc/1.7/dev_guide/reference_capi/latch.rst
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst
#: ../doc/1.7/dev_guide/reference_capi/txn.rst
#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "Returns"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:47
msgid ""
"-1 on error (perhaps, out of memory; check :ref:`box_error_last()<c_api-"
"error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:49
#: ../doc/1.7/dev_guide/reference_capi/box.rst:97
#: ../doc/1.7/dev_guide/reference_capi/box.rst:112
#: ../doc/1.7/dev_guide/reference_capi/box.rst:128
#: ../doc/1.7/dev_guide/reference_capi/box.rst:150
#: ../doc/1.7/dev_guide/reference_capi/box.rst:172
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:85
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:98
msgid "0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:55
msgid "Find space id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:57
msgid "This function performs SELECT request to _vspace system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:59
msgid "space name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:60
#: ../doc/1.7/dev_guide/reference_capi/box.rst:74
msgid "length of ``name``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:62
#: ../doc/1.7/dev_guide/reference_capi/box.rst:76
msgid ""
":c:macro:`BOX_ID_NIL` on error or if not found (check "
":ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:64
#: ../doc/1.7/dev_guide/reference_capi/box.rst:78
msgid "space_id otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:66
msgid "See also: :c:type:`box_index_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:70
msgid "Find index id by name."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:72
#: ../doc/1.7/dev_guide/reference_capi/box.rst:90
#: ../doc/1.7/dev_guide/reference_capi/box.rst:105
#: ../doc/1.7/dev_guide/reference_capi/box.rst:120
#: ../doc/1.7/dev_guide/reference_capi/box.rst:136
#: ../doc/1.7/dev_guide/reference_capi/box.rst:158
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:113
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:152
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:162
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:172
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:191
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:207
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:223
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:239
msgid "space identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:73
msgid "index name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:80
msgid "This function performs SELECT request to _vindex system space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:82
msgid "See also: :c:type:`box_space_id_by_name`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:88
msgid "Execute an INSERT/REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:91
#: ../doc/1.7/dev_guide/reference_capi/box.rst:106
#: ../doc/1.7/dev_guide/reference_capi/box.rst:160
msgid "encoded tuple in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:92
#: ../doc/1.7/dev_guide/reference_capi/box.rst:107
#: ../doc/1.7/dev_guide/reference_capi/box.rst:161
msgid "end of a ``tuple``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:93
#: ../doc/1.7/dev_guide/reference_capi/box.rst:108
msgid "output argument. Resulted tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:96
#: ../doc/1.7/dev_guide/reference_capi/box.rst:111
#: ../doc/1.7/dev_guide/reference_capi/box.rst:127
#: ../doc/1.7/dev_guide/reference_capi/box.rst:149
msgid "-1 on error (check :ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:99
msgid "See also :ref:`space_object.insert()<box_space-insert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:103
msgid "Execute an REPLACE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:114
msgid "See also :ref:`space_object.replace()<box_space-replace>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:118
msgid "Execute an DELETE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:121
#: ../doc/1.7/dev_guide/reference_capi/box.rst:137
#: ../doc/1.7/dev_guide/reference_capi/box.rst:159
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:114
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:153
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:163
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:173
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:192
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:208
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:224
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:240
msgid "index identifier"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:122
#: ../doc/1.7/dev_guide/reference_capi/box.rst:138
msgid "encoded key in MsgPack Array format ([ field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:123
#: ../doc/1.7/dev_guide/reference_capi/box.rst:139
msgid "end of a ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:124
#: ../doc/1.7/dev_guide/reference_capi/box.rst:146
#: ../doc/1.7/dev_guide/reference_capi/box.rst:168
msgid "output argument. Result an old tuple. Can be set to NULL to discard result"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:130
msgid "See also :ref:`space_object.delete()<box_space-delete>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:134
msgid "Execute an UPDATE request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:140
#: ../doc/1.7/dev_guide/reference_capi/box.rst:162
msgid ""
"encoded operations in MsgPack Arrat format, e.g. ``[[ '=', field_id,  "
"value ], ['!', 2, 'xxx']]``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:142
#: ../doc/1.7/dev_guide/reference_capi/box.rst:164
msgid "end of a ``ops``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:143
#: ../doc/1.7/dev_guide/reference_capi/box.rst:165
msgid ""
"0 if field_ids in update operation are zero-based indexed (like C) or 1 "
"if for one-based indexed field ids (like Lua)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:152
msgid "See also :ref:`space_object.update()<box_space-update>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:156
msgid "Execute an UPSERT request."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:171
msgid "-1 on error (check ::ref:`box_error_last()<c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box.rst:174
msgid "See also :ref:`space_object.upsert()<box_space-upsert>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:31
msgid "Module `index`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:35
msgid "A space iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:41
msgid ""
"Controls how to iterate over tuples in an index. Different index types "
"support different iterator types. For example, one can start iteration "
"from a particular value (request key) and then retrieve all tuples where "
"keys are greater or equal (= GE) to this key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:46
msgid ""
"If iterator type is not supported by the selected index type, iterator "
"constructor must fail with ER_UNSUPPORTED. To be selectable for primary "
"key, an index must support at least ITER_EQ and ITER_GE types."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:50
msgid ""
"NULL value of request key corresponds to the first or last key in the "
"index, depending on iteration direction. (first key for GE and GT types, "
"and last key for LE and LT). Therefore, to iterate over all tuples in an "
"index, one can use ITER_GE or ITER_LE iteration types with start key "
"equal to NULL. For ITER_EQ, the key must not be NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:58
msgid "key == x ASC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:62
msgid "key == x DESC order"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:66
msgid "all tuples"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:70
msgid "key < x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:74
msgid "key <= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:78
msgid "key >= x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:82
msgid "key > x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:86
msgid "all bits from x are set in key"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:90
msgid "at least one x's bit is set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:94
msgid "all bits are not set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:98
msgid "key overlaps x"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:102
msgid "tuples in distance ascending order from specified point"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:108
msgid "Allocate and initialize iterator for space_id, index_id."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:110
msgid ""
"The returned iterator must be destroyed by :ref:`box_iterator_free<c_api-"
"box_index-box_iterator_free>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:115
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:241
msgid ":ref:`iterator_type<c_api-box_index-iterator_type>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:116
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:193
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:209
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:225
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:242
msgid "encode key in MsgPack Array format ([part1, part2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:117
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:194
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:210
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:226
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:243
msgid "the end of encoded ``key``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:119
msgid "NULL on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:120
msgid "iterator otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:122
msgid ""
"See also :ref:`box_iterator_next<c_api-box_index-box_iterator_next>`, "
":ref:`box_iterator_free<c_api-box_index-box_iterator_free>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:129
msgid "Retrieve the next item from the ``iterator``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:131
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:145
msgid ""
"an iterator returned by :ref:box_index_iterator`c_api-box_index-"
"box_index_iterator>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:133
msgid "output argument. result a tuple or NULL if there is no more data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:136
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:155
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:165
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:198
msgid "-1 on error (check :ref:box_error_last`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:137
msgid "0 on success. The end of data is not an error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:143
msgid "Destroy and deallocate iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:150
msgid "Return the number of element in the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:156
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:166
msgid ">= 0 otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:160
msgid "Return the number of bytes used in memory by the index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:170
msgid "Return a random tuple from the index (useful for statistical analysis)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:174
msgid "random seed"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:175
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:195
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:211
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:227
msgid "output argument. result a tuple or NULL if there is no tuples in space"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:178
msgid "See also: :ref:`index_object.random<box_index-random>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:184
msgid "Get a tuple from index by the key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:186
msgid ""
"Please note that this function works much more faster than "
":ref:`index_object.select<box_index-select>` or :ref:`box_index_iterator"
"<c_api-box_index-box_index_iterator>` + :ref:`box_iterator_next<c_api-"
"box_index-box_iterator_next>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:199
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:215
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:231
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:246
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:44
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:51
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:93
msgid "0 on success"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:201
msgid "See also: ``index_object.get()``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:205
msgid "Return a first (minimal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:214
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:230
#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:245
msgid "-1 on error (check :ref:box_error_last()`c_api-error-box_error_last>`)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:217
msgid "See also: :ref:`index_object.min()<box_index-min>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:221
msgid "Return a last (maximal) tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:233
msgid "See also: :ref:`index_object.max()<box_index-max>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:237
msgid "Count the number of tuple matched the provided key."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/box_index.rst:248
msgid "See also: :ref:`index_object.count()<box_index-count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/clock.rst:31
#: ../doc/1.7/reference/reference_lua/clock.rst:33
msgid "Module `clock`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:31
msgid "Module `coio`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:37
msgid "READ event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:41
msgid "WRITE event"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:45
msgid "Wait until READ or WRITE event on socket (``fd``). Yields."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:47
msgid "non-blocking socket file description"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:48
msgid ""
"requested events to wait. Combination of ``COIO_READ | COIO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:50
msgid "timeout in seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:52
msgid "0 - timeout"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:53
msgid ""
">0 - returned events. Combination of ``TNT_IO_READ | TNT_IO_WRITE`` bit "
"flags."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:57
msgid ""
"Create new eio task with specified function and arguments. Yield and wait"
" until the task is complete or a timeout occurs."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:60
msgid ""
"This function doesn't throw exceptions to avoid double error checking: in"
" most cases it's also necessary to check the return value of the called "
"function and perform necessary actions. If func sets errno, the errno is "
"preserved across the call."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:65
msgid "-1 and ``errno`` = ENOMEM if failed to create a task"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:66
msgid "the function return (``errno`` is preserved)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:70
msgid ""
"static ssize_t openfile_cb(va_list ap)\n"
"{\n"
"        const char* filename = va_arg(ap);\n"
"        int flags = va_arg(ap);\n"
"        return open(filename, flags);\n"
"}\n"
"\n"
"if (coio_call(openfile_cb, 0.10, \"/tmp/file\", 0) == -1)\n"
"    // handle errors.\n"
"..."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/coio.rst:86
msgid "Fiber-friendly version of :manpage:`getaddrinfo(3)`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:31
msgid "Module `error`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:157
msgid "Error - contains information about error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:161
msgid "Return the error type, e.g. \"ClientError\", \"SocketError\", etc."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:163
#: ../doc/1.7/dev_guide/reference_capi/error.rst:170
#: ../doc/1.7/dev_guide/reference_capi/error.rst:177
msgid "error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:164
#: ../doc/1.7/dev_guide/reference_capi/error.rst:178
msgid "not-null string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:168
msgid "Return IPROTO error code"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:171
msgid "enum :ref:`box_error_code <capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:175
msgid "Return the error message"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:184
msgid "Get the information about the last API call error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:186
msgid ""
"The Tarantool error handling works most like libc's errno. All API calls "
"return -1 or NULL in the event of error. An internal pointer to "
"box_error_t type is set by API functions to indicate what went wrong. "
"This value is only significant if API call failed (returned -1 or NULL)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:191
msgid ""
"Successful function can also touch the last error in some cases. You "
"don't have to clear the last error before calling API functions. The "
"returned object is valid only until next call to **any** API function."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:195
msgid ""
"You must set the last error using box_error_set() in your stored C "
"procedures if you want to return a custom error message. You can re-throw"
" the last API error to IPROTO client by keeping the current value and "
"returning -1 to Tarantool from your stored procedure."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:200
msgid "last error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:204
msgid "Clear the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:208
msgid "Set the last error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:212
msgid "IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:214
#: ../doc/1.7/dev_guide/reference_capi/say.rst:59
#: ../doc/1.7/dev_guide/reference_capi/say.rst:73
msgid "format arguments"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:216
msgid "See also: IPROTO :ref:`error code<capi-box_error_code>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/error.rst:220
msgid "A backward-compatible API define."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:31
#: ../doc/1.7/reference/reference_lua/fiber.rst:33
msgid "Module `fiber`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:35
msgid "Fiber - contains information about fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:41
msgid "Create a new fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:43
msgid ""
"Takes a fiber from fiber cache, if it's not empty. Can fail only if there"
" is not enough memory for the fiber structure or fiber stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:46
msgid ""
"The created fiber automatically returns itself to the fiber cache when "
"its \"main\" function completes."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:49
msgid "string with fiber name"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:50
msgid "func for run inside fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:52
msgid "See also: :ref:`fiber_start()<c_api-fiber-fiber_start>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:56
msgid "Return control to another fiber and wait until it'll be woken."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:58
msgid "See also: :ref:`fiber_wakeup()<c_api-fiber-fiber_wakeup>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:64
msgid "Start execution of created fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:66
msgid "fiber to start"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:67
msgid "arguments to start the fiber with"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:73
msgid "Interrupt a synchronous wait of a fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:75
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:111
msgid "fiber to be woken up"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:79
msgid "Cancel the subject fiber (set ``FIBER_IS_CANCELLED`` flag)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:81
msgid ""
"If target fiber's flag ``FIBER_IS_CANCELLABLE`` set, then it would be "
"woken up (maybe prematurely). Then current fiber yields until the target "
"fiber is dead (or is woken up by :ref:`fiber_wakeup()<c_api-fiber-"
"fiber_wakeup>`)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:85
msgid "fiber to be cancelled"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:89
msgid ""
"Make it possible or not possible to wakeup the current fiber immediately "
"when it's cancelled."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:92
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:103
msgid "fiber"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:93
#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:104
msgid "status to set"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:95
msgid "previous state"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:101
msgid "Set fiber to be joinable (``false`` by default)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:108
msgid ""
"Wait until the fiber is dead and then move its execution status to the "
"caller. The fiber must not be detached."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:113
msgid "Before: ``FIBER_IS_JOINABLE`` flag is set."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:115
msgid "See also: :ref:`fiber_set_joinable()<c_api-fiber-fiber_set_joinable>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:119
msgid "Put the current fiber to sleep for at least 's' seconds."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:121
msgid "time to sleep"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:123
msgid "Note: this is a cancellation point."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:125
msgid "See also: :ref:`fiber_is_cancelled()<c_api-fiber-fiber_is_cancelled>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:131
msgid "Check current fiber for cancellation (it must be checked manually)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:135
msgid "Report loop begin time as double (cheap)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:139
msgid "Report loop begin time as 64-bit int."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:143
msgid "Reschedule fiber to end of event loop cycle."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/fiber.rst:149
msgid "Return slab_cache suitable to use with ``tarantool/small`` library"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/index.rst:33
msgid "C API reference"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/index.rst:35
msgid "List of C API headers"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:31
msgid "Module `latch`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:35
msgid "A lock for cooperative multitasking environment"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:39
msgid "Allocate and initialize the new latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:41
msgid "allocated latch object"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
msgid "Return type"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:42
msgid "box_latch_t *"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:46
msgid "Destroy and free the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:48
msgid "latch to destroy"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:52
msgid ""
"Lock a latch. Waits indefinitely until the current fiber can gain access "
"to the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst
msgid "param box_latch_t* latch"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:55
#: ../doc/1.7/dev_guide/reference_capi/latch.rst:61
msgid "latch to lock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:59
msgid "Try to lock a latch. Return immediately if the latch is locked."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:62
msgid "status of operation. 0 - success, 1 - latch is locked"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:63
msgid "int"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:67
msgid "Unlock a latch. The fiber calling this function must own the latch."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/latch.rst:69
msgid "latch to unlock"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:31
msgid "Module `say` (logging)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:39
msgid "do not use this value directly"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:55
#: ../doc/1.7/dev_guide/reference_capi/say.rst:70
msgid "Format and print a message to Tarantool log file."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:57
msgid ":ref:`log level <c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:58
#: ../doc/1.7/dev_guide/reference_capi/say.rst:72
msgid "``printf()``-like format string"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:61
#: ../doc/1.7/dev_guide/reference_capi/say.rst:75
msgid "See also :manpage:`printf(3)`, :ref:`say_level<c_api-say-say_level>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/say.rst:79
#, python-format
msgid "say_info(\"Some useful information: %s\", status);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:31
msgid "Module `schema`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:39
msgid "Start of the reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:43
msgid "Space id of _schema."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:47
msgid "Space id of _space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:51
msgid "Space id of _vspace view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:55
msgid "Space id of _index."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:59
msgid "Space id of _vindex view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:63
msgid "Space id of _func."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:67
msgid "Space id of _vfunc view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:71
msgid "Space id of _user."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:75
msgid "Space id of _vuser view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:79
msgid "Space id of _priv."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:83
msgid "Space id of _vpriv view."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:87
msgid "Space id of _cluster."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:91
msgid "End of reserved range of system spaces."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/schema.rst:95
msgid "NULL value, returned on error."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:31
msgid "Module `trivia/config`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:35
msgid "Extern modifier for all public functions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:39
msgid "Package major version - 1 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:43
msgid "Package minor version - 7 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:47
msgid "Package patch version - 0 for 1.7.0."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:51
msgid ""
"A string with major-minor-patch-commit-id identifier of the release, e.g."
" 1.7.0-1216-g73f7154."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:56
msgid "System configuration dir (e.g ``/etc``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:60
msgid "Install prefix (e.g. ``/usr``)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:64
msgid "Build type, e.g. Debug or Release"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:68
msgid "CMake build type signature, e.g. ``Linux-x86_64-Debug``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:72
msgid "Command line used to run CMake."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:76
msgid "Pathes to C and CXX compilers."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:80
msgid "C compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:84
msgid "CXX compile flags used to build Tarantool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:88
msgid "A path to install ``*.lua`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:92
msgid "A path to install ``*.so``/``*.dylib`` module files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:96
msgid "A path to Lua includes (the same directory where this file is contained)"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:100
msgid ""
"A constant added to ``package.path`` in Lua to find ``*.lua`` module "
"files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/trivia.rst:104
msgid ""
"A constant added to ``package.cpath`` in Lua to find ``*.so`` module "
"files."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:31
msgid "Module `tuple`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:39
msgid "Tuple format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:41
msgid ""
"Each Tuple has associated format (class). Default format is used to "
"create tuples which are not attach to any particular space."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:52
msgid "Allocate and initialize a new tuple from a raw MsgPack Array data."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:54
msgid ""
"tuple format. Use :ref:`box_tuple_format_default()<c_api-tuple-"
"box_tuple_format_default>` to create space-independent tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:57
msgid "tuple data in MsgPack Array format ([field1, field2, ...])"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:58
msgid "the end of ``data``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:60
#: ../doc/1.7/dev_guide/reference_capi/txn.rst:65
msgid "NULL on out of memory"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:61
msgid "tuple otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:63
msgid "See also: :ref:`box.tuple.new()<box_tuple-new>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:69
msgid "Increase the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:71
msgid ""
"Tuples are reference counted. All functions that return tuples guarantee "
"that the last returned tuple is refcounted internally until the next call"
" to API function that yields or returns another tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:75
msgid ""
"You should increase the reference counter before taking tuples for long "
"processing in your code. Such tuples will not be garbage collected even "
"if another fiber remove they from space. After processing please "
"decrement the reference counter using :ref:`box_tuple_unref()<c_api-"
"tuple-box_tuple_unref>`, otherwise the tuple will leak."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:82
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:95
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:108
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:114
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:133
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:148
msgid "a tuple"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:84
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:97
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:126
msgid "-1 on error"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:87
msgid "See also: :ref:`box_tuple_unref()<c_api-tuple-box_tuple_unref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:93
msgid "Decrease the reference counter of tuple."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:100
msgid "See also: :ref:`box_tuple_ref()<c_api-tuple-box_tuple_ref>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:106
msgid "Return the number of fields in tuple (the size of MsgPack Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:112
msgid ""
"Return the number of bytes used to store internal tuple data (MsgPack "
"Array)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:118
msgid "Dump raw MsgPack data to the memory buffer ``buf`` of size ``size``."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:120
msgid "Store tuple fields in the memory buffer."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:122
msgid ""
"Upon successful return, the function returns the number of bytes written."
" If buffer size is not enough then the return value is the number of "
"bytes which would have been written if enough space had been available."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:127
msgid "number of bytes written on success."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:131
msgid "Return the associated format."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:135
msgid "tuple format"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:141
msgid ""
"Return the raw tuple field in MsgPack format. The result is a pointer to "
"raw MessagePack data which can be decoded with mp_decode functions, for "
"an example see the tutorial program :ref:`read.c <f_c_tutorial-read>`."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:146
msgid "The buffer is valid until next call to box_tuple_* functions."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:149
msgid "zero-based index in MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:151
msgid ""
"NULL if i >= :ref:`box_tuple_field_count()<c_api-tuple-"
"box_tuple_field_count>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:152
msgid "msgpack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:156
msgid "Tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:160
msgid ""
"Allocate and initialize a new tuple iterator. The tuple iterator allow to"
" iterate over fields at root level of MsgPack array."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:165
msgid ""
"box_tuple_iterator_t* it = box_tuple_iterator(tuple);\n"
"if (it == NULL) {\n"
"    // error handling using box_error_last()\n"
"}\n"
"const char* field;\n"
"while (field = box_tuple_next(it)) {\n"
"    // process raw MsgPack data\n"
"}\n"
"\n"
"// rewind iterator to first position\n"
"box_tuple_rewind(it)\n"
"assert(box_tuple_position(it) == 0);\n"
"\n"
"// rewind three fields\n"
"field = box_tuple_seek(it, 3);\n"
"assert(box_tuple_position(it) == 4);\n"
"\n"
"box_iterator_free(it);"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:188
msgid "Destroy and free tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:194
msgid ""
"Return zero-based next position in iterator. That is, this function "
"return the field id of field that will be returned by the next call to "
":ref:`box_tuple_next()<c_api-tuple-box_tuple_next>`. Returned value is "
"zero after initialization or rewind and :ref:`box_tuple_field_count"
"()<c_api-tuple-box_tuple_field_count>` after the end of iteration."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:201
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:208
#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:222
msgid "a tuple iterator"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:202
msgid "position"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:206
msgid "Rewind iterator to the initial position."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:210
msgid "After: ``box_tuple_position(it) == 0``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:214
msgid "Seek the tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:216
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with"
" mp_decode functions, for an example see the tutorial program "
":ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until "
"next call to box_tuple_* API. Requested field_no returned by next call to"
" box_tuple_next(it)."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:223
msgid "field number - zero-based position in MsgPack array"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:226
msgid "After:"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:228
msgid "``box_tuple_position(it) == field_not`` if returned value is not NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:229
msgid ""
"``box_tuple_position(it) == box_tuple_field_count(tuple)`` if returned "
"value is NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:236
msgid "Return the next tuple field from tuple iterator."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:238
msgid ""
"The result is a pointer to raw MessagePack data which can be decoded with"
" mp_decode functions, for an example see the tutorial program "
":ref:`read.c <f_c_tutorial-read>`. The returned buffer is valid until "
"next call to box_tuple_* API."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:244
msgid "NULL if there are no more fields"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:245
msgid "MsgPack otherwise"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:247
msgid ""
"Before: :ref:`box_tuple_position()<c_api-tuple-box_tuple_position>` is "
"zero-based ID of returned field."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/tuple.rst:250
msgid ""
"After: ``box_tuple_position(it) == box_tuple_field_count(tuple)`` if "
"returned value is NULL."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:31
msgid "Module `txn`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:35
msgid "Return true if there is an active transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:39
msgid "Begin a transaction in the current fiber."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:41
msgid ""
"A transaction is attached to caller fiber, therefore one fiber can have "
"only one active transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:45
msgid "-1 on error. Perhaps a transaction has already been started"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:49
msgid "Commit the current transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:52
msgid "-1 on error. Perhaps a disk write failure"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:56
msgid "Rollback the current transaction."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:60
msgid "Allocate memory on txn memory pool."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/txn.rst:62
msgid ""
"The memory is automatically deallocated when the transaction is committed"
" or rolled back."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:31
msgid "Module `lua/utils`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:37
msgid "Push cdata of given ``ctypeid`` onto the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:39
msgid ""
"CTypeID must be used from FFI at least once. Allocated memory returned "
"uninitialized. Only numbers and pointers are supported."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:42
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:55
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:70
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:77
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:90
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:102
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:109
msgid "Lua State"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:43
msgid "FFI's CTypeID of this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:45
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:59
msgid "memory associated with this cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:47
msgid "See also: :ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:53
msgid "Checks whether the function argument ``idx`` is a cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:56
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:71
msgid "stack index"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:57
msgid "output argument. FFI's CTypeID of returned cdata"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:61
msgid "See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:65
msgid "Sets finalizer function on a cdata object."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:67
msgid ""
"Equivalent to call `ffi.gc(obj, function)`. Finalizer function must be on"
" the top of the stack."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:75
msgid "Return CTypeID (FFI) of given СDATA type"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:78
msgid "C type name as string (e.g. \"struct request\" or \"uint32_t\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:81
msgid "CTypeID"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:83
msgid ""
"See also: :ref:`luaL_pushcdata()<c_api-utils-luaL_pushcdata>`, "
":ref:`luaL_checkcdata()<c_api-utils-luaL_checkcdata>`"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:88
msgid "Declare symbols for FFI"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:91
msgid "C definitions (e.g. \"struct stat\")"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:94
msgid "``LUA_ERRRUN``, ``LUA_ERRMEM` or ``LUA_ERRERR`` otherwise."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:96
msgid "See also: ``ffi.cdef(def)``"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:100
msgid "Push uint64_t onto the stack"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:103
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:110
msgid "value to push"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:107
msgid "Push int64_t onto the stack"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:114
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:128
msgid ""
"Checks whether the argument idx is a uint64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst
msgid "throws"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:117
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:124
msgid "error if the argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:121
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:135
msgid ""
"Checks whether the argument idx is a int64 or a convertable string and "
"returns this number."
msgstr ""

#: ../doc/1.7/dev_guide/reference_capi/utils.rst:131
#: ../doc/1.7/dev_guide/reference_capi/utils.rst:138
msgid "the converted number or 0 of argument can't be converted"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:31
msgid "Release management"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:34
msgid "How to make a minor release"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:36
msgid ""
"$ git tag -a 1.4.4 -m \"Next minor in 1.4 series\"\n"
"$ vim CMakeLists.txt # edit CPACK_PACKAGE_VERSION_PATCH\n"
"$ git push --tags"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:42
msgid "Update the Web site in doc/www"
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:44
msgid ""
"Update all issues, upload the ChangeLog based on ``git log`` output. The "
"ChangeLog must only include items which are mentioned as issues on "
"github. If anything significant is there, which is not mentioned, "
"something went wrong in release planning and the release should be held "
"up until this is cleared."
msgstr ""

#: ../doc/1.7/dev_guide/release_management.rst:50
msgid ""
"Click 'Release milestone'. Create a milestone for the next minor release."
" Alert the driver to target bugs and blueprints to the new milestone."
msgstr ""

#: ../doc/1.7/index.rst:34
msgid "Tarantool - Documentation"
msgstr ""

#: ../doc/1.7/index.rst:80
msgid ""
"Manual in other formats  Single page  PDF  Manual for other versions  "
"Tarantool 1.8  Tarantool 1.7  Tarantool 1.6  Other sources  Discussion "
"boards  English  Russian  Telegram chat  Документация находится в "
"процессе перевода и может отставать от английской версии.  This manual "
"embraces all aspects of using Tarantool: from introductory information "
"and exercises for beginners -- to advanced instructions and detailed "
"references for power users and contributors."
msgstr ""

#: ../doc/1.7/index.rst:48
msgid "Manual in other formats"
msgstr ""

#: ../doc/1.7/index.rst:48
msgid "`Single page <singlehtml.html>`_"
msgstr ""

#: ../doc/1.7/index.rst:49
msgid "`PDF <Tarantool.pdf>`_"
msgstr ""

#: ../doc/1.7/index.rst:52
msgid "Manual for other versions"
msgstr ""

#: ../doc/1.7/index.rst:51
msgid "`Tarantool 1.8 <../1.8/index.html>`_"
msgstr ""

#: ../doc/1.7/index.rst:52
msgid "`Tarantool 1.7 <../1.7/index.html>`_"
msgstr ""

#: ../doc/1.7/index.rst:53
msgid "`Tarantool 1.6 <../1.6/index.html>`_"
msgstr ""

#: ../doc/1.7/index.rst:57
msgid "Other sources"
msgstr ""

#: ../doc/1.7/index.rst:56
msgid "Discussion boards"
msgstr ""

#: ../doc/1.7/index.rst:56
msgid "`English`_"
msgstr ""

#: ../doc/1.7/index.rst:57
msgid "`Russian`_"
msgstr ""

#: ../doc/1.7/index.rst:58
msgid "`Telegram chat`_"
msgstr ""

#: ../doc/1.7/index.rst:71
msgid ""
"This manual embraces all aspects of using Tarantool: from introductory "
"information and exercises for beginners -- to advanced instructions and "
"detailed references for power users and contributors."
msgstr ""

#: ../doc/1.7/intro.rst:31
msgid "Overview"
msgstr ""

#: ../doc/1.7/intro.rst:35
msgid "An application server together with a database manager"
msgstr ""

#: ../doc/1.7/intro.rst:37
msgid ""
"Tarantool is a Lua application server integrated with a database "
"management system. It has a \"fiber\" model which means that many "
"Tarantool applications can run simultaneously on a single thread, while "
"each instance of the Tarantool server itself can run multiple threads for"
" input-output and background maintenance. It incorporates the LuaJIT -- "
"\"Just In Time\" -- Lua compiler, Lua libraries for most common "
"applications, and the Tarantool Database Server which is an established "
"NoSQL DBMS. Thus Tarantool serves all the purposes that have made node.js"
" and Twisted popular, plus it supports data persistence."
msgstr ""

#: ../doc/1.7/intro.rst:45
msgid ""
"The code is free. The open-source license is `BSD license`_. The "
"supported platforms are GNU/Linux, Mac OS and FreeBSD."
msgstr ""

#: ../doc/1.7/intro.rst:48
msgid ""
"Tarantool's creator and biggest user is `Mail.Ru`_, the largest internet "
"company in Russia, with 30 million users, 25 million emails per day, and "
"a web site whose Alexa global rank is in the `top 40`_ worldwide. "
"Tarantool services Mail.Ru's hottest data, such as the session data of "
"online users, the properties of online applications, the caches of the "
"underlying data, the distribution and sharding algorithms, and much more."
" Outside Mail.Ru the software is used by a growing number of projects in "
"online gaming, digital marketing, and social media industries. Although "
"Mail.Ru is the sponsor for product development, the roadmap and the bugs "
"database and the development process are fully open. The software "
"incorporates patches from dozens of community contributors. The Tarantool"
" community writes and maintains most of the drivers for programming "
"languages.  The greater Lua community has hundreds of useful packages "
"most of which can become Tarantool extensions."
msgstr ""

#: ../doc/1.7/intro.rst:62
msgid ""
"Users can create, modify and drop **Lua functions** at runtime. Or they "
"can define **Lua programs** that are loaded during startup for triggers, "
"background tasks, and interacting with networked peers. Unlike popular "
"application development frameworks based on a \"reactor\" pattern, "
"networking in server-side Lua is sequential, yet very efficient, as it is"
" built on top of the **cooperative multitasking** environment that "
"Tarantool itself uses."
msgstr ""

#: ../doc/1.7/intro.rst:70
msgid ""
"One of the built-in Lua packages provides an API for the Database "
"Management System. Thus some developers see Tarantool as a DBMS with a "
"popular stored procedure language, while others see it as a Lua "
"interpreter, while still others see it as a replacement for many "
"components of multi-tier Web applications. Performance can be a few "
"hundred thousand transactions per second on a laptop, scalable upwards or"
" outwards to server farms."
msgstr ""

#: ../doc/1.7/intro.rst:80
msgid "Database features"
msgstr ""

#: ../doc/1.7/intro.rst:82
msgid ""
"Tarantool can run without it, but \"The Box\" -- the DBMS server -- is a "
"strong distinguishing feature."
msgstr ""

#: ../doc/1.7/intro.rst:85
msgid ""
"The database API allows for permanently storing Lua objects, managing "
"object collections, creating or dropping secondary keys, making changes "
"atomically, configuring and monitoring replication, performing controlled"
" fail-over, and executing Lua code triggered by database events. Remote "
"database instances are accessible transparently via a remote-procedure-"
"invocation API."
msgstr ""

#: ../doc/1.7/intro.rst:93
msgid ""
"Tarantool's DBMS server uses the **storage engine** concept, where "
"different sets of algorithms and data structures can be used for "
"different situations. Two storage engines are built-in: an in-memory "
"engine which has all the data and indexes in RAM, and a two-level B-tree "
"engine for data sets whose size is 10 to 1000 times the amount of "
"available RAM. All storage engines in Tarantool support transactions and "
"replication by using a common **write ahead log** (WAL). This ensures "
"consistency and crash safety of the persistent state. Changes are not "
"considered complete until the WAL is written. The logging subsystem "
"supports group commit."
msgstr ""

#: ../doc/1.7/intro.rst:104
msgid ""
"**Tarantool's in-memory storage engine** (memtx) keeps all the data in "
"random-access memory, and therefore has very low read latency. It also "
"keeps persistent copies of the data in non-volatile storage, such as "
"disk, when users request \"snapshots\". If an instance of the server "
"stops and the random-access memory is lost, then restarts, it reads the "
"latest snapshot and then replays the transactions that are in the log -- "
"therefore no data is lost."
msgstr ""

#: ../doc/1.7/intro.rst:113
msgid ""
"**Tarantool's in-memory engine is lock-free** in typical situations. "
"Instead of the operating system's concurrency primitives, such as "
"mutexes, Tarantool uses cooperative multitasking to handle thousands of "
"connections simultaneously. There is a fixed number of independent "
"execution threads. The threads do not share state. Instead they exchange "
"data using low-overhead message queues. While this approach limits the "
"number of cores that the instance will use, it removes competition for "
"the memory bus and ensures peak scalability of memory access and network "
"throughput. CPU utilization of a typical highly-loaded Tarantool instance"
" is under 10%. Searches are possible via **secondary index keys** as well"
" as primary keys."
msgstr ""

#: ../doc/1.7/intro.rst:123
msgid ""
"**Tarantool's disk-based storage engine** is a fusion of ideas from "
"modern filesystems, log-structured merge trees and classical B-trees. All"
" data is organized into **ranges**. Each range is represented by a file "
"on disk. Range size is a configuration option and normally is around "
"64MB. Each range is a collection of pages, serving different purposes. "
"Pages in a fully merged range contain non-overlapping ranges of keys. A "
"range can be partially merged if there were a lot of changes in its key "
"range recently. In that case some pages represent new keys and values in "
"the range. The disk-based storage engine is append only: new data never "
"overwrites old data. The disk-based storage engine is named *vinyl*."
msgstr ""

#: ../doc/1.7/intro.rst:134
msgid ""
"Tarantool supports **multi-part index keys**. The possible index types "
"are HASH, TREE, BITSET, and RTREE."
msgstr ""

#: ../doc/1.7/intro.rst:137
msgid ""
"Tarantool supports **asynchronous replication**, locally or to remote "
"hosts. The replication architecture can be **master-master**, that is, "
"many nodes may both handle the loads and receive what others have "
"handled, for the same data sets."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:1
#: ../doc/1.7/reference/configuration/cfg_basic.rst:29
msgid ":ref:`background <cfg_basic-background>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:2
#: ../doc/1.7/reference/configuration/cfg_basic.rst:30
msgid ":ref:`custom_proc_title <cfg_basic-custom_proc_title>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:3
#: ../doc/1.7/reference/configuration/cfg_basic.rst:31
msgid ":ref:`listen <cfg_basic-listen>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:4
#: ../doc/1.7/reference/configuration/cfg_basic.rst:32
msgid ":ref:`memtx_dir <cfg_basic-memtx_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:5
#: ../doc/1.7/reference/configuration/cfg_basic.rst:33
msgid ":ref:`pid_file <cfg_basic-pid_file>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:6
#: ../doc/1.7/reference/configuration/cfg_basic.rst:34
msgid ":ref:`read_only <cfg_basic-read_only>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:7
#: ../doc/1.7/reference/configuration/cfg_basic.rst:35
msgid ":ref:`vinyl_dir <cfg_basic-vinyl_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:8
#: ../doc/1.7/reference/configuration/cfg_basic.rst:36
msgid ":ref:`vinyl_timeout <cfg_basic-vinyl_timeout>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:9
#: ../doc/1.7/reference/configuration/cfg_basic.rst:37
msgid ":ref:`username <cfg_basic-username>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:10
#: ../doc/1.7/reference/configuration/cfg_basic.rst:38
msgid ":ref:`wal_dir <cfg_basic-wal_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:11
#: ../doc/1.7/reference/configuration/cfg_basic.rst:39
msgid ":ref:`work_dir <cfg_basic-work_dir>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:17
#: ../doc/1.7/reference/configuration/cfg_basic.rst:45
msgid ""
"Run the server as a background task. The :ref:`log <cfg_logging-log>` and"
" :ref:`pid_file <cfg_basic-pid_file>` parameters must be non-null for "
"this to work."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:21
#: ../doc/1.7/reference/configuration/cfg_basic.rst:49
#: ../doc/1.7/reference/configuration/cfg_basic.rst:110
#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:15
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:43
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:25
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:53
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:66
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:46
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:74
#: ../doc/1.7/reference/configuration/cfg_logging.rst:115
#: ../doc/1.7/reference/configuration/cfg_logging.rst:143
msgid "Type: boolean"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:22
#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:26
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:54
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:47
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:75
msgid "Default: false"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:23
#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
#: ../doc/1.7/reference/configuration/cfg_basic.rst:113
#: ../doc/1.7/reference/configuration/cfg_basic.rst:124
#: ../doc/1.7/reference/configuration/cfg_basic.rst:149
#: ../doc/1.7/reference/configuration/cfg_basic.rst:152
#: ../doc/1.7/reference/configuration/cfg_basic.rst:163
#: ../doc/1.7/reference/configuration/cfg_basic.rst:177
#: ../doc/1.7/reference/configuration/cfg_basic.rst:188
#: ../doc/1.7/reference/configuration/cfg_basic.rst:191
#: ../doc/1.7/reference/configuration/cfg_basic.rst:216
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:17
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:30
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:45
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:58
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:73
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:101
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:27
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:55
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:57
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:85
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:110
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:123
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:138
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:48
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:76
#: ../doc/1.7/reference/configuration/cfg_logging.rst:103
#: ../doc/1.7/reference/configuration/cfg_logging.rst:117
#: ../doc/1.7/reference/configuration/cfg_logging.rst:131
#: ../doc/1.7/reference/configuration/cfg_logging.rst:145
#: ../doc/1.7/reference/configuration/cfg_storage.rst:27
#: ../doc/1.7/reference/configuration/cfg_storage.rst:38
#: ../doc/1.7/reference/configuration/cfg_storage.rst:50
#: ../doc/1.7/reference/configuration/cfg_storage.rst:55
#: ../doc/1.7/reference/configuration/cfg_storage.rst:62
#: ../doc/1.7/reference/configuration/cfg_storage.rst:66
#: ../doc/1.7/reference/configuration/cfg_storage.rst:72
#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:82
#: ../doc/1.7/reference/configuration/cfg_storage.rst:90
#: ../doc/1.7/reference/configuration/cfg_storage.rst:93
#: ../doc/1.7/reference/configuration/cfg_storage.rst:100
#: ../doc/1.7/reference/configuration/cfg_storage.rst:104
#: ../doc/1.7/reference/configuration/cfg_storage.rst:110
#: ../doc/1.7/reference/configuration/cfg_storage.rst:116
#: ../doc/1.7/reference/configuration/cfg_storage.rst:121
#: ../doc/1.7/reference/configuration/cfg_storage.rst:127
#: ../doc/1.7/reference/configuration/cfg_storage.rst:132
#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
#: ../doc/1.7/reference/configuration/cfg_storage.rst:144
#: ../doc/1.7/reference/configuration/cfg_storage.rst:149
#: ../doc/1.7/reference/configuration/cfg_storage.rst:155
#: ../doc/1.7/reference/configuration/cfg_storage.rst:166
#: ../doc/1.7/reference/configuration/cfg_storage.rst:177
msgid "Dynamic: no"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:29
#: ../doc/1.7/reference/configuration/cfg_basic.rst:57
msgid ""
"Add the given string to the server's process title (what’s shown in the "
"COMMAND column for ``ps -ef`` and ``top -c`` commands)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:33
#: ../doc/1.7/reference/configuration/cfg_basic.rst:61
msgid ""
"For example, ordinarily :samp:`ps -ef` shows the Tarantool server process"
" thus:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:36
#: ../doc/1.7/reference/configuration/cfg_basic.rst:64
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:13 tarantool <running>"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:41
#: ../doc/1.7/reference/configuration/cfg_basic.rst:69
msgid ""
"But if the configuration parameters include "
"``custom_proc_title='sessions'`` then the output looks like:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:44
#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
msgid ""
"$ ps -ef | grep tarantool\n"
"1000     14939 14188  1 10:53 pts/2    00:00:16 tarantool <running>: "
"sessions"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:49
#: ../doc/1.7/reference/configuration/cfg_basic.rst:77
#: ../doc/1.7/reference/configuration/cfg_basic.rst:83
#: ../doc/1.7/reference/configuration/cfg_basic.rst:94
#: ../doc/1.7/reference/configuration/cfg_basic.rst:111
#: ../doc/1.7/reference/configuration/cfg_basic.rst:122
#: ../doc/1.7/reference/configuration/cfg_basic.rst:147
#: ../doc/1.7/reference/configuration/cfg_basic.rst:150
#: ../doc/1.7/reference/configuration/cfg_basic.rst:161
#: ../doc/1.7/reference/configuration/cfg_basic.rst:175
#: ../doc/1.7/reference/configuration/cfg_basic.rst:186
#: ../doc/1.7/reference/configuration/cfg_basic.rst:189
#: ../doc/1.7/reference/configuration/cfg_basic.rst:214
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:59
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:87
#: ../doc/1.7/reference/configuration/cfg_logging.rst:101
#: ../doc/1.7/reference/configuration/cfg_logging.rst:129
#: ../doc/1.7/reference/configuration/cfg_replication.rst:31
#: ../doc/1.7/reference/configuration/cfg_replication.rst:59
msgid "Type: string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:50
#: ../doc/1.7/reference/configuration/cfg_basic.rst:72
#: ../doc/1.7/reference/configuration/cfg_basic.rst:78
#: ../doc/1.7/reference/configuration/cfg_basic.rst:95
#: ../doc/1.7/reference/configuration/cfg_basic.rst:100
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:148
#: ../doc/1.7/reference/configuration/cfg_basic.rst:176
#: ../doc/1.7/reference/configuration/cfg_basic.rst:187
#: ../doc/1.7/reference/configuration/cfg_basic.rst:215
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:44
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:102
#: ../doc/1.7/reference/configuration/cfg_logging.rst:130
#: ../doc/1.7/reference/configuration/cfg_networking.rst:14
#: ../doc/1.7/reference/configuration/cfg_networking.rst:42
#: ../doc/1.7/reference/configuration/cfg_replication.rst:32
#: ../doc/1.7/reference/configuration/cfg_replication.rst:60
msgid "Default: null"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:51
#: ../doc/1.7/reference/configuration/cfg_basic.rst:73
#: ../doc/1.7/reference/configuration/cfg_basic.rst:79
#: ../doc/1.7/reference/configuration/cfg_basic.rst:101
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_basic.rst:139
#: ../doc/1.7/reference/configuration/cfg_basic.rst:140
#: ../doc/1.7/reference/configuration/cfg_basic.rst:167
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:68
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:96
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:45
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:69
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:73
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:97
msgid "Dynamic: yes"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:57
#: ../doc/1.7/reference/configuration/cfg_basic.rst:85
msgid ""
"The read/write data port number or :ref:`URI <index-uri>` (Universal "
"Resource Identifier) string. Has no default value, so **must be "
"specified** if connections will occur from remote clients that do not use"
" the :ref:`“admin port” <admin-security>`. Connections made with "
":samp:`listen = {URI}` are called \"binary port\" or \"binary protocol\" "
"connections."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:64
#: ../doc/1.7/reference/configuration/cfg_basic.rst:92
msgid "A typical value is 3301."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:68
#: ../doc/1.7/reference/configuration/cfg_basic.rst:96
msgid ""
"A replica also binds to this port, and accepts connections, but these "
"connections can only serve reads until the replica becomes a master."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:71
#: ../doc/1.7/reference/configuration/cfg_basic.rst:99
msgid "Type: integer or string"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:79
#: ../doc/1.7/reference/configuration/cfg_basic.rst:107
msgid ""
"A directory where memtx stores snapshot (.snap) files. Can be relative to"
" :ref:`work_dir <cfg_basic-work_dir>`. If not specified, defaults to "
"``work_dir``. See also :ref:`wal_dir <cfg_basic-wal_dir>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:84
#: ../doc/1.7/reference/configuration/cfg_basic.rst:112
#: ../doc/1.7/reference/configuration/cfg_basic.rst:123
#: ../doc/1.7/reference/configuration/cfg_basic.rst:151
#: ../doc/1.7/reference/configuration/cfg_basic.rst:162
#: ../doc/1.7/reference/configuration/cfg_basic.rst:190
msgid "Default: \".\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:91
#: ../doc/1.7/reference/configuration/cfg_basic.rst:119
msgid ""
"Store the process id in this file. Can be relative to :ref:`work_dir "
"<cfg_basic-work_dir>`. A typical value is “:file:`tarantool.pid`”."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:102
#: ../doc/1.7/reference/configuration/cfg_basic.rst:130
msgid ""
"Say ``box.cfg{read_only=true...}`` to put the server instance in read-"
"only mode. After this, any requests that try to change persistent data "
"will fail with error :errcode:`ER_READONLY`. Read-only mode should be "
"used for master-replica :ref:`replication <replication>`. Read-only mode "
"does not affect data-change requests for spaces defined as "
":ref:`temporary <box_schema-space_create>`. Although read-only mode "
"prevents the server from writing to the :ref:`WAL <internals-wal>`, it "
"does not prevent writing diagnostics with the :ref:`log module <log-"
"module>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:118
#: ../doc/1.7/reference/configuration/cfg_basic.rst:146
msgid ""
"A directory where vinyl files or subdirectories will be stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. If not specified, "
"defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:130
#: ../doc/1.7/reference/configuration/cfg_basic.rst:158
msgid ""
"The vinyl storage engine has a scheduler which does compaction. When "
"vinyl is low on available memory, the compaction scheduler may be unable "
"to keep up with incoming update requests. In that situation, queries may "
"time out after ``vinyl_timeout`` seconds. This should rarely occur, since"
" normally vinyl would throttle inserts when it is running low on "
"compaction bandwidth."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:137
#: ../doc/1.7/reference/configuration/cfg_basic.rst:165
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:43
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:71
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:99
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:93
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:108
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:121
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:136
#: ../doc/1.7/reference/configuration/cfg_logging.rst:127
#: ../doc/1.7/reference/configuration/cfg_logging.rst:155
#: ../doc/1.7/reference/configuration/cfg_networking.rst:13
#: ../doc/1.7/reference/configuration/cfg_networking.rst:41
#: ../doc/1.7/reference/configuration/cfg_storage.rst:25
#: ../doc/1.7/reference/configuration/cfg_storage.rst:53
#: ../doc/1.7/reference/configuration/cfg_storage.rst:60
#: ../doc/1.7/reference/configuration/cfg_storage.rst:88
#: ../doc/1.7/reference/configuration/cfg_storage.rst:125
#: ../doc/1.7/reference/configuration/cfg_storage.rst:153
msgid "Type: float"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:138
#: ../doc/1.7/reference/configuration/cfg_basic.rst:166
msgid "Default: 60"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:145
#: ../doc/1.7/reference/configuration/cfg_basic.rst:173
msgid "UNIX user name to switch to after start."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:155
#: ../doc/1.7/reference/configuration/cfg_basic.rst:183
msgid ""
"A directory where write-ahead log (.xlog) files are stored. Can be "
"relative to :ref:`work_dir <cfg_basic-work_dir>`. Sometimes ``wal_dir`` "
"and :ref:`memtx_dir <cfg_basic-memtx_dir>` are specified with different "
"values, so that write-ahead log files and snapshot files can be stored on"
" different disks. If not specified, defaults to ``work_dir``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:169
#: ../doc/1.7/reference/configuration/cfg_basic.rst:197
msgid ""
"A directory where database working files will be stored. The server "
"instance switches to ``work_dir`` with :manpage:`chdir(2)` after start. "
"Can be relative to the current directory. If not specified, defaults to "
"the current directory. Other directory parameters may be relative to "
"``work_dir``, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:175
#: ../doc/1.7/reference/configuration/cfg_basic.rst:203
msgid ""
"box.cfg{\n"
"    work_dir = '/home/user/A',\n"
"    wal_dir = 'B',\n"
"    memtx_dir = 'C'\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_basic.rst:183
#: ../doc/1.7/reference/configuration/cfg_basic.rst:211
msgid ""
"will put xlog files in ``/home/user/A/B``, snapshot files in "
"``/home/user/A/C``, and all other files or subdirectories in "
"``/home/user/A``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:1
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:29
msgid ":ref:`force_recovery <cfg_binary_logging_snapshots-force_recovery>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:2
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:30
msgid ":ref:`rows_per_wal <cfg_binary_logging_snapshots-rows_per_wal>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:3
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:31
msgid ""
":ref:`snap_io_rate_limit <cfg_binary_logging_snapshots-"
"snap_io_rate_limit>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:4
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:32
msgid ":ref:`wal_mode <cfg_binary_logging_snapshots-wal_mode>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:5
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:33
msgid ""
":ref:`wal_dir_rescan_delay <cfg_binary_logging_snapshots-"
"wal_dir_rescan_delay>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:11
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:39
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start) or a write-ahead log file (at server instance start or to relay to"
" a replica), abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:16
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:44
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:56
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:67
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:84
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:95
#: ../doc/1.7/reference/configuration/cfg_logging.rst:116
#: ../doc/1.7/reference/configuration/cfg_logging.rst:144
msgid "Default: true"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:23
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:51
msgid ""
"How many log records to store in a single write-ahead log file. When this"
" limit is reached, Tarantool creates another WAL file named :samp"
":`{<first-lsn-in-wal>}.xlog`. This can be useful for simple rsync-based "
"backups."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:28
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:56
#: ../doc/1.7/reference/configuration/cfg_logging.rst:27
#: ../doc/1.7/reference/configuration/cfg_logging.rst:55
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
#: ../doc/1.7/reference/configuration/cfg_networking.rst:58
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:43
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:67
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:71
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:95
#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
#: ../doc/1.7/reference/configuration/cfg_storage.rst:48
#: ../doc/1.7/reference/configuration/cfg_storage.rst:64
#: ../doc/1.7/reference/configuration/cfg_storage.rst:70
#: ../doc/1.7/reference/configuration/cfg_storage.rst:76
#: ../doc/1.7/reference/configuration/cfg_storage.rst:80
#: ../doc/1.7/reference/configuration/cfg_storage.rst:91
#: ../doc/1.7/reference/configuration/cfg_storage.rst:98
#: ../doc/1.7/reference/configuration/cfg_storage.rst:102
#: ../doc/1.7/reference/configuration/cfg_storage.rst:108
#: ../doc/1.7/reference/configuration/cfg_storage.rst:114
#: ../doc/1.7/reference/configuration/cfg_storage.rst:119
#: ../doc/1.7/reference/configuration/cfg_storage.rst:130
#: ../doc/1.7/reference/configuration/cfg_storage.rst:136
#: ../doc/1.7/reference/configuration/cfg_storage.rst:142
#: ../doc/1.7/reference/configuration/cfg_storage.rst:147
#: ../doc/1.7/reference/configuration/cfg_storage.rst:164
#: ../doc/1.7/reference/configuration/cfg_storage.rst:175
msgid "Type: integer"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:29
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:57
msgid "Default: 500000"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:36
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:64
msgid ""
"Reduce the throttling effect of :ref:`box.snapshot <box-snapshot>` on "
"INSERT/UPDATE/DELETE performance by setting a limit on how many megabytes"
" per second it can write to disk. The same can be achieved by splitting "
":ref:`wal_dir <cfg_basic-wal_dir>` and :ref:`memtx_dir <cfg_basic-"
"memtx_dir>` locations and moving snapshots to a separate disk."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:45
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:61
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:73
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:89
#: ../doc/1.7/reference/configuration/cfg_logging.rst:29
#: ../doc/1.7/reference/configuration/cfg_logging.rst:57
#: ../doc/1.7/reference/configuration/cfg_logging.rst:129
#: ../doc/1.7/reference/configuration/cfg_logging.rst:157
#: ../doc/1.7/reference/configuration/cfg_networking.rst:15
#: ../doc/1.7/reference/configuration/cfg_networking.rst:32
#: ../doc/1.7/reference/configuration/cfg_networking.rst:43
#: ../doc/1.7/reference/configuration/cfg_networking.rst:60
#: ../doc/1.7/reference/configuration/cfg_replication.rst:33
#: ../doc/1.7/reference/configuration/cfg_replication.rst:61
msgid "Dynamic: **yes**"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:51
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:79
msgid "Specify fiber-WAL-disk synchronization mode as:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:53
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:81
msgid "``none``: write-ahead log is not maintained;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:54
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:82
msgid ""
"``write``: fibers wait for their data to be written to the write-ahead "
"log (no :manpage:`fsync(2)`);"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:56
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:84
msgid ""
"``fsync``: fibers wait for their data, :manpage:`fsync(2)` follows each "
":manpage:`write(2)`;"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:60
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:88
msgid "Default: \"write\""
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:67
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:95
msgid ""
"Number of seconds between periodic scans of the write-ahead-log file "
"directory, when checking for changes to write-ahead-log files for the "
"sake of replication or :ref:`hot standby <index-hot_standby>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:72
#: ../doc/1.7/reference/configuration/cfg_binary_logging_snapshots.rst:100
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:68
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:96
msgid "Default: 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:3
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:31
msgid "These parameters are deprecated since Tarantool version 1.7.4:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:5
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
msgid ":ref:`coredump <cfg_basic-coredump_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:6
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:34
msgid ":ref:`logger <cfg_logging-logger_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:7
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:35
msgid ":ref:`logger_nonblock <cfg_logging-logger_nonblock_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:8
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:36
msgid ""
":ref:`panic_on_snap_error <cfg_binary_logging_snapshots-"
"panic_on_snap_error_deprecated>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:9
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:37
msgid ""
":ref:`panic_on_wal_error <cfg_binary_logging_snapshots-"
"panic_on_wal_error_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:10
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:38
msgid ":ref:`replication_source <cfg_replication-replication_source_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:11
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:39
msgid ":ref:`slab_alloc_arena <cfg_storage-slab_alloc_arena_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:12
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:40
msgid ":ref:`slab_alloc_factor <cfg_storage-slab_alloc_factor_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:13
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
msgid ":ref:`slab_alloc_maximal <cfg_storage-slab_alloc_maximal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:14
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:42
msgid ":ref:`slab_alloc_minimal <cfg_storage-slab_alloc_minimal_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:15
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:43
msgid ":ref:`snap_dir <cfg_basic-snap_dir_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:16
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:44
msgid ":ref:`snapshot_count <cfg_checkpoint_daemon-snapshot_count_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:17
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:45
msgid ":ref:`snapshot_period <cfg_checkpoint_daemon-snapshot_period_deprecated>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:23
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:51
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:101
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:129
msgid "**Deprecated**, do not use."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:33
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:61
msgid ""
"**Deprecated** in favor of :ref:`log <cfg_logging-log>`. The parameter "
"was only renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:41
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:69
msgid ""
"**Deprecated** in favor of :ref:`log_nonblock <cfg_logging-"
"log_nonblock>`. The parameter was only renamed, while the type, values "
"and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:49
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:63
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:77
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:91
msgid ""
"**Deprecated** in favor of :ref:`force_recovery "
"<cfg_binary_logging_snapshots-force_recovery>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:52
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:80
msgid ""
"If there is an error while reading a snapshot file (at server instance "
"start), abort."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:74
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:102
msgid ""
"**Deprecated** in favor of :ref:`replication <cfg_replication-"
"replication>`. The parameter was only renamed, while the type, values and"
" semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:83
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:111
msgid "**Deprecated** in favor of :ref:`memtx_memory <cfg_storage-memtx_memory>`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:86
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:114
msgid ""
"How much memory Tarantool allocates to actually store tuples, **in "
"gigabytes**. When the limit is reached, INSERT or UPDATE requests begin "
"failing with error :errcode:`ER_MEMORY_ISSUE`. While the server does not "
"go beyond the defined limit to allocate tuples, there is additional "
"memory used to store indexes and connection information. Depending on "
"actual configuration and workload, Tarantool can consume up to 20% more "
"than the limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:94
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:122
msgid "Default: 1.0"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:103
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:131
msgid ""
"The multiplier for computing the sizes of memory chunks that tuples are "
"stored in. A lower value may result in less wasted memory depending on "
"the total amount of memory available and the distribution of item sizes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:109
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:137
msgid "Default: 1.1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:116
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:144
msgid ""
"**Deprecated** in favor of :ref:`memtx_max_tuple_size <cfg_storage-"
"memtx_max_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:125
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:153
msgid ""
"**Deprecated** in favor of :ref:`memtx_min_tuple_size <cfg_storage-"
"memtx_min_tuple_size>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:134
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:162
msgid ""
"**Deprecated** in favor of :ref:`memtx_dir <cfg_basic-memtx_dir>`. The "
"parameter was only renamed, while the type, values and semantics remained"
" intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:142
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:170
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_interval "
"<cfg_checkpoint_daemon-checkpoint_interval>`. The parameter was only "
"renamed, while the type, values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:151
#: ../doc/1.7/reference/configuration/cfg_deprecated.rst:179
msgid ""
"**Deprecated** in favor of :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>`. The parameter was only renamed, while the type, "
"values and semantics remained intact."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:3
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:31
msgid "Whether to start the server in **hot standby** mode."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:5
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:33
msgid ""
"Hot standby is a feature which provides a simple form of failover without"
" replication."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:8
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:36
msgid ""
"The expectation is that there will be two instances of the server using "
"the same configuration. The first one to start will be the \"primary\" "
"instance. The second one to start will be the \"standby\" instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:12
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:40
msgid ""
"To initiate the standby instance, start a second instance of the "
"Tarantool server on the same computer with the same :ref:`box.cfg "
"<box_introspection-box_cfg>` configuration settings -- including the same"
" directories and same non-null URIs -- and with the additional parameter "
"``hot_standby = true``. Expect to see a notification ending with the "
"words ``I> Entering hot standby mode``. This is fine. It means that the "
"standby instance is ready to take over if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:21
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:49
msgid ""
"The standby instance will initialize and will try to take a lock on "
":ref:`wal_dir <cfg_basic-wal_dir>`, but will fail because the primary "
"instance has made a lock on ``wal_dir``. So the standby instance goes "
"into a loop, reading the write ahead log which the primary instance is "
"writing (so the two instances are always in synch), and trying to take "
"the lock. If the primary instance goes down for any reason, the lock will"
" be released. in this case, the standby instance will succeed in taking "
"the lock, will connect on listen address and will become the primary "
"instance. Expect to see a notification ending with the words ``I> ready "
"to accept requests``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:33
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:61
msgid "Thus there is no noticeable downtime if the primary instance goes down."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:35
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:63
msgid "Hot standby feature has no effect:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:37
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:65
msgid ""
"if :ref:`wal_dir_rescan_delay = a large number "
"<cfg_binary_logging_snapshots-wal_dir_rescan_delay>` (on Mac OS and "
"FreeBSD); on these platforms, it is designed so that the loop repeats "
"every ``wal_dir_rescan_delay`` seconds."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:41
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:69
msgid ""
"if :ref:`wal_mode = 'none' <cfg_binary_logging_snapshots-wal_mode>`; it "
"is designed to work with ``wal_mode = 'write'`` or ``wal_mode = "
"'fsync'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:43
#: ../doc/1.7/reference/configuration/cfg_hot_standby.rst:71
msgid ""
"for spaces created with :ref:`engine = 'vinyl' <box_schema-"
"space_create>`; it is designed to work for spaces created with ``engine ="
" 'memtx'``."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:3
#: ../doc/1.7/reference/configuration/cfg_logging.rst:31
msgid ":ref:`log_level <cfg_logging-log_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:4
#: ../doc/1.7/reference/configuration/cfg_logging.rst:32
msgid ":ref:`log <cfg_logging-log>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:5
#: ../doc/1.7/reference/configuration/cfg_logging.rst:33
msgid ":ref:`log_nonblock <cfg_logging-log_nonblock>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:6
#: ../doc/1.7/reference/configuration/cfg_logging.rst:34
msgid ":ref:`too_long_threshold <cfg_logging-too_long_threshold>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:12
#: ../doc/1.7/reference/configuration/cfg_logging.rst:40
msgid "What level of detail the log will have. There are seven levels:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:14
#: ../doc/1.7/reference/configuration/cfg_logging.rst:42
msgid "1 – ``SYSERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:15
#: ../doc/1.7/reference/configuration/cfg_logging.rst:43
msgid "2 – ``ERROR``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:16
#: ../doc/1.7/reference/configuration/cfg_logging.rst:44
msgid "3 – ``CRITICAL``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:17
#: ../doc/1.7/reference/configuration/cfg_logging.rst:45
msgid "4 – ``WARNING``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:18
#: ../doc/1.7/reference/configuration/cfg_logging.rst:46
msgid "5 – ``INFO``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:19
#: ../doc/1.7/reference/configuration/cfg_logging.rst:47
msgid "6 – ``VERBOSE``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:20
#: ../doc/1.7/reference/configuration/cfg_logging.rst:48
msgid "7 – ``DEBUG``"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:22
#: ../doc/1.7/reference/configuration/cfg_logging.rst:50
msgid ""
"By setting log_level, one can enable logging of all classes below or "
"equal to the given level. Tarantool prints its logs to the standard error"
" stream by default, but this can be changed with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:28
#: ../doc/1.7/reference/configuration/cfg_logging.rst:56
msgid "Default: 5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:31
#: ../doc/1.7/reference/configuration/cfg_logging.rst:59
msgid ""
"Warning: prior to Tarantool 1.7.5 there were only six levels and "
"``DEBUG`` was level 6. Starting with Tarantool 1.7.5 ``VERBOSE`` is level"
" 6 and ``DEBUG`` is level 7. ``VERBOSE`` is a new level for monitoring "
"repetitive events which would cause too much log writing if ``INFO`` were"
" used instead."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:40
#: ../doc/1.7/reference/configuration/cfg_logging.rst:68
msgid ""
"By default, Tarantool sends the log to the standard error stream "
"(``stderr``). If ``log`` is specified, Tarantool sends the log to a file,"
" or to a pipe, or to the system logger."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:44
#: ../doc/1.7/reference/configuration/cfg_logging.rst:56
#: ../doc/1.7/reference/configuration/cfg_logging.rst:70
#: ../doc/1.7/reference/configuration/cfg_logging.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:84
#: ../doc/1.7/reference/configuration/cfg_logging.rst:98
msgid "Example setting:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:46
#: ../doc/1.7/reference/configuration/cfg_logging.rst:74
msgid ""
"box.cfg{log = 'tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'file: tarantool.log'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:52
#: ../doc/1.7/reference/configuration/cfg_logging.rst:80
msgid ""
"This will open the file ``tarantool.log`` for output on the server’s "
"default directory. If the ``log`` string has no prefix or has the prefix "
"\"file:\", then the string is interpreted as a file path."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:58
#: ../doc/1.7/reference/configuration/cfg_logging.rst:86
msgid ""
"box.cfg{log = '| cronolog tarantool.log'}\n"
"-- or\n"
"box.cfg{log = 'pipe: cronolog tarantool.log'}'"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:64
#: ../doc/1.7/reference/configuration/cfg_logging.rst:92
msgid ""
"This will start the program ``cronolog`` when the server starts, and will"
" send all log messages to the standard input (``stdin``) of cronolog. If "
"the ``log`` string begins with '|' or has the prefix \"pipe:\", then the "
"string is interpreted as a Unix `pipeline "
"<https://en.wikipedia.org/wiki/Pipeline_%28Unix%29>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:72
#: ../doc/1.7/reference/configuration/cfg_logging.rst:100
msgid ""
"box.cfg{log = 'syslog:identity=tarantool'}\n"
"-- or\n"
"box.cfg{log = 'syslog:facility=user'}\n"
"-- or\n"
"box.cfg{log = 'syslog:identity=tarantool,facility=user'}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:80
#: ../doc/1.7/reference/configuration/cfg_logging.rst:108
msgid ""
"If the ``log`` string has the prefix \"syslog:\", then the string is "
"interpreted as a message for the `syslogd <http://www.rfc-"
"base.org/txt/rfc-5424.txt>`_ program which normally is running in the "
"background of any Unix-like platform. One can optionally specify an "
"``identity``, a ``facility``, or both. The ``identity`` is an arbitrary "
"string, default value = ``tarantool``, which will be placed at the "
"beginning of all messages. The facility is an abbreviation for the name "
"of one of the `syslog <https://en.wikipedia.org/wiki/Syslog>`_ "
"facilities, default value = ``user``, which tell syslogd where the "
"message should go."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:91
#: ../doc/1.7/reference/configuration/cfg_logging.rst:119
msgid ""
"Possible values for ``facility`` are: auth, authpriv, cron, daemon, ftp, "
"kern, lpr, mail, news, security, syslog, user, uucp, local0, local1, "
"local2, local3, local4, local5, local6, local7."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:95
#: ../doc/1.7/reference/configuration/cfg_logging.rst:123
msgid ""
"The ``facility`` setting is currently ignored but will be used in the "
"future."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:97
#: ../doc/1.7/reference/configuration/cfg_logging.rst:125
msgid ""
"When logging to a file, Tarantool reopens the log on SIGHUP. When log is "
"a program, its pid is saved in the :ref:`log.logger_pid <log-logger_pid>`"
" variable. You need to send it a signal to rotate logs."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:109
#: ../doc/1.7/reference/configuration/cfg_logging.rst:137
msgid ""
"If ``log_nonblock`` equals true, Tarantool does not block on the log file"
" descriptor when it’s not ready for write, and drops the message instead."
" If :ref:`log_level <cfg_logging-log_level>` is high, and a lot of "
"messages go to the log file, setting ``log_nonblock`` to true may improve"
" logging performance at the cost of some log messages getting lost."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:123
#: ../doc/1.7/reference/configuration/cfg_logging.rst:151
msgid ""
"If processing a request takes longer than the given value (in seconds), "
"warn about it in the log. Has effect only if :ref:`log_level "
"<cfg_logging-log_level>` is more than or equal to 4 (WARNING)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:128
#: ../doc/1.7/reference/configuration/cfg_logging.rst:156
msgid "Default: 0.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:135
#: ../doc/1.7/reference/configuration/cfg_logging.rst:163
msgid "Logging example"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:137
#: ../doc/1.7/reference/configuration/cfg_logging.rst:165
msgid ""
"This will illustrate how \"rotation\" works, that is, what happens when "
"the server instance is writing to a log and signals are used when "
"archiving it."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:140
#: ../doc/1.7/reference/configuration/cfg_logging.rst:168
msgid "Start with two terminal shells, Terminal #1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:142
#: ../doc/1.7/reference/configuration/cfg_logging.rst:170
msgid ""
"On Terminal #1: start an interactive Tarantool session, then say the "
"logging will go to `Log_file`, then put a message \"Log Line #1\" in the "
"log file:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:145
#: ../doc/1.7/reference/configuration/cfg_logging.rst:173
msgid ""
"box.cfg{log='Log_file'}\n"
"log = require('log')\n"
"log.info('Log Line #1')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:151
#: ../doc/1.7/reference/configuration/cfg_logging.rst:179
msgid ""
"On Terminal #2: use ``mv`` so the log file is now named `Log_file.bak`. "
"The result of this is: the next log message will go to `Log_file.bak`."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:185
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1033
msgid "mv Log_file Log_file.bak"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:159
#: ../doc/1.7/reference/configuration/cfg_logging.rst:187
msgid "On Terminal #1: put a message \"Log Line #2\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:161
#: ../doc/1.7/reference/configuration/cfg_logging.rst:189
msgid "log.info('Log Line #2')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:165
#: ../doc/1.7/reference/configuration/cfg_logging.rst:193
msgid ""
"On Terminal #2: use ``ps`` to find the process ID of the Tarantool "
"instance."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:198
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1046
msgid "ps -A | grep tarantool"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:172
#: ../doc/1.7/reference/configuration/cfg_logging.rst:200
msgid ""
"On Terminal #2: use ``kill -HUP`` to send a SIGHUP signal to the "
"Tarantool instance. The result of this is: Tarantool will open `Log_file`"
" again, and the next log message will go to `Log_file`. (The same effect "
"could be accomplished by executing log.rotate() on the instance.)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:208
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1056
msgid "kill -HUP *process_id*"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:182
#: ../doc/1.7/reference/configuration/cfg_logging.rst:210
msgid "On Terminal #1: put a message \"Log Line #3\" in the log file."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:184
#: ../doc/1.7/reference/configuration/cfg_logging.rst:212
msgid "log.info('Log Line #3')"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:188
#: ../doc/1.7/reference/configuration/cfg_logging.rst:216
msgid ""
"On Terminal #2: use ``less`` to examine files. `Log_file.bak` will have "
"these lines, except that the date and time will depend on when the "
"example is done:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:222
#: ../doc/1.7/reference/configuration/cfg_logging.rst:1070
msgid ""
"2015-11-30 15:13:06.373 [27469] main/101/interactive I> Log Line #1`\n"
"2015-11-30 15:14:25.973 [27469] main/101/interactive I> Log Line #2`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:197
#: ../doc/1.7/reference/configuration/cfg_logging.rst:225
msgid "and `Log_file` will have"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_logging.rst:230 ../internal after
#: doc/1.7/reference/configuration/cfg_logging.rst:1078 padding
msgid ""
"log file has been reopened\n"
"2015-11-30 15:15:32.629 [27469] main/101/interactive I> Log Line #3"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:1
#: ../doc/1.7/reference/configuration/cfg_networking.rst:29
msgid ":ref:`io_collect_interval <cfg_networking-io_collect_interval>`,"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:2
#: ../doc/1.7/reference/configuration/cfg_networking.rst:30
msgid ":ref:`readahead <cfg_networking-readahead>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:8
#: ../doc/1.7/reference/configuration/cfg_networking.rst:36
msgid ""
"The instance will sleep for io_collect_interval seconds between "
"iterations of the event loop. Can be used to reduce CPU load in "
"deployments in which the number of client connections is large, but "
"requests are not so frequent (for example, each connection issues just a "
"handful of requests per second)."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:21
#: ../doc/1.7/reference/configuration/cfg_networking.rst:49
msgid ""
"The size of the read-ahead buffer associated with a client connection. "
"The larger the buffer, the more memory an active connection consumes and "
"the more requests can be read from the operating system buffer in a "
"single system call. The rule of thumb is to make sure the buffer can "
"contain at least a few dozen requests. Therefore, if a typical tuple in a"
" request is large, e.g. a few kilobytes or even megabytes, the read-ahead"
" buffer size should be increased. If batched request processing is not "
"used, it’s prudent to leave this setting at its default."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_networking.rst:31
#: ../doc/1.7/reference/configuration/cfg_networking.rst:59
msgid "Default: 16320"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:1
#: ../doc/1.7/reference/configuration/cfg_replication.rst:29
msgid ":ref:`replication <cfg_replication-replication>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:7
#: ../doc/1.7/reference/configuration/cfg_replication.rst:35
msgid ""
"If ``replication`` is not an empty string, the instance is considered to "
"be a Tarantool :ref:`replica <replication>`. The replica will try to "
"connect to the master specified in ``replication`` with a :ref:`URI "
"<index-uri>` (Universal Resource Identifier), for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:12
#: ../doc/1.7/reference/configuration/cfg_replication.rst:40
msgid ":samp:`{konstantin}:{secret_password}@{tarantool.org}:{3301}`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:14
#: ../doc/1.7/reference/configuration/cfg_replication.rst:42
msgid ""
"If there is more than one replication source in a replica set, specify an"
" array of URIs, for example: (replace 'uri' and 'uri2' in this example "
"with valid URIs):"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:17
#: ../doc/1.7/reference/configuration/cfg_replication.rst:45
msgid ":extsamp:`box.cfg{ replication = { {*{'uri1'}*}, {*{'uri2'}*} } }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:19
#: ../doc/1.7/reference/configuration/cfg_replication.rst:47
msgid ""
"If one of the URIs is \"self\" -- that is, if one of the URIs is for the "
"instance where ``box.cfg{}`` is being executed on -- then it is ignored. "
"Thus it is possible to use the same ``replication`` specification on "
"multiple servers."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:24
#: ../doc/1.7/reference/configuration/cfg_replication.rst:52
msgid ""
"The default user name is ‘guest’. A replica does not accept data-change "
"requests on the :ref:`listen <cfg_basic-listen>` port. The "
"``replication`` parameter is dynamic, that is, to enter master mode, "
"simply set ``replication`` to an empty string and issue:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_replication.rst:29
#: ../doc/1.7/reference/configuration/cfg_replication.rst:57
msgid ":extsamp:`box.cfg{ replication = {*{new-value}*} }`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:1
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:29
msgid ":ref:`checkpoint_count <cfg_checkpoint_daemon-checkpoint_count>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:2
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:30
msgid ":ref:`checkpoint_interval <cfg_checkpoint_daemon-checkpoint_interval>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:4
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:32
msgid ""
"The checkpoint daemon is a fiber which is constantly running. At "
"intervals, it may make new snapshot (.snap) files and then may delete old"
" snapshot files. If the checkpoint daemon deletes an old snapshot file, "
"then it will also delete any write-ahead log (.xlog) files which are "
"older than the snapshot file and which contain information that is "
"present in the snapshot file. It will also delete obsolete vinyl .run "
"files."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:11
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:39
msgid ""
"Exceptions: the checkpoint daemon will not delete a file if a backup is "
"ongoing and the file has not been backed up (see :ref:`\"Hot backup\" "
"<admin-backups-hot_backup_vinyl_memtx>`), or if replication is ongoing "
"and the file has not been relayed to a replica (see :ref:`\"Replication "
"architecture\" <replication-architecture>`), or if a replica is "
"connecting."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:18
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:46
msgid ""
"The :ref:`checkpoint_interval <cfg_checkpoint_daemon-"
"checkpoint_interval>` and :ref:`checkpoint_count <cfg_checkpoint_daemon-"
"checkpoint_count>` configuration settings determine how long the "
"intervals are, and how many snapshots should exist before deletions "
"occur."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:27
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:55
msgid ""
"The interval between actions by the checkpoint daemon, in seconds. If "
"``checkpoint_interval`` is set to a value greater than zero, and there is"
" activity which causes change to a database, then the checkpoint daemon "
"will call :ref:`box.snapshot <box-snapshot>` every "
"``checkpoint_interval`` seconds, creating a new snapshot file each time. "
"If ``checkpoint_interval`` is set to zero, then the checkpoint daemon is "
"disabled."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:36
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:64
msgid "box.cfg{checkpoint_interval=60}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:40
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:68
msgid ""
"will cause the checkpoint daemon to create a new database snapshot once "
"per minute, if there is activity."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:44
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:72
msgid "Default: 3600 (one hour)"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:51
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:79
msgid ""
"The maximum number of snapshots that may exist on the ``memtx_dir`` "
"directory before the checkpoint daemon will delete old snapshots. If "
"``checkpoint_count`` equals zero, then the checkpoint daemon does not "
"delete old snapshots. For example:"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:56
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:84
msgid ""
"box.cfg{\n"
"    checkpoint_interval = 3600,\n"
"    checkpoint_count  = 10\n"
"}"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:63
#: ../doc/1.7/reference/configuration/cfg_snapshot_daemon.rst:91
msgid ""
"will cause the checkpoint daemon to create a new snapshot each hour until"
" it has created ten snapshots. After that, it will delete the oldest "
"snapshot (and any associated write-ahead-log files) after creating a new "
"one."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:1
#: ../doc/1.7/reference/configuration/cfg_storage.rst:29
msgid ":ref:`memtx_memory <cfg_storage-memtx_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:2
#: ../doc/1.7/reference/configuration/cfg_storage.rst:30
msgid ":ref:`memtx_max_tuple_size <cfg_storage-memtx_max_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:3
#: ../doc/1.7/reference/configuration/cfg_storage.rst:31
msgid ":ref:`memtx_min_tuple_size <cfg_storage-memtx_min_tuple_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:4
#: ../doc/1.7/reference/configuration/cfg_storage.rst:32
msgid ":ref:`vinyl_bloom_fpr <cfg_storage-vinyl_bloom_fpr>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:5
#: ../doc/1.7/reference/configuration/cfg_storage.rst:33
msgid ":ref:`vinyl_cache <cfg_storage-vinyl_cache>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:6
#: ../doc/1.7/reference/configuration/cfg_storage.rst:34
msgid ":ref:`vinyl_memory <cfg_storage-vinyl_memory>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:7
#: ../doc/1.7/reference/configuration/cfg_storage.rst:35
msgid ":ref:`vinyl_page_size <cfg_storage-vinyl_page_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:8
#: ../doc/1.7/reference/configuration/cfg_storage.rst:36
msgid ":ref:`vinyl_range_size <cfg_storage-vinyl_range_size>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:9
#: ../doc/1.7/reference/configuration/cfg_storage.rst:37
msgid ":ref:`vinyl_run_count_per_level <cfg_storage-vinyl_run_count_per_level>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:10
#: ../doc/1.7/reference/configuration/cfg_storage.rst:38
msgid ":ref:`vinyl_run_size_ratio <cfg_storage-vinyl_run_size_ratio>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:11
#: ../doc/1.7/reference/configuration/cfg_storage.rst:39
msgid ":ref:`vinyl_read_threads <cfg_storage-vinyl_read_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:12
#: ../doc/1.7/reference/configuration/cfg_storage.rst:40
msgid ":ref:`vinyl_write_threads <cfg_storage-vinyl_write_threads>`"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:18
#: ../doc/1.7/reference/configuration/cfg_storage.rst:46
msgid ""
"How much memory Tarantool allocates to actually store tuples, in bytes. "
"When the limit is reached, INSERT or UPDATE requests begin failing with "
"error :errcode:`ER_MEMORY_ISSUE`. While the server does not go beyond the"
" defined limit to allocate tuples, there is additional memory used to "
"store indexes and connection information. Depending on actual "
"configuration and workload, Tarantool can consume up to 20% more than the"
" limit set here."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:26
#: ../doc/1.7/reference/configuration/cfg_storage.rst:54
msgid "Default: 256 * 1024 * 1024 = 268435456"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:33
#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
msgid ""
"Size of the largest allocation unit, in bytes. It can be increased if it "
"is necessary to store large tuples."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:37
#: ../doc/1.7/reference/configuration/cfg_storage.rst:65
msgid "Default: 1024 * 1024 = 1048576"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:44
#: ../doc/1.7/reference/configuration/cfg_storage.rst:72
msgid ""
"Size of the smallest allocation unit, in bytes. It can be decreased if "
"most of the tuples are very small. The value must be between 8 and "
"1048280 inclusive."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:49
#: ../doc/1.7/reference/configuration/cfg_storage.rst:77
msgid "Default: 16"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:56
#: ../doc/1.7/reference/configuration/cfg_storage.rst:84
msgid ""
"Bloom filter false positive rate -- the suitable probability of the bloom"
" filter to give a wrong result. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:61
#: ../doc/1.7/reference/configuration/cfg_storage.rst:89
msgid "Default = 0.05"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:68
#: ../doc/1.7/reference/configuration/cfg_storage.rst:96
msgid "The maximal cache size for vinyl, in bytes."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:71
#: ../doc/1.7/reference/configuration/cfg_storage.rst:81
#: ../doc/1.7/reference/configuration/cfg_storage.rst:99
#: ../doc/1.7/reference/configuration/cfg_storage.rst:109
msgid "Default = 128 * 1024 * 1024 = 134217728"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:78
#: ../doc/1.7/reference/configuration/cfg_storage.rst:106
msgid "The maximum number of in-memory bytes that vinyl uses."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:88
#: ../doc/1.7/reference/configuration/cfg_storage.rst:116
msgid ""
"Page size, in bytes. Page is a R/W unit for vinyl disk operations. This "
"can be overridden by a :ref:`create_index <box_space-create_index>` "
"option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:92
#: ../doc/1.7/reference/configuration/cfg_storage.rst:120
msgid "Default = 8 * 1024"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:99
#: ../doc/1.7/reference/configuration/cfg_storage.rst:127
msgid ""
"The maximal range size for vinyl, in bytes. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:103
#: ../doc/1.7/reference/configuration/cfg_storage.rst:131
msgid "Default = 1024 * 1024 * 1024"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:110
#: ../doc/1.7/reference/configuration/cfg_storage.rst:138
msgid ""
"The maximal number of runs per level in vinyl LSM tree. If this number is"
" exceeded, a new level is created. This can be overridden by a "
":ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:115
#: ../doc/1.7/reference/configuration/cfg_storage.rst:143
#: ../doc/1.7/reference/configuration/cfg_storage.rst:148
#: ../doc/1.7/reference/configuration/cfg_storage.rst:176
msgid "Default = 2"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:122
#: ../doc/1.7/reference/configuration/cfg_storage.rst:150
msgid ""
"Ratio between the sizes of different levels in the LSM tree. This can be "
"overridden by a :ref:`create_index <box_space-create_index>` option."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:126
#: ../doc/1.7/reference/configuration/cfg_storage.rst:154
msgid "Default = 3.5"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:133
#: ../doc/1.7/reference/configuration/cfg_storage.rst:161
msgid ""
"The maximum number of read threads that vinyl can use for some concurrent"
" operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:137
#: ../doc/1.7/reference/configuration/cfg_storage.rst:165
msgid "Default = 1"
msgstr ""

#: ../doc/1.7/reference/configuration/cfg_storage.rst:144
#: ../doc/1.7/reference/configuration/cfg_storage.rst:172
msgid ""
"The maximum number of write threads that vinyl can use for some "
"concurrent operations, such as I/O and compression."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:33
msgid "Configuration reference"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:35
msgid ""
"This reference covers all options and parameters which can be set for "
"Tarantool on the command line or in an :ref:`initialization file <index-"
"init_label>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:38
msgid "Tarantool is started by entering the following command:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:43
msgid ""
"$ **tarantool**\n"
"# OR\n"
"$ **tarantool** *options*\n"
"# OR\n"
"$ **tarantool** *lua-initialization-file* **[** *arguments* **]**"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:51
msgid "Command options"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:55
msgid "Print an annotated list of all available options and exit."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:61
msgid "Print product name and version, for example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:63
msgid ""
"$ ./tarantool --version\n"
"Tarantool 1.7.0-1216-g73f7154\n"
"Target: Linux-x86_64-Debug\n"
"..."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:70
msgid "In this example:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:72
msgid ""
"“Tarantool” is the name of the reusable asynchronous networking "
"programming framework."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:75
msgid ""
"The 3-number version follows the standard ``<major>-<minor>-<patch>`` "
"scheme, in which ``<major>`` number is changed only rarely, ``<minor>`` "
"is incremented for each new milestone and indicates possible incompatible"
" changes, and ``<patch>`` stands for the number of bug fix releases made "
"after the start of the milestone. For non-released versions only, there "
"may be a commit number and commit SHA1 to indicate how much this "
"particular build has diverged from the last release."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:83
msgid ""
"“Target” is the platform tarantool was built on. Some platform-specific "
"details may follow this line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:88
msgid ""
"Tarantool uses `git describe "
"<http://www.kernel.org/pub/software/scm/git/docs/git-describe.html>`_ to "
"produce its version id, and this id can be used at any time to check out "
"the corresponding source from our `git repository "
"<http://github.com/tarantool/tarantool.git>`_."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:98
msgid "URI"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:100
msgid ""
"Some configuration parameters and some functions depend on a URI, or "
"\"Universal Resource Identifier\". The URI string format is similar to "
"the `generic syntax for a URI schema "
"<http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax>`_. So it may "
"contain (in order) a user name for login, a password, a host name or host"
" IP address, and a port number. Only the port number is always mandatory."
" The password is mandatory if the user name is specified, unless the user"
" name is 'guest'. So, formally, the URI syntax is ``[host:]port`` or "
"``[username:password@]host:port``. If host is omitted, then '0.0.0.0' or "
"'[::]' is assumed, meaning respectively any IPv4 address or any IPv6 "
"address, on the local machine. If username:password is omitted, then "
"'guest' is assumed. Some examples:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:119
msgid "URI fragment"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:121
msgid "port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:121
msgid "3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:123
msgid "host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:123
msgid "127.0.0.1:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:125
msgid "username:password@host:port"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:125
msgid "notguest:sesame@mail.ru:3301"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:128
msgid ""
"In certain circumstances a Unix domain socket may be used where a URI is "
"expected, for example \"unix/:/tmp/unix_domain_socket.sock\" or simply "
"\"/tmp/unix_domain_socket.sock\"."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:132
msgid "A method for parsing URIs is illustrated in :ref:`Module uri <uri-parse>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:138
msgid "Initialization file"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:140
msgid ""
"If the command to start Tarantool includes :codeitalic:`lua-"
"initialization-file`, then Tarantool begins by invoking the Lua program "
"in the file, which by convention may have the name \"``script.lua``\". "
"The Lua program may get further arguments from the command line or may "
"use operating-system functions, such as ``getenv()``. The Lua program "
"almost always begins by invoking ``box.cfg()``, if the database server "
"will be used or if ports need to be opened. For example, suppose "
"``script.lua`` contains the lines"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:148
msgid ""
"#!/usr/bin/env tarantool\n"
"box.cfg{\n"
"    listen              = os.getenv(\"LISTEN_URI\"),\n"
"    slab_alloc_arena    = 0.1,\n"
"    pid_file            = \"tarantool.pid\",\n"
"    rows_per_wal        = 50\n"
"}\n"
"print('Starting ', arg[1])"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:159
msgid ""
"and suppose the environment variable LISTEN_URI contains 3301, and "
"suppose the command line is ``~/tarantool/src/tarantool script.lua ARG``."
" Then the screen might look like this:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:163
msgid ""
"$ export LISTEN_URI=3301\n"
"$ ~/tarantool/src/tarantool script.lua ARG\n"
"... main/101/script.lua C> version 1.7.0-1216-g73f7154\n"
"... main/101/script.lua C> log level 5\n"
"... main/101/script.lua I> mapping 107374184 bytes for a shared arena...\n"
"... main/101/script.lua I> recovery start\n"
"... main/101/script.lua I> recovering from './00000000000000000000.snap'\n"
"... main/101/script.lua I> primary: bound to 0.0.0.0:3301\n"
"... main/102/leave_local_hot_standby I> ready to accept requests\n"
"Starting  ARG\n"
"... main C> entering the event loop"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:177
msgid ""
"If you wish to start an interactive session on the same terminal after "
"initialization is complete, you can use :ref:`console.start() <console-"
"start>`."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:193
msgid "Configuration parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:195
msgid "Configuration parameters have the form:"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:197
msgid ":extsamp:`{**{box.cfg}**}{[{*{key = value}*} [, {*{key = value ...}*}]]}`"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:199
msgid ""
"Since ``box.cfg`` may contain many configuration parameters and since "
"some of the parameters (such as directory addresses) are semi-permanent, "
"it's best to keep ``box.cfg`` in a Lua file. Typically this Lua file is "
"the initialization file which is specified on the tarantool command line."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:204
msgid ""
"Most configuration parameters are for allocating resources, opening "
"ports, and specifying database behavior. All parameters are optional. A "
"few parameters are dynamic, that is, they can be changed at runtime by "
"calling ``box.cfg{}`` a second time."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:209
msgid ""
"To see all the non-null parameters, say ``box.cfg`` (no parentheses). To "
"see a particular parameter, for example the listen address, say "
"``box.cfg.listen``."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:212
msgid ""
"The following sections describe all parameters for basic operation, for "
"storage, for binary logging and snapshots, for replication, for "
"networking, and for logging."
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:217
msgid "Basic parameters"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:223
msgid "Configuring the storage"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:231
msgid "Checkpoint daemon"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:237
msgid "Binary logging and snapshots"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:245
msgid "Hot standby"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:257
msgid "Networking"
msgstr ""

#: ../doc/1.7/reference/configuration/index.rst:269
msgid "Deprecated parameters"
msgstr ""

#: ../doc/1.7/reference/index.rst:33
msgid "Reference"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:33
msgid "Tips on Lua syntax"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:35
msgid ""
"The Lua syntax for :ref:`data-manipulation functions <index-box_data-"
"operations>` can vary. Here are examples of the variations with "
"``select()`` requests. The same rules exist for the other data-"
"manipulation functions."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:39
msgid ""
"Every one of the examples does the same thing: select a tuple set from a "
"space named 'tester' where the primary-key field value equals 1. For "
"these examples, we assume that the numeric id of 'tester' is 512, which "
"happens to be the case in our sandbox example only."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:46
msgid "First, there are three **object reference variations**:"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:48
msgid ""
"-- #1 module . submodule . name\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2 replace name with a literal in square brackets\n"
"tarantool> box.space['tester']:select{1}\n"
"-- #3 use a variable for the entire object reference\n"
"tarantool> s = box.space.tester\n"
"tarantool> s:select{1}"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:58
msgid ""
"Examples in this manual usually have the \":samp:`box.space.{tester}:`\" "
"form (#1). However, this is a matter of user preference and all the "
"variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:62
msgid ""
"Also, descriptions in this manual use the syntax \"``space_object:``\" "
"for references to objects which are spaces, and \"``index_object:``\" for"
" references to objects which are indexes (for example "
":samp:`box.space.{tester}.index.{primary}:`)."
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:69
msgid "Then, there are seven **parameter variations**:"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:71
msgid ""
"-- #1\n"
"tarantool> box.space.tester:select{1}\n"
"-- #2\n"
"tarantool> box.space.tester:select({1})\n"
"-- #3\n"
"tarantool> box.space.tester:select(1)\n"
"-- #4\n"
"tarantool> box.space.tester.select(box.space.tester,1)\n"
"-- #5\n"
"tarantool> box.space.tester:select({1},{iterator='EQ'})\n"
"-- #6\n"
"tarantool> variable = 1\n"
"tarantool> box.space.tester:select{variable}\n"
"-- #7\n"
"tarantool> variable = {1}\n"
"tarantool> box.space.tester:select(variable)"
msgstr ""

#: ../doc/1.7/reference/lua_tips.rst:90
msgid ""
"Lua allows to omit parentheses ``()`` when invoking a function if its "
"only argument is a Lua table, and we use it sometimes in our examples. "
"This is why ``select{1}`` is equivalent to ``select({1})``. Literal "
"values such as ``1`` (a scalar value) or ``{1}`` (a Lua table value) may "
"be replaced by variable names, as in examples #6 and #7. Although there "
"are special cases where braces can be omitted, they are preferable "
"because they signal \"Lua table\". Examples and descriptions in this "
"manual have the ``{1}`` form. However, this too is a matter of user "
"preference and all the variations exist in the wild."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:35
msgid ""
"As well as executing Lua chunks or defining their own functions, you can "
"exploit Tarantool's storage functionality with the ``box`` module and its"
" submodules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:38
msgid ""
"The contents of the ``box`` module can be inspected at runtime with "
"``box``, with no arguments. The ``box`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box.rst:61
msgid ""
"Every submodule contains one or more Lua functions. A few submodules "
"contain members as well as functions. The functions allow data definition"
" (create alter drop), data manipulation (insert delete update upsert "
"select replace), and introspection (inspecting contents of spaces, "
"accessing server configuration)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:31
msgid "Submodule `box.error`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:35
msgid ""
"The ``box.error`` function is for raising an error. The difference "
"between this function and Lua's built-in ``error()`` function is that "
"when the error reaches the client, its error code is preserved. In "
"contrast, a Lua error would always be presented to the client as "
":errcode:`ER_PROC_LUA`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:42
msgid ""
"When called with a Lua-table argument, the code and reason have any user-"
"desired values. The result will be those values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:50
msgid ""
"When called without arguments, ``box.error()`` re-throws whatever the "
"last error was."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:57
msgid ""
"Emulate a request error, with text based on one of the pre-defined "
"Tarantool errors defined in the file `errcode.h "
"<https://github.com/tarantool/tarantool/blob/1.7/src/box/errcode.h>`_ in "
"the source tree. Lua constants which correspond to those Tarantool errors"
" are defined as members of ``box.error``, for example "
"``box.error.NO_SUCH_USER == 45``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:63
msgid "number of a pre-defined error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:64
msgid "part of the message which will accompany the error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:68
#, python-format
msgid ""
"the ``NO_SUCH_USER`` message is \"``User '%s' is not found``\" -- it "
"includes one \"``%s``\" component which will be replaced with errtext. "
"Thus a call to ``box.error(box.error.NO_SUCH_USER, 'joe')`` or "
"``box.error(45, 'joe')`` will result in an error with the accompanying "
"message \"``User 'joe' is not found``\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst
msgid "except"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:74
msgid "whatever is specified in errcode-number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:78
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error()\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.error(box.error.FUNCTION_ACCESS_DENIED, 'A', 'B', 'C')\n"
"---\n"
"- error: A access denied for user 'B' to function 'C'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:97
msgid ""
"Returns a description of the last error, as a Lua table with five "
"members: \"line\" (number) Tarantool source file line number, \"code\" "
"(number) error's number, \"type\", (string) error's C++ class, "
"\"message\" (string) error's message, \"file\" (string) Tarantool source "
"file. Additionally, if the error is a system error (for example due to a "
"failure in socket or file io), there may be a sixth member: \"errno\" "
"(number) C standard error number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:107
msgid "rtype: table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:111
msgid ""
"Clears the record of errors, so functions like `box.error()` or "
"`box.error.last()` will have no effect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_error.rst:116
msgid ""
"tarantool> box.error{code = 555, reason = 'Arbitrary message'}\n"
"---\n"
"- error: Arbitrary message\n"
"...\n"
"tarantool> box.schema.space.create('#')\n"
"---\n"
"- error: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- line: 278\n"
"  code: 70\n"
"  type: ClientError\n"
"  message: Invalid identifier '#' (expected letters, digits or an "
"underscore)\n"
"  file: "
"/tmp/buildd/tarantool-1.7.0.252.g1654e31~precise/src/box/key_def.cc\n"
"...\n"
"tarantool> box.error.clear()\n"
"---\n"
"...\n"
"tarantool> box.error.last()\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:33
msgid "Function `box.once`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:37
msgid ""
"Execute a function, provided it has not been executed before. A passed "
"value is checked to see whether the function has already been executed. "
"If it has been executed before, nothing happens. If it has not been "
"executed before, the function is invoked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:42
msgid ""
"See an example of using ``box.once()`` while :ref:`bootstrapping a "
"replica set <replication-bootstrap>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:45
msgid ""
"If an error occurs inside ``box.once()`` when initializing a database, "
"you can re-execute the failed ``box.once()`` block without stopping the "
"database. The solution is to delete the ``once`` object from the system "
"space :ref:`_schema <box_space-schema>`. Say "
"``box.space._schema:select{}``, find your ``once`` object there and "
"delete it. For example, re-executing a block with ``key='hello'`` :"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:52
msgid ""
"tarantool> box.space._schema:select{}\n"
"---\n"
"- - ['cluster', 'b4e15788-d962-4442-892e-d6c1dd5d13f2']\n"
"  - ['max_id', 512]\n"
"  - ['oncebye']\n"
"  - ['oncehello']\n"
"  - ['version', 1, 7, 2]\n"
"...\n"
"\n"
"tarantool> box.space._schema:delete('oncehello')\n"
"---\n"
"- ['oncehello']\n"
"...\n"
"\n"
"tarantool> box.once('hello', function() end)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:72
msgid "a value that will be checked"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:73
msgid "a function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_once.rst:74
msgid "arguments that must be passed to function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:33
msgid "Function `box.snapshot`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:37
msgid ""
"Take a snapshot of all data and store it in :ref:`memtx_dir <cfg_basic-"
"memtx_dir>`:samp:`/{<latest-lsn>}.snap`. To take a snapshot, Tarantool "
"first enters the delayed garbage collection mode for all data. In this "
"mode, tuples which were allocated before the snapshot has started are not"
" freed until the snapshot has finished. To preserve consistency of the "
"primary key, used to iterate over tuples, a copy-on-write technique is "
"employed. If the master process changes part of a primary key, the "
"corresponding process page is split, and the snapshot process obtains an "
"old copy of the page. In effect, the snapshot process uses multi-version "
"concurrency control in order to avoid copying changes which are "
"superseded while it is running."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:49
msgid ""
"Since a snapshot is written sequentially, one can expect a very high "
"write performance (averaging to 80MB/second on modern disks), which means"
" an average database instance gets saved in a matter of minutes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:55
#, python-format
msgid ""
"As long as there are any changes to the parent index memory through "
"concurrent updates, there are going to be page splits, and therefore you "
"need to have some extra free memory to run this command. 10% of "
":ref:`memtx_memory <cfg_storage-memtx_memory>` is, on average, "
"sufficient. This statement waits until a snapshot is taken and returns "
"operation result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:63
msgid ""
"**Change notice:** Prior to Tarantool version 1.6.6, the snapshot process"
" caused a fork, which could cause occasional latency spikes. Starting "
"with Tarantool version 1.6.6, the snapshot process creates a consistent "
"read view and writes this view to the snapshot file from a separate "
"thread."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:68
msgid ""
"Although ``box.snapshot()`` does not cause a fork, there is a separate "
"fiber which may produce snapshots at regular intervals -- see the "
"discussion of the :ref:`checkpoint daemon <book_cfg_checkpoint_daemon>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:74
msgid ""
"tarantool> box.info.version\n"
"---\n"
"- 1.7.0-1216-g73f7154\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- ok\n"
"...\n"
"tarantool> box.snapshot()\n"
"---\n"
"- error: can't save snapshot, errno 17 (File exists)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:89
msgid ""
"Taking a snapshot does not cause the server to start a new write-ahead "
"log. Once a snapshot is taken, old WALs can be deleted as long as all "
"replicated data is up to date. But the WAL which was current at the time "
"``box.snapshot()`` started must be kept for recovery, since it still "
"contains log records written after the start of ``box.snapshot()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/box_snapshot.rst:95
msgid ""
"An alternative way to save a snapshot is to send a SIGUSR1 signal to the "
"instance. While this approach could be handy, it is not recommended for "
"use in automation: a signal provides no way to find out whether the "
"snapshot was taken successfully or not."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:35
msgid ""
"The ``clock`` module returns time values derived from the Posix / C "
"CLOCK_GETTIME_ function or equivalent. Most functions in the module "
"return a number of seconds; functions whose names end in \"64\" return a "
"64-bit number of nanoseconds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:47
msgid ""
"The wall clock time. Derived from C function "
"clock_gettime(CLOCK_REALTIME). This is the best function for knowing what"
" the official time is, as determined by the system administrator."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:51
msgid "seconds or nanoseconds since epoch (1970-01-01 00:00:00), adjusted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:52
#: ../doc/1.7/reference/reference_lua/clock.rst:75
#: ../doc/1.7/reference/reference_lua/clock.rst:94
#: ../doc/1.7/reference/reference_lua/clock.rst:113
msgid "number or number64"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:56
msgid ""
"-- This will print an approximate number of years since 1970.\n"
"clock = require('clock')\n"
"print(clock.time() / (365*24*60*60))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:62
msgid ""
"See also :ref:`fiber.time64 <fiber-time64>` and the standard Lua function"
" `os.clock <http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:68
msgid ""
"The monotonic time. Derived from C function "
"clock_gettime(CLOCK_MONOTONIC). Monotonic time is similar to wall clock "
"time but is not affected by changes to or from daylight saving time, or "
"by changes done by a user. This is the best function to use with "
"benchmarks that need to calculate elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:74
msgid "seconds or nanoseconds since the last time that the computer was booted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:79
msgid ""
"-- This will print nanoseconds since the start.\n"
"clock = require('clock')\n"
"print(clock.monotonic64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:88
msgid ""
"The processor time. Derived from C function "
"``clock_gettime(CLOCK_PROCESS_CPUTIME_ID)``. This is the best function to"
" use with benchmarks that need to calculate how much time has been spent "
"within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:93
msgid "seconds or nanoseconds since processor start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:98
msgid ""
"-- This will print nanoseconds in the CPU since the start.\n"
"clock = require('clock')\n"
"print(clock.proc64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:107
msgid ""
"The thread time. Derived from C function "
"``clock_gettime(CLOCK_THREAD_CPUTIME_ID)``. This is the best function to "
"use with benchmarks that need to calculate how much time has been spent "
"within a thread within a CPU."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:112
msgid "seconds or nanoseconds since thread start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:117
msgid ""
"-- This will print seconds in the thread since the start.\n"
"clock = require('clock')\n"
"print(clock.thread64())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:125
msgid ""
"The time that a function takes within a processor. This function uses "
"``clock.proc()``, therefore it calculates elapsed CPU time. Therefore it "
"is not useful for showing actual elapsed time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:129
msgid "function or function reference"
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:130
msgid "whatever values are required by the function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:132
msgid ""
"**table**. first element - seconds of CPU time, second element - whatever"
" the function returns."
msgstr ""

#: ../doc/1.7/reference/reference_lua/clock.rst:137
msgid ""
"-- Benchmark a function which sleeps 10 seconds.\n"
"-- NB: bench() will not calculate sleep time.\n"
"-- So the returned value will be {a number less than 10, 88}.\n"
"clock = require('clock')\n"
"fiber = require('fiber')\n"
"function f(param)\n"
"  fiber.sleep(param)\n"
"  return 88\n"
"end\n"
"clock.bench(f, 10)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:33
msgid "Module `console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:35
msgid ""
"The console module allows one Tarantool instance to access another "
"Tarantool instance, and allows one Tarantool instance to start listening "
"on an :ref:`admin port <admin-security>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:45
msgid ""
"Connect to the instance at :ref:`URI <index-uri>`, change the prompt from"
" '``tarantool>``' to ':samp:`{uri}>`', and act henceforth as a client "
"until the user ends the session or types ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:49
msgid ""
"The console.connect function allows one Tarantool instance, in "
"interactive mode, to access another Tarantool instance. Subsequent "
"requests will appear to be handled locally, but in reality the requests "
"are being sent to the remote instance and the local instance is acting as"
" a client. Once connection is successful, the prompt will change and "
"subsequent requests are sent to, and executed on, the remote instance. "
"Results are displayed on the local instance. To return to local mode, "
"enter ``control-D``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:57
msgid ""
"If the Tarantool instance at :samp:`uri` requires authentication, the "
"connection might look something like: "
"``console.connect('admin:secretpassword@distanthost.com:3301')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:61
msgid ""
"There are no restrictions on the types of requests that can be entered, "
"except those which are due to privilege restrictions -- by default the "
"login to the remote instance is done with user name = 'guest'. The remote"
" instance could allow for this by granting at least one privilege: "
"``box.schema.user.grant('guest','execute','universe')``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:67
msgid "the URI of the remote instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:70
msgid ""
"Possible errors: the connection will fail if the target Tarantool "
"instance was not initiated with ``box.cfg{listen=...}``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:75
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.connect('198.18.44.44:3301')\n"
"---\n"
"...\n"
"198.18.44.44:3301> -- prompt is telling us that instance is remote"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:89
msgid ""
"Listen on :ref:`URI <index-uri>`. The primary way of listening for "
"incoming requests is via the connection-information string, or URI, "
"specified in ``box.cfg{listen=...}``. The alternative way of listening is"
" via the URI specified in ``console.listen(...)``. This alternative way "
"is called \"administrative\" or simply :ref:`\"admin port\" <admin-"
"security>`. The listening is usually over a local host with a Unix domain"
" socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:96
msgid "the URI of the local instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:98
msgid ""
"The \"admin\" address is the URI to listen on. It has no default value, "
"so it must be specified if connections will occur via an admin port. The "
"parameter is expressed with URI = Universal Resource Identifier format, "
"for example \"/tmpdir/unix_domain_socket.sock\", or a numeric TCP port. "
"Connections are often made with telnet. A typical port value is 3313."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:106
msgid ""
"tarantool> console = require('console')\n"
"---\n"
"...\n"
"tarantool> console.listen('unix/:/tmp/X.sock')\n"
"... main/103/console/unix/:/tmp/X I> started\n"
"---\n"
"- fd: 6\n"
"  name:\n"
"    host: unix/\n"
"    family: AF_UNIX\n"
"    type: SOCK_STREAM\n"
"    protocol: 0\n"
"    port: /tmp/X.sock\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:127
msgid "Start the console on the current interactive terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:131
msgid ""
"A special use of ``console.start()`` is with :ref:`initialization files "
"<index-init_label>`. Normally, if one starts the Tarantool instance with "
":samp:`tarantool {initialization file}` there is no console. This can be "
"remedied by adding these lines at the end of the initialization file:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:136
msgid ""
"local console = require('console')\n"
"console.start()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:145
msgid ""
"Set the auto-completion flag. If auto-completion is `true`, and the user "
"is using Tarantool as a client or the user is using Tarantool via "
"``console.connect()``, then hitting the TAB key may cause tarantool to "
"complete a word automatically. The default auto-completion value is "
"`true`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:154
msgid "Set a custom end-of-request marker for Tarantool console."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:156
msgid ""
"The default end-of-request marker is a newline (line feed). Custom "
"markers are not necessary because Tarantool can tell when a multi-line "
"request has not ended (for example, if it sees that a function "
"declaration does not have an end keyword). Nonetheless for special needs,"
" or for entering multi-line requests in older Tarantool versions, you can"
" change the end-of-request marker. As a result, newline alone is not "
"treated as end of request."
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:164
msgid "To go back to normal mode, say: ``console.delimiter('')<marker>``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:166
msgid "a custom end-of-request marker for Tarantool console"
msgstr ""

#: ../doc/1.7/reference/reference_lua/console.rst:170
msgid ""
"console = require('console'); console.delimiter('!')\n"
"function f ()\n"
"    statement_1 = 'a'\n"
"    statement_2 = 'b'\n"
"end!\n"
"console.delimiter('')!"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:33
msgid "Module `crypto`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:37
msgid ""
"\"Crypto\" is short for \"Cryptography\", which generally refers to the "
"production of a digest value from a function (usually a `Cryptographic "
"hash function`_), applied against a string. Tarantool's crypto module "
"supports ten types of cryptographic hash functions (AES_, DES_, DSS_, "
"MD4_, MD5_, MDC2_, RIPEMD_, SHA-0_, SHA-1_, SHA-2_). Some of the crypto "
"functionality is also present in the :ref:`digest` module. The functions "
"in crypto are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:49
msgid ""
"Pass or return a cipher derived from the string, key, and (optionally, "
"sometimes) initialization vector. The four choices of algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:52
msgid "aes128 - aes-128 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:53
msgid "aes192 - aes-192 (with 192-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:54
msgid "aes256 - aes-256 (with 256-bit binary strings using AES)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:55
msgid ""
"des    - des (with 56-bit binary strings using DES, though DES is not "
"recommended)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:58
msgid "Four choices of block cipher modes are also available:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:60
msgid "cbc - Cipher Block Chaining"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:61
msgid "cfb - Cipher Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:62
msgid "ecb - Electronic Codebook"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:63
msgid "ofb - Output Feedback"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:65
msgid "For more information on, read article about `Encryption Modes`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:69
msgid ""
"crypto.cipher.aes192.cbc.encrypt('string', 'key', 'initialization')\n"
"crypto.cipher.aes256.ecb.decrypt('string', 'key', 'initialization')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:80
msgid ""
"Pass or return a digest derived from the string. The twelve choices of "
"algorithms:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:83
msgid "dss - dss (using DSS)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:84
msgid "dss1 - dss (using DSS-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:85
msgid "md4 - md4 (with 128-bit binary strings using MD4)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:86
msgid "md5 - md5 (with 128-bit binary strings using MD5)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:87
msgid "mdc2 - mdc2 (using MDC2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:88
msgid "ripemd160 -"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:89
msgid "sha - sha (with 160-bit binary strings using SHA-0)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:90
msgid "sha1 - sha-1 (with 160-bit binary strings using SHA-1)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:91
msgid "sha224 - sha-224 (with 224-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:92
msgid "sha256 - sha-256 (with 256-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:93
msgid "sha384 - sha-384 (with 384-bit binary strings using SHA-2)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:94
msgid "sha512 - sha-512(with 512-bit binary strings using SHA-2)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:98
msgid ""
"crypto.digest.md4('string')\n"
"crypto.digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:105
msgid "Incremental methods in the crypto module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:107
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports for all crypto functions.."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:113
msgid ""
"crypto = require('crypto')\n"
"\n"
"-- print aes-192 digest of 'AB', with one step, then incrementally\n"
"print(crypto.cipher.aes192.cbc.encrypt('AB', 'key'))\n"
"c = crypto.cipher.aes192.cbc.encrypt.new()\n"
"c:init()\n"
"c:update('A', 'key')\n"
"c:update('B', 'key')\n"
"print(c:result())\n"
"c:free()\n"
"\n"
"-- print sha-256 digest of 'AB', with one step, then incrementally\n"
"print(crypto.digest.sha256('AB'))\n"
"c = crypto.digest.sha256.new()\n"
"c:init()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"c:free()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:137
msgid "Getting the same results from digest and crypto modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:139
msgid ""
"The following functions are equivalent. For example, the ``digest`` "
"function and the ``crypto`` function will both produce the same result."
msgstr ""

#: ../doc/1.7/reference/reference_lua/crypto.rst:142
msgid ""
"crypto.cipher.aes256.cbc.encrypt('string', 'key') == "
"digest.aes256cbc.encrypt('string', 'key')\n"
"crypto.digest.md4('string') == digest.md4('string')\n"
"crypto.digest.md5('string') == digest.md5('string')\n"
"crypto.digest.sha('string') == digest.sha('string')\n"
"crypto.digest.sha1('string') == digest.sha1('string')\n"
"crypto.digest.sha224('string') == digest.sha224('string')\n"
"crypto.digest.sha256('string') == digest.sha256('string')\n"
"crypto.digest.sha384('string') == digest.sha384('string')\n"
"crypto.digest.sha512('string') == digest.sha512('string')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:31
msgid "Module `csv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:35
msgid ""
"The csv module handles records formatted according to Comma-Separated-"
"Values (CSV) rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:38
msgid "The default formatting rules are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:40
msgid ""
"Lua `escape sequences`_ such as \\\\n or \\\\10 are legal within strings "
"but not within files,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:42
msgid "Commas designate end-of-field,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:43
msgid "Line feeds, or line feeds plus carriage returns, designate end-of-record,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:44
msgid "Leading or trailing spaces are ignored,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:45
msgid "Quote marks may enclose fields or parts of fields,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:46
msgid ""
"When enclosed by quote marks, commas and line feeds and spaces are "
"treated as ordinary characters, and a pair of quote marks \"\" is treated"
" as a single quote mark."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:52
msgid "The possible options which can be passed to csv functions are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:54
msgid ""
":samp:`delimiter = {string}` (default: comma) -- single-byte character to"
" designate end-of-field"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:56
msgid ""
":samp:`quote_char = {string}` (default: quote mark) -- single-byte "
"character to designate encloser of string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:58
msgid ""
":samp:`chunk_size = {number}` (default: 4096) -- number of characters to "
"read at once (usually for file-IO efficiency)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:60
msgid ""
":samp:`skip_head_lines = {number}` (default: 0) -- number of lines to "
"skip at the start (usually for a header)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:67
msgid ""
"Get CSV-formatted input from ``readable`` and return a table as output. "
"Usually ``readable`` is either a string or a file opened for reading. "
"Usually :samp:`{options}` is not specified."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:71
msgid ""
"a string, or any object which has a read() method, formatted according to"
" the CSV rules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:73
#: ../doc/1.7/reference/reference_lua/csv.rst:199
msgid "see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:74
msgid "loaded_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:79
msgid ""
"Readable string has 3 fields, field#2 has comma and space so use quote "
"marks:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:82
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.load('a,\"b,c \",d')\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:94
msgid ""
"Readable string contains 2-byte character = Cyrillic Letter Palochka: "
"(This displays a palochka if and only if character set = UTF-8.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:97
msgid ""
"tarantool> csv.load('a\\\\211\\\\128b')\n"
"---\n"
"- - - a\\211\\128b\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:104
msgid "Semicolon instead of comma for the delimiter:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:106
msgid ""
"tarantool> csv.load('a,b;c,d', {delimiter = ';'})\n"
"---\n"
"- - - a,b\n"
"    - c,d\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:114
msgid ""
"Readable file :file:`./file.csv` contains two CSV records. Explanation of"
" ``fio`` is in section :ref:`fio <fio-section>`. Source CSV file and "
"example respectively:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:118
msgid ""
"tarantool> -- input in file.csv is:\n"
"tarantool> -- a,\"b,c \",d\n"
"tarantool> -- a\\\\211\\\\128b\n"
"tarantool> fio = require('fio')\n"
"---\n"
"...\n"
"tarantool> f = fio.open('./file.csv', {'O_RDONLY'})\n"
"---\n"
"...\n"
"tarantool> csv.load(f, {chunk_size = 4096})\n"
"---\n"
"- - - a\n"
"    - 'b,c '\n"
"    - d\n"
"  - - a\\\\211\\\\128b\n"
"...\n"
"tarantool> f:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:145
msgid ""
"Get table input from ``csv-table`` and return a CSV-formatted string as "
"output. Or, get table input from ``csv-table`` and put the output in "
"``writable``. Usually :samp:`{options}` is not specified. Usually "
"``writable``, if specified, is a file opened for writing. "
":ref:`csv.dump() <csv-dump>` is the reverse of :ref:`csv.load() <csv-"
"load>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:151
#: ../doc/1.7/reference/reference_lua/csv.rst:197
msgid "a table which can be formatted according to the CSV rules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:153
msgid "optional. see :ref:`above <csv-options>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:154
msgid "any object which has a ``write()`` method"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:156
msgid "dumped_value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:157
msgid "string, which is written to ``writable`` if specified"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:161
msgid "CSV-table has 3 fields, field#2 has \",\" so result has quote marks"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:163
msgid ""
"tarantool> csv = require('csv')\n"
"---\n"
"...\n"
"tarantool> csv.dump({'a','b,c ','d'})\n"
"---\n"
"- 'a,\"b,c \",d\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:175
msgid "Round Trip: from string to table and back to string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:177
msgid ""
"tarantool> csv_table = csv.load('a,b,c')\n"
"---\n"
"...\n"
"tarantool> csv.dump(csv_table)\n"
"---\n"
"- 'a,b,c\n"
"\n"
"'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:193
msgid ""
"Form a Lua iterator function for going through CSV records one field at a"
" time. Use of an iterator is strongly recommended if the amount of data "
"is large (ten or more megabytes)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:201
msgid "Lua iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:202
msgid "iterator function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:206
msgid ""
":ref:`csv.iterate() <csv-iterate>` is the low level of :ref:`csv.load() "
"<csv-load>` and :ref:`csv.dump() <csv-dump>`. To illustrate that, here is"
" a function which is the same as the :ref:`csv.load() <csv-load>` "
"function, as seen in `the Tarantool source code`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/csv.rst:211
msgid ""
"tarantool> load = function(readable, opts)\n"
"         >   opts = opts or {}\n"
"         >   local result = {}\n"
"         >   for i, tup in csv.iterate(readable, opts) do\n"
"         >     result[i] = tup\n"
"         >   end\n"
"         >   return result\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> load('a,b,c')\n"
"---\n"
"- - - a\n"
"    - b\n"
"    - c\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:33
msgid "Module `digest`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:37
msgid ""
"A \"digest\" is a value which is returned by a function (usually a "
"`Cryptographic hash function`_), applied against a string. Tarantool's "
"digest module supports several types of cryptographic hash functions "
"(AES_, MD4_, MD5_, SHA-0_, SHA-1_, SHA-2_) as well as a checksum function"
" (CRC32_), two functions for base64_, and two non-cryptographic hash "
"functions (guava_, murmur_). Some of the digest functionality is also "
"present in the :ref:`crypto <crypto>` module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:45
msgid "The functions in digest are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:50
msgid "Returns 256-bit binary string = digest made with AES."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:54
msgid "Returns 128-bit binary string = digest made with MD4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:58
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md4."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:62
msgid "Returns 128-bit binary string = digest made with MD5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:66
msgid "Returns 32-byte string = hexadecimal of a digest calculated with md5."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:70
msgid ""
"Returns 160-bit binary string = digest made with SHA-0.|br| Not "
"recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:75
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:79
msgid "Returns 160-bit binary string = digest made with SHA-1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:83
msgid "Returns 40-byte string = hexadecimal of a digest calculated with sha1."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:87
msgid "Returns 224-bit binary string = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:91
msgid "Returns 56-byte string = hexadecimal of a digest calculated with sha224."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:95
msgid "Returns 256-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:99
msgid "Returns 64-byte string = hexadecimal of a digest calculated with sha256."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:103
msgid "Returns 384-bit binary string =  digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:107
msgid "Returns 96-byte string = hexadecimal of a digest calculated with sha384."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:111
msgid "Returns 512-bit binary tring = digest made with SHA-2."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:115
msgid "Returns 128-byte string = hexadecimal of a digest calculated with sha512."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:119
msgid "Returns base64 encoding from a regular string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:123
msgid "Returns a regular string from a base64 encoding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:127
msgid "Returns array of random bytes with length = integer."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:131
msgid "Returns 32-bit checksum made with CRC32."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:133
msgid ""
"The crc32 and crc32_update functions use the `CRC-32C (Castagnoli)`_ "
"polynomial value: ``0x1EDC6F41`` / ``4812730177``. If it is necessary to "
"be compatible with other checksum functions in other programming "
"languages, ensure that the other functions use the same polynomial value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:138
msgid "For example, in Python, install the ``crcmod`` package and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:145
msgid "In Perl, install the ``Digest::CRC`` module and run the following code:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:147
msgid ""
"use Digest::CRC;\n"
"$d = Digest::CRC->new(width => 32, poly => 0x1EDC6F41, init => "
"0xFFFFFFFF, refin => 1, refout => 1);\n"
"$d->add('string');\n"
"print $d->digest;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:154
msgid "(the expected output is 3304160206)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:160
msgid ""
"Initiates incremental crc32. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:167
msgid "Returns a number made with consistent hash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:169
msgid ""
"The guava function uses the `Consistent Hashing`_ algorithm of the Google"
" guava library. The first parameter should be a hash code; the second "
"parameter should be the number of buckets; the returned value will be an "
"integer between 0 and the number of buckets. For example,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:174
msgid ""
"tarantool> digest.guava(10863919174838991, 11)\n"
"---\n"
"- 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:184
msgid "Returns 32-bit binary string = digest made with MurmurHash."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:189
msgid ""
"Initiates incremental MurmurHash. See :ref:`incremental methods <digest-"
"incremental_digests>` notes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:196
msgid "Incremental methods in the digest module"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:198
msgid ""
"Suppose that a digest is done for a string 'A', then a new part 'B' is "
"appended to the string, then a new digest is required. The new digest "
"could be recomputed for the whole string 'AB', but it is faster to take "
"what was computed before for 'A' and apply changes based on the new part "
"'B'. This is called multi-step or \"incremental\" digesting, which "
"Tarantool supports with crc32 and with murmur..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:204
msgid ""
"digest = require('digest')\n"
"\n"
"-- print crc32 of 'AB', with one step, then incrementally\n"
"print(digest.crc32('AB'))\n"
"c = digest.crc32.new()\n"
"c:update('A')\n"
"c:update('B')\n"
"print(c:result())\n"
"\n"
"-- print murmur hash of 'AB', with one step, then incrementally\n"
"print(digest.murmur('AB'))\n"
"m = digest.murmur.new()\n"
"m:update('A')\n"
"m:update('B')\n"
"print(m:result())"
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:226
msgid ""
"In the following example, the user creates two functions, "
"``password_insert()`` which inserts a SHA-1_ digest of the word "
"\"**^S^e^c^ret Wordpass**\" into a tuple set, and ``password_check()`` "
"which requires input of a password."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:230
msgid ""
"tarantool> digest = require('digest')\n"
"---\n"
"...\n"
"tarantool> function password_insert()\n"
"         >   box.space.tester:insert{1234, digest.sha1('^S^e^c^ret "
"Wordpass')}\n"
"         >   return 'OK'\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function password_check(password)\n"
"         >   local t = box.space.tester:select{12345}\n"
"         >   if digest.sha1(password) == t[2] then\n"
"         >     return 'Password is valid'\n"
"         >   else\n"
"         >     return 'Password is not valid'\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> password_insert()\n"
"---\n"
"- 'OK'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:256
msgid ""
"If a later user calls the ``password_check()`` function and enters the "
"wrong password, the result is an error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/digest.rst:259
msgid ""
"tarantool> password_check('Secret Password')\n"
"---\n"
"- 'Password is not valid'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:33
msgid "Database error codes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:35
msgid ""
"In the current version of the binary protocol, error messages, which are "
"normally more descriptive than error codes, are not present in server "
"responses. The actual message may contain a file name, a detailed reason "
"or operating system error code. All such messages, however, are logged in"
" the error log. Below are general descriptions of some popular codes. A "
"complete list of errors can be found in file `errcode.h`_ in the source "
"tree."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:46
msgid "**List of error codes**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:52
msgid "ER_NONMASTER"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:52
msgid ""
"(In replication) A server instance cannot modify data unless it is a "
"master."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "ER_ILLEGAL_PARAMS"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:55
msgid "Illegal parameters. Malformed protocol message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid "ER_MEMORY_ISSUE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:58
msgid ""
"Out of memory: :ref:`memtx_memory <cfg_storage-memtx_memory>` limit has "
"been reached."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:62
msgid "ER_WAL_IO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:62
msgid ""
"Failed to write to disk. May mean: failed to record a change in the "
"write-ahead log. Some sort of disk error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:66
msgid "ER_KEY_PART_COUNT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:66
msgid "Key part count is not the same as index part count"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:69
msgid "ER_NO_SUCH_SPACE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:69
msgid "The specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "ER_NO_SUCH_INDEX"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:72
msgid "The specified index in the specified space does not exist."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "ER_PROC_LUA"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:75
msgid "An error occurred inside a Lua procedure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid "ER_FIBER_STACK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:78
msgid ""
"The recursion limit was reached when creating a new fiber. This usually "
"indicates that a stored procedure is recursively invoking itself too "
"often."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:83
msgid "ER_UPDATE_FIELD"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:83
msgid "An error occurred during update of a field."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:86
msgid "ER_TUPLE_FOUND"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:86
msgid "A duplicate key exists in a unique index."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:92
msgid "Handling errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:94
msgid ""
"Here are some procedures that can make Lua functions more robust when "
"there are errors, particularly database errors."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:97
msgid "Invoke with pcall."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"Take advantage of Lua's mechanisms for `\"Error handling and exceptions\""
" <http://www.lua.org/pil/8.4.html>`_, particularly ``pcall``. That is, "
"instead of simply invoking with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ":samp:`box.space.{space-name}:{function-name}()`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
":samp:`if pcall(box.space.{space-name}.{function-name}, box.space.{space-"
"name}) ...`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid ""
"For some Tarantool box functions, pcall also returns error details "
"including a file-name and line-number within Tarantool's source code. "
"This can be seen by unpacking. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``x, y = pcall(function() box.schema.space.create('') end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst
msgid "``y:unpack()``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:112
msgid ""
"See the tutorial :ref:`Sum a JSON field for all tuples <c_lua_tutorial-"
"sum_a_json_field>` to see how pcall can fit in an application."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:115
msgid "Examine and raise with box.error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:117
msgid ""
"To make a new error and pass it on, the box.error module provides "
":ref:`box.error(code, errtext [, errtext ...]) <box_error-error>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:120
msgid ""
"To find the last error, the box.error module provides "
":ref:`box.error.last() <box_error-last>`. (There is also a way to find "
"the text of the last operating-system error for certain functions -- "
":ref:`errno.strerror([code]) <errno-strerror>`.)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:125
msgid "Log."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:127
msgid "Put messages in a log using the :ref:`log module <log-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:129
msgid ""
"And filter messages that are automatically generated, with the :ref:`log "
"<cfg_logging-log>` configuration parameter."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:133
msgid ""
"Generally, for Tarantool built-in functions which are designed to return "
"objects: the result will be an object, or nil, or `a Lua error "
"<https://www.lua.org/pil/8.3.html>`_. For example consider the "
":ref:`fio_read.lua <cookbook-fio_read>` program in our cookbook:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:151
msgid ""
"After a function call that might fail, like fio.open() above, it is "
"common to see syntax like ``if not f then ...`` or ``if f == nil then "
"...``, which check for common failures. But if there had been a syntax "
"error, for example fio.opex instead of fio.open, then there would have "
"been a Lua error and f would not have been changed. If checking for such "
"an obvious error had been a concern, the programmer would probably have "
"used pcall()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errcodes.rst:161
msgid ""
"All functions in Tarantool modules should work this way, unless the "
"manual explicitly says otherwise."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:33
msgid "Module `errno`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:37
msgid "The ``errno`` module provides:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:39
msgid "a function :ref:`strerror() <errno-strerror>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:40
msgid "an operator :ref:`errno() <errno-errno>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:41
msgid ""
"a `metatable <https://www.lua.org/pil/13.html>`_ with constant error "
"names."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:43
msgid ""
"The ``errno`` module is typically used within a function or within a Lua "
"program, in association with a module whose functions can return "
"operating-system errors, such as :ref:`fio <fio-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:51
msgid ""
"Return an error number for the last operating-system-related function, or"
" 0. To invoke it, simply say ``errno()``, without the module name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:60
msgid ""
"Return a string, given an error number. The string will contain the text "
"of the conventional error message for the current operating system. If "
"``code`` is not supplied, the error message will be for the last "
"operating-system-related function, or 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:65
msgid "number of an operating-system error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:71
msgid ""
"This function displays the result of a call to :ref:`fio.open() <fio-"
"open>` which causes error 2 (``errno.ENOENT``). The display includes the "
"error number, the associated error string, and the error name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:75
msgid ""
"tarantool> function f()\n"
"         >   local fio = require('fio')\n"
"         >   local errno = require('errno')\n"
"         >   fio.open('no_such_file')\n"
"         >   print('errno() = ' .. errno())\n"
"         >   print('errno.strerror() = ' .. errno.strerror())\n"
"         >   local t = getmetatable(errno).__index\n"
"         >   for k, v in pairs(t) do\n"
"         >     if v == errno() then\n"
"         >       print('errno() constant = ' .. k)\n"
"         >     end\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"\n"
"tarantool> f()\n"
"errno() = 2\n"
"errno.strerror() = No such file or directory\n"
"errno() constant = ENOENT\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:100
msgid ""
"To see all possible error names stored in the ``errno`` metatable, say "
"``getmetatable(errno)`` (output abridged):"
msgstr ""

#: ../doc/1.7/reference/reference_lua/errno.rst:103
msgid ""
"tarantool> getmetatable(errno)\n"
"---\n"
"- __newindex: 'function: 0x41666a38'\n"
"  __call: 'function: 0x41666890'\n"
"  __index:\n"
"  ENOLINK: 67\n"
"  EMSGSIZE: 90\n"
"  EOVERFLOW: 75\n"
"  ENOTCONN: 107\n"
"  EFAULT: 14\n"
"  EOPNOTSUPP: 95\n"
"  EEXIST: 17\n"
"  ENOSR: 63\n"
"  ENOTSOCK: 88\n"
"  EDESTADDRREQ: 89\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:35
msgid "The ``fiber`` module allows for creating, running and managing *fibers*."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:37
msgid ""
"A fiber is a set of instructions which are executed with cooperative "
"multitasking. Fibers managed by the fiber module are associated with a "
"user-supplied function called the *fiber function*. A fiber has three "
"possible states: **running**, **suspended** or **dead**. When a fiber is "
"created with :ref:`fiber.create() <fiber-create>`, it is running. When a "
"fiber yields control with :ref:`fiber.sleep() <fiber-sleep>`, it is "
"suspended. When a fiber ends (because the fiber function ends), it is "
"dead."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:45
msgid ""
"All fibers are part of the fiber registry. This registry can be searched "
"with :ref:`fiber.find() <fiber-find>` - via fiber id (fid), which is a "
"numeric identifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:49
msgid ""
"A runaway fiber can be stopped with :ref:`fiber_object.cancel "
"<fiber_object-cancel>`. However, :ref:`fiber_object.cancel <fiber_object-"
"cancel>` is advisory — it works only if the runaway fiber calls "
":ref:`fiber.testcancel() <fiber-testcancel>` occasionally. Most ``box.*``"
" functions, such as :ref:`box.space...delete() <box_space-delete>` or "
":ref:`box.space...update() <box_space-update>`, do call "
":ref:`fiber.testcancel() <fiber-testcancel>` but "
":ref:`box.space...select{} <box_space-select>` does not. In practice, a "
"runaway fiber can only become unresponsive if it does many computations "
"and does not check whether it has been cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:60
msgid ""
"The other potential problem comes from fibers which never get scheduled, "
"because they are not subscribed to any events, or because no relevant "
"events occur. Such morphing fibers can be killed with :ref:`fiber.kill() "
"<fiber-kill>` at any time, since :ref:`fiber.kill() <fiber-kill>` sends "
"an asynchronous wakeup event to the fiber, and :ref:`fiber.testcancel() "
"<fiber-testcancel>` is checked whenever such a wakeup event occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:67
msgid ""
"Like all Lua objects, dead fibers are garbage collected. The garbage "
"collector frees pool allocator memory owned by the fiber, resets all "
"fiber data, and returns the fiber (now called a fiber carcass) to the "
"fiber pool. The carcass can be reused when another fiber is created."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:72
msgid ""
"A fiber has all the features of a Lua coroutine_ and all the programming "
"concepts that apply for Lua coroutines will apply for fibers as well. "
"However, Tarantool has made some enhancements for fibers and has used "
"fibers internally. So, although use of coroutines is possible and "
"supported, use of fibers is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:85
msgid ""
"Create and start a fiber. The fiber is created and begins to run "
"immediately."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:87
msgid "the function to be associated with the fiber"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Return"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:90
msgid "created fiber object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Rtype"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:95
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function function_name()\n"
"         >   fiber.sleep(1000)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> fiber_object = fiber.create(function_name)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:114
msgid "fiber object for the currently scheduled fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:119
msgid ""
"tarantool> fiber.self()\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:132
msgid "numeric identifier of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:134
msgid "fiber object for the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:139
msgid ""
"tarantool> fiber.find(101)\n"
"---\n"
"- status: running\n"
"  name: interactive\n"
"  id: 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:152
msgid ""
"Yield control to the transaction processor thread and sleep for the "
"specified number of seconds. Only the current fiber can be made to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:155
msgid "number of seconds to sleep."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:159
msgid ""
"tarantool> fiber.sleep(1.5)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:169
msgid ""
"Yield control to the scheduler. Equivalent to :ref:`fiber.sleep(0) "
"<fiber-sleep>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:173
msgid ""
"tarantool> fiber.yield()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:183
msgid "Return the status of the current fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:185
msgid "the status of ``fiber``. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:190
msgid ""
"tarantool> fiber.status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:201
msgid "Return information about all fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:203
msgid ""
"number of context switches, backtrace, id, total memory, used memory, "
"name for each fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:209
msgid ""
"tarantool> fiber.info()\n"
"---\n"
"- 101:\n"
"    csw: 7\n"
"    backtrace: []\n"
"    fid: 101\n"
"    memory:\n"
"      total: 65776\n"
"      used: 0\n"
"    name: interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:227
msgid ""
"Locate a fiber by its numeric id and cancel it. In other words, "
":ref:`fiber.kill() <fiber-kill>` combines :ref:`fiber.find() <fiber-"
"find>` and :ref:`fiber_object:cancel() <fiber_object-cancel>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:231
msgid "the id of the fiber to be cancelled."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst
msgid "Exception"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:232
msgid "the specified fiber does not exist or cancel is not permitted."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:236
msgid ""
"tarantool> fiber.kill(fiber.id()) -- kill self, may make program end\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:248
msgid ""
"Check if the current fiber has been cancelled and throw an exception if "
"this is the case."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:253
msgid ""
"tarantool> fiber.testcancel()\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:266
#: ../doc/1.7/reference/reference_lua/fiber.rst:287
#: ../doc/1.7/reference/reference_lua/fiber.rst:311
#: ../doc/1.7/reference/reference_lua/fiber.rst:331
#: ../doc/1.7/reference/reference_lua/fiber.rst:355
msgid ""
"fiber object, for example the fiber object returned by :ref:`fiber.create"
" <fiber-create>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:268
msgid "id of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:273
msgid ""
"tarantool> fiber_object = fiber.self()\n"
"---\n"
"...\n"
"tarantool> fiber_object:id()\n"
"---\n"
"- 101\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:289
msgid "name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:294
msgid ""
"tarantool> fiber.self():name()\n"
"---\n"
"- interactive\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:305
msgid ""
"Change the fiber name. By default a Tarantool server's interactive-mode "
"fiber is named 'interactive' and new fibers created due to "
":ref:`fiber.create <fiber-create>` are named 'lua'. Giving fibers "
"distinct names makes it easier to distinguish them when using "
":ref:`fiber.info <fiber-info>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:313
msgid "the new name of the fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:319
msgid ""
"tarantool> fiber.self():name('non-interactive')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:329
msgid "Return the status of the specified fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:334
msgid "the status of fiber. One of: “dead”, “suspended”, or “running”."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:339
msgid ""
"tarantool> fiber.self():status()\n"
"---\n"
"- running\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:350
msgid ""
"Cancel a fiber. Running and suspended fibers can be cancelled. After a "
"fiber has been cancelled, attempts to operate on it will cause errors, "
"for example :ref:`fiber_object:id() <fiber_object-id>` will cause "
"``error: the fiber is dead``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:360
msgid "Possible errors: cancel is not permitted for the specified fiber object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:364
msgid ""
"tarantool> fiber.self():cancel() -- kill self, may make program send\n"
"---\n"
"- error: fiber is cancelled\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:375
msgid ""
"Local storage within the fiber. The storage can contain any number of "
"named values, subject to memory limitations. Naming may be done with "
":samp:`{fiber_object}.storage.{name}` or "
":samp:`{fiber_object}.storage['{name}'].` or with a number "
":samp:`{fiber_object}.storage[{number}]`. Values may be either numbers or"
" strings. The storage is garbage-collected when "
":samp:`{fiber_object}:cancel()` happens."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:384
msgid ""
"tarantool> fiber = require('fiber')\n"
"---\n"
"...\n"
"tarantool> function f () fiber.sleep(1000); end\n"
"---\n"
"...\n"
"tarantool> fiber_function = fiber:create(f)\n"
"---\n"
"- error: '[string \"fiber_function = fiber:create(f)\"]:1: "
"fiber.create(function, ...):\n"
"    bad arguments'\n"
"...\n"
"tarantool> fiber_function = fiber.create(f)\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage.str1 = 'string'\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- string\n"
"...\n"
"tarantool> fiber_function:cancel()\n"
"---\n"
"...\n"
"tarantool> fiber_function.storage['str1']\n"
"---\n"
"- error: '[string \"return fiber_function.storage[''str1'']\"]:1: the "
"fiber is dead'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:415
msgid "See also :ref:`box.session.storage <box_session-storage>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:421
msgid ""
"current system time (in seconds since the epoch) as a Lua number. The "
"time is taken from the event loop clock, which makes this call very "
"cheap, but still useful for constructing artificial tuple keys."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:425
#: ../doc/1.7/reference/reference_lua/fiber.rst:444
msgid "num"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:429
msgid ""
"tarantool> fiber.time(), fiber.time()\n"
"---\n"
"- 1448466279.2415\n"
"- 1448466279.2415\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:441
msgid ""
"current system time (in microseconds since the epoch) as a 64-bit "
"integer. The time is taken from the event loop clock."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:448
msgid ""
"tarantool> fiber.time(), fiber.time64()\n"
"---\n"
"- 1448466351.2708\n"
"- 1448466351270762\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:458
msgid "Example Of Fiber Use"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:460
msgid ""
"Make the function which will be associated with the fiber. This function "
"contains an infinite loop (``while 0 == 0`` is always true). Each "
"iteration of the loop adds 1 to a global variable named gvar, then goes "
"to sleep for 2 seconds. The sleep causes an implicit :ref:`fiber.yield() "
"<fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:465
msgid ""
"tarantool> fiber = require('fiber')\n"
"tarantool> function function_x()\n"
"         >   gvar = 0\n"
"         >   while 0 == 0 do\n"
"         >     gvar = gvar + 1\n"
"         >     fiber.sleep(2)\n"
"         >   end\n"
"         > end\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:478
msgid ""
"Make a fiber, associate function_x with the fiber, and start function_x. "
"It will immediately \"detach\" so it will be running independently of the"
" caller."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:481
msgid ""
"tarantool> gvar = 0\n"
"\n"
"tarantool> fiber_of_x = fiber.create(function_x)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:489
msgid "Get the id of the fiber (fid), to be used in later displays."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:491
msgid ""
"tarantool> fid = fiber_of_x:id()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:497
msgid ""
"Pause for a while, while the detached function runs. Then ... Display the"
" fiber id, the fiber status, and gvar (gvar will have gone up a bit "
"depending how long the pause lasted). The status is suspended because the"
" fiber spends almost all its time sleeping or yielding."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:502
msgid ""
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  suspended . gvar= 399\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:509
msgid ""
"Pause for a while, while the detached function runs. Then ... Cancel the "
"fiber. Then, once again ... Display the fiber id, the fiber status, and "
"gvar (gvar will have gone up a bit more depending how long the pause "
"lasted). This time the status is dead because the cancel worked."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber.rst:514
msgid ""
"tarantool> fiber_of_x:cancel()\n"
"---\n"
"...\n"
"tarantool> print('#', fid, '. ', fiber_of_x:status(), '. gvar=', gvar)\n"
"# 102 .  dead . gvar= 421\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:31
msgid "Submodule `fiber-ipc`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:33
msgid ""
"The ``fiber-ipc`` submodule allows sending and receiving messages between"
" different processes and has a synchronization mechanism for fibers, "
"similar to \"Condition Variables\" and similar to operating-system "
"functions such as ``pthread_cond_wait()`` plus ``pthread_cond_signal()``."
" The words \"different processes\" in this context mean different "
"connections, different sessions, or different fibers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:40
msgid ""
"Call ``fiber.channel()`` to allocate space and get a channel object, "
"which will be called channel for examples in this section. Call the other"
" ``fiber-ipc`` routines, via channel, to send messages, receive messages,"
" or check ipc status. Message exchange is synchronous. The channel is "
"garbage collected when no one is using it, as with any other Lua object. "
"Use object-oriented syntax, for example ``channel:put(message)`` rather "
"than ``fiber.channel.put(message)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:47
msgid ""
"Call ``fiber.cond()`` to create a named condition variable, which will be"
" called cond for examples in this section. Call ``cond:wait()`` to make a"
" fiber wait for a signal via a condition variable. Call ``cond:signal()``"
" to send a signal to wake up a single fiber that has executed "
"``cond:wait()``. Call ``cond:broadcast()`` to send a signal to all fibers"
" that have executed ``cond:wait()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:60
msgid "Channel"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:64
msgid "Create a new communication channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:66
msgid ""
"the maximum number of slots (spaces for ``channel:put`` messages) that "
"can be in use at once. The default is 0."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:70
msgid "new channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:71
msgid "userdata, possibly including the string \"channel ...\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:77
msgid ""
"Send a message using a channel. If the channel is full, ``channel:put()``"
" waits until there is a free slot in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:80
msgid "what will be sent, usually a string or number or table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:81
msgid "maximum number of seconds to wait for a slot to become free"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:82
msgid ""
"If timeout is specified, and there is no free slot in the channel for the"
" duration of the timeout, then the return value is ``false``. If the "
"channel is closed, then the return value is ``false``. Otherwise, the "
"return value is ``true``, indicating success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:90
msgid ""
"Close the channel. All waiters in the channel will stop waiting. All "
"following ``channel:get()`` operations will return ``nil``, and all "
"following ``channel:put()`` operations will return ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:96
msgid ""
"Fetch and remove a message from a channel. If the channel is empty, "
"``channel:get()`` waits for a message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:99
msgid "maximum number of seconds to wait for a message"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:100
msgid ""
"If timeout is specified, and there is no message in the channel for the "
"duration of the timeout, then the return value is ``nil``. If the channel"
" is closed, then the return value is ``nil``. Otherwise, the return value"
" is the message placed on the channel by ``channel:put()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:105
msgid "usually string or number or table, as determined by ``channel:put``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:109
msgid "Check whether the channel is empty (has no messages)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:111
msgid "``true`` if the channel is empty. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:116
msgid "Find out how many messages are in the channel."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:118
msgid "the number of messages."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:123
msgid "Check whether the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:125
msgid ""
"``true`` if the channel is full (the number of messages in the channel "
"equals the number of slots so there is no room for a new message). "
"Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:132
msgid ""
"Check whether readers are waiting for a message because they have issued "
"``channel:get()`` and the channel is empty."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:135
msgid "``true`` if readers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:140
msgid ""
"Check whether writers are waiting because they have issued "
"``channel:put()`` and the channel is full."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:143
msgid "``true`` if writers are waiting. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:148
msgid "``true`` if the channel is already closed. Otherwise ``false``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:156
msgid ""
"This example should give a rough idea of what some functions for fibers "
"should look like. It's assumed that the functions would be referenced in "
":ref:`fiber.create() <fiber-create>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:160
msgid ""
"fiber = require('fiber')\n"
"channel = fiber.channel(10)\n"
"function consumer_fiber()\n"
"    while true do\n"
"        local task = channel:get()\n"
"        ...\n"
"    end\n"
"end\n"
"\n"
"function consumer2_fiber()\n"
"    while true do\n"
"        -- 10 seconds\n"
"        local task = channel:get(10)\n"
"        if task ~= nil then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"function producer_fiber()\n"
"    while true do\n"
"        task = box.space...:select{...}\n"
"        ...\n"
"        if channel:is_empty() then\n"
"            -- channel is empty\n"
"        end\n"
"\n"
"        if channel:is_full() then\n"
"            -- channel is full\n"
"        end\n"
"\n"
"        ...\n"
"        if channel:has_readers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for data\n"
"        end\n"
"        ...\n"
"\n"
"        if channel:has_writers() then\n"
"            -- there are some fibers\n"
"            -- that are waiting for readers\n"
"        end\n"
"        channel:put(task)\n"
"    end\n"
"end\n"
"\n"
"function producer2_fiber()\n"
"    while true do\n"
"        task = box.space...select{...}\n"
"        -- 10 seconds\n"
"        if channel:put(task, 10) then\n"
"            ...\n"
"        else\n"
"            -- timeout\n"
"        end\n"
"    end\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:224
msgid "Condition variables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:228
msgid "Create a new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:230
msgid "new condition variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:231
msgid "Lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:237
msgid ""
"Make the current fiber go to sleep, waiting until until another fiber "
"invokes the ``signal()`` or ``broadcast()`` method on the cond object. "
"The sleep causes an implicit :ref:`fiber.yield() <fiber-yield>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:241
msgid "number of seconds to wait, default = forever."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:242
msgid ""
"If timeout is provided, and a signal doesn't happen for the duration of "
"the timeout, ``wait()`` returns false. If a signal or broadcast happens, "
"``wait()`` returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:249
msgid "Wake up a single fiber that has executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:256
msgid "Wake up all fibers that have executed ``wait()`` for the same variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:264
msgid ""
"Assume that a tarantool instance is running and listening for connections"
" on localhost port 3301. Assume that guest users have privileges to "
"connect. We will use the tarantoolctl utility to start two clients."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:268
msgid "On terminal #1, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:270
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> fiber = require('fiber')\n"
"tarantool> cond = fiber.cond()\n"
"tarantool> cond:wait()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:277
msgid ""
"The job will hang because ``cond:wait()`` -- without an optional timeout "
"argument -- will go to sleep until the condition variable changes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:280
msgid "On terminal #2, say"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:282
msgid ""
"$ tarantoolctl connect '3301'\n"
"tarantool> cond:signal()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:287
msgid ""
"Now look again at terminal #1. It will show that the waiting stopped, and"
" the ``cond:wait()`` function returned ``true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fiber_ipc.rst:290
msgid ""
"This example depended on the use of a global conditional variable with "
"the arbitrary name ``cond``. In real life, programmers would make sure to"
" use different conditional variable names for different applications."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:33
msgid "Module `fio`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:37
msgid ""
"Tarantool supports file input/output with an API that is similar to POSIX"
" syscalls. All operations are performed asynchronously. Multiple fibers "
"can access the same file simultaneously."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:41
msgid "The ``fio`` module contains:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:43
msgid "functions for :ref:`common pathname manipulations <fio-pathname>`,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:44
msgid "functions for :ref:`common file manipulations <fio-file>`, and"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:45
msgid ""
":ref:`constants <fio-c>` which are the same as POSIX flag values (for "
"example ``fio.c.flag.O_RDONLY`` = POSIX O_RDONLY)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:54
msgid "Common pathname manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:58
msgid "Concatenate partial string, separated by '/' to form a path name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:60
msgid "one or more strings to be concatenated."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:61
#: ../doc/1.7/reference/reference_lua/fio.rst:78
#: ../doc/1.7/reference/reference_lua/fio.rst:97
msgid "path name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:66
msgid ""
"tarantool> fio.pathjoin('/etc', 'default', 'myfile')\n"
"---\n"
"- /etc/default/myfile\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:75
msgid ""
"Given a full path name, remove all but the final part (the file name). "
"Also remove the suffix, if it is passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:79
msgid "suffix"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:81
msgid "file name"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:86
msgid ""
"tarantool> fio.basename('/path/to/my.lua', '.lua')\n"
"---\n"
"- my\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:95
msgid "Given a full path name, remove the final part (the file name)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:99
msgid "directory name, that is, path name except for file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:104
msgid ""
"tarantool> fio.dirname('path/to/my.lua')\n"
"---\n"
"- 'path/to/'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:115
msgid "Common file manipulations"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:119
msgid ""
"Set the mask bits used when creating files or directories. For a detailed"
" description type \"man 2 umask\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:122
msgid "mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:123
msgid "previous mask bits."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:128
msgid ""
"tarantool> fio.umask(tonumber('755', 8))\n"
"---\n"
"- 493\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:138
msgid ""
"Returns information about a file object. For details type \"man 2 lstat\""
" or \"man 2 stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:141
msgid "path name of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:142
msgid ""
"fields which describe the file's block size, creation time, size, and "
"other attributes."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:146
msgid ""
"Additionally, the result of ``fio.stat('file-name')`` will include "
"methods equivalent to POSIX macros:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:149
msgid "``is_blk()`` = POSIX macro S_ISBLK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:150
msgid "``is_chr()`` = POSIX macro S_ISCHR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:151
msgid "``is_dir()`` = POSIX macro S_ISDIR,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:152
msgid "``is_fifo()`` = POSIX macro S_ISFIFO,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:153
msgid "``is_link()`` = POSIX macro S_ISLINK,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:154
msgid "``is_reg()`` = POSIX macro S_ISREG,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:155
msgid "``is_sock()`` = POSIX macro S_ISSOCK."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:157
msgid "For example, ``fio.stat('/'):is_dir()`` will return true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:161
msgid ""
"tarantool> fio.lstat('/etc')\n"
"---\n"
"- inode: 1048577\n"
"  rdev: 0\n"
"  size: 12288\n"
"  atime: 1421340698\n"
"  mode: 16877\n"
"  mtime: 1424615337\n"
"  nlink: 160\n"
"  uid: 0\n"
"  blksize: 4096\n"
"  gid: 0\n"
"  ctime: 1424615337\n"
"  dev: 2049\n"
"  blocks: 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:187
msgid ""
"Create or delete a directory. For details type \"man 2 mkdir\" or \"man 2"
" rmdir\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:190
msgid "path of directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:191
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:194
#: ../doc/1.7/reference/reference_lua/fio.rst:290
#: ../doc/1.7/reference/reference_lua/fio.rst:332
#: ../doc/1.7/reference/reference_lua/fio.rst:348
#: ../doc/1.7/reference/reference_lua/fio.rst:476
#: ../doc/1.7/reference/reference_lua/fio.rst:550
msgid "true if success, false if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:199
msgid ""
"tarantool> fio.mkdir('/etc')\n"
"---\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:208
msgid ""
"Return a list of files that match an input string. The list is "
"constructed with a single flag that controls the behavior of the "
"function: GLOB_NOESCAPE. For details type \"man 3 glob\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:212
msgid "path-name, which may contain wildcard characters."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:213
msgid "list of files whose names match the input string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:216
#: ../doc/1.7/reference/reference_lua/fio.rst:384
#: ../doc/1.7/reference/reference_lua/fio.rst:500
#: ../doc/1.7/reference/reference_lua/socket.rst:375
msgid "Possible errors: nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:220
msgid ""
"tarantool> fio.glob('/etc/x*')\n"
"---\n"
"- - /etc/xdg\n"
"  - /etc/xml\n"
"  - /etc/xul-ext\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:231
msgid "Return the name of a directory that can be used to store temporary files."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:235
msgid ""
"tarantool> fio.tempdir()\n"
"---\n"
"- /tmp/lG31e7\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:244
msgid "Return the name of the current working directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:248
msgid ""
"tarantool> fio.cwd()\n"
"---\n"
"- /home/username/tarantool_sandbox\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:260
msgid ""
"Functions to create and delete links. For details type \"man readlink\", "
"\"man 2 link\", \"man 2 symlink\", \"man 2 unlink\".."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:263
msgid "existing file name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:264
msgid "linked name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:266
msgid ""
"``fio.link`` and ``fio.symlink`` and ``fio.unlink`` return true if "
"success, false if failure. ``fio.readlink`` returns the link value if "
"success, nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:272
msgid ""
"tarantool> fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.unlink('/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:285
msgid "Rename a file or directory. For details type \"man 2 rename\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:287
msgid "original name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:288
msgid "new name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:295
msgid ""
"tarantool> fio.rename('/home/username/tmp.txt', "
"'/home/username/tmp.txt2')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:305
msgid ""
"Manage the rights to file objects, or ownership of file objects. For "
"details type \"man 2 chown\" or \"man 2 chmod\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:308
msgid "new user uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:309
msgid "new group uid."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:310
msgid "new permissions"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:314
msgid ""
"tarantool> fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))\n"
"---\n"
"- true\n"
"...\n"
"tarantool> fio.chown('/home/username/tmp.txt', 'username', 'username')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:327
msgid ""
"Reduce file size to a specified value. For details type \"man 2 "
"truncate\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:337
msgid ""
"tarantool> fio.truncate('/home/username/tmp.txt', 99999)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:346
msgid "Ensure that changes are written to disk. For details type \"man 2 sync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:353
msgid ""
"tarantool> fio.sync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:369
msgid "Open a file in preparation for reading or writing or seeking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:372
msgid ""
"Flags can be passed as a number or as string constants, for example "
"'``O_RDONLY``', '``O_WRONLY``', '``O_RDWR``'. Flags can be combined by "
"enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:376
msgid ""
"Mode bits can be passed as a number or as string constants, for example "
"''`S_IWUSR`\". Mode bits are significant if flags include `O_CREAT` or "
"`O_TMPFILE`. Mode bits can be combined by enclosing them in braces."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:381
msgid "file handle (later - fh)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:388
msgid ""
"tarantool> fh = fio.open('/home/username/tmp.txt', {'O_RDWR', "
"'O_APPEND'})\n"
"---\n"
"...\n"
"tarantool> fh -- display file handle returned by fio.open\n"
"---\n"
"- fh: 11\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:402
msgid ""
"Close a file that was opened with ``fio.open``. For details type \"man 2 "
"close\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:404
#: ../doc/1.7/reference/reference_lua/fio.rst:424
#: ../doc/1.7/reference/reference_lua/fio.rst:455
#: ../doc/1.7/reference/reference_lua/fio.rst:475
#: ../doc/1.7/reference/reference_lua/fio.rst:493
#: ../doc/1.7/reference/reference_lua/fio.rst:516
#: ../doc/1.7/reference/reference_lua/fio.rst:549
msgid "file-handle as returned by ``fio.open()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:405
msgid "true if success, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:410
msgid ""
"tarantool> fh:close() -- where fh = file-handle\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:420
msgid ""
"Perform read/write random-access operation on a file, without affecting "
"the current seek position of the file. For details type \"man 2 pread\" "
"or \"man 2 pwrite\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:425
#: ../doc/1.7/reference/reference_lua/fio.rst:456
msgid "number of bytes to read"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:426
#: ../doc/1.7/reference/reference_lua/fio.rst:457
msgid "value to write"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:427
msgid "offset within file where reading or writing begins"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:428
msgid ""
"``fh:pwrite`` returns true if success, false if failure. ``fh:pread`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:433
msgid ""
"tarantool> fh:pread(25, 25)\n"
"---\n"
"- |\n"
"  elete from t8//\n"
"  insert in\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:445
msgid ""
"Perform non-random-access read or write on a file. For details type \"man"
" 2 read\" or \"man 2 write\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:450
msgid ""
"``fh:read`` and ``fh:write`` affect the seek position within the file, "
"and this must be taken into account when working on the same file from "
"multiple fibers. It is possible to limit or prevent file access from "
"other fibers with ``fiber.ipc``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:458
msgid ""
"``fh:write`` returns true if success, false if failure. ``fh:read`` "
"returns the data that was read, or nil if failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:463
msgid ""
"tarantool> fh:write('new data')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:472
msgid ""
"Change the size of an open file. Differs from ``fio.truncate``, which "
"changes the size of a closed file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:481
msgid ""
"tarantool> fh:truncate(0)\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:490
msgid ""
"Shift position in the file to the specified position. For details type "
"\"man 2 seek\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:494
msgid "position to seek to"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:495
msgid ""
"'``SEEK_END``' = end of file, '``SEEK_CUR``' = current position, "
"'``SEEK_SET``' = start of file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:497
msgid "the new position if success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:504
msgid ""
"tarantool> fh:seek(20, 'SEEK_SET')\n"
"---\n"
"- 20\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:513
msgid ""
"Return statistics about an open file. This differs from ``fio.stat`` "
"which return statistics about a closed file. For details type \"man 2 "
"stat\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:517
msgid "details about the file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:522
msgid ""
"tarantool> fh:stat()\n"
"---\n"
"- inode: 729866\n"
"  rdev: 0\n"
"  size: 100\n"
"  atime: 140942855\n"
"  mode: 33261\n"
"  mtime: 1409430660\n"
"  nlink: 1\n"
"  uid: 1000\n"
"  blksize: 4096\n"
"  gid: 1000\n"
"  ctime: 1409430660\n"
"  dev: 2049\n"
"  blocks: 8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:545
msgid ""
"Ensure that file changes are written to disk, for an open file. Compare "
"``fio.sync``, which is for all files. For details type \"man 2 fsync\" or"
" \"man 2 fdatasync\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:554
msgid ""
"tarantool> fh:fsync()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:565
msgid "FIO constants"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:569
msgid ""
"Table with constants which are the same as POSIX flag values on the "
"target platform (see ``man 2 stat``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fio.rst:574
msgid ""
"tarantool> fio.c\n"
"---\n"
"- seek:\n"
"    SEEK_SET: 0\n"
"    SEEK_END: 2\n"
"    SEEK_CUR: 1\n"
"  mode:\n"
"    S_IWGRP: 16\n"
"    S_IXGRP: 8\n"
"    S_IROTH: 4\n"
"    S_IXOTH: 1\n"
"    S_IRUSR: 256\n"
"    S_IXUSR: 64\n"
"    S_IRWXU: 448\n"
"    S_IRWXG: 56\n"
"    S_IWOTH: 2\n"
"    S_IRWXO: 7\n"
"    S_IWUSR: 128\n"
"    S_IRGRP: 32\n"
"  flag:\n"
"    O_EXCL: 2048\n"
"    O_NONBLOCK: 4\n"
"    O_RDONLY: 0\n"
"    <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:33
msgid "Module `fun`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:35
msgid ""
"Luafun, also known as the Lua Functional Library, takes advantage of the "
"features of LuaJIT to help users create complex functions. Inside the "
"module are \"sequence processors\" such as ``map``, ``filter``, "
"``reduce``, ``zip`` -- they take a user-written function as an argument "
"and run it against every element in a sequence, which can be faster or "
"more convenient than a user-written loop. Inside the module are "
"\"generators\" such as ``range``, ``tabulate``, and ``rands`` -- they "
"return a bounded or boundless series of values. Within the module are "
"\"reducers\", \"filters\", \"composers\" ... or, in short, all the "
"important features found in languages like Standard ML, Haskell, or "
"Erlang."
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:45
msgid ""
"The full documentation is `On the luafun section of github`_. However, "
"the first chapter can be skipped because installation is already done, "
"it's inside Tarantool. All that is needed is the usual ``require`` "
"request. After that, all the operations described in the Lua fun manual "
"will work, provided they are preceded by the name returned by the "
"``require`` request. For example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/fun.rst:51
msgid ""
"tarantool> fun = require('fun')\n"
"---\n"
"...\n"
"tarantool> for _k, a in fun.range(3) do\n"
"         >   print(a)\n"
"         > end\n"
"1\n"
"2\n"
"3\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:33
msgid "Module `http`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:37
msgid ""
"The ``http`` module, specifically the ``http.client`` submodule, provides"
" the functionality of an HTTP client with support for HTTPS and "
"keepalive. It uses routines in the `libcurl "
"<https://curl.haxx.se/libcurl/>`_ library."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:45
msgid "Construct a new HTTP client instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:47
msgid "the maximum number of entries in the connection cache."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:49
msgid "a new HTTP client instance"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:54
msgid ""
"tarantool> http_client = require('http.client').new({5})\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:64
msgid ""
"If ``http_client`` is an HTTP client instance, ``http_client:request()`` "
"will perform an HTTP request and, if there is a successful connection, "
"will return a table with connection information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:68
msgid "HTTP method, for example 'GET' or 'POST' or 'PUT'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:69
msgid "location, for example 'https://tarantool.org/doc'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:70
msgid "optional initial message, for example 'My text string!'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:71
msgid ""
"table of connection options, with any of these components:   * "
"``timeout`` - number of seconds to wait for a curl API read request    "
"before timing out  * ``ca_path`` - path to a directory holding one or "
"more certificates to    verify the peer with  * ``ca_file`` - path to an "
"SSL certificate file to verify the peer with  * ``headers`` - table of "
"HTTP headers  * ``keepalive_idle`` - delay, in seconds, that the "
"operating system    will wait while the connection is idle before sending"
" keepalive    probes. See also    `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``keepalive_interval`` - the interval, in seconds, that the operating    "
"system will wait between sending keepalive probes. See also    "
"`CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_  * "
"``low_speed_time`` - set the \"low speed time\" -- the time that the    "
"transfer speed should be below the \"low speed limit\" for the library"
"    to consider it too slow and abort. See also    "
"`CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_  * "
"``low_speed_limit`` - set the \"low speed limit\" -- the average    "
"transfer speed in bytes per second that the transfer should be below    "
"during \"low speed time\" seconds for the library to consider it to be"
"    too slow and abort. See also    `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_  * "
"``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:71
msgid "table of connection options, with any of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:74
msgid ""
"``timeout`` - number of seconds to wait for a curl API read request "
"before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:76
msgid ""
"``ca_path`` - path to a directory holding one or more certificates to "
"verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:78
msgid "``ca_file`` - path to an SSL certificate file to verify the peer with"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:79
msgid "``headers`` - table of HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:80
msgid ""
"``keepalive_idle`` - delay, in seconds, that the operating system will "
"wait while the connection is idle before sending keepalive probes. See "
"also `CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:84
msgid ""
"``keepalive_interval`` - the interval, in seconds, that the operating "
"system will wait between sending keepalive probes. See also "
"`CURLOPT_TCP_KEEPALIVE "
"<https://curl.haxx.se/libcurl/c/CURLOPT_TCP_KEEPALIVE.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:87
msgid ""
"``low_speed_time`` - set the \"low speed time\" -- the time that the "
"transfer speed should be below the \"low speed limit\" for the library to"
" consider it too slow and abort. See also `CURLOPT_LOW_SPEED_TIME "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_TIME.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:91
msgid ""
"``low_speed_limit`` - set the \"low speed limit\" -- the average transfer"
" speed in bytes per second that the transfer should be below during \"low"
" speed time\" seconds for the library to consider it to be too slow and "
"abort. See also `CURLOPT_LOW_SPEED_LIMIT "
"<https://curl.haxx.se/libcurl/c/CURLOPT_LOW_SPEED_LIMIT.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:96
msgid "``verbose`` - set on/off verbose mode"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:98
msgid "connection information, with all of these components:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:100
msgid "``status`` - HTTP response status"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:101
msgid "``reason`` - HTTP response status text"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:102
msgid "``headers`` - a Lua table with normalized HTTP headers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:103
msgid "``body`` - response body"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:104
msgid "``proto`` - protocol version"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:108
msgid "The following \"shortcuts\" exist for requests:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:110
msgid ""
"``http_client:get(url, options)`` - shortcut for "
"``http_client:request(\"GET\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:112
msgid ""
"``http_client:post (url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:114
msgid ""
"``http_client:put(url, body, options)`` - shortcut for "
"``http_client:request(\"POST\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:116
msgid ""
"``http_client:patch(url, body, options)`` - shortcut for "
"``http_client:request(\"PATCH\", url, body, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:118
msgid ""
"``http_client:options(url, options)`` - shortcut for "
"``http_client:request(\"OPTIONS\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:120
msgid ""
"``http_client:head(url, options)`` - shortcut for "
"``http_client:request(\"HEAD\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:122
msgid ""
"``http_client:delete(url, options)`` - shortcut for "
"``http_client:request(\"DELETE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:124
msgid ""
"``http_client:trace(url, options)`` - shortcut for "
"``http_client:request(\"TRACE\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:126
msgid ""
"``http_client:connect:(url, options)`` - shortcut for "
"``http_client:request(\"CONNECT\", url, nil, opts)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:131
msgid "The ``http_client:stat()`` function returns a table with statistics:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:133
msgid "``active_requests`` - number of currently executing requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:134
msgid "``sockets_added`` - total number of sockets added into an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:135
msgid "``sockets_deleted`` - total number of sockets sockets from an event loop"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:136
msgid "``total_requests`` - total number of requests"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:137
msgid ""
"``http_200_responses`` - total number of requests which have returned "
"code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:139
msgid ""
"``http_other_responses`` - total number of requests which have not "
"returned code HTTP 200"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:141
msgid ""
"``failed_requests`` - total number of requests which have failed "
"including system errors, curl errors, and HTTP errors"
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:146
msgid ""
"Connect to an HTTP server, look at the size of the response for a 'GET' "
"request, and look at the statistics for the session."
msgstr ""

#: ../doc/1.7/reference/reference_lua/http.rst:149
msgid ""
"tarantool> http_client = require('http.client').new()\n"
"---\n"
"...\n"
"tarantool> r = http_client:request('GET','http://tarantool.org')\n"
"---\n"
"...\n"
"tarantool> string.len(r.body)\n"
"---\n"
"- 21725\n"
"...\n"
"tarantool> http_client:stat()\n"
"---\n"
"- total_requests: 1\n"
"  sockets_deleted: 2\n"
"  failed_requests: 0\n"
"  active_requests: 0\n"
"  http_other_responses: 0\n"
"  http_200_responses: 1\n"
"  sockets_added: 2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:33
msgid "Module `iconv`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:37
msgid ""
"The ``iconv`` module provides a way to convert a string with one encoding"
" to a string with another encoding, for example from ASCII to UTF-8. It "
"is based on the POSIX iconv routines."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:41
msgid ""
"An exact list of the available encodings may depend on environment. "
"Typically the list includes ASCII, BIG5, KOI8R, LATIN8, MS-GREEK, SJIS, "
"and about 100 others. For a complete list, type ``iconv --list`` on a "
"terminal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:50
msgid "Construct a new iconv instance."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:52
msgid "the name of the encoding that we will convert to."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:53
msgid "the name of the encoding that we will convert from."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:55
msgid "a new iconv instance -- in effect, a callable function"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:58
msgid "If either parameter is not a valid name, there will be an error message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:62
msgid ""
"tarantool> converter = require('iconv').new('UTF8', 'ASCII')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:70
msgid "Convert."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:72
msgid "the string to be converted (the \"from\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:74
msgid "the string that results from the conversion (the \"to\" string)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:76
msgid ""
"If anything in input-string cannot be converted, there will be an error "
"message and the result string will be unchanged."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:81
msgid ""
"We know that the Unicode code point for \"Д\" (CYRILLIC CAPITAL LETTER "
"DE) is hexadecimal 0414 according to the character database of Unicode_. "
"Therefore that is what it will look like in UTF-16. We know that "
"Tarantool typically uses the UTF-8 character set. So make a from-UTF-8"
"-to-UTF-16 converter, use string.hex('Д') to show what Д's encoding looks"
" like in the UTF-8 source, and use string.hex('Д'-after-conversion) to "
"show what it looks like in the UTF-16 target. Since the result is 0414, "
"we see that iconv conversion works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/iconv.rst:90
msgid ""
"tarantool> string.hex('Д')\n"
"---\n"
"- d094\n"
"...\n"
"\n"
"tarantool> converter = require('iconv').new('UTF16BE', 'UTF8')\n"
"---\n"
"...\n"
"\n"
"tarantool> utf16_string = converter('Д')\n"
"---\n"
"...\n"
"\n"
"tarantool> string.hex(utf16_string)\n"
"---\n"
"- '0414'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:33
msgid "Built-in modules reference"
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:35
msgid "This reference covers Tarantool's built-in Lua modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:39
msgid ""
"Some functions in these modules are analogs to functions from `standard "
"Lua libraries <http://www.lua.org/manual/>`_. For better results, we "
"recommend using functions from Tarantool's built-in modules."
msgstr ""

#: ../doc/1.7/reference/reference_lua/index.rst:43
msgid "List of Lua modules"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:31
msgid "Module `jit`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:35
msgid ""
"The ``jit`` module has functions for tracing the LuaJIT Just-In-Time "
"compiler's progress, showing the byte-code or assembler output that the "
"compiler produces, and in general providing information about what LuaJIT"
" does with Lua code."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:41
msgid "Prints the byte code of a function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:45
msgid ""
"function f()\n"
"  print(\"D\")\n"
"end\n"
"jit.bc.dump(f)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:52
msgid "For a list of available options, read `the source code of bc.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:56
msgid "Prints the i386 assembler code of a string of bytes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:60
msgid ""
"-- Disassemble hexadecimal 97 which is the x86 code for xchg eax, edi\n"
"jit.dis_x86.disass('\\x97')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:65
msgid "For a list of available options, read `the source code of dis_x86.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:69
msgid "Prints the x86-64 assembler code of a string of bytes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:73
msgid ""
"-- Disassemble hexadecimal 97 which is the x86-64 code for xchg eax, edi\n"
"jit.dis_x64.disass('\\x97')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:78
msgid "For a list of available options, read `the source code of dis_x64.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:83
msgid "Prints the intermediate or machine code of following Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:87
msgid ""
"-- Show the machine code of a Lua \"for\" loop\n"
"jit.dump.on('m')\n"
"local x = 0;\n"
"for i = 1, 1e6 do\n"
"  x = x + i\n"
"end\n"
"print(x)\n"
"jit.dump.off()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:98
msgid "For a list of available options, read `the source code of dump.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:104
msgid "Prints a trace of LuaJIT's progress compiling and interpreting code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:108
msgid ""
"-- Show what LuaJIT is doing for a Lua \"for\" loop\n"
"jit.v.on()\n"
"local x = 0\n"
"for i = 1, 1e6 do\n"
"    x = x + i\n"
"end\n"
"print(x)\n"
"jit.v.off()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/jit.rst:119
msgid "For a list of available options, read `the source code of v.lua`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:33
msgid "Module `json`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:35
msgid ""
"The json module provides JSON manipulation routines. It is based on the "
"`Lua-CJSON module by Mark Pulford`_. For a complete manual on Lua-CJSON "
"please read `the official documentation`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:45
msgid "Convert a Lua object to a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:47
#: ../doc/1.7/reference/reference_lua/msgpack.rst:44
#: ../doc/1.7/reference/reference_lua/yaml.rst:44
msgid "either a scalar value or a Lua table value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:48
msgid "the original value reformatted as a JSON string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:53
msgid ""
"tarantool> json=require('json')\n"
"---\n"
"...\n"
"tarantool> json.encode(123)\n"
"---\n"
"- '123'\n"
"...\n"
"tarantool> json.encode({123})\n"
"---\n"
"- '[123]'\n"
"...\n"
"tarantool> json.encode({123, 234, 345})\n"
"---\n"
"- '[123,234,345]'\n"
"...\n"
"tarantool> json.encode({abc = 234, cde = 345})\n"
"---\n"
"- '{\"cde\":345,\"abc\":234}'\n"
"...\n"
"tarantool> json.encode({hello = {'world'}})\n"
"---\n"
"- '{\"hello\":[\"world\"]}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:83
msgid "Convert a JSON string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:85
msgid "a string formatted as JSON."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:86
#: ../doc/1.7/reference/reference_lua/yaml.rst:53
msgid "the original contents formatted as a Lua table."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:91
msgid ""
"tarantool> json = require('json')\n"
"---\n"
"...\n"
"tarantool> json.decode('123')\n"
"---\n"
"- 123\n"
"...\n"
"tarantool> json.decode('[123, \"hello\"]')\n"
"---\n"
"- [123, 'hello']\n"
"...\n"
"tarantool> json.decode('{\"hello\": \"world\"}').hello\n"
"---\n"
"- world\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:113
#: ../doc/1.7/reference/reference_lua/msgpack.rst:63
#: ../doc/1.7/reference/reference_lua/yaml.rst:60
msgid ""
"A value comparable to Lua \"nil\" which may be useful as a placeholder in"
" a tuple."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:118
msgid ""
"-- When nil is assigned to a Lua-table field, the field is null\n"
"tarantool> {nil, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a Lua-table field, the field is "
"json.NULL\n"
"tarantool> {json.NULL, 'a', 'b'}\n"
"---\n"
"- - null\n"
"  - a\n"
"  - b\n"
"...\n"
"-- When json.NULL is assigned to a JSON field, the field is null\n"
"tarantool> json.encode({field2 = json.NULL, field1 = 'a', field3 = 'c'})\n"
"---\n"
"- '{\"field2\":null,\"field1\":\"a\",\"field3\":\"c\"}'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:140
msgid "The JSON output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:142
msgid "``__serialize=\"seq\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:143
msgid "``__serialize=\"map\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:145
#: ../doc/1.7/reference/reference_lua/yaml.rst:97
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:148
msgid ""
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- '[\"A\",\"B\"]'\n"
"...\n"
"tarantool> json.encode(setmetatable({'A', 'B'}, { __serialize=\"map\"}))\n"
"---\n"
"- '{\"1\":\"A\",\"2\":\"B\"}'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- '[{\"f2\":\"B\",\"f1\":\"A\"}]'\n"
"...\n"
"tarantool> json.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"seq\"})})\n"
"---\n"
"- '[[]]'\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:172
msgid "Configuration settings"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:174
msgid ""
"There are configuration settings which affect the way that Tarantool "
"encodes invalid numbers or types. They are all boolean ``true``/``false``"
" values"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:177
msgid "``cfg.encode_invalid_numbers`` (default is true) -- allow nan and inf"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:178
msgid ""
"``cfg.encode_use_tostring`` (default is false) -- use tostring for "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:180
msgid ""
"``cfg.encode_invalid_as_nil`` (default is false) -- use null for all "
"unrecognizable types"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:182
msgid "``cfg.encode_load_metatables`` (default is false) -- load metatables"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:184
msgid ""
"For example, the following code will interpret 0/0 (which is \"not a "
"number\") and 1/0 (which is \"infinity\") as special values rather than "
"nulls or errors:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:187
msgid ""
"json = require('json')\n"
"json.cfg{encode_invalid_numbers = true}\n"
"x = 0/0\n"
"y = 1/0\n"
"json.encode({1, x, y, 2})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:195
msgid "The result of the json.encode request will look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:197
msgid ""
"tarantool> json.encode({1, x, y, 2})\n"
"---\n"
"- '[1,nan,inf,2]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/json.rst:204
msgid ""
"The same configuration settings exist for json, for :ref:`MsgPack "
"<msgpack-module>`, and for :ref:`YAML <yaml-module>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:33
msgid "Module `log`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:37
msgid ""
"The Tarantool server puts all diagnostic messages in a log file specified"
" by the :ref:`log <cfg_logging-log>` configuration parameter. Diagnostic "
"messages may be either system-generated by the server's internal code, or"
" user-generated with the :samp:`log.{log_level}` function."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:48
msgid ""
"Output a user-generated message to the :ref:`log file <cfg_logging-log>`,"
" given log_level_function_name = ``error`` or ``warn`` or ``info`` or "
"``verbose`` or ``debug``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:52
#, python-format
msgid ""
"The actual output will be a line containing the current timestamp, a "
"module name, 'E' or 'W' or 'I' or 'V' or 'D' or 'R' depending on "
"``log_level_function_name``, and ``message``. Output will not occur if "
"``log_level_function_name`` is for a type greater than :ref:`log_level "
"<cfg_logging-log_level>`. Messages may contain C-style format specifiers "
"%d or %s, so :samp:`log.error('...%d...%s', {x}, {y})` will work if x is "
"a number and y is a string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:74
#, python-format
msgid ""
"$ tarantool\n"
"tarantool> box.cfg{log_level=3, logger='tarantool.txt'}\n"
"tarantool> log = require('log')\n"
"tarantool> log.error('Error')\n"
"tarantool> log.info('Info %s', box.info.version)\n"
"tarantool> os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:83
msgid "$ less tarantool.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:90
msgid ""
"2...0 [5257] main/101/interactive C> version 1.7.0-355-ga4f762d\n"
"2...1 [5257] main/101/interactive C> log level 3\n"
"2...0 [5257] main/101/interactive [C]:-1 E> Error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:94
msgid "The 'Error' line is visible in tarantool.txt preceded by the letter E."
msgstr ""

#: ../doc/1.7/reference/reference_lua/log.rst:96
msgid "The 'Info' line is not present because the log_level is 3."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:33
msgid "Module `msgpack`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:35
msgid ""
"The ``msgpack`` module takes strings in MsgPack_ format and decodes them,"
" or takes a series of non-MsgPack values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:42
msgid "Convert a Lua object to a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:45
msgid "the original value reformatted as a MsgPack string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:50
msgid "Convert a MsgPack string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:52
msgid "a string formatted as MsgPack."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:54
msgid "the original contents formatted as a Lua table;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:55
msgid "the number of bytes that were decoded."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:57
msgid "lua object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:70
msgid ""
"tarantool> msgpack = require('msgpack')\n"
"---\n"
"...\n"
"tarantool> y = msgpack.encode({'a',1,'b',2})\n"
"---\n"
"...\n"
"tarantool> z = msgpack.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> box.space.tester:insert{20, msgpack.NULL, 20}\n"
"---\n"
"- [20, null, 20]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:95
msgid "The MsgPack output structure can be specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:97
msgid "``__serialize = \"seq\" or \"sequence\"`` for an array"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:98
msgid "``__serialize = \"map\" or \"mapping\"`` for a map"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:100
msgid ""
"Serializing 'A' and 'B' with different ``__serialize`` values causes "
"different results. To show this, here is a routine which encodes "
"`{'A','B'}` both as an array and as a map, then displays each result in "
"hexadecimal."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:104
#, python-format
msgid ""
"function hexdump(bytes)\n"
"    local result = ''\n"
"    for i = 1, #bytes do\n"
"        result = result .. string.format(\"%x\", string.byte(bytes, i)) "
".. ' '\n"
"    end\n"
"    return result\n"
"end\n"
"\n"
"msgpack = require('msgpack')\n"
"m1 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"seq\"\n"
"                          }))\n"
"m2 = msgpack.encode(setmetatable({'A', 'B'}, {\n"
"                             __serialize = \"map\"\n"
"                          }))\n"
"print('array encoding: ', hexdump(m1))\n"
"print('map encoding: ', hexdump(m2))"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:124
msgid "**Result:**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:129
msgid ""
"**array** encoding: 92 a1 41 a1 42\n"
"**map** encoding:   82 01 a1 41 02 a1 42"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:132
msgid "The MsgPack Specification_ page explains that the first encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:137
msgid "fixarray(2), fixstr(1), \"A\", fixstr(1), \"B\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:139
msgid "and the second encoding means:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:144
msgid "fixmap(2), key(1), fixstr(1), \"A\", key(2), fixstr(2), \"B\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:146
msgid ""
"Here are examples for all the common types, with the Lua-table "
"representation on the left, with the MsgPack format name and encoding on "
"the right."
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:154
msgid "**Common Types and MsgPack Encodings**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:160
msgid "{}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:160
msgid "'fixmap' if metatable is 'map' = 80 otherwise 'fixarray' = 90"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:163
msgid "'a'"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:163
msgid "'fixstr' = a1 61"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:165
msgid "'false' = c2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:167
msgid "'true' = c3"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:169
msgid "127"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:169
msgid "'positive fixint' = 7f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "65535"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:171
msgid "'uint 16' = cd ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "4294967295"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:173
msgid "'uint 32' = ce ff ff ff ff"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:175
msgid "'nil' = c0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:177
msgid "same as nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid "[0] = 5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:179
msgid ""
"'fixmap(1)' + 'positive fixint' (for the key) + 'positive fixint' (for "
"the value) = 81 00 05"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:182
msgid "[0] = nil"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:182
msgid "'fixmap(0)' = 80 -- nil is not stored when it is a missing map value"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "1.5"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:185
msgid "'float 64' = cb 3f f8 00 00 00 00 00 00"
msgstr ""

#: ../doc/1.7/reference/reference_lua/msgpack.rst:188
msgid ""
"Also, some MsgPack configuration settings for encoding can be changed, in"
" the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:33
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:33
msgid "Module `net.box`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:35
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is connecting to MySQL or MariaDB or "
"PostgreSQL (see :ref:`SQL DBMS modules <dbms_modules>` reference). The "
"other variant, which is discussed in this section, is connecting to "
"Tarantool server instances via a network using the built-in ``net.box`` "
"module."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:41
msgid "You can call the following methods:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:43
msgid ""
"``require('net.box')`` to get a ``net.box`` object (named ``net_box`` for"
" examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:45
msgid ""
"``net_box.connect()`` to connect and get a connection object (named "
"``conn`` for examples in this section),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:47
msgid ""
"other ``net.box()`` routines, passing ``conn:``, to execute requests on a"
" remote box,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:49
msgid "``conn:close`` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:51
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example, when"
" it's necessary to prioritize requests or to use different authentication"
" IDs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:60
msgid "The diagram below shows possible connection states and transitions:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:68
msgid "On this diagram:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:70
msgid "The state machine starts in the 'initial' state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:72
msgid ""
"``net_box.connect()`` method changes the state to 'connecting' and spawns"
" a worker fiber."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:74
msgid ""
"If authentication and schema upload are required, it's possible later on "
"to re-enter the 'fetch_schema' state from 'active' if a request fails due"
" to a schema version mismatch error, so schema reload is triggered."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:78
msgid ""
"``conn.close()`` method sets the state to 'closed' and kills the worker. "
"If the transport is already in the 'error' state, ``close()`` does "
"nothing."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:88
msgid ""
"The names ``connect()`` and ``new()`` are synonymous with the only "
"difference that ``connect()`` is the preferred name, while ``new()`` is "
"retained for backward compatibility."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:92
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It can be re-established automatically after a"
" disconnect (see ``reconnect_after`` option below). The returned ``conn``"
" object supports methods for making remote requests, such as select, "
"update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:98
msgid ""
"For a local Tarantool server, there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.connect('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-implicit-yields>` any"
" request can yield, and database state may have changed by the time it "
"regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:110
msgid "Possible options:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:112
msgid ""
"`wait_connected`: by default, connection creation is blocked until the "
"connection is established, but passing ``wait_connected=false`` makes it "
"return immediately. Also, passing a timeout makes it wait before "
"returning (e.g. ``wait_connected=1.5`` makes it wait at most 1.5 secs)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:118
msgid ""
"In the presence of ``reconnect_after``, ``wait_connected`` ignores "
"transient failures. The wait completes once the connection is established"
" or is closed explicitly."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:121
msgid ""
"`reconnect_after`: a ``net.box`` instance automatically reconnects any "
"time the connection is broken or if a connection attempt fails. This "
"makes transient network failures become transparent to the application. "
"Reconnect happens automatically in the background, so queries/requests "
"that suffered due to connectivity loss are transparently retried. The "
"number of retries is unlimited, connection attempts are done over the "
"specified timeout (e.g. ``reconnect_after=5`` for 5 secs). Once a "
"connection is explicitly closed (or garbage-collected), reconnects stop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:130
msgid ""
"`call_16`: [since 1.7.2] by default, ``net.box`` connections comply with "
"a new binary protocol command for CALL, which is not backward compatible "
"with previous versions. The new CALL no longer restricts a function to "
"returning an array of tuples and allows returning an arbitrary "
"MsgPack/JSON result, including scalars, nil and void (nothing). The old "
"CALL is left intact for backward compatibility. It will be removed in the"
" next major release. All programming language drivers will be gradually "
"changed to use the new CALL. To connect to a Tarantool instance that uses"
" the old CALL, specify ``call_16=true``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:139
msgid ""
"`console`: depending on the option's value, the connection supports "
"different methods (as if instances of different classes were returned). "
"With ``console = true``, you can use ``conn`` methods ``close()``, "
"``is_connected()``, ``wait_state()``, ``eval()`` (in this case, both "
"binary and Lua console network protocols are supported). With ``console ="
" false`` (default), you can also use ``conn`` database methods (in this "
"case, only the binary protocol is supported)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:145
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:75
msgid "the :ref:`URI <index-uri>` of the target for the connection"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:146
msgid ""
"possible options are `wait_connected`, `reconnect_after`, `call_16` and "
"`console`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:147
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:77
msgid "conn object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:152
msgid ""
"conn = net_box.connect('localhost:3301')\n"
"conn = net_box.connect('127.0.0.1:3302', {wait_connected = false})\n"
"conn = net_box.connect('127.0.0.1:3303', {reconnect_after = 5, call_16 = "
"true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:162
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:91
msgid "Execute a PING command."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:164
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:93
msgid "true on success, false on error"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:169
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:98
msgid "net_box.self:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:175
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:104
msgid "Wait for connection to be active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:177
#: ../doc/1.7/reference/reference_lua/net_box.rst:205
msgid "in seconds"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:178
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:107
msgid "true when connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:183
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:112
msgid "net_box.self:wait_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:189
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:118
msgid "Show whether connection is active or closed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:191
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:120
msgid "true if connected, false on failure."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:196
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:125
msgid "net_box.self:is_connected()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:202
msgid "[since 1.7.2] Wait for a target state."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:204
msgid "target states"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:206
msgid ""
"true when a target state is reached, false on timeout or connection "
"closure"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:211
msgid ""
"-- wait infinitely for 'active' state:\n"
"conn:wait_state('active')\n"
"\n"
"-- wait for 1.5 secs at most:\n"
"conn:wait_state('active', 1.5)\n"
"\n"
"-- wait infinitely for either `active` or `fetch_schema` state:\n"
"conn:wait_state({active=true, fetch_schema=true})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:224
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:132
msgid "Close a connection."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:226
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:134
msgid ""
"Connection objects are garbage collected just like any other objects in "
"Lua, so an explicit destruction is not mandatory. However, since close() "
"is a system call, it is good programming practice to close a connection "
"explicitly when it is no longer needed, to avoid lengthy stalls of the "
"garbage collector."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:233
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:141
msgid "conn:close()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:239
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:147
msgid ""
":samp:`conn.space.{space-name}:select`:code:`{...}` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-"
"name}:select`:code:`{...}`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:244
msgid ""
"Due to :ref:`the implicit yield rules <atomic-implicit-yields>` a local "
":samp:`box.space.{space-name}:select`:code:`{...}` does not yield, but a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` call does "
"yield, so global variables or database tuples data may change when a "
"remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:253
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:161
msgid ""
":samp:`conn.space.{space-name}:get(...)` is the remote-call equivalent of"
" the local call :samp:`box.space.{space-name}:get(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:258
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:166
msgid ""
":samp:`conn.space.{space-name}:insert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:insert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:263
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:171
msgid ""
":samp:`conn.space.{space-name}:replace(...)` is the remote-call "
"equivalent of the local call :samp:`box.space.{space-name}:replace(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:268
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:176
msgid ""
":samp:`conn.space.{space-name}:update(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:update(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:273
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:181
msgid ""
":samp:`conn.space.{space-name}:upsert(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:upsert(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:278
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:186
msgid ""
":samp:`conn.space.{space-name}:delete(...)` is the remote-call equivalent"
" of the local call :samp:`box.space.{space-name}:delete(...)`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:285
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:193
msgid ""
"``conn:call('func', '1', '2', '3')`` is the remote-call equivalent of "
"``func('1', '2', '3')``. That is, ``conn:call`` is a remote stored-"
"procedure call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:291
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:199
msgid "conn:call('function5')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:299
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-owners_privileges>` is required; "
"if the user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:307
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:215
msgid "conn:eval('return 5+5')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:313
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:221
msgid ""
"``timeout(...)`` is a wrapper which sets a timeout for the request that "
"follows it."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:318
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:226
msgid "conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:322
#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:230
msgid ""
"All remote calls support execution timeouts. Using a wrapper object makes"
" the remote connection API compatible with the local one, removing the "
"need for a separate ``timeout`` argument, which the local version would "
"ignore. Once a request is sent, it cannot be revoked from the remote "
"server even if a timeout expires: the timeout expiration only aborts the "
"wait for the remote server response, not the request itself."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:333
msgid "This example shows the use of most of the ``net.box`` methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:335
msgid "The sandbox configuration for this example assumes that:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:337
msgid "the Tarantool instance is running on ``localhost 127.0.0.1:3301``,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:338
msgid ""
"there is a space named ``tester`` with a numeric primary key and with a "
"tuple that contains a key value = 800,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:340
msgid "the current user has read, write and execute privileges."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:342
msgid "Here are commands for a quick sandbox setup:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:347
msgid ""
"box.cfg{listen = 3301}\n"
"s = box.schema.space.create('tester')\n"
"s:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"t = s:insert({800, 'TEST'})\n"
"box.schema.user.grant('guest', 'read,write,execute', 'universe')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:353
msgid "And here starts the example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box.rst:355
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.connect('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:35
msgid ""
"The ``net.box`` module contains connectors to remote database systems. "
"One variant, to be discussed later, is for connecting to MySQL or MariaDB"
" or PostgreSQL — that variant is the subject of the :ref:`SQL DBMS "
"modules <dbms_modules>` reference. In this section the subject is the "
"built-in variant, ``net.box``. This is for connecting to tarantool "
"servers via a network."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:41
msgid ""
"Call ``require('net.box')`` to get a ``net.box`` object, which will be "
"called ``net_box`` for examples in this section. Call ``net_box.new()`` "
"to connect and get a connection object, which will be called ``conn`` for"
" examples in this section. Call the other ``net.box()`` routines, passing"
" ``conn:``, to execute requests on the remote box. Call :ref:`conn:close "
"<socket-close>` to disconnect."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:47
msgid ""
"All ``net.box`` methods are fiber-safe, that is, it is safe to share and "
"use the same connection object across multiple concurrent fibers. In "
"fact, it's perhaps the best programming practice with Tarantool. When "
"multiple fibers use the same connection, all requests are pipelined "
"through the same network socket, but each fiber gets back a correct "
"response. Reducing the number of active sockets lowers the overhead of "
"system calls and increases the overall server performance. There are, "
"however, cases when a single connection is not enough — for example when "
"it's necessary to prioritize requests or to use different authentication "
"ids."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:60
msgid ""
"Create a new connection. The connection is established on demand, at the "
"time of the first request. It is re-established automatically after a "
"disconnect. The returned ``conn`` object supports methods for making "
"remote requests, such as select, update or delete."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:65
msgid ""
"For the local tarantool server there is a pre-created always-established "
"connection object named :samp:`{net_box}.self`. Its purpose is to make "
"polymorphic use of the ``net_box`` API easier. Therefore :samp:`conn = "
"{net_box}.new('localhost:3301')` can be replaced by :samp:`conn = "
"{net_box}.self`. However, there is an important difference between the "
"embedded connection and a remote one. With the embedded connection, "
"requests which do not modify data do not yield. When using a remote "
"connection, due to :ref:`the implicit rules <atomic-"
"the_implicit_yield_rules>` any request can yield, and database state may "
"have changed by the time it regains control."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:76
msgid "a possible option is `wait_connect`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:82
msgid ""
"conn = net_box.new('localhost:3301')\n"
"conn = net_box.new('127.0.0.1:3306', {wait_connect = false})"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:152
msgid ""
"due to :ref:`the implicit yield rules <atomic-the_implicit_yield_rules>` "
"a local :samp:`box.space.{space-name}:select`:code:`{...}` does not "
"yield, but a remote :samp:`conn.space.{space-name}:select`:code:`{...}` "
"call does yield, so global variables or database tuples data may change "
"when a remote :samp:`conn.space.{space-name}:select`:code:`{...}` occurs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:207
msgid ""
":samp:`conn:eval({Lua-string})` evaluates and executes the expression in "
"Lua-string, which may be any statement or series of statements. An "
":ref:`execute privilege <authentication-privileges>` is required; if the "
"user does not have it, an administrator may grant it with "
":samp:`box.schema.user.grant({username}, 'execute', 'universe')`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:239
msgid "Example showing use of most of the net.box methods"
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:241
msgid ""
"This example will work with the sandbox configuration described in the "
"preface. That is, there is a space named tester with a numeric primary "
"key. Assume that the database is nearly empty. Assume that the tarantool "
"server is running on ``localhost 127.0.0.1:3301``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/net_box_1.6.rst:246
msgid ""
"tarantool> net_box = require('net.box')\n"
"---\n"
"...\n"
"tarantool> function example()\n"
"         >   local conn, wtuple\n"
"         >   if net_box.self:ping() then\n"
"         >     table.insert(ta, 'self:ping() succeeded')\n"
"         >     table.insert(ta, '  (no surprise -- self connection is "
"pre-established)')\n"
"         >   end\n"
"         >   if box.cfg.listen == '3301' then\n"
"         >     table.insert(ta,'The local server listen address = 3301')\n"
"         >   else\n"
"         >     table.insert(ta, 'The local server listen address is not "
"3301')\n"
"         >     table.insert(ta, '(  (maybe box.cfg{...listen=\"3301\"...}"
" was not stated)')\n"
"         >     table.insert(ta, '(  (so connect will fail)')\n"
"         >   end\n"
"         >   conn = net_box.new('127.0.0.1:3301')\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester.')\n"
"         >   conn.space.tester:insert{800, 'data'}\n"
"         >   table.insert(ta, 'conn insert done on tester, index 0')\n"
"         >   table.insert(ta, '  primary key value = 800.')\n"
"         >   wtuple = conn.space.tester:select{800}\n"
"         >   table.insert(ta, 'conn select done on tester, index 0')\n"
"         >   table.insert(ta, '  number of fields = ' .. #wtuple)\n"
"         >   conn.space.tester:delete{800}\n"
"         >   table.insert(ta, 'conn delete done on tester')\n"
"         >   conn.space.tester:replace{800, 'New data', 'Extra data'}\n"
"         >   table.insert(ta, 'conn:replace done on tester')\n"
"         >   conn:timeout(0.5).space.tester:update({800}, {{'=', 2, "
"'Fld#1'}})\n"
"         >   table.insert(ta, 'conn update done on tester')\n"
"         >   conn:close()\n"
"         >   table.insert(ta, 'conn close done')\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> ta = {}\n"
"---\n"
"...\n"
"tarantool> example()\n"
"---\n"
"...\n"
"tarantool> ta\n"
"---\n"
"- - self:ping() succeeded\n"
"  - '  (no surprise -- self connection is pre-established)'\n"
"  - The local server listen address = 3301\n"
"  - conn delete done on tester.\n"
"  - conn insert done on tester, index 0\n"
"  - '  primary key value = 800.'\n"
"  - conn select done on tester, index 0\n"
"  - '  number of fields = 1'\n"
"  - conn delete done on tester\n"
"  - conn:replace done on tester\n"
"  - conn update done on tester\n"
"  - conn close done\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:33
msgid "Module `os`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:37
msgid ""
"The ``os`` module contains the functions :ref:`execute() <os-execute>`, "
":ref:`rename() <os-rename>`, :ref:`getenv() <os-getenv>`, :ref:`remove() "
"<os-remove>`, :ref:`date() <os-date>`, :ref:`exit() <os-exit>`, "
":ref:`time() <os-time>`, :ref:`clock() <os-clock>`, :ref:`tmpname() <os-"
"tmpname>`, :ref:`environ() <os-environ>`, :ref:`setenv() <os-setenv>`, "
":ref:`setlocale() <os-setlocale>`, :ref:`difftime() <os-difftime>`. Most "
"of these functions are described in the Lua manual Chapter 22 `The "
"Operating System Library <https://www.lua.org/pil/contents.html#22>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:54
msgid "Execute by passing to the shell."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:56
msgid "what to execute."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:60
msgid ""
"tarantool> os.execute('ls -l /usr')\n"
"total 200\n"
"drwxr-xr-x   2 root root 65536 Apr 22 15:49 bin\n"
"drwxr-xr-x  59 root root 20480 Apr 18 07:58 include\n"
"drwxr-xr-x 210 root root 65536 Apr 18 07:59 lib\n"
"drwxr-xr-x  12 root root  4096 Apr 22 15:49 local\n"
"drwxr-xr-x   2 root root 12288 Jan 31 09:50 sbin\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:76
msgid "Rename a file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:78
msgid "name of existing file or directory,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:79
msgid "changed name of file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:83
msgid ""
"tarantool> os.rename('local','foreign')\n"
"---\n"
"- null\n"
"- 'local: No such file or directory'\n"
"- 2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:96
msgid "Get environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:98
msgid "Parameters: (string) variable-name = environment variable name."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:102
msgid ""
"tarantool> os.getenv('PATH')\n"
"---\n"
"- /usr/local/sbin:/usr/local/bin:/usr/sbin\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:113
msgid "Remove file or directory."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:115
msgid ""
"Parameters: (string) name = name of file or directory which will be "
"removed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:119
msgid ""
"tarantool> os.remove('file')\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:130
msgid "Return a formatted date."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:132
msgid ""
"Parameters: (string) format-string = instructions; (string) time-since-"
"epoch = number of seconds since 1970-01-01. If time-since-epoch is "
"omitted, it is assumed to be the current time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:137
#, python-format
msgid ""
"tarantool> os.date(\"%A %B %d\")\n"
"---\n"
"- Sunday April 24\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:148
msgid ""
"Exit the program. If this is done on a server instance, then the instance"
" stops."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:152
msgid ""
"tarantool> os.exit()\n"
"user@user-shell:~/tarantool_sandbox$"
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:161
msgid "Return the number of seconds since the epoch."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:165
msgid ""
"tarantool> os.time()\n"
"---\n"
"- 1461516945\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:176
msgid "Return the number of CPU seconds since the program start."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:180
msgid ""
"tarantool> os.clock()\n"
"---\n"
"- 0.05\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:191
msgid "Return a name for a temporary file."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:195
msgid ""
"tarantool> os.tmpname()\n"
"---\n"
"- /tmp/lua_7SW1m2\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:206
msgid "Return a table containing all environment variables."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:210
msgid ""
"tarantool> os.environ()['TERM']..os.environ()['SHELL']\n"
"---\n"
"- xterm/bin/bash\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:221
msgid "Set an environment variable."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:225
msgid ""
"tarantool> os.setenv('VERSION','99')\n"
"---\n"
"-\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:236
msgid ""
"Change the locale. If new-locale-string is not specified, return the "
"current locale."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:241
msgid ""
"tarantool> require('string').sub(os.setlocale(),1,20)\n"
"---\n"
"- LC_CTYPE=en_US.UTF-8\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:252
msgid "Return the number of seconds between two times."
msgstr ""

#: ../doc/1.7/reference/reference_lua/osmodule.rst:256
msgid ""
"tarantool> os.difftime(os.time() - 0)\n"
"---\n"
"- 1486594859\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:31
msgid "Miscellaneous"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:37
msgid ""
"Convert a string or a Lua number to a 64-bit integer. The input value can"
" be expressed in decimal, binary (for example 0b1010), or hexadecimal "
"(for example -0xffff). The result can be used in arithmetic, and the "
"arithmetic will be 64-bit integer arithmetic rather than floating-point "
"arithmetic. (Operations on an unconverted Lua number use floating-point "
"arithmetic.) The ``tonumber64()`` function is added by Tarantool; the "
"name is global."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:47
msgid ""
"tarantool> type(123456789012345), type(tonumber64(123456789012345))\n"
"---\n"
"- number\n"
"- number\n"
"...\n"
"tarantool> i = tonumber64('1000000000')\n"
"---\n"
"...\n"
"tarantool> type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2\n"
"---\n"
"- number\n"
"- 500000000\n"
"- 999999998\n"
"- 2000000000\n"
"- 1000000002\n"
"- 0\n"
"- 1000000000000000000\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:70
msgid ""
"Parse and execute an arbitrary chunk of Lua code. This function is mainly"
" useful to define and run Lua code without having to introduce changes to"
" the global Lua environment."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:74
msgid "Lua code"
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:75
msgid ""
"zero or more scalar values which will be appended to, or substitute for, "
"items in the Lua chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:78
msgid "whatever is returned by the Lua code chunk."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:80
msgid ""
"Possible errors: If there is a compilation error, it is raised as a Lua "
"error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/other.rst:85
msgid ""
"tarantool> dostring('abc')\n"
"---\n"
"error: '[string \"abc\"]:1: ''='' expected near ''<eof>'''\n"
"...\n"
"tarantool> dostring('return 1')\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> dostring('return ...', 'hello', 'world')\n"
"---\n"
"- hello\n"
"- world\n"
"...\n"
"tarantool> dostring([[\n"
"         >   local f = function(key)\n"
"         >     local t = box.space.tester:select{key}\n"
"         >     if t ~= nil then\n"
"         >       return t[1]\n"
"         >     else\n"
"         >       return nil\n"
"         >     end\n"
"         >   end\n"
"         >   return f(...)]], 1)\n"
"---\n"
"- null\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:31
msgid "Module `pickle`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:37
msgid ""
"To use Tarantool binary protocol primitives from Lua, it's necessary to "
"convert Lua variables to binary format. The ``pickle.pack()`` helper "
"function is prototyped after Perl 'pack_'."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:43
msgid "**Format specifiers**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:48
msgid "b, B"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:48
msgid ""
"converts Lua variable to a 1-byte integer, and stores the integer in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:51
msgid "s, S"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:51
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:55
msgid "i, I"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:55
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:59
msgid "l, L"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:59
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, low byte first"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:63
msgid "n"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:63
msgid ""
"converts Lua variable to a 2-byte integer, and stores the integer in the "
"resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:67
msgid "N"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:67
msgid ""
"converts Lua variable to a 4-byte integer, and stores the integer in the "
"resulting string, big"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:70
msgid "q, Q"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:70
msgid ""
"converts Lua variable to an 8-byte integer, and stores the integer in the"
" resulting string, big endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:74
msgid "f"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:74
msgid ""
"converts Lua variable to a 4-byte float, and stores the float in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:77
msgid "d"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:77
msgid ""
"converts Lua variable to a 8-byte double, and stores the double in the "
"resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid "a, A"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:80
msgid ""
"converts Lua variable to a sequence of bytes, and stores the sequence in "
"the resulting string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:84
msgid "string containing format specifiers"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:85
msgid "scalar values to be formatted"
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:86
msgid ""
"a binary string containing all arguments, packed according to the format "
"specifiers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:90
msgid "Possible errors: unknown format specifier."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:94
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> box.space.tester:insert{0, 'hello world'}\n"
"---\n"
"- [0, 'hello world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 'bye world'}})\n"
"---\n"
"- [0, 'bye world']\n"
"...\n"
"tarantool> box.space.tester:update({0}, {\n"
"         >   {'=', 2, pickle.pack('iiA', 0, 3, 'hello')}\n"
"         > })\n"
"---\n"
"- [0, \"\\0\\0\\0\\0\\x03\\0\\0\\0hello\"]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'=', 2, 4}})\n"
"---\n"
"- [0, 4]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'+', 2, 4}})\n"
"---\n"
"- [0, 8]\n"
"...\n"
"tarantool> box.space.tester:update({0}, {{'^', 2, 4}})\n"
"---\n"
"- [0, 12]\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:128
msgid ""
"Counterpart to ``pickle.pack()``. Warning: if format specifier 'A' is "
"used, it must be the last item."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:134
msgid "A list of strings or numbers."
msgstr ""

#: ../doc/1.7/reference/reference_lua/pickle.rst:139
msgid ""
"tarantool> pickle = require('pickle')\n"
"---\n"
"...\n"
"tarantool> tuple = box.space.tester:replace{0}\n"
"---\n"
"...\n"
"tarantool> string.len(tuple[1])\n"
"---\n"
"- 1\n"
"...\n"
"tarantool> pickle.unpack('b', tuple[1])\n"
"---\n"
"- 48\n"
"...\n"
"tarantool> pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, "
"4294967295))\n"
"---\n"
"- 255\n"
"- 65535\n"
"- 4294967295\n"
"...\n"
"tarantool> pickle.unpack('ls', pickle.pack('ls', "
"tonumber64('18446744073709551615'), 65535))\n"
"---\n"
"...\n"
"tarantool> num, num64, str = pickle.unpack('slA', pickle.pack('slA', 666,"
"\n"
"         > tonumber64('666666666666666'), 'string'))\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:33
msgid "Module `socket`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:35
msgid ""
"The ``socket`` module allows exchanging data via BSD sockets with a local"
" or remote host in connection-oriented (TCP) or datagram-oriented (UDP) "
"mode. Semantics of the calls in the ``socket`` API closely follow "
"semantics of the corresponding POSIX calls. Function names and signatures"
" are mostly compatible with `luasocket`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:41
msgid ""
"The functions for setting up and connecting are ``socket``, "
"``sysconnect``, ``tcp_connect``. The functions for sending data are "
"``send``, ``sendto``, ``write``, ``syswrite``. The functions for "
"receiving data are ``recv``, ``recvfrom``, ``read``. The functions for "
"waiting before sending/receiving data are ``wait``, ``readable``, "
"``writable``. The functions for setting flags are ``nonblock``, "
"``setsockopt``. The functions for stopping and disconnecting are "
"``shutdown``, ``close``. The functions for error checking are ``errno``, "
"``error``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:52
msgid "**Socket functions**"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid "Purposes"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:57
msgid "Names"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:59
msgid "setup"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:59
msgid ":ref:`socket() <socket-socket>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:61
#: ../doc/1.7/reference/reference_lua/socket.rst:63
#: ../doc/1.7/reference/reference_lua/socket.rst:65
#: ../doc/1.7/reference/reference_lua/socket.rst:67
#: ../doc/1.7/reference/reference_lua/socket.rst:71
#: ../doc/1.7/reference/reference_lua/socket.rst:73
#: ../doc/1.7/reference/reference_lua/socket.rst:77
#: ../doc/1.7/reference/reference_lua/socket.rst:79
#: ../doc/1.7/reference/reference_lua/socket.rst:83
#: ../doc/1.7/reference/reference_lua/socket.rst:85
#: ../doc/1.7/reference/reference_lua/socket.rst:89
#: ../doc/1.7/reference/reference_lua/socket.rst:93
#: ../doc/1.7/reference/reference_lua/socket.rst:97
#: ../doc/1.7/reference/reference_lua/socket.rst:101
#: ../doc/1.7/reference/reference_lua/socket.rst:103
#: ../doc/1.7/reference/reference_lua/socket.rst:105
#: ../doc/1.7/reference/reference_lua/socket.rst:109
#: ../doc/1.7/reference/reference_lua/socket.rst:111
#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid "\"\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:61
msgid ":ref:`socket.tcp_connect() <socket-tcp_connect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:63
msgid ":ref:`socket.tcp_server() <socket-tcp_server>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:65
msgid ":ref:`socket_object:sysconnect() <socket-sysconnect>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:67
msgid ":ref:`socket_object:send() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:69
msgid "sending"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:69
msgid ":ref:`socket_object:sendto() <socket-sendto>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:71
msgid ":ref:`socket_object:write() <socket-send>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:73
msgid ":ref:`socket_object:syswrite() <socket-syswrite>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid "receiving"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:75
msgid ":ref:`socket_object:recv() <socket-recv>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:77
msgid ":ref:`socket_object:recvfrom() <socket-recvfrom>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:79
msgid ":ref:`socket_object:read() <socket-read>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid "flag setting"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:81
msgid ":ref:`socket_object:nonblock() <socket-nonblock>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:83
msgid ":ref:`socket_object:setsockopt() <socket-setsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:85
msgid ":ref:`socket_object:linger() <socket-linger>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid "client/server"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:87
msgid ":ref:`socket_object:listen() <socket-listen>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:89
msgid ":ref:`socket_object:accept() <socket-accept>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:91
msgid "teardown"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:91
msgid ":ref:`socket_object:shutdown() <socket-shutdown>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:93
msgid ":ref:`socket_object:close() <socket-close>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:95
msgid "error checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:95
msgid ":ref:`socket_object:error() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:97
msgid ":ref:`socket_object:errno() <socket-error>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid "information"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:99
msgid ":ref:`socket.getaddrinfo() <socket-getaddrinfo>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:101
msgid ":ref:`socket_object:getsockopt() <socket-getsockopt>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:103
msgid ":ref:`socket_object:peer() <socket-peer>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:105
msgid ":ref:`socket_object:name() <socket-name>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:107
msgid "state checking"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:107
msgid ":ref:`socket_object:readable() <socket-readable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:109
msgid ":ref:`socket_object:writable() <socket-writable>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:111
msgid ":ref:`socket_object:wait() <socket-wait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:113
msgid ":ref:`socket.iowait() <socket-iowait>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:117
msgid ""
"Typically a socket session will begin with the setup functions, will set "
"one or more flags, will have a loop with sending and receiving functions,"
" will end with the teardown functions -- as an example at the end of this"
" section will show. Throughout, there may be error-checking and waiting "
"functions for synchronization. To prevent a fiber containing socket "
"functions from \"blocking\" other fibers, the :ref:`implicit yield rules "
"<atomic-implicit-yields>` will cause a yield so that other processes may "
"take over, as is the norm for cooperative multitasking."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:126
msgid ""
"For all examples in this section the socket name will be sock and the "
"function invocations will look like ``sock:function_name(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:135
msgid ""
"Create a new TCP or UDP socket. The argument values are the same as in "
"the `Linux socket(2) man page <http://man7.org/linux/man-"
"pages/man2/socket.2.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:138
msgid "an unconnected socket, or nil."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:143
msgid "socket('AF_INET', 'SOCK_STREAM', 'tcp')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:151
msgid "Connect a socket to a remote host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:153
msgid "URL or IP address"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:154
msgid "port number"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:155
msgid "timeout"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:156
msgid "a connected socket, if no error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:161
msgid "socket.tcp_connect('127.0.0.1', 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:169
msgid ""
"The ``socket.getaddrinfo()`` function is useful for finding information "
"about a remote site so that the correct arguments for "
"``sock:sysconnect()`` can be passed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:173
#: ../doc/1.7/reference/reference_lua/socket.rst:547
#: ../doc/1.7/reference/reference_lua/socket.rst:559
msgid ""
"A table containing these fields: \"host\", \"family\", \"type\", "
"\"protocol\", \"port\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:178
msgid ""
"``socket.getaddrinfo('tarantool.org', 'http')`` will return variable "
"information such as"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:181
msgid ""
"---\n"
"- - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_STREAM\n"
"    protocol: tcp\n"
"    port: 80\n"
"  - host: 188.93.56.70\n"
"    family: AF_INET\n"
"    type: SOCK_DGRAM\n"
"    protocol: udp\n"
"    port: 80\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:200
msgid ""
"The ``socket.tcp_server()`` function makes Tarantool act as a server that"
" can accept connections. Usually the same objective is accomplished with "
":ref:`box.cfg{listen=...} <cfg_basic-listen>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:204
msgid "host name or IP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:205
msgid "host port, may be 0"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:206
msgid "what to execute when a connection occurs"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:208
msgid "number of seconds to wait before timing out"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:211
msgid ""
"The handler-function parameter may be a function name (for example "
"``function_55``), a function declaration (for example ``function () "
"print('!') end``), or a table including handler = function (for example "
"``{handler=function_55, name='A'}``)."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:216
msgid "Example:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:218
msgid "``socket.tcp_server('localhost', 3302, function () end)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:226
msgid ""
"Connect an existing socket to a remote host. The argument values are the "
"same as in tcp_connect(). The host must be an IP address."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:243
msgid "Parameters:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:233
msgid "Either:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:232
msgid "host - a string representation of an IPv4 address or an IPv6 address;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:234
msgid "port - a number."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:236
#: ../doc/1.7/reference/reference_lua/socket.rst:243
msgid "Or:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:236
msgid "host - a string containing \"unix/\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:237
msgid "port - a string containing a path to a unix socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:239
msgid "host - a number, 0 (zero), meaning \"all local interfaces\";"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:241
msgid ""
"port - a number. If a port number is 0 (zero), the socket will be bound "
"to a random local port."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:245
msgid "the socket object value may change if sysconnect() succeeds."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:250
msgid ""
"socket = require('socket')\n"
"sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')\n"
"sock:sysconnect(0, 3301)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:261
msgid "Send data over a connected socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:264
#: ../doc/1.7/reference/reference_lua/socket.rst:387
msgid "the number of bytes sent."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:267
msgid "Possible errors: nil on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:273
msgid ""
"Write as much as possible data to the socket buffer if non-blocking. "
"Rarely used. For details see `this description`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:280
msgid ""
"Read ``size`` bytes from a connected socket. An internal read-ahead "
"buffer is used to reduce the cost of this call."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:284
msgid "a string of the requested length on success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:287
msgid ""
"Possible errors: On error, returns an empty string, followed by status, "
"errno, errstr. In case the writing side has closed its end, returns the "
"remainder read from the socket (possibly an empty string), followed by "
"\"eof\" status."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:300
msgid ""
"Read from a connected socket until some condition is true, and return the"
" bytes that were read. Reading goes on until ``limit`` bytes have been "
"read, or a delimiter has been read, or a timeout has expired."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:305
#: ../doc/1.7/reference/reference_lua/socket.rst:327
msgid ""
"maximum number of bytes to read, for example 50 means \"stop after 50 "
"bytes\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:307
msgid "separator for example '?' means \"stop after a question mark\""
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:309
msgid ""
"maximum number of seconds to wait for example 50 means \"stop after 50 "
"seconds\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:312
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``limit`` bytes long, which may include the "
"bytes that matched the ``delimiter`` expression."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:322
msgid ""
"Return data from the socket buffer if non-blocking. In case the socket is"
" blocking, ``sysread()`` can block the calling process. Rarely used. For "
"details, see also `this description "
"<https://github.com/tarantool/tarantool/wiki/sockets%201.6>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:330
msgid ""
"an empty string if there is nothing more to read, or a nil value if "
"error, or a string up to ``size`` bytes long."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:338
msgid ""
"Bind a socket to the given host/port. A UDP socket after binding can be "
"used to receive data (see :ref:`socket_object.recvfrom <socket-"
"recvfrom>`). A TCP socket can be used to accept new connections, after it"
" has been put in listen mode."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:346
msgid "a socket object on success"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:349
msgid "Possible errors: Returns nil, status, errno, errstr on error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:355
msgid "Start listening for incoming connections."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:357
msgid ""
"On Linux the listen ``backlog`` backlog may be from "
"/proc/sys/net/core/somaxconn, on BSD the backlog may be ``SOMAXCONN``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:361
msgid "true for success, false for error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:362
msgid "boolean."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:368
msgid ""
"Accept a new client connection and create a new connected socket. It is "
"good practice to set the socket's blocking mode explicitly after "
"accepting."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:372
msgid "new socket if success."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:381
msgid "Send a message on a UDP socket to a specified host."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:390
#: ../doc/1.7/reference/reference_lua/socket.rst:402
msgid "Possible errors: on error, returns status, errno, errstr."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:396
msgid "Receive a message on a UDP socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:399
msgid "message, a table containing \"host\", \"family\" and \"port\" fields."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:400
msgid "string, table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:406
msgid ""
"After ``message_content, message_sender = recvfrom(1)`` the value of "
"``message_content`` might be a string containing 'X' and the value of "
"``message_sender`` might be a table containing"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:410
msgid ""
"message_sender.host = '18.44.0.1'\n"
"message_sender.family = 'AF_INET'\n"
"message_sender.port = 43065"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:420
msgid "Shutdown a reading end, a writing end, or both ends of a socket."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:422
msgid "socket.SHUT_RD, socket.SHUT_WR, or socket.SHUT_RDWR."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:424
#: ../doc/1.7/reference/reference_lua/tap.rst:94
#: ../doc/1.7/reference/reference_lua/tap.rst:126
#: ../doc/1.7/reference/reference_lua/tap.rst:157
#: ../doc/1.7/reference/reference_lua/tap.rst:168
#: ../doc/1.7/reference/reference_lua/tap.rst:185
#: ../doc/1.7/reference/reference_lua/tap.rst:193
msgid "true or false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:431
msgid ""
"Close (destroy) a socket. A closed socket should not be used any more. A "
"socket is closed automatically when its userdata is garbage collected by "
"Lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:434
msgid ""
"true on success, false on error. For example, if sock is already closed, "
"sock:close() returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:443
msgid ""
"Retrieve information about the last error that occurred on a socket, if "
"any. Errors do not cause throwing of exceptions so these functions are "
"usually necessary."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:446
msgid ""
"result for ``sock:errno()``, result for ``sock:error()``. If there is no "
"error, then ``sock:errno()`` will return 0 and ``sock:error()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:448
msgid "number, string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:454
msgid ""
"Set socket flags. The argument values are the same as in the `Linux "
"getsockopt(2) man page <http://man7.org/linux/man-"
"pages/man2/setsockopt.2.html>`_. The ones that Tarantool accepts are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:458
msgid "SO_ACCEPTCONN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:459
msgid "SO_BINDTODEVICE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:460
msgid "SO_BROADCAST"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:461
msgid "SO_DEBUG"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:462
msgid "SO_DOMAIN"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:463
msgid "SO_ERROR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:464
msgid "SO_DONTROUTE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:465
msgid "SO_KEEPALIVE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:466
msgid "SO_MARK"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:467
msgid "SO_OOBINLINE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:468
msgid "SO_PASSCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:469
msgid "SO_PEERCRED"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:470
msgid "SO_PRIORITY"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:471
msgid "SO_PROTOCOL"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:472
msgid "SO_RCVBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:473
msgid "SO_RCVBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:474
msgid "SO_RCVLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:475
msgid "SO_SNDLOWAT"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:476
msgid "SO_RCVTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:477
msgid "SO_SNDTIMEO"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:478
msgid "SO_REUSEADDR"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:479
msgid "SO_SNDBUF"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:480
msgid "SO_SNDBUFFORCE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:481
msgid "SO_TIMESTAMP"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:482
msgid "SO_TYPE"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:484
msgid "Setting SO_LINGER is done with ``sock:linger(active)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:490
msgid "Get socket flags. For a list of possible flags see ``sock:setsockopt()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:496
msgid ""
"Set or clear the SO_LINGER flag. For a description of the flag, see the "
"`Linux man page <http://man7.org/linux/man-pages/man1/loginctl.1.html>`_."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:501
msgid "new active and timeout values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:507
msgid "``sock:nonblock()`` returns the current flag value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:508
msgid "``sock:nonblock(false)`` sets the flag to false and returns false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:509
msgid "``sock:nonblock(true)`` sets the flag to true and returns true."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:511
msgid ""
"This function may be useful before invoking a function which might "
"otherwise block indefinitely."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:518
msgid "Wait until something is readable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:520
msgid "true if the socket is now readable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:526
msgid "Wait until something is writable, or until a timeout value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:528
msgid "true if the socket is now writable, false if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:534
msgid ""
"Wait until something is either readable or writable, or until a timeout "
"value expires."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:536
msgid ""
"'R' if the socket is now readable, 'W' if the socket is now writable, "
"'RW' if the socket is now both readable and writable, '' (empty string) "
"if timeout expired;"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:542
msgid ""
"The ``sock:name()`` function is used to get information about the near "
"side of the connection. If a socket was bound to ``xyz.com:45``, then "
"``sock:name`` will return information about ``[host:xyz.com, port:45]``. "
"The equivalent POSIX function is ``getsockname()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:554
msgid ""
"The ``sock:peer()`` function is used to get information about the far "
"side of a connection. If a TCP connection has been made to a distant host"
" ``tarantool.org:80``, ``sock:peer()`` will return information about "
"``[host:tarantool.org, port:80]``. The equivalent POSIX function is "
"``getpeername()``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:566
msgid ""
"The ``socket.iowait()`` function is used to wait until read-or-write "
"activity occurs for a file descriptor."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:569
msgid "file descriptor"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:570
msgid "'R' or 1 = read, 'W' or 2 = write, 'RW' or 3 = read|write."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:571
msgid "number of seconds to wait"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:573
msgid ""
"If the fd parameter is nil, then there will be a sleep until the timeout."
" If the timeout parameter is nil or unspecified, then timeout is "
"infinite."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:576
msgid ""
"Ordinarily the return value is the activity that occurred ('R' or 'W' or "
"'RW' or 1 or 2 or 3). If the timeout period goes by without any reading "
"or writing, the return is an error = ETIMEDOUT."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:580
msgid "Example: ``socket.iowait(sock:fd(), 'r', 1.11)``"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:588
msgid "Use of a TCP socket over the Internet"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:590
msgid ""
"In this example a connection is made over the internet between a "
"Tarantool instance and tarantool.org, then an HTTP \"head\" message is "
"sent, and a response is received: \"``HTTP/1.1 200 OK``\" or something "
"else if the site has moved. This is not a useful way to communicate with "
"this particular site, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:596
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock = socket.tcp_connect('tarantool.org', 80)\n"
"---\n"
"...\n"
"tarantool> type(sock)\n"
"---\n"
"- table\n"
"...\n"
"tarantool> sock:error()\n"
"---\n"
"- null\n"
"...\n"
"tarantool> sock:send(\"HEAD / HTTP/1.0\\r\\nHost: "
"tarantool.org\\r\\n\\r\\n\")\n"
"---\n"
"- 40\n"
"...\n"
"tarantool> sock:read(17)\n"
"---\n"
"- HTTP/1.1 302 Move\n"
"...\n"
"tarantool> sock:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:627
msgid "Use of a UDP socket on localhost"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:629
msgid ""
"Here is an example with datagrams. Set up two connections on 127.0.0.1 "
"(localhost): ``sock_1`` and ``sock_2``. Using ``sock_2``, send a message "
"to ``sock_1``. Using ``sock_1``, receive a message. Display the received "
"message. Close both connections. |br| This is not a useful way for a "
"computer to communicate with itself, but shows that the system works."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:635
msgid ""
"tarantool> socket = require('socket')\n"
"---\n"
"...\n"
"tarantool> sock_1 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_1:bind('127.0.0.1')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2 = socket('AF_INET', 'SOCK_DGRAM', 'udp')\n"
"---\n"
"...\n"
"tarantool> sock_2:sendto('127.0.0.1', sock_1:name().port,'X')\n"
"---\n"
"- true\n"
"...\n"
"tarantool> message = sock_1:recvfrom()\n"
"---\n"
"...\n"
"tarantool> message\n"
"---\n"
"- X\n"
"...\n"
"tarantool> sock_1:close()\n"
"---\n"
"- true\n"
"...\n"
"tarantool> sock_2:close()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:672
msgid "Use tcp_server to accept file contents sent with socat"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:674
msgid ""
"Here is an example of the tcp_server function, reading strings from the "
"client and printing them. On the client side, the Linux socat utility "
"will be used to ship a whole file for the tcp_server function to read."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:679
msgid ""
"Start two shells. The first shell will be a server instance. The second "
"shell will be the client."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:682
msgid "On the first shell, start Tarantool and say:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:684
msgid ""
"box.cfg{}\n"
"socket = require('socket')\n"
"socket.tcp_server('0.0.0.0', 3302, function(s)\n"
"    while true do\n"
"      local request\n"
"      request = s:read(\"\\n\");\n"
"      if request == \"\" or request == nil then\n"
"        break\n"
"      end\n"
"      print(request)\n"
"    end\n"
"  end)"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:699
msgid ""
"The above code means: use `tcp_server()` to wait for a connection from "
"any host on port 3302. When it happens, enter a loop that reads on the "
"socket and prints what it reads. The \"delimiter\" for the read function "
"is \"\\\\n\" so each `read()` will read a string as far as the next line "
"feed, including the line feed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:706
msgid ""
"On the second shell, create a file that contains a few lines. The "
"contents don't matter. Suppose the first line contains A, the second line"
" contains B, the third line contains C. Call this file \"tmp.txt\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:711
msgid ""
"On the second shell, use the socat utility to ship the tmp.txt file to "
"the server instance's host and port:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:714
msgid "$ socat TCP:localhost:3302 ./tmp.txt"
msgstr ""

#: ../doc/1.7/reference/reference_lua/socket.rst:718
msgid ""
"Now watch what happens on the first shell. The strings \"A\", \"B\", "
"\"C\" are printed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:33
msgid "Module `strict`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:37
msgid ""
"The :code:`strict` module has functions for turning \"strict mode\" on or"
" off. When strict mode is on, an attempt to use an undeclared global "
"variable will cause an error. A global variable is considered "
"\"undeclared\" if it has never had a value assigned to it. Often this is "
"an indication of a programming error."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:42
msgid ""
"By default strict mode is off, unless tarantool was built with the "
"``-DCMAKE_BUILD_TYPE=Debug`` option -- see the description of build "
"options in section :ref:`building-from-source <building_from_source>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/strict.rst:48
msgid ""
"tarantool> strict = require('strict')\n"
"---\n"
"...\n"
"tarantool> strict.on()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is on so this will cause an error\n"
"---\n"
"- error: ... variable ''b'' is not declared'\n"
"...\n"
"tarantool> strict.off()\n"
"---\n"
"...\n"
"tarantool> a = b -- strict mode is off so this will not cause an error\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:31
msgid "Module `tap`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:33
msgid ""
"The tap module streamlines the testing of other modules. It allows "
"writing of tests in the `TAP protocol`_. The results from the tests can "
"be parsed by standard TAP-analyzers so they can be passed to utilities "
"such as `prove`_. Thus one can run tests and then use the results for "
"statistics, decision-making, and so on."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:43
msgid "Initialize."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:45
msgid ""
"The result of ``tap.test`` is an object, which will be called taptest in "
"the rest of this discussion, which is necessary for ``taptest:plan()`` "
"and all the other methods."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:49
msgid "an arbitrary name to give for the test outputs."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:50
msgid "taptest"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:53
msgid ""
"tap = require('tap')\n"
"taptest = tap.test('test-name')"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:62
msgid "Indicate how many tests will be performed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:69
msgid ""
"Checks the number of tests performed. This check should only be done "
"after all planned tests are complete, so ordinarily ``taptest:check()`` "
"will only appear at the end of a script."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:73
msgid ""
"Will display ``# bad plan: ...`` if the number of completed tests is not "
"equal to the number of tests specified by ``taptest:plan(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:80
msgid "Display a diagnostic message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:82
msgid "the message to be displayed."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:87
msgid ""
"This is a basic function which is used by other functions. Depending on "
"the value of ``condition``, print 'ok' or 'not ok' along with debugging "
"information. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:91
msgid "an expression which is true or false"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:92
#: ../doc/1.7/reference/reference_lua/tap.rst:124
#: ../doc/1.7/reference/reference_lua/tap.rst:135
#: ../doc/1.7/reference/reference_lua/tap.rst:156
#: ../doc/1.7/reference/reference_lua/tap.rst:166
#: ../doc/1.7/reference/reference_lua/tap.rst:183
#: ../doc/1.7/reference/reference_lua/tap.rst:198
msgid "name of test"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:99
msgid ""
"tarantool> taptest:ok(true, 'x')\n"
"ok - x\n"
"---\n"
"- true\n"
"...\n"
"tarantool> tap = require('tap')\n"
"---\n"
"...\n"
"tarantool> taptest = tap.test('test-name')\n"
"TAP version 13\n"
"---\n"
"...\n"
"tarantool> taptest:ok(1 + 1 == 2, 'X')\n"
"ok - X\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:121
msgid ""
"``taptest:fail('x')`` is equivalent to ``taptest:ok(false, 'x')``. "
"Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:131
msgid ""
"``taptest:skip('x')`` is equivalent to ``taptest:ok(true, 'x' .. '# "
"skip')``. Displays the message."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:141
msgid ""
"tarantool> taptest:skip('message')\n"
"ok - message # skip\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:151
msgid ""
"Check whether the first argument equals the second argument. Displays "
"extensive message if the result is false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:154
#: ../doc/1.7/reference/reference_lua/tap.rst:164
#: ../doc/1.7/reference/reference_lua/tap.rst:196
msgid "actual result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:155
#: ../doc/1.7/reference/reference_lua/tap.rst:165
#: ../doc/1.7/reference/reference_lua/tap.rst:197
msgid "expected result"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:162
msgid "This is the negation of ``taptest:is(...)``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:179
msgid ""
"Test whether a value has a particular type. Displays a long message if "
"the value is not of the specified type."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:190
msgid ""
"Recursive version of ``taptest:is(...)``, which can be be used to compare"
" tables as well as scalar values."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:208
msgid ""
"To run this example: put the script in a file named ./tap.lua, then make "
"tap.lua executable by saying ``chmod a+x ./tap.lua``, then execute using "
"Tarantool as a script processor by saying ./tap.lua."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:212
msgid ""
"#!/usr/bin/tarantool\n"
"local tap = require('tap')\n"
"test = tap.test(\"my test name\")\n"
"test:plan(2)\n"
"test:ok(2 * 2 == 4, \"2 * 2 is 4\")\n"
"test:test(\"some subtests for test2\", function(test)\n"
"    test:plan(2)\n"
"    test:is(2 + 2, 4, \"2 + 2 is 4\")\n"
"    test:isnt(2 + 3, 4, \"2 + 3 is not 4\")\n"
"end)\n"
"test:check()"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:226
msgid "The output from the above script will look approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tap.rst:228
msgid ""
"TAP version 13\n"
"1..2\n"
"ok - 2 * 2 is 4\n"
"    # Some subtests for test2\n"
"    1..2\n"
"    ok - 2 + 2 is 4,\n"
"    ok - 2 + 3 is not 4\n"
"    # Some subtests for test2: end\n"
"ok - some subtests for test2"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:31
msgid "Module `tarantool`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:35
msgid ""
"By saying ``require('tarantool')``, one can answer some questions about "
"how the tarantool server was built, such as \"what flags were used\", or "
"\"what was the version of the compiler\"."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:41
msgid ""
"Additionally one can see the uptime and the server version and the "
"process id. Those information items can also be accessed with "
":ref:`box.info() <box_introspection-box_info>` but use of the tarantool "
"module is recommended."
msgstr ""

#: ../doc/1.7/reference/reference_lua/tarantool.rst:48
msgid ""
"tarantool> tarantool = require('tarantool')\n"
"---\n"
"...\n"
"tarantool> tarantool\n"
"---\n"
"- build:\n"
"    target: Linux-x86_64-RelWithDebInfo\n"
"    options: cmake . -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_BACKTRACE=ON\n"
"    mod_format: so\n"
"    flags: ' -fno-common -fno-omit-frame-pointer -fno-stack-protector "
"-fexceptions\n"
"      -funwind-tables -fopenmp -msse2 -std=c11 -Wall -Wextra -Wno-sign-"
"compare -Wno-strict-aliasing\n"
"      -fno-gnu89-inline'\n"
"    compiler: /usr/bin/x86_64-linux-gnu-gcc /usr/bin/x86_64-linux-gnu-g++"
"\n"
"  uptime: 'function: 0x408668e0'\n"
"  version: 1.7.0-66-g9093daa\n"
"  pid: 'function: 0x40866900'\n"
"...\n"
"tarantool> tarantool.pid()\n"
"---\n"
"- 30155\n"
"...\n"
"tarantool> tarantool.uptime()\n"
"---\n"
"- 108.64641499519\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:31
msgid "Module `uri`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:33
msgid ""
"A \"URI\" is a \"Uniform Resource Identifier\". The `IETF standard "
"<https://www.ietf.org/rfc/rfc2396.txt>`_ says a URI string looks like "
"this: |br| [scheme:]scheme-specific-part[#fragment] |br| A common type, a"
" hierarchical URI, looks like this: |br| "
"[scheme:][//authority][path][?query][#fragment] |br| For example the "
"string `'https://tarantool.org/x.html#y'` has three components: https is "
"the scheme, tarantool.org/x.html is the path, and y is the fragment. "
"Tarantool's URI module provides routines which convert URI strings into "
"their components, or turn components into URI strings."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:51
msgid "a Uniform Resource Identifier"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst
#: ../doc/1.7/reference/reference_lua/xlog.rst
msgid "returns"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:52
msgid ""
"URI-components-table. Possible components are fragment, host, login, "
"password, path, query, scheme, service."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:53
msgid "Table"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:57
msgid ""
"tarantool> uri = require('uri')\n"
"---\n"
"...\n"
"\n"
"tarantool> uri.parse('http://x.html#y')\n"
"---\n"
"- host: x.html\n"
"  scheme: http\n"
"  fragment: y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:74
msgid "a series of name:value pairs, one for each component"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:75
msgid "URI-string. Thus uri.format() is the reverse of uri.parse()."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uri.rst:80
msgid ""
"tarantool> uri.format({host = 'x.html', scheme = 'http', fragment = 'y'})"
"\n"
"---\n"
"- http://x.html#y\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:31
msgid "Module `uuid`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:33
msgid ""
"A \"UUID\" is a `Universally unique identifier`_. If an application "
"requires that a value be unique only within a single computer or on a "
"single database, then a simple counter is better than a UUID, because "
"getting a UUID is time-consuming (it requires a syscall_). For clusters "
"of computers, or widely distributed applications, UUIDs are better."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:39
msgid "The functions that can return a UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:41
msgid ":ref:`uuid() <uuid-__call>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:42
msgid ":ref:`uuid.bin() <uuid-bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:43
msgid ":ref:`uuid.str() <uuid-str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:45
msgid "The functions that can convert between different types of UUID are:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:47
msgid ":ref:`uuid_object:bin() <uuid-object_bin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:48
msgid ":ref:`uuid_object:str() <uuid-object_str>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:49
msgid ":ref:`uuid.fromstr() <uuid-fromstr>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:50
msgid ":ref:`uuid.frombin() <uuid-frombin>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:52
msgid "The function that can determine whether a UUID is an all-zero value is:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:54
msgid ":ref:`uuid_object:isnil() <uuid-isnil>`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:60
msgid "A nil object"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:66
#: ../doc/1.7/reference/reference_lua/uuid.rst:73
#: ../doc/1.7/reference/reference_lua/uuid.rst:80
msgid "a UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:67
#: ../doc/1.7/reference/reference_lua/uuid.rst:89
#: ../doc/1.7/reference/reference_lua/uuid.rst:97
msgid "cdata"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:74
msgid "16-byte string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:81
msgid "36-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:87
msgid "UUID in 36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:88
#: ../doc/1.7/reference/reference_lua/uuid.rst:96
msgid "converted UUID"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:95
msgid "UUID in 16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:105
msgid "``byte-order`` can be one of next flags:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:107
msgid "'l' - little-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:108
msgid "'b' - big-endian,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:109
msgid "'h' - endianness depends on host (default),"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:110
msgid "'n' - endianness depends on network"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:112
msgid "one of ``'l'``, ``'b'``, ``'h'`` or ``'n'``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:114
#: ../doc/1.7/reference/reference_lua/uuid.rst:121
msgid "UUID converted from cdata input value."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:115
msgid "16-byte binary string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:122
msgid "36-byte hexadecimal string"
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:128
msgid ""
"The all-zero UUID value can be expressed as uuid.NULL, or as "
"``uuid.fromstr('00000000-0000-0000-0000-000000000000')``. The comparison "
"with an all-zero value can also be expressed as ``uuid_with_type_cdata =="
" uuid.NULL``."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:133
msgid "true if the value is all zero, otherwise false."
msgstr ""

#: ../doc/1.7/reference/reference_lua/uuid.rst:140
msgid ""
"tarantool> uuid = require('uuid')\n"
"---\n"
"...\n"
"tarantool> uuid(), uuid.bin(), uuid.str()\n"
"---\n"
"- 16ffedc8-cbae-4f93-a05e-349f3ab70baa\n"
"- !!binary FvG+Vy1MfUC6kIyeM81DYw==\n"
"- 67c999d2-5dce-4e58-be16-ac1bcb93160f\n"
"...\n"
"tarantool> uu = uuid()\n"
"---\n"
"...\n"
"tarantool> #uu:bin(), #uu:str(), type(uu), uu:isnil()\n"
"---\n"
"- 16\n"
"- 36\n"
"- cdata\n"
"- false\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:33
msgid "Module `xlog`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:35
msgid ""
"The xlog module contains one function: ``pairs()``. It can be used to "
"read Tarantool's snapshot files or write-ahead-log (WAL) files. A "
"description of the file format is in section :ref:`Data persistence and "
"the WAL file format <internals-data_persistence>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:46
msgid "Open a file, and allow iterating over one file entry at a time."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:48
msgid "iterator  which can be used in a for/end loop."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:49
msgid "`iterator <https://www.lua.org/pil/7.1.html>`_"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:51
msgid ""
"Possible errors: File does not contain properly formatted snapshot or "
"write-ahead-log information."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:56
msgid ""
"This will read the first write-ahead-log (WAL) file that was created in "
"the :ref:`wal_dir <cfg_basic-wal_dir>` directory in our :ref:`\"Getting "
"started\" exercises <getting_started>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:60
msgid ""
"Each result from ``pairs()`` is formatted with MsgPack so its structure "
"can be specified with :ref:`__serialize <msgpack-serialize>`."
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:63
msgid ""
"xlog = require('xlog')\n"
"t = {}\n"
"for k, v in xlog.pairs('00000000000000000000.xlog') do\n"
"  table.insert(t, setmetatable(v, { __serialize = \"map\"}))\n"
"end\n"
"return t"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:72
msgid "The first lines of the result will look like:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/xlog.rst:74
msgid ""
"(...)\n"
"---\n"
"- - {'BODY':   {'space_id': 272, 'index_base': 1, 'key': ['max_id'],\n"
"                'tuple': [['+', 2, 1]]},\n"
"     'HEADER': {'type': 'UPDATE', 'timestamp': 1477846870.8541,\n"
"                'lsn': 1, 'server_id': 1}}\n"
"  - {'BODY':   {'space_id': 280,\n"
"                 'tuple': [512, 1, 'tester', 'memtx', 0, {}, []]},\n"
"     'HEADER': {'type': 'INSERT', 'timestamp': 1477846870.8597,\n"
"                'lsn': 2, 'server_id': 1}}"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:33
msgid "Module `yaml`"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:35
msgid ""
"The ``yaml`` module takes strings in YAML_ format and decodes them, or "
"takes a series of non-YAML values and encodes them."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:42
msgid "Convert a Lua object to a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:45
msgid "the original value reformatted as a YAML string."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:50
msgid "Convert a YAML string to a Lua object."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:52
msgid "a string formatted as YAML."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:66
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> y = yaml.encode({'a', 1, 'b', 2})\n"
"---\n"
"...\n"
"tarantool> z = yaml.decode(y)\n"
"---\n"
"...\n"
"tarantool> z[1], z[2], z[3], z[4]\n"
"---\n"
"- a\n"
"- 1\n"
"- b\n"
"- 2\n"
"...\n"
"tarantool> if yaml.NULL == nil then print('hi') end\n"
"hi\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:89
msgid ""
"The `YAML collection style <http://yaml.org/spec/1.1/#id930798>`_ can be "
"specified with ``__serialize``:"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:92
msgid "``__serialize=\"sequence\"`` for a Block Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:93
msgid "``__serialize=\"seq\"`` for a Flow Sequence array,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:94
msgid "``__serialize=\"mapping\"`` for a Block Mapping map,"
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:95
msgid "``__serialize=\"map\"`` for a Flow Mapping map."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:100
msgid ""
"tarantool> yaml = require('yaml')\n"
"---\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { "
"__serialize=\"sequence\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  - A\n"
"  - B\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode(setmetatable({'A', 'B'}, { __serialize=\"seq\"}))\n"
"---\n"
"- |\n"
"  ---\n"
"  ['A', 'B']\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"map\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - {'f2': 'B', 'f1': 'A'}\n"
"  ...\n"
"...\n"
"tarantool> yaml.encode({setmetatable({f1 = 'A', f2 = 'B'}, { "
"__serialize=\"mapping\"})})\n"
"---\n"
"- |\n"
"  ---\n"
"  - f2: B\n"
"    f1: A\n"
"  ...\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_lua/yaml.rst:136
msgid ""
"Also, some YAML configuration settings for encoding can be changed, in "
"the same way that they can be changed for :ref:`JSON <json-module_cfg>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:33
msgid "SQL DBMS Modules"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:35
msgid ""
"The discussion here in the reference is about incorporating and using two"
" modules that have already been created: the \"SQL DBMS rocks\" for MySQL"
" and PostgreSQL."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:39
msgid ""
"To call another DBMS from Tarantool, the essential requirements are: "
"another DBMS, and Tarantool. The module which connects Tarantool to "
"another DBMS may be called a \"connector\". Within the module there is a "
"shared library which may be called a \"driver\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:44
msgid ""
"Tarantool supplies DBMS connector modules with the module manager for "
"Lua, LuaRocks. So the connector modules may be called \"rocks\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:47
msgid ""
"The Tarantool rocks allow for connecting to SQL servers and executing SQL"
" statements the same way that a MySQL or PostgreSQL client does. The SQL "
"statements are visible as Lua methods. Thus Tarantool can serve as a "
"\"MySQL Lua Connector\" or \"PostgreSQL Lua Connector\", which would be "
"useful even if that was all Tarantool could do. But of course Tarantool "
"is also a DBMS, so the module also is useful for any operations, such as "
"database copying and accelerating, which work best when the application "
"can work on both SQL and Tarantool inside the same Lua routine. The "
"methods for connect/select/insert/etc. are similar to the ones in the "
":ref:`net.box <net_box-module>` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:58
msgid ""
"From a user's point of view the MySQL and PostgreSQL rocks are very "
"similar, so the following sections -- \"MySQL Example\" and \"PostgreSQL "
"Example\" -- contain some redundancy."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:66
msgid "MySQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:68
msgid ""
"This example assumes that MySQL 5.5 or MySQL 5.6 or MySQL 5.7 has been "
"installed. Recent MariaDB versions will also work, the MariaDB C "
"connector is used. The package that matters most is the MySQL client "
"developer package, typically named something like libmysqlclient-dev. The"
" file that matters most from this package is libmysqlclient.so or a "
"similar name. One can use ``find`` or ``whereis`` to see what directories"
" these files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:75
msgid ""
"It will be necessary to install Tarantool's MySQL driver shared library, "
"load it, and use it to connect to a MySQL server instance. After that, "
"one can pass any MySQL statement to the server instance and receive "
"results, including multiple result sets."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:81
#: ../doc/1.7/reference/reference_rock/dbms.rst:434
msgid "Installation"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:83
#: ../doc/1.7/reference/reference_rock/dbms.rst:436
msgid ""
"Check the instructions for `downloading and installing a binary package "
"<http://tarantool.org/download.html>`_ that apply for the environment "
"where Tarantool was installed. In addition to installing ``tarantool``, "
"install ``tarantool-dev``. For example, on Ubuntu, add the line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:89
#: ../doc/1.7/reference/reference_rock/dbms.rst:442
msgid "sudo apt-get install tarantool-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:93
msgid "Now, for the MySQL driver shared library, there are two ways to install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:97
#: ../doc/1.7/reference/reference_rock/dbms.rst:450
msgid "With LuaRocks"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:99
#: ../doc/1.7/reference/reference_rock/dbms.rst:452
msgid ""
"Begin by installing luarocks and making sure that tarantool is among the "
"upstream servers, as in the instructions on `rocks.tarantool.org`_, the "
"Tarantool luarocks page. Now execute this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:106
msgid ""
"luarocks install mysql [MYSQL_LIBDIR = *path*]\n"
"                       [MYSQL_INCDIR = *path*]\n"
"                       [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:112
msgid "luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:118
#: ../doc/1.7/reference/reference_rock/dbms.rst:471
msgid "With GitHub"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:120
msgid ""
"Go the site `github.com/tarantool/mysql`_. Follow the instructions there,"
" saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:122
msgid ""
"git clone https://github.com/tarantool/mysql.git\n"
"cd mysql && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:129
#: ../doc/1.7/reference/reference_rock/dbms.rst:482
msgid ""
"At this point it is a good idea to check that the installation produced a"
" file named ``driver.so``, and to check that this file is on a directory "
"that is searched by the ``require`` request."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:135
#: ../doc/1.7/reference/reference_rock/dbms.rst:488
msgid "Connecting"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:137
msgid ""
"Begin by making a ``require`` request for the mysql driver. We will "
"assume that the name is ``mysql`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:140
msgid "mysql = require('mysql')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:144
#: ../doc/1.7/reference/reference_rock/dbms.rst:497
msgid "Now, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:149
msgid "*connection_name* = mysql.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:151
#: ../doc/1.7/reference/reference_rock/dbms.rst:504
msgid "The connection-options parameter is a table. Possible options are:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:153
#: ../doc/1.7/reference/reference_rock/dbms.rst:506
msgid ":samp:`host = {host-name}` - string, default value = 'localhost'"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:154
#: ../doc/1.7/reference/reference_rock/dbms.rst:507
msgid ":samp:`port = {port-number}` - number, default value = 3306"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:155
#: ../doc/1.7/reference/reference_rock/dbms.rst:508
msgid ""
":samp:`user = {user-name}` - string, default value is operating-system "
"user name"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:156
msgid ":samp:`password = {password}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:157
#: ../doc/1.7/reference/reference_rock/dbms.rst:510
msgid ":samp:`db = {database-name}` - string, default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:158
msgid ":samp:`raise = {true|false}` - boolean, default value is false"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:160
msgid ""
"The option names, except for `raise`, are similar to the names that "
"MySQL's mysql client uses, for details see the MySQL manual at "
"`dev.mysql.com/doc/refman/5.6/en/connecting.html`_. The `raise` option "
"should be set to :codenormal:`true` if errors should be raised when "
"encountered. To connect with a Unix socket rather than with TCP, specify "
"``host = 'unix/'`` and :samp:`port = {socket-name}`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:167
#: ../doc/1.7/reference/reference_rock/dbms.rst:514
msgid "Example, using a table literal enclosed in {braces}:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:169
msgid ""
"conn = mysql.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 3306,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test',\n"
"    raise = true\n"
"})\n"
"-- OR\n"
"conn = mysql.connect({\n"
"    host = 'unix/',\n"
"    port = '/var/run/mysqld/mysqld.sock'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:185
#: ../doc/1.7/reference/reference_rock/dbms.rst:526
msgid "Example, creating a function which sets each option in a separate line:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:187
msgid ""
"tarantool> -- Connection function. Usage: conn = mysql_connect()\n"
"tarantool> function mysql_connection()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   conn = mysql.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = mysql_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:203
#: ../doc/1.7/reference/reference_rock/dbms.rst:545
msgid "We will assume that the name is 'conn' in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:207
#: ../doc/1.7/reference/reference_rock/dbms.rst:549
msgid "How to ping"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:209
#: ../doc/1.7/reference/reference_rock/dbms.rst:551
msgid "To ensure that a connection is working, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:214
#: ../doc/1.7/reference/reference_rock/dbms.rst:556
msgid "*connection-name*:ping()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:218
#: ../doc/1.7/reference/reference_rock/dbms.rst:561
msgid ""
"tarantool> conn:ping()\n"
"---\n"
"- true\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:227
#: ../doc/1.7/reference/reference_rock/dbms.rst:570
msgid "Executing a statement"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:229
msgid "For all MySQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:234
#: ../doc/1.7/reference/reference_rock/dbms.rst:577
msgid "*connection-name*:execute(*sql-statement* [, *parameters*])"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:236
#: ../doc/1.7/reference/reference_rock/dbms.rst:579
msgid ""
"where ``sql-statement`` is a string, and the optional ``parameters`` are "
"extra values that can be plugged in to replace any question marks "
"(\"?\"s) in the SQL statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:242
msgid ""
"tarantool> conn:execute('select table_name from "
"information_schema.tables')\n"
"---\n"
"- - table_name: ALL_PLUGINS\n"
"  - table_name: APPLICABLE_ROLES\n"
"  - table_name: CHARACTER_SETS\n"
"  <...>\n"
"- 78\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:255
#: ../doc/1.7/reference/reference_rock/dbms.rst:597
msgid "Closing connection"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:257
msgid "To end a session that began with ``mysql.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:262
#: ../doc/1.7/reference/reference_rock/dbms.rst:604
msgid "*connection-name*:close()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:266
#: ../doc/1.7/reference/reference_rock/dbms.rst:608
msgid ""
"tarantool> conn:close()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:272
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/mysql`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:279
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of MySQL "
"had been installed on ~/mysql-5.5. The mysqld server instance is already "
"running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:283
msgid ""
"$ export TMDIR=~/mysql-5.5\n"
"$ # Check that the include subdirectory exists by looking\n"
"$ # for .../include/mysql.h. (If this fails, there's a chance\n"
"$ # that it's in .../include/mysql/mysql.h instead.)\n"
"$ [ -f $TMDIR/include/mysql.h ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the\n"
"$ # necessary .so file.\n"
"$ [ -f $TMDIR/lib/libmysqlclient.so ] && echo \"OK\" || echo \"Error\"\n"
"OK\n"
"\n"
"$ # Check that the mysql client can connect using some factory\n"
"$ # defaults: port = 3306, user = 'root', user password = '',\n"
"$ # database = 'test'. These can be changed, provided one uses\n"
"$ # the changed values in all places.\n"
"$ $TMDIR/bin/mysql --port=3306 -h 127.0.0.1 --user=root \\\n"
"    --password= --database=test\n"
"Welcome to the MySQL monitor.  Commands end with ; or \\g.\n"
"Your MySQL connection id is 25\n"
"Server version: 5.5.35 MySQL Community Server (GPL)\n"
"...\n"
"Type 'help;' or '\\h' for help. Type '\\c' to clear ...\n"
"\n"
"$ # Insert a row in database test, and quit.\n"
"mysql> CREATE TABLE IF NOT EXISTS test (s1 INT, s2 VARCHAR(50));\n"
"Query OK, 0 rows affected (0.13 sec)\n"
"mysql> INSERT INTO test.test VALUES (1,'MySQL row');\n"
"Query OK, 1 row affected (0.02 sec)\n"
"mysql> QUIT\n"
"Bye\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"    ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool\n"
"$ # master repository. The resultant display is normal for Ubuntu\n"
"$ # 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.6\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.6.6.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install mysql MYSQL_LIBDIR=/usr/local/mysql/lib --local\n"
"Installing http://rocks.tarantool.org/mysql-scm-1.rockspec...\n"
"... (more info about building the Tarantool/MySQL driver appears here)\n"
"mysql scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/mysql/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the name\n"
"$ # of this directory is /home/pgulutzan/tarantool_sandbox.\n"
"$ # (Change \"/home/pgulutzan\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"$ cd /home/pgulutzan/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-222-g48b98bb\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:364
msgid ""
"Configure tarantool and load mysql module. Make sure that tarantool "
"doesn't reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:367
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> mysql = require('mysql')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:375
msgid ""
"Create a Lua function that will connect to the MySQL server instance, "
"(using some factory default values for the port and user and password), "
"retrieve one row, and display the row. For explanations of the statement "
"types used here, read the Lua tutorial earlier in the Tarantool user "
"manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:380
msgid ""
"tarantool> function mysql_select ()\n"
"         >   local conn = mysql.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 3306,\n"
"         >     user = 'root',\n"
"         >     db = 'test'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> mysql_select()\n"
"---\n"
"- 'MySQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:404
msgid ""
"Observe the result. It contains \"MySQL row\". So this is the row that "
"was inserted into the MySQL database. And now it's been selected with the"
" Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:411
msgid "PostgreSQL Example"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:413
msgid ""
"This example assumes that PostgreSQL 8 or PostgreSQL 9 has been "
"installed. More recent versions should also work. The package that "
"matters most is the PostgreSQL developer package, typically named "
"something like libpq-dev. On Ubuntu this can be installed with:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:418
msgid "sudo apt-get install libpq-dev"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:422
msgid ""
"However, because not all platforms are alike, for this example the "
"assumption is that the user must check that the appropriate PostgreSQL "
"files are present and must explicitly state where they are when building "
"the Tarantool/PostgreSQL driver. One can use ``find`` or ``whereis`` to "
"see what directories PostgreSQL files are installed in."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:428
msgid ""
"It will be necessary to install Tarantool's PostgreSQL driver shared "
"library, load it, and use it to connect to a PostgreSQL server instance. "
"After that, one can pass any PostgreSQL statement to the server instance "
"and receive results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:446
msgid ""
"Now, for the PostgreSQL driver shared library, there are two ways to "
"install:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:459
msgid ""
"luarocks install pg [POSTGRESQL_LIBDIR = *path*]\n"
"                    [POSTGRESQL_INCDIR = *path*]\n"
"                    [--local]"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:465
msgid "luarocks install pg POSTGRESQL_LIBDIR=/usr/local/postgresql/lib"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:473
msgid ""
"Go the site `github.com/tarantool/pg`_. Follow the instructions there, "
"saying:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:475
msgid ""
"git clone https://github.com/tarantool/pg.git\n"
"cd pg && cmake . -DCMAKE_BUILD_TYPE=RelWithDebInfo\n"
"make\n"
"make install"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:490
msgid ""
"Begin by making a ``require`` request for the pg driver. We will assume "
"that the name is ``pg`` in further examples."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:493
msgid "pg = require('pg')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:502
msgid "*connection_name* = pg.connect(*connection options*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:509
msgid ""
":samp:`pass = {password}` or :samp:`password = {password}` - string, "
"default value is blank"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:512
msgid "The names are similar to the names that PostgreSQL itself uses."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:516
msgid ""
"conn = pg.connect({\n"
"    host = '127.0.0.1',\n"
"    port = 5432,\n"
"    user = 'p',\n"
"    password = 'p',\n"
"    db = 'test'\n"
"})"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:528
msgid ""
"tarantool> function pg_connect()\n"
"         >   local p = {}\n"
"         >   p.host = 'widgets.com'\n"
"         >   p.db = 'test'\n"
"         >   p.user = 'postgres'\n"
"         >   p.password = 'postgres'\n"
"         >   local conn = pg.connect(p)\n"
"         >   return conn\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> conn = pg_connect()\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:572
msgid "For all PostgreSQL statements, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:585
msgid ""
"tarantool> conn:execute('select tablename from pg_tables')\n"
"---\n"
"- - tablename: pg_statistic\n"
"  - tablename: pg_type\n"
"  - tablename: pg_authid\n"
"  <...>\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:599
msgid "To end a session that began with ``pg.connect``, the request is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:614
msgid ""
"For further information, including examples of rarely-used requests, see "
"the README.md file at `github.com/tarantool/pg`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:621
msgid ""
"The example was run on an Ubuntu 12.04 (\"precise\") machine where "
"tarantool had been installed in a /usr subdirectory, and a copy of "
"PostgreSQL had been installed on /usr. The PostgreSQL server instance is "
"already running on the local host 127.0.0.1."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:625
msgid ""
"$ # Check that the include subdirectory exists\n"
"$ # by looking for /usr/include/postgresql/libpq-fe-h.\n"
"$ [ -f /usr/include/postgresql/libpq-fe.h ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the library subdirectory exists and has the necessary .so "
"file.\n"
"$ [ -f /usr/lib/x86_64-linux-gnu/libpq.so ] && echo \"OK\" || echo "
"\"Error\"\n"
"OK\n"
"\n"
"$ # Check that the psql client can connect using some factory defaults:\n"
"$ # port = 5432, user = 'postgres', user password = 'postgres',\n"
"$ # database = 'postgres'. These can be changed, provided one changes\n"
"$ # them in all places. Insert a row in database postgres, and quit.\n"
"$ psql -h 127.0.0.1 -p 5432 -U postgres -d postgres\n"
"Password for user postgres:\n"
"psql (9.3.10)\n"
"SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)\n"
"Type \"help\" for help.\n"
"\n"
"postgres=# CREATE TABLE test (s1 INT, s2 VARCHAR(50));\n"
"CREATE TABLE\n"
"postgres=# INSERT INTO test VALUES (1,'PostgreSQL row');\n"
"INSERT 0 1\n"
"postgres=# \\q\n"
"$\n"
"\n"
"$ # Install luarocks\n"
"$ sudo apt-get -y install luarocks | grep -E \"Setting up|already\"\n"
"Setting up luarocks (2.0.8-2) ...\n"
"\n"
"$ # Set up the Tarantool rock list in ~/.luarocks,\n"
"$ # following instructions at rocks.tarantool.org\n"
"$ mkdir ~/.luarocks\n"
"$ echo \"rocks_servers = {[[http://rocks.tarantool.org/]]}\" >> \\\n"
"        ~/.luarocks/config.lua\n"
"\n"
"$ # Ensure that the next \"install\" will get files from Tarantool master"
"\n"
"$ # repository. The resultant display is normal for Ubuntu 12.04 precise\n"
"$ cat /etc/apt/sources.list.d/tarantool.list\n"
"deb http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"deb-src http://tarantool.org/dist/1.7/ubuntu/ precise main\n"
"\n"
"$ # Install tarantool-dev. The displayed line should show version = 1.7\n"
"$ sudo apt-get -y install tarantool-dev | grep -E \"Setting up|already\"\n"
"Setting up tarantool-dev (1.7.0.222.g48b98bb~precise-1) ...\n"
"$\n"
"\n"
"$ # Use luarocks to install locally, that is, relative to $HOME\n"
"$ luarocks install pg POSTGRESQL_LIBDIR=/usr/lib/x86_64-linux-gnu --local"
"\n"
"Installing http://rocks.tarantool.org/pg-scm-1.rockspec...\n"
"... (more info about building the Tarantool/PostgreSQL driver appears "
"here)\n"
"pg scm-1 is now built and installed in ~/.luarocks/\n"
"\n"
"$ # Ensure driver.so now has been created in a place\n"
"$ # tarantool will look at\n"
"$ find ~/.luarocks -name \"driver.so\"\n"
"~/.luarocks/lib/lua/5.1/pg/driver.so\n"
"\n"
"$ # Change directory to a directory which can be used for\n"
"$ # temporary tests. For this example we assume that the\n"
"$ # name of this directory is $HOME/tarantool_sandbox.\n"
"$ # (Change \"$HOME\" to whatever is the user's actual\n"
"$ # home directory for the machine that's used for this test.)\n"
"cd $HOME/tarantool_sandbox\n"
"\n"
"$ # Start the Tarantool server instance. Do not use a Lua initialization "
"file.\n"
"\n"
"$ tarantool\n"
"tarantool: version 1.7.0-412-g803b15c\n"
"type 'help' for interactive help\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:699
msgid ""
"Configure tarantool and load pg module. Make sure that tarantool doesn't "
"reply \"error\" for the call to \"require()\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:702
msgid ""
"tarantool> box.cfg{}\n"
"...\n"
"tarantool> pg = require('pg')\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:710
msgid ""
"Create a Lua function that will connect to a PostgreSQL server, (using "
"some factory default values for the port and user and password), retrieve"
" one row, and display the row. For explanations of the statement types "
"used here, read the Lua tutorial earlier in the Tarantool user manual."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:715
msgid ""
"tarantool> function pg_select ()\n"
"         >   local conn = pg.connect({\n"
"         >     host = '127.0.0.1',\n"
"         >     port = 5432,\n"
"         >     user = 'postgres',\n"
"         >     password = 'postgres',\n"
"         >     db = 'postgres'\n"
"         >   })\n"
"         >   local test = conn:execute('SELECT * FROM test WHERE s1 = 1')"
"\n"
"         >   local row = ''\n"
"         >   for i, card in pairs(test) do\n"
"         >       row = row .. card.s2 .. ' '\n"
"         >       end\n"
"         >   conn:close()\n"
"         >   return row\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> pg_select()\n"
"---\n"
"- 'PostgreSQL row '\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/dbms.rst:740
msgid ""
"Observe the result. It contains \"PostgreSQL row\". So this is the row "
"that was inserted into the PostgreSQL database. And now it's been "
"selected with the Tarantool client."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:33
msgid "Module `expirationd`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:35
msgid ""
"For a commercial-grade example of a Lua rock that works with Tarantool, "
"let us look at expirationd, which Tarantool supplies on GitHub_ with an "
"Artistic license. The expirationd.lua program is lengthy (about 500 "
"lines), so here we will only highlight the matters that will be enhanced "
"by studying the full source later."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:40
msgid ""
"task.worker_fiber = fiber.create(worker_loop, task)\n"
"log.info(\"expiration: task %q restarted\", task.name)\n"
"...\n"
"fiber.sleep(expirationd.constants.check_interval)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:48
msgid ""
"Whenever one hears \"daemon\" in Tarantool, one should suspect it's being"
" done with a :doc:`fiber<../reference_lua/fiber>`. The program is making "
"a fiber and turning control over to it so it runs occasionally, goes to "
"sleep, then comes back for more."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:53
msgid ""
"for _, tuple in scan_space.index[0]:pairs(nil, {iterator = "
"box.index.ALL}) do\n"
"...\n"
"        if task.is_tuple_expired(task.args, tuple) then\n"
"        task.expired_tuples_count = task.expired_tuples_count + 1\n"
"        task.process_expired_tuple(task.space_id, task.args, tuple)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:62
msgid ""
"The \"for\" instruction can be translated as \"iterate through the index "
"of the space that is being scanned\", and within it, if the tuple is "
"\"expired\" (for example, if the tuple has a timestamp field which is "
"less than the current time), process the tuple as an expired tuple."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:67
msgid ""
"-- default process_expired_tuple function\n"
"local function default_tuple_drop(space_id, args, tuple)\n"
"    local key = fun.map(\n"
"        function(x) return tuple[x.fieldno] end,\n"
"        box.space[space_id].index[0].parts\n"
"    ):totable()\n"
"    box.space[space_id]:delete(key)\n"
"end"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:78
msgid ""
"Ultimately the tuple-expiry process leads to ``default_tuple_drop()`` "
"which does a \"delete\" of a tuple from its original space. First the fun"
" :ref:`fun <fun-module>` module is used, specifically fun.map_. "
"Remembering that :codenormal:`index[0]` is always the space's primary "
"key, and "
":codenormal:`index[0].parts[`:codeitalic:`N`:codenormal:`].fieldno` is "
"always the field number for key part :codeitalic:`N`, fun.map() is "
"creating a table from the primary-key values of the tuple. The result of "
"fun.map() is passed to :ref:`space_object:delete() <box_space-delete>`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:88
msgid ""
"local function expirationd_run_task(name, space_id, is_tuple_expired, "
"options)\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:93
msgid ""
"At this point, if the above explanation is worthwhile, it's clear that "
"``expirationd.lua`` starts a background routine (fiber) which iterates "
"through all the tuples in a space, sleeps cooperatively so that other "
"fibers can operate at the same time, and - whenever it finds a tuple that"
" has expired - deletes it from this space. Now the "
"\"``expirationd_run_task()``\" function can be used in a test which "
"creates sample data, lets the daemon run for a while, and prints results."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:102
msgid ""
"For those who like to see things run, here are the exact steps to get "
"expirationd through the test."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:105
msgid ""
"Get ``expirationd.lua``. There are standard ways - it is after all part "
"of a `standard rock <https://luarocks.org/modules/rtsisyk/expirationd>`_"
"  - but for this purpose just copy the contents of expirationd.lua_ to a "
"default directory."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:108
msgid "Start the Tarantool server as described before."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:109
msgid "Execute these requests:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:111
msgid ""
"fiber = require('fiber')\n"
"expd = require('expirationd')\n"
"box.cfg{}\n"
"e = box.schema.space.create('expirationd_test')\n"
"e:create_index('primary', {type = 'hash', parts = {1, 'unsigned'}})\n"
"e:replace{1, fiber.time() + 3}\n"
"e:replace{2, fiber.time() + 30}\n"
"function is_tuple_expired(args, tuple)\n"
"  if (tuple[2] < fiber.time()) then return true end\n"
"  return false\n"
"  end\n"
"expd.run_task('expirationd_test', e.id, is_tuple_expired)\n"
"retval = {}\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"fiber.sleep(2)\n"
"expd.task_stats()\n"
"expd.kill_task('expirationd_test')\n"
"e:drop()\n"
"os.exit()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:134
msgid ""
"The database-specific requests (``cfg``, :ref:`space.create <box_schema-"
"space_create>`, :ref:`create_index <box_space-create_index>`) should "
"already be familiar."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:139
msgid ""
"The function which will be supplied to expirationd is "
":codenormal:`is_tuple_expired`, which is saying \"if the second field of "
"the tuple is less than the :ref:`current time <fiber-time>`  , then "
"return true, otherwise return false\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:144
msgid ""
"The key for getting the rock rolling is ``expd = "
"require('expirationd')``. The \"``require``\" function is what reads in "
"the program; it will appear in many later examples in this manual, when "
"it's necessary to get a module that's not part of the Tarantool kernel. "
"After the Lua variable expd has been assigned the value of the "
"expirationd module, it's possible to invoke the module's ``run_task()`` "
"function."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:151
msgid ""
"After :ref:`sleeping <fiber-sleep>` for two seconds, when the task has "
"had time to do its iterations through the spaces, ``expd.task_stats()`` "
"will print out a report showing how many tuples have expired -- "
"\"expired_count: 0\". After sleeping for two more seconds, "
"``expd.task_stats()`` will print out a report showing how many tuples "
"have expired -- \"expired_count: 1\". This shows that the "
"is_tuple_expired() function eventually returned \"true\" for one of the "
"tuples, because its timestamp field was more than three seconds old."
msgstr ""

#: ../doc/1.7/reference/reference_rock/expirationd.rst:161
msgid ""
"Of course, expirationd can be customized to do different things by "
"passing different parameters, which will be evident after looking in more"
" detail at the source code."
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:31
msgid "Rocks reference"
msgstr ""

#: ../doc/1.7/reference/reference_rock/index.rst:33
msgid "This reference covers third-party Lua modules for Tarantool."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:33
msgid "Module `shard`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:37
msgid ""
"With sharding, the tuples of a tuple set are distributed to multiple "
"nodes, with a Tarantool database server instance on each node. With this "
"arrangement, each instance is handling only a subset of the total data, "
"so larger loads can be handled by simply adding more computers to a "
"network."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:42
msgid ""
"The Tarantool shard module has facilities for creating shards, as well as"
" analogues for the data-manipulation functions of the box library "
"(select, insert, replace, update, delete)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:46
msgid "First some terminology:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:49
msgid "**Consistent Hash**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:51
msgid ""
"The shard module distributes according to a hash algorithm, that is, it "
"applies a hash function to a tuple's primary-key value in order to decide"
" which shard the tuple belongs to. The hash function is `consistent`_ so "
"that changing the number of servers will not affect results for many "
"keys. The specific hash function that the shard module uses is "
":ref:`digest.guava <digest-guava>` in the :codeitalic:`digest` module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:57
msgid "**Instance**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:59
msgid ""
"A currently-running in-memory copy of the Tarantool server, sometimes "
"called a \"server instance\". Usually each shard is associated with one "
"instance, or, if both sharding and replicating are going on, each shard "
"is associated with one replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:63
msgid "**Queue**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:65
msgid ""
"A temporary list of recent update requests. Sometimes called "
"\"batching\". Since updates to a sharded database can be slow, it may "
"speed up throughput to send requests to a queue rather than wait for the "
"update to finish on every node. The shard module has functions for adding"
" requests to the queue, which it will process without further "
"intervention. Queuing is optional."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:71
msgid "**Redundancy**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:73
msgid "The number of replicated data copies in each shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:74
msgid "**Replica**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:76
msgid "An instance which is part of a replica set."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:77
msgid "**Replica set**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:79
msgid ""
"Often a single shard is associated with a single instance; however, often"
" the shard is replicated. When a shard is replicated, the multiple "
"instances (\"replicas\"), which handle the shard's replicated data, are a"
" \"replica set\"."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:83
msgid "**Replicated data**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:85
msgid ""
"A complete copy of the data. The shard module handles both sharding and "
"replication. One shard can contain one or more replicated data copies. "
"When a write occurs, the write is attempted on every replicated data copy"
" in turn. The shard module does not use the built-in replication feature."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:89
msgid "**Shard**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:91
msgid ""
"A subset of the tuples in the database partitioned according to the value"
" returned by the consistent hash function. Usually each shard is on a "
"separate node, or a separate set of nodes (for example if redundancy = 3 "
"then the shard will be on three nodes)."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:95
msgid "**Zone**"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:97
msgid ""
"A physical location where the nodes are closely connected, with the same "
"security and backup and access points. The simplest example of a zone is "
"a single computer with a single Tarantool-server instance. A shard's "
"replicated data copies should be in different zones."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:102
msgid ""
"The shard package is distributed separately from the main tarantool "
"package. To acquire it, do a separate install. For example on Ubuntu say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:105
msgid "sudo apt-get install tarantool-shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:109
msgid ""
"Or, download from github tarantool/shard and tarantool/connpool and use "
"the Lua files as described in the README. Then, before using the module, "
"say ``shard = require('shard')``"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:113
msgid "The most important function is:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:118
msgid "shard.init(*shard-configuration*)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:120
msgid ""
"This must be called for every shard. The shard-configuration is a table "
"with these fields:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:123
msgid "servers (a list of URIs of nodes and the zones the nodes are in)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:124
msgid "login (the user name which applies for accessing via the shard module)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:125
msgid "password (the password for the login)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:126
msgid "redundancy (a number, minimum 1)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:127
msgid ""
"binary (a port number that this host is listening on, on the current "
"host) (distinguishable from the 'listen' port specified by box.cfg)"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:130
msgid ""
"Possible Errors: Redundancy should not be greater than the number of "
"servers; the servers must be alive; two replicated data copies of the "
"same shard should not be in the same zone."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:136
msgid "Example: shard.init syntax for one shard"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:138
msgid ""
"The number of replicated data copies per shard (redundancy) is 3. The "
"number of instances is 3. The shard module will conclude that there is "
"only one shard."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:142
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:33131', zone = '1' },\n"
"         >     { uri = 'localhost:33132', zone = '2' },\n"
"         >     { uri = 'localhost:33133', zone = '3' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '3',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:163
msgid "Example: shard.init syntax for three shards"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:165
msgid ""
"This describes three shards. Each shard has two replicated data copies. "
"Since the number of servers is 7, and the number of replicated data "
"copies per shard is 2, and dividing 7 / 2 leaves a remainder of 1, one of"
" the servers will not be used. This is not necessarily an error, because "
"perhaps one of the servers in the list is not alive."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:170
msgid ""
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'host1:33131', zone = '1' },\n"
"         >     { uri = 'host2:33131', zone = '2' },\n"
"         >     { uri = 'host3:33131', zone = '3' },\n"
"         >     { uri = 'host4:33131', zone = '4' },\n"
"         >     { uri = 'host5:33131', zone = '5' },\n"
"         >     { uri = 'host6:33131', zone = '6' },\n"
"         >     { uri = 'host7:33131', zone = '7' }\n"
"         >   },\n"
"         >   login = 'tester',\n"
"         >   password = 'pass',\n"
"         >   redundancy = '2',\n"
"         >   binary = 33131,\n"
"         > }\n"
"---\n"
"...\n"
"tarantool> shard.init(cfg)\n"
"---\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:196
msgid ""
"shard[*space-name*].insert{...}\n"
"shard[*space-name*].replace{...}\n"
"shard[*space-name*].delete{...}\n"
"shard[*space-name*].select{...}\n"
"shard[*space-name*].update{...}\n"
"shard[*space-name*].auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:203
msgid ""
"Every data-access function in the box module has an analogue in the shard"
" module, so (for example) to insert in table T in a sharded database one "
"simply says ``shard.T:insert{...}`` instead of "
"``box.space.T:insert{...}``. A ``shard.T:select{}`` request without a "
"primary key will search all shards."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:211
msgid ""
"shard[*space-name*].q_insert{...}\n"
"shard[*space-name*].q_replace{...}\n"
"shard[*space-name*].q_delete{...}\n"
"shard[*space-name*].q_select{...}\n"
"shard[*space-name*].q_update{...}\n"
"shard[*space-name*].q_auto_increment{...}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:218
msgid ""
"Every queued data-access function has an analogue in the shard module. "
"The user must add an operation_id. The details of queued data-access "
"functions, and of maintenance-related functions, are on `the shard "
"section of github`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:224
msgid "Example: Shard, Minimal Configuration"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:226
msgid ""
"There is only one shard, and that shard contains only one replicated data"
" copy. So this isn't illustrating the features of either replication or "
"sharding, it's only illustrating what the syntax is, and what the "
"messages look like, that anyone could duplicate in a minute or two with "
"the magic of cut-and-paste."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:231
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >       { uri = 'localhost:3301', zone = '1' },\n"
"         >   },\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3301;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:257
msgid ""
"If one cuts and pastes the above, then the result, showing only the "
"requests and responses for shard.init and shard.tester, should look "
"approximately like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:261
msgid ""
"tarantool> shard.init(cfg)\n"
"2015-08-09 ... I> Sharding initialization started...\n"
"2015-08-09 ... I> establishing connection to cluster servers...\n"
"2015-08-09 ... I>  - localhost:3301 - connecting...\n"
"2015-08-09 ... I>  - localhost:3301 - connected\n"
"2015-08-09 ... I> connected to all servers\n"
"2015-08-09 ... I> started\n"
"2015-08-09 ... I> redundancy = 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> Adding localhost:3301 to shard 1\n"
"2015-08-09 ... I> Zone len=1 THERE\n"
"2015-08-09 ... I> shards = 1\n"
"2015-08-09 ... I> Done\n"
"---\n"
"- true\n"
"...\n"
"tarantool> -- Now put something in ...\n"
"---\n"
"...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}\n"
"---\n"
"- - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:290
msgid "Example: Shard, Scaling Out"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:292
msgid ""
"There are two shards, and each shard contains one replicated data copy. "
"This requires two nodes. In real life the two nodes would be two "
"computers, but for this illustration the requirement is merely: start two"
" shells, which we'll call Terminal#1 and Terminal #2."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:297
msgid "On Terminal #1, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:299
msgid ""
"$ mkdir ~/tarantool_sandbox_1\n"
"$ cd ~/tarantool_sandbox_1\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3301}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' },\n"
"         >     { uri = 'localhost:3302', zone = '2' },\n"
"         >   },\n"
"         >   login = 'admin',\n"
"         >   password = 'password',\n"
"         >   redundancy = 1,\n"
"         >   binary = 3301,\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now put something in ...\n"
"tarantool> shard.tester:insert{1,'Tuple #1'}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:327
msgid "On Terminal #2, say:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:329
msgid ""
"$ mkdir ~/tarantool_sandbox_2\n"
"$ cd ~/tarantool_sandbox_2\n"
"$ rm -r *.snap\n"
"$ rm -r *.xlog\n"
"$ ~/tarantool-1.7/src/tarantool\n"
"\n"
"tarantool> box.cfg{listen = 3302}\n"
"tarantool> box.schema.space.create('tester')\n"
"tarantool> box.space.tester:create_index('primary', {})\n"
"tarantool> box.schema.user.passwd('admin', 'password')\n"
"tarantool> console = require('console')\n"
"tarantool> cfg = {\n"
"         >   servers = {\n"
"         >     { uri = 'localhost:3301', zone = '1' };\n"
"         >     { uri = 'localhost:3302', zone = '2' };\n"
"         >   };\n"
"         >   login = 'admin';\n"
"         >   password = 'password';\n"
"         >   redundancy = 1;\n"
"         >   binary = 3302;\n"
"         > }\n"
"tarantool> shard = require('shard')\n"
"tarantool> shard.init(cfg)\n"
"tarantool> -- Now get something out ...\n"
"tarantool> shard.tester:select{1}"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:357
msgid ""
"What will appear on Terminal #1 is: a loop of error messages saying "
"\"Connection refused\" and \"server check failure\". This is normal. It "
"will go on until Terminal #2 process starts."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:361
msgid "What will appear on Terminal #2, at the end, should look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:363
msgid ""
"tarantool> shard.tester:select{1}\n"
"---\n"
"- - - [1, 'Tuple #1']\n"
"..."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:370
msgid ""
"This shows that what was inserted by Terminal #1 can be selected by "
"Terminal #2, via the shard module."
msgstr ""

#: ../doc/1.7/reference/reference_rock/shard.rst:373
msgid "Details are on `the shard section of github`_."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:31
msgid "Module `tdb`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:33
msgid ""
"The Tarantool Debugger (abbreviation = tdb) can be used with any Lua "
"program. The operational features include: setting breakpoints, examining"
" variables, going forward one line at a time, backtracing, and showing "
"information about fibers. The display features include: using different "
"colors for different situations, including line numbers, and adding "
"hints."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:39
msgid ""
"It is not supplied as part of the Tarantool repository; it must be "
"installed separately. Here is the usual way:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:42
msgid ""
"git clone --recursive https://github.com/Sulverus/tdb\n"
"cd tdb\n"
"make\n"
"sudo make install prefix=/usr/share/tarantool/"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:49
msgid ""
"To initiate tdb within a Lua program and set a breakpoint, edit the "
"program to include these lines:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:52
msgid ""
"tdb = require('tdb')\n"
"tdb.start()"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:57
msgid ""
"To start the debugging session, execute the Lua program. Execution will "
"stop at the breakpoint, and it will be possible to enter debugging "
"commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:62
msgid "Debugger Commands"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:66
msgid ":codebold:`bt`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:65
msgid ""
"Backtrace -- show the stack (in red), with program/function names and "
"line numbers of whatever has been invoked to reach the current line."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:69
msgid ":codebold:`c`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:69
msgid "Continue till next breakpoint or till program ends."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:76
msgid ":codebold:`e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:72
msgid ""
"Enter evaluation mode. When the program is in evaluation mode, one can "
"execute certain Lua statements that would be valid in the context. This "
"is particularly useful for displaying the values of the program's "
"variables. Other debugger commands will not work until one exits "
"evaluation mode by typing :codebold:`-e`."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:79
msgid ":codebold:`-e`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:79
msgid "Exit evaluation mode."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:83
msgid ":codebold:`f`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:82
msgid ""
"Display the fiber id, the program name, and the percentage of memory "
"used, as a table."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:86
msgid ":codebold:`n`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:86
msgid "Go to the next line, skipping over any function calls."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid ":codebold:`globals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:89
msgid "Display names of variables or functions which are defined as global."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid ":codebold:`h`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:92
msgid "Display a list of debugger commands."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:96
msgid ":codebold:`locals`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:95
msgid ""
"Display names and values of variables, for example the control variables "
"of a Lua \"for\" statement."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:99
msgid ":codebold:`q`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:99
msgid "Quit immediately."
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:103
msgid "Example Session"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:105
msgid ""
"Put the following program in a default directory and call it "
"\"example.lua\":"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:107
msgid ""
"tdb = require('tdb')\n"
"tdb.start()\n"
"i = 1\n"
"j = 'a' .. i\n"
"print('end of program')"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:115
msgid "Now start Tarantool, using example.lua as the initialization file"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:120
msgid "$ :codebold:`tarantool example.lua`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:122
#: ../doc/1.7/reference/reference_rock/tdb.rst:147
msgid "The screen should now look like this:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:127
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>`"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:134
msgid ""
"Debugger prompts are blue, debugger hints and information are green, and "
"the current line -- line 3 of example.lua -- is the default color. Now "
"enter six debugger commands:"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:138
msgid ""
"n  -- go to next line\n"
"n  -- go to next line\n"
"e  -- enter evaluation mode\n"
"j  -- display j\n"
"-e -- exit evaluation mode\n"
"q  -- quit"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:152
msgid ""
"$ :codebold:`tarantool example.lua`\n"
":codeblue:`(TDB)`  :codegreen:`Tarantool debugger v.0.0.3. Type h for "
"help`\n"
"example.lua\n"
":codeblue:`(TDB)`  :codegreen:`[example.lua]`\n"
":codeblue:`(TDB)`  :codenormal:`3: i = 1`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`4: j = 'a' .. i`\n"
":codeblue:`(TDB)>` n\n"
":codeblue:`(TDB)`  :codenormal:`5: print('end of program')`\n"
":codeblue:`(TDB)>` e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode ON`\n"
":codeblue:`(TDB)>` j\n"
"j       a1\n"
":codeblue:`(TDB)>` -e\n"
":codeblue:`(TDB)`  :codegreen:`Eval mode OFF`\n"
":codeblue:`(TDB)>` q"
msgstr ""

#: ../doc/1.7/reference/reference_rock/tdb.rst:169
msgid "Another debugger example can be found here_."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:33
msgid "Utility `tarantoolctl`"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:35
msgid ""
"``tarantoolctl`` is a utility for administering Tarantool instances. It "
"is shipped and installed as part of Tarantool distribution."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:38
msgid "The command format is:"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:40
msgid "``tarantoolctl COMMAND NAME [URI] [FILE] [OPTIONS..]``"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:44
msgid ""
"COMMAND is one of the following: start, stop, logrotate, status, enter, "
"restart, eval, check, connect, cat, play."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:47
msgid "NAME is the name of an :ref:`instance file <admin-instance_file>`."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:49
msgid "FILE is the path to some file (.lua, .xlog or .snap)."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:51
msgid "URI is the URI of some Tarantool instance."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:53
msgid "OPTIONS are options taken by some ``tarantoolctl`` commands."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:55
msgid "See also:"
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:57
msgid "Detailed reference upon ``man tarantoolctl`` or ``tarantoolctl --help``."
msgstr ""

#: ../doc/1.7/reference/tarantoolctl.rst:58
msgid "Usage examples in :ref:`Server administration <admin>` section."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:31
msgid "C tutorial"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:33
msgid ""
"Here is one C tutorial: :ref:`C stored procedures <f_c_tutorial-"
"c_stored_procedures>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:40
msgid "C stored procedures"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:42
msgid ""
"Tarantool can call C code with :ref:`modules <app_server-modules>`, or "
"with :ref:`ffi <cookbook-ffi_printf>`, or with C stored procedures. This "
"tutorial only is about the third option, C stored procedures. In fact the"
" routines are always \"C functions\" but the phrase \"stored procedure\" "
"is commonly used for historical reasons."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:49
msgid ""
"In this tutorial, which can be followed by anyone with a Tarantool "
"development package and a C compiler, there are four tasks. The first -- "
":code:`easy.c` -- prints \"hello world\". The second -- :code:`harder.c` "
"-- decodes a passed parameter value. The third -- :code:`hardest.c` -- "
"uses the C API to do a DBMS insert. The fourth -- :code:`read.c` -- uses "
"the C API to do a DBMS select."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:56
msgid ""
"After following the instructions, and seeing that the results are what is"
" described here, users should feel confident about writing their own "
"stored procedures."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:60
msgid "**Preparation**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:62
msgid ""
"Check that these items exist on the computer: |br| * Tarantool 1.7 |br| *"
" A gcc compiler, any modern version should work |br| * \"module.h\" and "
"files #included in it |br| * \"msgpuck.h\" |br| * \"libmsgpuck.a\" (only "
"for some recent msgpuck versions) |br|"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:69
msgid ""
"The \"module.h\" file will exist if Tarantool 1.7 was installed from "
"source. Otherwise Tarantool's \"developer\" package must be installed. "
"For example on Ubuntu say |br| :code:`sudo apt-get install tarantool-dev`"
" |br| or on Fedora say |br| :code:`dnf -y install tarantool-devel`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:76
msgid ""
"The \"msgpuck.h\" file will exist if Tarantool 1.7 was installed from "
"source. Otherwise the \"msgpuck\" package must be installed from "
"`https://github.com/rtsisyk/msgpuck "
"<https://github.com/rtsisyk/msgpuck>`_."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:80
msgid ""
"Both module.h and msgpuck.h must be on the include path for the C "
"compiler to see them. For example, if module.h address is "
"/usr/local/include/tarantool/module.h, and msgpuck.h address is "
"/usr/local/include/msgpuck/msgpuck.h, and they are not currently on the "
"include path, say |br| :code:`export "
"CPATH=/usr/local/include/tarantool:/usr/local/include/msgpuck`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:86
msgid ""
"The libmsgpuck.a static library is necessary with msgpuck versions "
"produced after February 2017. If and only if you encounter linking "
"problems when using the gcc statements in the examples for this tutorial,"
" you should put libmsgpuck.a on the path (libmsgpuck.a is produced from "
"both msgpuck and Tarantool source downloads so it should be easy to "
"find). For example, instead of \":code:`gcc -shared -o harder.so -fPIC "
"harder.c`\" for the second example below, you will need to say "
"\":code:`gcc -shared -o harder.so -fPIC harder.c libmsgpuck.a`\"."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:95
msgid ""
"Requests will be done using Tarantool as a :ref:`client <admin-"
"using_tarantool_as_a_client>`. Start Tarantool, and enter these requests."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:99
msgid ""
"box.cfg{listen=3306}\n"
"box.schema.space.create('capi_test')\n"
"box.space.capi_test:create_index('primary')\n"
"net_box = require('net.box')\n"
"capi_connection = net_box:new(3306)"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:107
msgid ""
"In plainer language: create a space named capi_test, and make a "
"connection to self named capi_connection."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:110
msgid ""
"Leave the client running. It will be necessary to enter more requests "
"later."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:112
msgid "**easy.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:114
msgid ""
"Start another shell. Change directory (cd) so that it is the same as the "
"directory that the client is running on."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:117
msgid "Create a file. Name it easy.c. Put these six lines in it."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:119
msgid ""
"#include \"module.h\"\n"
"int easy(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  printf(\"hello world\\n\");\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:128
msgid ""
"Compile the program, producing a library file named easy.so: |br| "
":code:`gcc -shared -o easy.so -fPIC easy.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:131
#: ../doc/1.7/tutorials/c_tutorial.rst:200
#: ../doc/1.7/tutorials/c_tutorial.rst:283
#: ../doc/1.7/tutorials/c_tutorial.rst:374
msgid "Now go back to the client and execute these requests:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:133
msgid ""
"box.schema.func.create('easy', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'easy')\n"
"capi_connection:call('easy')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:139
msgid ""
"If these requests appear unfamiliar, re-read the descriptions of "
":ref:`box.schema.func.create <box_schema-func_create>` and "
":ref:`box.schema.user.grant <box_schema-user_grant>` and :ref:`conn:call "
"<net_box-call>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:145
msgid "The function that matters is capi_connection:call('easy')."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:147
msgid ""
"Its first job is to find the 'easy' function, which should be easy "
"because by default Tarantool looks on the current directory for a file "
"named easy.so."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:151
msgid ""
"Its second job is to call the 'easy' function. Since the easy() function "
"in easy.c begins with :code:`printf(\"hello world\\n\")`, the words "
"\"hello world\" will appear on the screen."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:155
msgid ""
"Its third job is to check that the call was successful. Since the easy() "
"function in easy.c ends with :code:`return 0`, there is no error message "
"to display and the request is over."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:159
#: ../doc/1.7/tutorials/c_tutorial.rst:301
msgid "The result should look like this:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:161
msgid ""
"tarantool> capi_connection:call('easy')\n"
"hello world\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:169
msgid "Conclusion: calling a C function is easy."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:171
msgid "**harder.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:173
msgid "Go back to the shell where the easy.c program was created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:175
msgid "Create a file. Name it harder.c. Put these 17 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:177
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int harder(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t arg_count = mp_decode_array(&args);\n"
"  printf(\"arg_count = %d\\n\", arg_count);\n"
"  uint32_t field_count = mp_decode_array(&args);\n"
"  printf(\"field_count = %d\\n\", field_count);\n"
"  uint32_t val;\n"
"  int i;\n"
"  for (i = 0; i < field_count; ++i)\n"
"  {\n"
"    val = mp_decode_uint(&args);\n"
"    printf(\"val=%d.\\n\", val);\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:197
msgid ""
"Compile the program, producing a library file named harder.so: |br| "
":code:`gcc -shared -o harder.so -fPIC harder.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:202
msgid ""
"box.schema.func.create('harder', {language = 'C'})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'harder')\n"
"passable_table = {}\n"
"table.insert(passable_table, 1)\n"
"table.insert(passable_table, 2)\n"
"table.insert(passable_table, 3)\n"
"capi_connection:call('harder', passable_table)"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:212
msgid ""
"This time the call is passing a Lua table (passable_table) to the "
"harder() function. The harder() function will see it, it's in the "
":code:`char *args` parameter."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:216
msgid ""
"At this point the harder() function will start using functions defined in"
" msgpuck.h, which are documented in `http://rtsisyk.github.io/msgpuck "
"<http://rtsisyk.github.io/msgpuck>`_. The routines that begin with \"mp\""
" are msgpuck functions that handle data formatted according to the "
"MsgPack_ specification. Passes and returns are always done with this "
"format so one must become acquainted with msgpuck to become proficient "
"with the C API."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:225
msgid ""
"For now, though, it's enough to know that mp_decode_array() returns the "
"number of elements in an array, and mp_decode_uint returns an unsigned "
"integer, from :code:`args`. And there's a side effect: when the decoding "
"finishes, :code:`args` has changed and is now pointing to the next "
"element."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:231
msgid ""
"Therefore the first displayed line will be \"arg_count = 1\" because "
"there was only one item passed: passable_table. |br| The second displayed"
" line will be \"field_count = 3\" because there are three items in the "
"table. |br| The next three lines will be \"1\" and \"2\" and \"3\" "
"because those are the values in the items in the table."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:238
msgid "And now the screen looks like this:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:240
msgid ""
"tarantool> capi_connection:call('harder', passable_table)\n"
"arg_count = 1\n"
"field_count = 3\n"
"val=1.\n"
"val=2.\n"
"val=3.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:252
msgid ""
"Conclusion: decoding parameter values passed to a C function is not easy "
"at first, but there are routines to do the job, and they're documented, "
"and there aren't very many of them."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:257
msgid "**hardest.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:259
msgid ""
"Go back to the shell where the easy.c and the harder.c programs were "
"created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:262
msgid "Create a file. Name it hardest.c. Put these 13 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:264
msgid ""
"#include \"module.h\"\n"
"#include \"msgpuck.h\"\n"
"int hardest(box_function_ctx_t *ctx, const char *args, const char "
"*args_end)\n"
"{\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  char tuple[1024];\n"
"  char *tuple_pointer = tuple;\n"
"  tuple_pointer = mp_encode_array(tuple_pointer, 2);\n"
"  tuple_pointer = mp_encode_uint(tuple_pointer, 10000);\n"
"  tuple_pointer = mp_encode_str(tuple_pointer, \"String 2\", 8);\n"
"  int n = box_insert(space_id, tuple, tuple_pointer, NULL);\n"
"  return n;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:280
msgid ""
"Compile the program, producing a library file named hardest.so: |br| "
":code:`gcc -shared -o hardest.so -fPIC hardest.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:285
msgid ""
"box.schema.func.create('hardest', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'hardest')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('hardest')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:292
msgid ""
"This time the C function is doing three things: |br| (1) finding the "
"numeric identifier of the \"capi_test\" space by calling "
"box_space_id_by_name(); |br| (2) formatting a tuple using more msgpuck.h "
"functions; |br| (3) inserting a tuple using box_insert."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:298
msgid ""
"Now, still on the client, execute this request: |br| "
":code:`box.space.capi_test:select()`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:303
msgid ""
"tarantool> box.space.capi_test:select()\n"
"---\n"
"- - [10000, 'String 2']\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:310
msgid ""
"This proves that the hardest() function succeeded, but where did "
"box_space_id_by_name() and box_insert() come from? Answer: the C API. The"
" whole C API is documented :ref:`here <index-c_api_reference>`. The "
"function box_space_id_by_name() is documented :ref:`here <box-"
"box_space_id_by_name>`. The function box_insert() is documented "
":ref:`here <box-box_insert>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:318
msgid "**read.c**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:320
msgid ""
"Go back to the shell where the easy.c and the harder.c and the hardest.c "
"programs were created."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:323
msgid "Create a file. Name it read.c. Put these 43 lines in it:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:325
#, python-format
msgid ""
"#include \"module.h\"\n"
"#include <msgpuck.h>\n"
"int read(box_function_ctx_t *ctx, const char *args, const char *args_end)"
"\n"
"{\n"
"  char tuple_buf[1024];      /* where the raw MsgPack tuple will be "
"stored */\n"
"  uint32_t space_id = box_space_id_by_name(\"capi_test\", "
"strlen(\"capi_test\"));\n"
"  uint32_t index_id = 0;     /* The number of the space's first index */\n"
"  uint32_t key = 10000;      /* The key value that box_insert() used */\n"
"  mp_encode_array(tuple_buf, 0); /* clear */\n"
"  box_tuple_format_t *fmt = box_tuple_format_default();\n"
"  box_tuple_t *tuple = box_tuple_new(fmt, tuple_buf, tuple_buf+512);\n"
"  assert(tuple != NULL);\n"
"  char key_buf[16];          /* Pass key_buf = encoded key = 1000 */\n"
"  char *key_end = key_buf;\n"
"  key_end = mp_encode_array(key_end, 1);\n"
"  key_end = mp_encode_uint(key_end, key);\n"
"  assert(key_end < key_buf + sizeof(key_buf));\n"
"  /* Get the tuple. There's no box_select() but there's this. */\n"
"  int r = box_index_get(space_id, index_id, key_buf, key_end, &tuple);\n"
"  assert(r == 0);\n"
"  assert(tuple != NULL);\n"
"  /* Get each field of the tuple + display what you get. */\n"
"  int field_no;             /* The first field number is 0. */\n"
"  for (field_no = 0; field_no < 2; ++field_no)\n"
"  {\n"
"    const char *field = box_tuple_field(tuple, field_no);\n"
"    assert(field != NULL);\n"
"    assert(mp_typeof(*field) == MP_STR || mp_typeof(*field) == MP_UINT);\n"
"    if (mp_typeof(*field) == MP_UINT)\n"
"    {\n"
"      uint32_t uint_value = mp_decode_uint(&field);\n"
"      printf(\"uint value=%u.\\n\", uint_value);\n"
"    }\n"
"    else /* if (mp_typeof(*field) == MP_STR) */\n"
"    {\n"
"      const char *str_value;\n"
"      uint32_t str_value_length;\n"
"      str_value = mp_decode_str(&field, &str_value_length);\n"
"      printf(\"string value=%.*s.\\n\", str_value_length, str_value);\n"
"    }\n"
"  }\n"
"  return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:371
msgid ""
"Compile the program, producing a library file named read.so: |br| "
":code:`gcc -shared -o read.so -fPIC read.c`"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:376
msgid ""
"box.schema.func.create('read', {language = \"C\"})\n"
"box.schema.user.grant('guest', 'execute', 'function', 'read')\n"
"box.schema.user.grant('guest', 'read,write', 'space', 'capi_test')\n"
"capi_connection:call('read')"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:383
msgid ""
"This time the C function is doing four things: |br| (1) once again, "
"finding the numeric identifier of the \"capi_test\" space by calling "
"box_space_id_by_name(); |br| (2) formatting a search key = 10000 using "
"more msgpuck.h functions; |br| (3) getting a tuple using box_index_get' "
"|br| (4) going through the tuple's fields with box_tuple_get() and then "
"decoding each field depending  on its type. In this case, since what we "
"are getting is the tuple that we inserted with hardest.c, we know in "
"advance that the type is either MP_UINT or MP_STR; however, it's very "
"common to have a case statement here with one option for each possible "
"type."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:395
msgid "The result of capi_connection:call('read') should look like this:"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:397
msgid ""
"tarantool> capi_connection:call('read')\n"
"uint value=10000.\n"
"string value=String 2.\n"
"---\n"
"- []\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:406
msgid ""
"This proves that the read() function succeeded. Once again the important "
"functions that start with `box` came from the C API. The function "
"box_index_get() is documented :ref:`here <c_api-box_index-"
"box_index_get>`. The function box_tuple_field() is documented :ref:`here "
"<c_api-tuple-box_tuple_field>`."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:411
msgid ""
"Conclusion: the long description of the whole C API is there for a good "
"reason. All of the functions in it can be called from C functions which "
"are called from Lua. So C \"stored procedures\" have full access to the "
"database."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:418
msgid "**Cleaning up**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:420
msgid ""
"Get rid of each of the function tuples with :ref:`box.schema.func.drop "
"<box_schema-func_drop>`, and get rid of the capi_test space with "
":ref:`box.schema.capi_test:drop() <box_space-drop>`, and remove the .c "
"and .so files that were created for this tutorial."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:425
msgid "**An example in the test suite**"
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:427
msgid ""
"Download the source code of Tarantool. Look in a subdirectory "
":code:`test/box`. Notice that there is a file named "
":code:`tuple_bench.test.lua` and another file named "
":code:`tuple_bench.c`. Examine the Lua file and observe that it is "
"calling a function in the C file, using the same techniques that this "
"tutorial has shown."
msgstr ""

#: ../doc/1.7/tutorials/c_tutorial.rst:434
msgid ""
"Conclusion: parts of the standard test suite use C stored procedures, and"
" they must work, because releases don't happen if Tarantool doesn't pass "
"the tests."
msgstr ""

#: ../doc/1.7/tutorials/index.rst:33
msgid "Tutorials"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:33
msgid "`libslave` tutorial"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:35
msgid ""
"``libslave`` is a C++ library for reading data changes done by MysQL and,"
" optionally, writing them to a Tarantool database. It works by acting as "
"a replication slave. The MySQL server writes data-change information to a"
" \"binary log\", and transfers the information to any client that says "
"\"I want to see the information starting with this file and this record, "
"continuously\". So, ``libslave`` is primarily good for making a Tarantool"
" database replica (much faster than using a conventional MySQL slave "
"server), and for keeping track of data changes so they can be searched."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:46
msgid ""
"We will not go into the many details here -- the `API documentation "
"<https://github.com/vozbu/libslave/wiki/API>`_ has them. We will only "
"show an exercise: a minimal program that uses the library."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:52
msgid "Use a test machine. Do not use a production machine."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:54
msgid "STEP 1: Make sure you have:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:56
msgid "a recent version of Linux (versions such as Ubuntu 14.04 will not do),"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:57
msgid "a recent version of MySQL 5.6 or MySQL 5.7 server (MariaDB will not do),"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:58
msgid ""
"MySQL client development package. For example, on Ubuntu you can download"
" it with this command:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:61
msgid "sudo apt-get install mysql-client-core-5.7"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:65
msgid "STEP 2: Download ``libslave``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:67
msgid ""
"The recommended source is https://github.com/tarantool/libslave/. "
"Downloads include the source code only."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:70
msgid ""
"sudo apt-get install libboost-all-dev\n"
"cd ~\n"
"git clone https://github.com/tarantool/libslave.git tarantool-libslave\n"
"cd tarantool-libslave\n"
"git submodule init\n"
"git submodule update\n"
"cmake .\n"
"make"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:81
msgid ""
"If you see an error message mentioning the word \"vector\", edit "
"``field.h`` and add this line:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:84
msgid "#include <vector>"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:88
msgid ""
"STEP 3: Start the MySQL server. On the command line, add appropriate "
"switches for doing replication. For example:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:91
msgid "mysqld --log-bin=mysql-bin --server-id=1"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:95
msgid "STEP 4: For purposes of this exercise, we are assuming you have:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:97
msgid "a \"root\" user with password \"root\" with privileges,"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:98
msgid "a \"test\" database with a table named \"test\","
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:99
msgid "a binary log named \"mysql-bin\","
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:100
msgid "a server with server id = 1."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:102
msgid ""
"The values are hard-coded in the program, though of course you can change"
" the program -- it's easy to see their settings."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:105
msgid "STEP 5: Look at the program:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:107
msgid ""
"#include <unistd.h>\n"
"#include <iostream>\n"
"#include <sstream>\n"
"#include \"Slave.h\"\n"
"#include \"DefaultExtState.h\"\n"
"\n"
"slave::Slave* sl = NULL;\n"
"\n"
"void callback(const slave::RecordSet& event) {\n"
"    slave::Slave::binlog_pos_t sBinlogPos = sl->getLastBinlog();\n"
"    switch (event.type_event) {\n"
"    case slave::RecordSet::Update: std::cout << \"UPDATE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Delete: std::cout << \"DELETE\" << \"\\n\"; "
"break;\n"
"    case slave::RecordSet::Write:  std::cout << \"INSERT\" << \"\\n\"; "
"break;\n"
"    default: break;\n"
"    }\n"
"}\n"
"\n"
"bool isStopping()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"    slave::MasterInfo masterinfo;\n"
"    masterinfo.conn_options.mysql_host = \"127.0.0.1\";\n"
"    masterinfo.conn_options.mysql_port = 3306;\n"
"    masterinfo.conn_options.mysql_user = \"root\";\n"
"    masterinfo.conn_options.mysql_pass = \"root\";\n"
"    bool error = false;\n"
"    try {\n"
"        slave::DefaultExtState sDefExtState;\n"
"        slave::Slave slave(masterinfo, sDefExtState);\n"
"        sl = &slave;\n"
"        sDefExtState.setMasterLogNamePos(\"mysql-bin\", 0);\n"
"        slave.setCallback(\"test\", \"test\", callback);\n"
"        slave.init();\n"
"        slave.createDatabaseStructure();\n"
"        try {\n"
"            slave.get_remote_binlog(isStopping);\n"
"        } catch (std::exception& ex) {\n"
"            std::cout << \"Error reading: \" << ex.what() << std::endl;\n"
"            error = true;\n"
"        }\n"
"    } catch (std::exception& ex) {\n"
"        std::cout << \"Error initializing: \" << ex.what() << std::endl;\n"
"        error = true;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:161
msgid ""
"Everything unnecessary has been stripped so that you can see quickly how "
"it works. At the start of ``main()``, there are some settings used for "
"connecting -- host, port, user, password. Then there is an initialization"
" call with the binary log file name = \"mysql-bin\". Pay particular "
"attention to the ``setCallback`` statement, which passes database name = "
"\"test\", table name = \"test\", and callback function address = "
"callback. The program will be looping and invoking this callback "
"function. See how, earlier in the program, the callback function prints "
"\"UPDATE\" or \"DELETE\" or \"INSERT\" depending on what is passed to it."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:172
msgid ""
"STEP 5: Put the program in the ``tarantool-libslave`` directory and name "
"it ``example.cpp``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:175
msgid "Step 6: Compile and build:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:177
msgid ""
"g++ -I/tarantool-libslave/include example.cpp -o example libslave_a.a "
"-ldl -lpthread"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:183
msgid "Replace ``tarantool-libslave/include`` with the full directory name."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:185
msgid ""
"Notice that the name of the static library is ``libslave_a.a``, not "
"``libslave.a``."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:188
msgid "Step 7: Run:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:190
msgid "./example"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:194
msgid ""
"The result will be nothing -- the program is looping, waiting for the "
"MySQL server to write to the replication binary log."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:197
msgid ""
"Step 8: Start a MySQL client program -- any client program will do. Enter"
" these statements:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:200
msgid ""
"USE test\n"
"INSERT INTO test VALUES ('A');\n"
"INSERT INTO test VALUES ('B');\n"
"DELETE FROM test;"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:207
msgid "Watch what happens in ``example.cpp`` output -- it displays:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:209
msgid ""
"INSERT\n"
"INSERT\n"
"DELETE\n"
"DELETE"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:216
msgid ""
"This is row-based replication, so you see two DELETEs, because there are "
"two rows."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:219
msgid "What the exercise has shown is:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:221
msgid "the library can be built, and"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:222
msgid ""
"programs that use the library can access everything that the MySQL server"
" dumps."
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:225
msgid "For the many details and examples of usage in the field, see:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "Our downloadable ``libslave`` version:"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "https://github.com/tarantool/libslave"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "The version it was forked from (with a different README):"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst
msgid "https://github.com/vozbu/libslave/wiki/API"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:233
msgid ""
"`How to speed up your MySQL with replication to in-memory database "
"<http://highscalability.com/blog/2017/3/29/how-to-speed-up-your-mysql-"
"with-replication-to-in-memory-dat.html>`_ article"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:235
msgid ""
"`Replicating data from MySQL to Tarantool "
"<https://habrahabr.ru/company/mailru/blog/323870/>`_ article (in Russian)"
msgstr ""

#: ../doc/1.7/tutorials/libslave.rst:237
msgid ""
"`Asynchronous replication uncensored <https://habrahabr.ru/company/oleg-"
"bunin/blog/313594/>`_ article (in Russian)"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:33
msgid "Lua tutorials"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:35
msgid "Here are three tutorials on using Lua stored procedures with Tarantool:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:37
msgid ""
":ref:`Insert one million tuples with a Lua stored procedure "
"<c_lua_tutorial-insert_one_million_tuples>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:38
msgid ":ref:`Sum a JSON field for all tuples <c_lua_tutorial-sum_a_json_field>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:39
msgid ":ref:`Indexed pattern search <c_lua_tutorial-indexed_pattern_search>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:45
msgid "Insert one million tuples with a Lua stored procedure"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:47
msgid ""
"This is an exercise assignment: “Insert one million tuples. Each tuple "
"should have a constantly-increasing numeric primary-key field and a "
"random alphabetic 10-character string field.”"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:51
msgid ""
"The purpose of the exercise is to show what Lua functions look like "
"inside Tarantool. It will be necessary to employ the Lua math library, "
"the Lua string library, the Tarantool box library, the Tarantool "
"box.tuple library, loops, and concatenations. It should be easy to follow"
" even for a person who has not used either Lua or Tarantool before. The "
"only requirement is a knowledge of how other programming languages work "
"and a memory of the first two chapters of this manual. But for better "
"understanding, follow the comments and the links, which point to the Lua "
"manual or to elsewhere in this Tarantool manual. To further enhance "
"learning, type the statements in with the tarantool client while reading "
"along."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:63
msgid "Configure"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:65
msgid ""
"We are going to use the Tarantool sandbox that was created our "
":ref:`\"Getting started\" exercises <getting_started>`. So there is a "
"single space, and a numeric primary key, and a running Tarantool server "
"instance which also serves as a client."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:72
msgid "Delimiter"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:74
msgid ""
"In earlier versions of Tarantool, multi-line functions had to be enclosed"
" within \"delimiters\". They are no longer necessary, and so they will "
"not be used in this tutorial. However, they are still supported. Users "
"who wish to use delimiters, or users of older versions of Tarantool, "
"should check the syntax description for :ref:`declaring a delimiter "
"<console-delimiter>` before proceeding."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:83
msgid "Create a function that returns a string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:85
msgid ""
"We will start by making a function that returns a fixed string, “Hello "
"world”."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:87
msgid ""
"function string_function()\n"
"  return \"hello world\"\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:93
msgid ""
"The word \"``function``\" is a Lua keyword -- we're about to go into Lua."
" The function name is string_function. The function has one executable "
"statement, ``return \"hello world\"``. The string \"hello world\" is "
"enclosed in double quotes here, although Lua doesn't care -- one could "
"use single quotes instead. The word \"``end``\" means “this is the end of"
" the Lua function declaration.” To confirm that the function works, we "
"can say"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:100
msgid "string_function()"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:104
msgid ""
"Sending ``function-name()`` means “invoke the Lua function.” The effect "
"is that the string which the function returns will end up on the screen."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:107
msgid ""
"For more about Lua strings see Lua manual `chapter 2.4 \"Strings\"`_ . "
"For more about functions see Lua manual `chapter 5 \"Functions\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:113
#: ../doc/1.7/tutorials/lua_tutorials.rst:157
#: ../doc/1.7/tutorials/lua_tutorials.rst:209
#: ../doc/1.7/tutorials/lua_tutorials.rst:265
#: ../doc/1.7/tutorials/lua_tutorials.rst:311
#: ../doc/1.7/tutorials/lua_tutorials.rst:369
#: ../doc/1.7/tutorials/lua_tutorials.rst:462
msgid "The screen now looks like this:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:115
msgid ""
"tarantool> function string_funciton()\n"
"         >   return \"hello world\"\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> string_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:130
msgid "Create a function that calls another function and sets a variable"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:132
msgid ""
"Now that ``string_function`` exists, we can invoke it from another "
"function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:135
msgid ""
"function main_function()\n"
"  local string_value\n"
"  string_value = string_function()\n"
"  return string_value\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:143
msgid ""
"We begin by declaring a variable \"``string_value``\". The word "
"\"``local``\" means that string_value appears only in ``main_function``. "
"If we didn't use \"``local``\" then ``string_value`` would be visible "
"everywhere - even by other users using other clients connected to this "
"server instance! Sometimes that's a very desirable feature for inter-"
"client communication, but not this time."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:149
msgid ""
"Then we assign a value to ``string_value``, namely, the result of "
"``string_function()``. Soon we will invoke ``main_function()`` to check "
"that it got the value."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:153
msgid ""
"For more about Lua variables see Lua manual `chapter 4.2 \"Local "
"Variables and Blocks\"`_ ."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:159
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value\n"
"         >   string_value = string_function()\n"
"         >   return string_value\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- hello world\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:176
msgid "Modify the function so it returns a one-letter random string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:178
msgid ""
"Now that it's a bit clearer how to make a variable, we can change "
"``string_function()`` so that, instead of returning a fixed literal "
"\"Hello world\", it returns a random letter between 'A' and 'Z'."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:182
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_number = math.random(65, 90)\n"
"  random_string = string.char(random_number)\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:192
msgid ""
"It is not necessary to destroy the old ``string_function()`` contents, "
"they're simply overwritten. The first assignment invokes a random-number "
"function in Lua's math library; the parameters mean “the number must be "
"an integer between 65 and 90.” The second assignment invokes an integer-"
"to-character function in Lua's string library; the parameter is the code "
"point of the character. Luckily the ASCII value of 'A' is 65 and the "
"ASCII value of 'Z' is 90 so the result will always be a letter between A "
"and Z."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:200
msgid ""
"For more about Lua math-library functions see Lua users \"`Math Library "
"Tutorial`_\". For more about Lua string-library functions see Lua users "
"\"`String Library Tutorial`_\" ."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:206
msgid ""
"Once again the ``string_function()`` can be invoked from main_function() "
"which can be invoked with ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:211
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_number = math.random(65, 90)\n"
"         >   random_string = string.char(random_number)\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- C\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:228
msgid ""
"... Well, actually it won't always look like this because "
"``math.random()`` produces random numbers. But for the illustration "
"purposes it won't matter what the random string values are."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:234
msgid "Modify the function so it returns a ten-letter random string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:236
msgid ""
"Now that it's clear how to produce one-letter random strings, we can "
"reach our goal of producing a ten-letter string by concatenating ten one-"
"letter strings, in a loop."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:240
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:253
msgid ""
"The words \"for x = 1,10,1\" mean “start with x equals 1, loop until x "
"equals 10, increment x by 1 for each iteration.” The symbol \"..\" means "
"\"concatenate\", that is, add the string on the right of the \"..\" sign "
"to the string on the left of the \"..\" sign. Since we start by saying "
"that random_string is \"\" (a blank string), the end result is that "
"random_string has 10 random letters. Once again the ``string_function()``"
" can be invoked from ``main_function()`` which can be invoked with "
"``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:261
msgid "For more about Lua loops see Lua manual `chapter 4.3.4 \"Numeric for\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:267
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- 'ZUDJBHKEFM'\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:289
msgid "Make a tuple out of a number and a string"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:291
msgid ""
"Now that it's clear how to make a 10-letter random string, it's possible "
"to make a tuple that contains a number and a 10-letter random string, by "
"invoking a function in Tarantool's library of Lua functions."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:295
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1, string_value})\n"
"  return t\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:304
msgid ""
"Once this is done, t will be the value of a new tuple which has two "
"fields. The first field is numeric: 1. The second field is a random "
"string. Once again the ``string_function()`` can be invoked from "
"``main_function()`` which can be invoked with  ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:309
msgid ""
"For more about Tarantool tuples see Tarantool manual section "
":ref:`Submodule box.tuple <box_tuple>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:313
msgid ""
"tarantool> function main_function()\n"
"         > local string_value, t\n"
"         > string_value = string_function()\n"
"         > t = box.tuple.new({1, string_value})\n"
"         > return t\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"- [1, 'PNPZPCOOKA']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:331
msgid "Modify main_function to insert a tuple into the database"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:333
msgid ""
"Now that it's clear how to make a tuple that contains a number and a "
"10-letter random string, the only trick remaining is putting that tuple "
"into tester. Remember that tester is the first space that was defined in "
"the sandbox, so it's like a database table."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:338
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  string_value = string_function()\n"
"  t = box.tuple.new({1,string_value})\n"
"  box.space.tester:replace(t)\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:347
msgid ""
"The new line here is ``box.space.tester:replace(t)``. The name contains "
"'tester' because the insertion is going to be to tester. The second "
"parameter is the tuple value. To be perfectly correct we could have said "
"``box.space.tester:insert(t)`` here, rather than "
"``box.space.tester:replace(t)``, but \"replace\" means “insert even if "
"there is already a tuple whose primary-key value is a duplicate”, and "
"that makes it easier to re-run the exercise even if the sandbox database "
"isn't empty. Once this is done, tester will contain a tuple with two "
"fields. The first field will be 1. The second field will be a random "
"10-letter string. Once again the ``string_function(``) can be invoked "
"from ``main_function()`` which can be invoked with ``main_function()``. "
"But ``main_function()`` won't tell the whole story, because it does not "
"return t, it only puts t into the database. To confirm that something got"
" inserted, we'll use a SELECT request."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:361
msgid ""
"main_function()\n"
"box.space.tester:select{1}"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:366
msgid ""
"For more about Tarantool insert and replace calls, see Tarantool manual "
"section :ref:`Submodule box.space <box_space>`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:371
msgid ""
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   string_value = string_function()\n"
"         >   t = box.tuple.new({1,string_value})\n"
"         >   box.space.tester:replace(t)\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> box.space.tester:select{1}\n"
"---\n"
"- - [1, 'EUJYVEECIL']\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:392
msgid "Modify main_function to insert a million tuples into the database"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:394
msgid ""
"Now that it's clear how to insert one tuple into the database, it's no "
"big deal to figure out how to scale up: instead of inserting with a "
"literal value = 1 for the primary key, insert with a variable value = "
"between 1 and 1 million, in a loop. Since we already saw how to loop, "
"that's a simple thing. The only extra wrinkle that we add here is a "
"timing function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:400
msgid ""
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:415
msgid ""
"The standard Lua function `os.clock() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.clock>`_ will return "
"the number of CPU seconds since the start. Therefore, by getting "
"start_time = number of seconds just before the inserting, and then "
"getting end_time = number of seconds just after the inserting, we can "
"calculate (end_time - start_time) = elapsed time in seconds. We will "
"display that value by putting it in a request without any assignments, "
"which causes Tarantool to send the value to the client, which prints it. "
"(Lua's answer to the C ``printf()`` function, which is ``print()``, will "
"also work.)"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:425
msgid ""
"For more on Lua ``os.clock()`` see Lua manual `chapter 22.1 \"Date and "
"Time\"`_. For more on Lua print() see Lua manual `chapter 5 "
"\"Functions\"`_."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:431
msgid ""
"Since this is the grand finale, we will redo the final versions of all "
"the necessary requests: the request that created ``string_function()``, "
"the request that created ``main_function()``, and the request that "
"invokes ``main_function()``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:436
msgid ""
"function string_function()\n"
"  local random_number\n"
"  local random_string\n"
"  random_string = \"\"\n"
"  for x = 1,10,1 do\n"
"    random_number = math.random(65, 90)\n"
"    random_string = random_string .. string.char(random_number)\n"
"  end\n"
"  return random_string\n"
"end\n"
"\n"
"function main_function()\n"
"  local string_value, t\n"
"  for i = 1,1000000,1 do\n"
"    string_value = string_function()\n"
"    t = box.tuple.new({i,string_value})\n"
"    box.space.tester:replace(t)\n"
"  end\n"
"end\n"
"start_time = os.clock()\n"
"main_function()\n"
"end_time = os.clock()\n"
"'insert done in ' .. end_time - start_time .. ' seconds'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:464
msgid ""
"tarantool> function string_function()\n"
"         >   local random_number\n"
"         >   local random_string\n"
"         >   random_string = \"\"\n"
"         >   for x = 1,10,1 do\n"
"         >     random_number = math.random(65, 90)\n"
"         >     random_string = random_string .. "
"string.char(random_number)\n"
"         >   end\n"
"         >   return random_string\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> function main_function()\n"
"         >   local string_value, t\n"
"         >   for i = 1,1000000,1 do\n"
"         >     string_value = string_function()\n"
"         >     t = box.tuple.new({i,string_value})\n"
"         >     box.space.tester:replace(t)\n"
"         >   end\n"
"         > end\n"
"---\n"
"...\n"
"tarantool> start_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> main_function()\n"
"---\n"
"...\n"
"tarantool> end_time = os.clock()\n"
"---\n"
"...\n"
"tarantool> 'insert done in ' .. end_time - start_time .. ' seconds'\n"
"---\n"
"- insert done in 37.62 seconds\n"
"...\n"
"tarantool>"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:503
msgid ""
"What has been shown is that Lua functions are quite expressive (in fact "
"one can do more with Tarantool's Lua stored procedures than one can do "
"with stored procedures in some SQL DBMSs), and that it's straightforward "
"to combine Lua-library functions and Tarantool-library functions."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:508
msgid ""
"What has also been shown is that inserting a million tuples took 37 "
"seconds. The host computer was a Linux laptop. By changing :ref:`wal_mode"
" <cfg_binary_logging_snapshots-wal_mode>` to 'none' before running the "
"test, one can reduce the elapsed time to 4 seconds."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:516
msgid "Sum a JSON field for all tuples"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:518
msgid ""
"This is an exercise assignment: “Assume that inside every tuple there is "
"a string formatted as JSON. Inside that string there is a JSON numeric "
"field. For each tuple, find the numeric field's value and add it to a "
"'sum' variable. At end, return the 'sum' variable.” The purpose of the "
"exercise is to get experience in one way to read and process tuples."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:524
msgid ""
"json = require('json')\n"
"function sum_json_field(field_name)\n"
"  local v, t, sum, field_value, is_valid_json, lua_table\n"
"  sum = 0\n"
"  for v, t in box.space.tester:pairs() do\n"
"    is_valid_json, lua_table = pcall(json.decode, t[2])\n"
"    if is_valid_json then\n"
"      field_value = lua_table[field_name]\n"
"      if type(field_value) == \"number\" then sum = sum + field_value end"
"\n"
"    end\n"
"  end\n"
"  return sum\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:541
msgid ""
"**LINE 3: WHY \"LOCAL\".** This line declares all the variables that will"
" be used in the function. Actually it's not necessary to declare all "
"variables at the start, and in a long function it would be better to "
"declare variables just before using them. In fact it's not even necessary"
" to declare variables at all, but an undeclared variable is \"global\". "
"That's not desirable for any of the variables that are declared in line "
"1, because all of them are for use only within the function."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:548
msgid ""
"**LINE 5: WHY \"PAIRS()\".** Our job is to go through all the rows and "
"there are two ways to do it: with :ref:`box.space.space_object:pairs() "
"<box_space-pairs>` or with ``variable = select(...)`` followed by "
":samp:`for i, {n}, 1 do {some-function}(variable[i]) end`. We preferred "
"``pairs()`` for this example."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:553
msgid ""
"**LINE 5: START THE MAIN LOOP.** Everything inside this \"``for``\" loop "
"will be repeated as long as there is another index key. A tuple is "
"fetched and can be referenced with variable :code:`t`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:557
msgid ""
"**LINE 6: WHY \"PCALL\".** If we simply said ``lua_table = "
"json.decode(t[2]))``, then the function would abort with an error if it "
"encountered something wrong with the JSON string - a missing colon, for "
"example. By putting the function inside \"``pcall``\" (`protected "
"call`_), we're saying: we want to intercept that sort of error, so if "
"there's a problem just set ``is_valid_json = false`` and we will know "
"what to do about it later."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:564
msgid ""
"**LINE 6: MEANING.** The function is :ref:`json.decode <json-decode>` "
"which means decode a JSON string, and the parameter is t[2] which is a "
"reference to a JSON string. There's a bit of hard coding here, we're "
"assuming that the second field in the tuple is where the JSON string was "
"inserted. For example, we're assuming a tuple looks like"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:574
msgid ""
"field[1]: 444\n"
"field[2]: '{\"Hello\": \"world\", \"Quantity\": 15}'"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:577
msgid ""
"meaning that the tuple's first field, the primary key field, is a number "
"while the tuple's second field, the JSON string, is a string. Thus the "
"entire statement means \"decode ``t[2]`` (the tuple's second field) as a "
"JSON string; if there's an error set ``is_valid_json = false``; if "
"there's no error set ``is_valid_json = true`` and set ``lua_table =`` a "
"Lua table which has the decoded string\"."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:583
msgid ""
"**LINE 8.** At last we are ready to get the JSON field value from the Lua"
" table that came from the JSON string. The value in field_name, which is "
"the parameter for the whole function, must be a name of a JSON field. For"
" example, inside the JSON string ``'{\"Hello\": \"world\", \"Quantity\": "
"15}'``, there are two JSON fields: \"Hello\" and \"Quantity\". If the "
"whole function is invoked with ``sum_json_field(\"Quantity\")``, then "
"``field_value = lua_table[field_name]`` is effectively the same as "
"``field_value = lua_table[\"Quantity\"]`` or even ``field_value = "
"lua_table.Quantity``. Those are just three different ways of saying: for "
"the Quantity field in the Lua table, get the value and put it in variable"
" :code:`field_value`."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:593
msgid ""
"**LINE 9: WHY \"IF\".** Suppose that the JSON string is well formed but "
"the JSON field is not a number, or is missing. In that case, the function"
" would be aborted when there was an attempt to add it to the sum. By "
"first checking ``type(field_value) == \"number\"``, we avoid that "
"abortion. Anyone who knows that the database is in perfect shape can skip"
" this kind of thing."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:599
msgid ""
"And the function is complete. Time to test it. Starting with an empty "
"database, defined the same way as the sandbox database in our "
":ref:`\"Getting started\" exercises <getting_started>`,"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:603
msgid ""
"-- if tester is left over from some previous test, destroy it\n"
"box.space.tester:drop()\n"
"box.schema.space.create('tester')\n"
"box.space.tester:create_index('primary', {parts = {1, 'unsigned'}})"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:610
msgid ""
"then add some tuples where the first field is a number and the second "
"field is a string."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:613
msgid ""
"box.space.tester:insert{444, '{\"Item\": \"widget\", \"Quantity\": 15}'}\n"
"box.space.tester:insert{445, '{\"Item\": \"widget\", \"Quantity\": 7}'}\n"
"box.space.tester:insert{446, '{\"Item\": \"golf club\", \"Quantity\": "
"\"sunshine\"}'}\n"
"box.space.tester:insert{447, '{\"Item\": \"waffle iron\", \"Quantit\": "
"3}'}"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:620
msgid ""
"Since this is a test, there are deliberate errors. The \"golf club\" and "
"the \"waffle iron\" do not have numeric Quantity fields, so must be "
"ignored. Therefore the real sum of the Quantity field in the JSON strings"
" should be: 15 + 7 = 22."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:625
msgid "Invoke the function with ``sum_json_field(\"Quantity\")``."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:627
msgid ""
"tarantool> sum_json_field(\"Quantity\")\n"
"---\n"
"- 22\n"
"..."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:634
msgid ""
"It works. We'll just leave, as exercises for future improvement, the "
"possibility that the \"hard coding\" assumptions could be removed, that "
"there might have to be an overflow check if some field values are huge, "
"and that the function should contain a \"yield\" instruction if the count"
" of tuples is huge."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:643
msgid "Indexed pattern search"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:645
msgid ""
"Here is a generic function which takes a field identifier and a search "
"pattern, and returns all tuples that match. |br| * The field must be the "
"first field of a TREE index. |br| * The function will use `Lua pattern "
"matching <http://www.lua.org/manual/5.2/manual.html#6.4.1>`_, which "
"allows \"magic characters\" in regular expressions. |br| * The initial "
"characters in the pattern, as far as the first magic character, will be "
"used as an index search key. For each tuple that is found via the index, "
"there will be a match of the whole pattern. |br| * To be "
":ref:`cooperative <atomic-cooperative_multitasking>`, the function should"
" yield after every 10 tuples, unless there is a reason to delay yielding."
" |br| With this function, we can take advantage of Tarantool's indexes "
"for speed, and take advantage of Lua's pattern matching for flexibility. "
"It does everything that an SQL \"LIKE\" search can do, and far more."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:662
msgid ""
"Read the following Lua code to see how it works. The comments that begin "
"with \"SEE NOTE ...\" refer to long explanations that follow the code."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:666
msgid ""
"function indexed_pattern_search(space_name, field_no, pattern)\n"
"  -- SEE NOTE #1 \"FIND AN APPROPRIATE INDEX\"\n"
"  if (box.space[space_name] == nil) then\n"
"    print(\"Error: Failed to find the specified space\")\n"
"    return nil\n"
"  end\n"
"  local index_no = -1\n"
"  for i=0,box.schema.INDEX_MAX,1 do\n"
"    if (box.space[space_name].index[i] == nil) then break end\n"
"    if (box.space[space_name].index[i].type == \"TREE\"\n"
"        and box.space[space_name].index[i].parts[1].fieldno == field_no\n"
"        and (box.space[space_name].index[i].parts[1].type == \"scalar\"\n"
"        or box.space[space_name].index[i].parts[1].type == \"string\")) "
"then\n"
"      index_no = i\n"
"      break\n"
"    end\n"
"  end\n"
"  if (index_no == -1) then\n"
"    print(\"Error: Failed to find an appropriate index\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\"\n"
"  local index_search_key = \"\"\n"
"  local index_search_key_length = 0\n"
"  local last_character = \"\"\n"
"  local c = \"\"\n"
"  local c2 = \"\"\n"
"  for i=1,string.len(pattern),1 do\n"
"    c = string.sub(pattern, i, i)\n"
"    if (last_character ~= \"%\") then\n"
"      if (c == '^' or c == \"$\" or c == \"(\" or c == \")\" or c == "
"\".\"\n"
"                   or c == \"[\" or c == \"]\" or c == \"*\" or c == "
"\"+\"\n"
"                   or c == \"-\" or c == \"?\") then\n"
"        break\n"
"      end\n"
"      if (c == \"%\") then\n"
"        c2 = string.sub(pattern, i + 1, i + 1)\n"
"        if (string.match(c2, \"%p\") == nil) then break end\n"
"        index_search_key = index_search_key .. c2\n"
"      else\n"
"        index_search_key = index_search_key .. c\n"
"      end\n"
"    end\n"
"    last_character = c\n"
"  end\n"
"  index_search_key_length = string.len(index_search_key)\n"
"  if (index_search_key_length < 3) then\n"
"    print(\"Error: index search key \" .. index_search_key .. \" is too "
"short\")\n"
"    return nil\n"
"  end\n"
"  -- SEE NOTE #3 \"OUTER LOOP: INITIATE\"\n"
"  local result_set = {}\n"
"  local number_of_tuples_in_result_set = 0\n"
"  local previous_tuple_field = \"\"\n"
"  while true do\n"
"    local number_of_tuples_since_last_yield = 0\n"
"    local is_time_for_a_yield = false\n"
"    -- SEE NOTE #4 \"INNER LOOP: ITERATOR\"\n"
"    for _,tuple in box.space[space_name].index[index_no]:\n"
"    pairs(index_search_key,{iterator = box.index.GE}) do\n"
"      -- SEE NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\"\n"
"      if (string.sub(tuple[field_no], 1, index_search_key_length)\n"
"      > index_search_key) then\n"
"        break\n"
"      end\n"
"      -- SEE NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\""
"\n"
"      number_of_tuples_since_last_yield = "
"number_of_tuples_since_last_yield + 1\n"
"      if (number_of_tuples_since_last_yield >= 10\n"
"          and tuple[field_no] ~= previous_tuple_field) then\n"
"        index_search_key = tuple[field_no]\n"
"        is_time_for_a_yield = true\n"
"        break\n"
"        end\n"
"      previous_tuple_field = tuple[field_no]\n"
"      -- SEE NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\""
"\n"
"      if (string.match(tuple[field_no], pattern) ~= nil) then\n"
"        number_of_tuples_in_result_set = number_of_tuples_in_result_set +"
" 1\n"
"        result_set[number_of_tuples_in_result_set] = tuple\n"
"      end\n"
"    end\n"
"    -- SEE NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\"\n"
"    if (is_time_for_a_yield ~= true) then\n"
"      break\n"
"    end\n"
"    require('fiber').yield()\n"
"  end\n"
"  return result_set\n"
"end"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:757
msgid ""
"NOTE #1 \"FIND AN APPROPRIATE INDEX\" |br| The caller has passed "
"space_name (a string) and field_no (a number). The requirements are: |br|"
" (a) index type must be \"TREE\" because for other index types (HASH, "
"BITSET, RTREE) a search with iterator=GE will not return strings in order"
" by string value; |br| (b) field_no must be the first index part; |br| "
"(c) the field must contain strings, because for other data types (such as"
" \"unsigned\") pattern searches are not possible; |br| If these "
"requirements are not met by any index, then print an error message and "
"return nil."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:769
msgid ""
"NOTE #2 \"DERIVE INDEX SEARCH KEY FROM PATTERN\" |br| The caller has "
"passed pattern (a string). The index search key will be the characters in"
" the pattern as far as the first magic character. Lua's magic characters "
"are % ^ $ ( ) . [ ] * + - ?. For example, if the pattern is \"ABC.E\", "
"the period is a magic character and therefore the index search key will "
"be \"ABC\". But there is a complication ... If we see \"%\" followed by a"
" punctuation character, that punctuation character is \"escaped\" so "
"remove the \"%\" when making the index search key. For example, if the "
"pattern is \"AB%$E\", the dollar sign is escaped and therefore the index "
"search key will be \"AB$E\". Finally there is a check that the index "
"search key length must be at least three -- this is an arbitrary number, "
"and in fact zero would be okay, but short index search keys will cause "
"long search times."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:786
msgid ""
"NOTE #3 -- \"OUTER LOOP: INITIATE\" |br| The function's job is to return "
"a result set, just as box.space.select would. We will fill it within an "
"outer loop that contains an inner loop. The outer loop's job is to "
"execute the inner loop, and possibly yield, until the search ends. The "
"inner loop's job is to find tuples via the index, and put them in the "
"result set if they match the pattern."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:795
msgid ""
"NOTE #4 \"INNER LOOP: ITERATOR\" |br| The for loop here is using pairs(),"
" see the :ref:`explanation of what index iterators are <box_index-"
"index_pairs>`. Within the inner loop, there will be a local variable "
"named \"tuple\" which contains the latest tuple found via the index "
"search key."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:802
msgid ""
"NOTE #5 \"INNER LOOP: BREAK IF INDEX KEY IS TOO GREAT\" |br| The iterator"
" is GE (Greater or Equal), and we must be more specific: if the search "
"index key has N characters, then the leftmost N characters of the "
"result's index field must not be greater than the search index key. For "
"example, if the search index key is 'ABC', then 'ABCDE' is a potential "
"match, but 'ABD' is a signal that no more matches are possible."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:811
msgid ""
"NOTE #6 \"INNER LOOP: BREAK AFTER EVERY 10 TUPLES -- MAYBE\" |br| This "
"chunk of code is for cooperative multitasking. The number 10 is "
"arbitrary, and usually a larger number would be okay. The simple rule "
"would be \"after checking 10 tuples, yield, and then resume the search "
"(that is, do the inner loop again) starting after the last value that was"
" found\". However, if the index is non-unique or if there is more than "
"one field in the index, then we might have duplicates -- for example "
"{\"ABC\",1}, {\"ABC\", 2}, {\"ABC\", 3}\" -- and it would be difficult to"
" decide which \"ABC\" tuple to resume with. Therefore, if the result's "
"index field is the same as the previous result's index field, there is no"
" break."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:824
msgid ""
"NOTE #7 \"INNER LOOP: ADD TO RESULT SET IF PATTERN MATCHES\" |br| Compare"
" the result's index field to the entire pattern. For example, suppose "
"that the caller passed pattern \"ABC.E\" and there is an indexed field "
"containing \"ABCDE\". Therefore the initial index search key is \"ABC\". "
"Therefore a tuple containing an indexed field with \"ABCDE\" will be "
"found by the iterator, because \"ABCDE\" > \"ABC\". In that case "
"string.match will return a value which is not nil. Therefore this tuple "
"can be added to the result set."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:834
msgid ""
"NOTE #8 \"OUTER LOOP: BREAK, OR YIELD AND CONTINUE\" |br| There are three"
" conditions which will cause a break from the inner loop: (1) the for "
"loop ends naturally because there are no more index keys which are "
"greater than or equal to the index search key, (2) the index key is too "
"great as described in NOTE #5, (3) it is time for a yield as described in"
" NOTE #6. If condition (1) or condition (2) is true, then there is "
"nothing more to do, the outer loop ends too. If and only if condition (3)"
" is true, the outer loop must yield and then continue. If it does "
"continue, then the inner loop -- the iterator search -- will happen again"
" with a new value for the index search key."
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:847
msgid "EXAMPLE:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:849
msgid ""
"Start Tarantool, cut and paste the code for function "
"``indexed_pattern_search``, and try the following:"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:855
msgid ""
"box.space.t:drop()\n"
"box.schema.space.create('t')\n"
"box.space.t:create_index('primary',{})\n"
"box.space.t:create_index('secondary',{unique=false,parts={2,'string',3,'string'}})"
"\n"
"box.space.t:insert{1,'A','a'}\n"
"box.space.t:insert{2,'AB',''}\n"
"box.space.t:insert{3,'ABC','a'}\n"
"box.space.t:insert{4,'ABCD',''}\n"
"box.space.t:insert{5,'ABCDE','a'}\n"
"box.space.t:insert{6,'ABCDE',''}\n"
"box.space.t:insert{7,'ABCDEF','a'}\n"
"box.space.t:insert{8,'ABCDF',''}\n"
"indexed_pattern_search(\"t\", 2, \"ABC.E.\")"
msgstr ""

#: ../doc/1.7/tutorials/lua_tutorials.rst:874
msgid ""
"tarantool> **indexed_pattern_search(\"t\", 2, \"ABC.E.\")**\n"
"---\n"
"- - [7, 'ABCDEF', 'a']\n"
"..."
msgstr ""

#: ../doc/1.7/whats_new.rst:33
msgid "What's new?"
msgstr ""

#: ../doc/1.7/whats_new.rst:35
msgid ""
"Here is a summary of significant changes introduced in specific versions "
"of Tarantool."
msgstr ""

#: ../doc/1.7/whats_new.rst:38
msgid ""
"For smaller feature changes and bug fixes, see closed `milestones "
"<https://github.com/tarantool/tarantool/milestones?state=closed>`_ at "
"GitHub."
msgstr ""

#: ../doc/1.7/whats_new.rst:46
msgid "What's new in Tarantool 1.7?"
msgstr ""

#: ../doc/1.7/whats_new.rst:48
msgid ""
"The disk-based storage engine, which was called `sophia` or `phia` in "
"earlier versions, is superseded by the `vinyl` storage engine."
msgstr ""

#: ../doc/1.7/whats_new.rst:51
msgid "There are new types for indexed fields."
msgstr ""

#: ../doc/1.7/whats_new.rst:53
msgid "The LuaJIT version is updated."
msgstr ""

#: ../doc/1.7/whats_new.rst:55
msgid ""
"Automatic replica set bootstrap (for easier configuration of a new "
"replica set) is supported."
msgstr ""

#: ../doc/1.7/whats_new.rst:58
msgid "The ``space_object:inc()`` function is removed."
msgstr ""

#: ../doc/1.7/whats_new.rst:60
msgid "The ``space_object:dec()`` function is removed."
msgstr ""

#: ../doc/1.7/whats_new.rst:62
msgid "The ``space_object:bsize()`` function is added."
msgstr ""

#: ../doc/1.7/whats_new.rst:64
msgid ""
"The ``box.coredump()`` function is removed, for an alternative see "
":ref:`Core dumps <admin-core_dumps>`."
msgstr ""

#: ../doc/1.7/whats_new.rst:67
msgid "The ``hot_standby`` configuration option is added."
msgstr ""

#: ../doc/1.7/whats_new.rst:69
msgid "Configuration parameters revised:"
msgstr ""

#: ../doc/1.7/whats_new.rst:71
msgid "Parameters renamed:"
msgstr ""

#: ../doc/1.7/whats_new.rst:73
msgid "``slab_alloc_arena`` (in gigabytes) to ``memtx_memory`` (in bytes),"
msgstr ""

#: ../doc/1.7/whats_new.rst:74
msgid "``slab_alloc_minimal`` to ``memtx_min_tuple_size``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:75
msgid "``slab_alloc_maximal`` to ``memtx_max_tuple_size``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:76
msgid "``replication_source`` to ``replication``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:77
msgid "``snap_dir`` to ``memtx_dir``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:78
msgid "``logger`` to ``log``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:79
msgid "``logger_nonblock`` to ``log_nonblock``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:80
msgid "``snapshot_count`` to ``checkpoint_count``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:81
msgid "``snapshot_period`` to ``checkpoint_interval``,"
msgstr ""

#: ../doc/1.7/whats_new.rst:82
msgid ""
"``panic_on_wal_error`` and ``panic_on_snap_error`` united under "
"``force_recovery``."
msgstr ""

#: ../doc/1.7/whats_new.rst:85
msgid ""
"Until Tarantool 1.8, you can use :ref:`deprecated parameters "
"<cfg_deprecated>` for both initial and runtime configuration, but "
"Tarantool will display a warning. Also, you can specify both deprecated "
"and up-to-date parameters, provided that their values are harmonized. If "
"not, Tarantool will display an error."
msgstr ""

#: ../doc/1.7/whats_new.rst:94
msgid "What's new in Tarantool 1.6.9 after February 15, 2017?"
msgstr ""

#: ../doc/1.7/whats_new.rst:96
msgid ""
"Due to Tarantool issue#2040 `Remove sophia engine from 1.6 "
"<https://github.com/tarantool/tarantool/issues/2040>`_ there no longer is"
" a storage engine named `sophia`. It will be superseded in version 1.7 by"
" the `vinyl` storage engine."
msgstr ""

#: ../doc/1.7/whats_new.rst:105
msgid "What's new in Tarantool 1.6?"
msgstr ""

#: ../doc/1.7/whats_new.rst:107
msgid ""
"Tarantool 1.6 is no longer getting major new features, although it will "
"be maintained. The developers are concentrating on Tarantool version 1.7."
msgstr ""

